<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LT's Tarkov AI - FriendlyPMC Knowledge Base</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <style>

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --border-color: #dee2e6;
            --accent-primary: #0d6efd;
            --accent-secondary: #6610f2;
            --success: #198754;
            --warning: #ffc107;
            --sidebar-width: 320px;
            --header-height: 70px;
        }

        body.dark-theme {
            --bg-primary: #1a1d23;
            --bg-secondary: #22252c;
            --bg-tertiary: #2a2d35;
            --text-primary: #e9ecef;
            --text-secondary: #adb5bd;
            --border-color: #343a40;
            --accent-primary: #0dcaf0;
            --accent-secondary: #a855f7;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background 0.3s ease, color 0.3s ease;
        }

        .wiki-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .wiki-header {
            height: var(--header-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 100%;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: opacity 0.2s ease;
        }

        .logo:hover {
            opacity: 0.8;
        }

        .logo-icon {
            font-size: 2rem;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .logo h1 {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .logo p {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: none;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 1.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Search Modal */
        .search-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease;
        }

        .search-modal.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 10vh;
        }

        .search-modal-content {
            background: var(--bg-secondary);
            border-radius: 16px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #searchInput {
            width: 100%;
            padding: 1.25rem;
            font-size: 1.125rem;
            border: none;
            background: transparent;
            color: var(--text-primary);
            outline: none;
            border-bottom: 1px solid var(--border-color);
        }

        .search-results {
            max-height: 400px;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .search-result-item {
            padding: 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .search-result-item:hover {
            background: var(--bg-tertiary);
        }

        .search-result-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .search-result-category {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .search-result-excerpt {
            font-size: 0.875rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        /* Body Layout */
        .wiki-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-header h3 {
            font-size: 1.125rem;
            font-weight: 600;
        }

        .sidebar-nav {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
        }

        .nav-category {
            margin-bottom: 0.5rem;
        }

        .category-toggle {
            width: 100%;
            padding: 0.75rem;
            border: none;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .category-toggle:hover {
            background: var(--bg-primary);
        }

        .category-name {
            flex: 1;
            text-align: left;
        }

        .category-count {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            background: var(--accent-primary);
            color: white;
            border-radius: 12px;
        }

        .toggle-icon {
            transition: transform 0.2s ease;
        }

        .category-toggle.expanded .toggle-icon {
            transform: rotate(-180deg);
        }

        .nav-items {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .nav-items.expanded {
            max-height: 2000px;
        }

        .nav-item {
            width: 100%;
            padding: 0.75rem 1rem;
            margin: 0.25rem 0;
            border: none;
            background: transparent;
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-align: left;
            transition: all 0.2s ease;
            font-size: 0.875rem;
        }

        .nav-item:hover {
            background: var(--bg-primary);
            padding-left: 1.25rem;
        }

        .nav-item.active {
            background: var(--accent-primary);
            color: white;
        }

        .doc-title {
            flex: 1;
        }

        .sidebar-footer {
            padding: 1rem;
            border-top: 1px solid var(--border-color);
        }

        .stats {
            display: flex;
            gap: 1rem;
        }

        .stat {
            flex: 1;
            text-align: center;
        }

        .stat-value {
            display: block;
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
        }

        .welcome-screen {
            max-width: 1200px;
            margin: 0 auto;
        }

        .welcome-content h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            font-size: 1.25rem;
            color: var(--text-secondary);
            margin-bottom: 3rem;
        }

        .feature-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 3rem;
        }

        .feature-card {
            background: var(--bg-secondary);
            padding: 2rem;
            border-radius: 16px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-color: var(--accent-primary);
        }

        .feature-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .feature-card h3 {
            margin-bottom: 0.5rem;
        }

        .feature-card p {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .quick-start {
            background: var(--bg-secondary);
            padding: 2rem;
            border-radius: 16px;
            border: 1px solid var(--border-color);
        }

        .quick-start h2 {
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .quick-links {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .quick-link {
            padding: 1rem;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .quick-link:hover {
            background: var(--accent-primary);
            color: white;
            transform: scale(1.05);
        }

        .breadcrumb {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .document-content {
            max-width: 900px;
            margin: 0 auto;
        }

        .document-content h1,
        .document-content h2,
        .document-content h3,
        .document-content h4 {
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        .document-content h1 {
            font-size: 2.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }

        .document-content h2 {
            font-size: 2rem;
        }

        .document-content h3 {
            font-size: 1.5rem;
        }

        .document-content p {
            margin-bottom: 1rem;
        }

        .document-content ul,
        .document-content ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        .document-content li {
            margin-bottom: 0.5rem;
        }

        .document-content pre {
            background: var(--bg-tertiary);
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
        }

        .document-content code {
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
        }

        .document-content :not(pre) > code {
            background: var(--bg-tertiary);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .document-content table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1rem;
        }

        .document-content th,
        .document-content td {
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .document-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .document-content blockquote {
            border-left: 4px solid var(--accent-primary);
            padding-left: 1rem;
            margin-left: 0;
            margin-bottom: 1rem;
            color: var(--text-secondary);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-color);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

    </style>
</head>
<body class="dark-theme">
    <div class="wiki-container">
        <!-- Header -->
        <header class="wiki-header">
            <div class="header-content">
                <div class="logo" onclick="goHome()" style="cursor: pointer;">
                    <div class="logo-icon">üéÆ</div>
                    <div>
                        <h1>LT's Tarkov AI</h1>
                        <p>FriendlyPMC Knowledge Base</p>
                    </div>
                </div>
                <div class="header-actions">
                    <button id="searchBtn" class="icon-btn" title="Search (Ctrl+K)">
                        üîç
                    </button>
                    <button id="themeToggle" class="icon-btn" title="Toggle Theme">
                        üåô
                    </button>
                </div>
            </div>
        </header>

        <!-- Search Modal -->
        <div id="searchModal" class="search-modal">
            <div class="search-modal-content">
                <input 
                    type="text" 
                    id="searchInput" 
                    placeholder="Search documentation... (Ctrl+K)"
                    autocomplete="off"
                >
                <div id="searchResults" class="search-results"></div>
            </div>
        </div>

        <div class="wiki-body">
            <!-- Sidebar -->
            <aside class="sidebar">
                <div class="sidebar-header">
                    <h3>üìö Documentation</h3>
                </div>
                <nav class="sidebar-nav">

                    <div class="nav-category">
                        <button class="category-toggle" data-category="core-systems">
                            <span class="category-icon">üìÅ</span>
                            <span class="category-name">Core Systems</span>
                            <span class="category-count">14</span>
                            <span class="toggle-icon">‚ñº</span>
                        </button>
                        <div class="nav-items" id="category-core-systems">
                            <button class="nav-item" data-doc="00-INDEX" onclick="loadDocument('00-INDEX')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Tarkov API Knowledge Base - Index</span>
                            </button>
                            <button class="nav-item" data-doc="01-Bot-Spawning" onclick="loadDocument('01-Bot-Spawning')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Tarkov Bot Spawning System - API Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="02-Bot-AI-Brain" onclick="loadDocument('02-Bot-AI-Brain')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Tarkov Bot AI/Brain System - API Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="03-Party-Friends-Messenger-System" onclick="loadDocument('03-Party-Friends-Messenger-System')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Tarkov Party/Invite/Friends/Messenger System Analysis</span>
                            </button>
                            <button class="nav-item" data-doc="04-Voice-Gesture-Commands" onclick="loadDocument('04-Voice-Gesture-Commands')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Tarkov Voice/Gesture Command System - API Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="05-Health-Medical-System" onclick="loadDocument('05-Health-Medical-System')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Tarkov Health & Medical System - API Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="06-Grenade-Explosive-System" onclick="loadDocument('06-Grenade-Explosive-System')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Tarkov Grenade & Explosive System - API Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="07-Server-Routes-Patterns" onclick="loadDocument('07-Server-Routes-Patterns')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT Server Routes - Complete Guide (SOURCE-VERIFIED)</span>
                            </button>
                            <button class="nav-item" data-doc="08-Cover-Navigation-System" onclick="loadDocument('08-Cover-Navigation-System')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Tarkov Cover Finding & Navigation System - API Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="09-Item-Loot-System" onclick="loadDocument('09-Item-Loot-System')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Tarkov Item, Inventory & Loot System - API Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="10-GClass-Mapping-Index" onclick="loadDocument('10-GClass-Mapping-Index')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">GClass Obfuscation Mapping Index</span>
                            </button>
                            <button class="nav-item" data-doc="11-INNOVATION-IMPLEMENTATION-GUIDES" onclick="loadDocument('11-INNOVATION-IMPLEMENTATION-GUIDES')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Innovation Implementation Guides</span>
                            </button>
                            <button class="nav-item" data-doc="12-SAIN-INTEGRATION-GUIDE" onclick="loadDocument('12-SAIN-INTEGRATION-GUIDE')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN AI Integration Guide for FriendlyPMC</span>
                            </button>
                            <button class="nav-item" data-doc="16-SAIN-PATTERNS-FOR-FRIENDLYPMC" onclick="loadDocument('16-SAIN-PATTERNS-FOR-FRIENDLYPMC')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN Patterns for FriendlyPMC - Practical Integration Guide</span>
                            </button>
                        </div>
                    </div>
                    <div class="nav-category">
                        <button class="category-toggle" data-category="bigbrain-foundation">
                            <span class="category-icon">üìÅ</span>
                            <span class="category-name">BigBrain Foundation</span>
                            <span class="category-count">3</span>
                            <span class="toggle-icon">‚ñº</span>
                        </button>
                        <div class="nav-items" id="category-bigbrain-foundation">
                            <button class="nav-item" data-doc="13-BIGBRAIN-ARCHITECTURE" onclick="loadDocument('13-BIGBRAIN-ARCHITECTURE')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">BigBrain (LTBRAIN) - Complete Architecture Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="14-BIGBRAIN-API-REFERENCE" onclick="loadDocument('14-BIGBRAIN-API-REFERENCE')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">BigBrain - Complete API Reference</span>
                            </button>
                            <button class="nav-item" data-doc="15-BIGBRAIN-IMPLEMENTATION-GUIDE" onclick="loadDocument('15-BIGBRAIN-IMPLEMENTATION-GUIDE')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">BigBrain - Implementation Guide for FriendlyPMC</span>
                            </button>
                        </div>
                    </div>
                    <div class="nav-category">
                        <button class="category-toggle" data-category="sain-ai-reference">
                            <span class="category-icon">üìÅ</span>
                            <span class="category-name">SAIN AI Reference</span>
                            <span class="category-count">10</span>
                            <span class="toggle-icon">‚ñº</span>
                        </button>
                        <div class="nav-items" id="category-sain-ai-reference">
                            <button class="nav-item" data-doc="AIDecisionSystem" onclick="loadDocument('AIDecisionSystem')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN AI Decision System Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="Architecture" onclick="loadDocument('Architecture')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN AI System - Architecture Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="CombatSystems" onclick="loadDocument('CombatSystems')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN Combat Systems Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="CoreComponents" onclick="loadDocument('CoreComponents')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN AI System - Core Components Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="DataModels" onclick="loadDocument('DataModels')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN Data Models and Structures</span>
                            </button>
                            <button class="nav-item" data-doc="INDEX" onclick="loadDocument('INDEX')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN AI System - Complete Technical Documentation Index</span>
                            </button>
                            <button class="nav-item" data-doc="MovementSystem" onclick="loadDocument('MovementSystem')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN Movement System Documentation</span>
                            </button>
                            <button class="nav-item" data-doc="PatchesIntegration" onclick="loadDocument('PatchesIntegration')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN Patches and SPT Integration</span>
                            </button>
                            <button class="nav-item" data-doc="PersonalityConfig" onclick="loadDocument('PersonalityConfig')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN Personality and Configuration System</span>
                            </button>
                            <button class="nav-item" data-doc="SensorySystem" onclick="loadDocument('SensorySystem')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN Sensory Systems Documentation</span>
                            </button>
                        </div>
                    </div>
                    <div class="nav-category">
                        <button class="category-toggle" data-category="sain-source-code">
                            <span class="category-icon">üìÅ</span>
                            <span class="category-name">SAIN Source Code</span>
                            <span class="category-count">2</span>
                            <span class="toggle-icon">‚ñº</span>
                        </button>
                        <div class="nav-items" id="category-sain-source-code">
                            <button class="nav-item" data-doc="SAIN-SOURCE-COMPLETE" onclick="loadDocument('SAIN-SOURCE-COMPLETE')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN v4.2.0 Source Code Documentation - COMPLETE ANALYSIS</span>
                            </button>
                            <button class="nav-item" data-doc="SAIN-SOURCE-DOCUMENTATION-COMPLETE" onclick="loadDocument('SAIN-SOURCE-DOCUMENTATION-COMPLETE')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SAIN v4.2.0 Complete Source Code Documentation</span>
                            </button>
                        </div>
                    </div>
                    <div class="nav-category">
                        <button class="category-toggle" data-category="general">
                            <span class="category-icon">üìÅ</span>
                            <span class="category-name">General</span>
                            <span class="category-count">19</span>
                            <span class="toggle-icon">‚ñº</span>
                        </button>
                        <div class="nav-items" id="category-general">
                            <button class="nav-item" data-doc="CREATING-PROFILE-BOTS-GUIDE" onclick="loadDocument('CREATING-PROFILE-BOTS-GUIDE')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Creating AI Bots with Real Profiles - Complete Guide</span>
                            </button>
                            <button class="nav-item" data-doc="FRIENDLIST-NOTIFICATION-FIX" onclick="loadDocument('FRIENDLIST-NOTIFICATION-FIX')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Friend List Notification Fix - Diagnostic Guide</span>
                            </button>
                            <button class="nav-item" data-doc="FRIENDLYPMC-FIKA-COMPATIBILITY-ANALYSIS" onclick="loadDocument('FRIENDLYPMC-FIKA-COMPATIBILITY-ANALYSIS')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">FriendlyPMC + Fika Compatibility Analysis</span>
                            </button>
                            <button class="nav-item" data-doc="FRIENDLYPMC-FIKA-CONDITIONAL-FLOW" onclick="loadDocument('FRIENDLYPMC-FIKA-CONDITIONAL-FLOW')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">FriendlyPMC + Fika Conditional Flow - Complete Implementation Guide</span>
                            </button>
                            <button class="nav-item" data-doc="MASTER-SPT-KNOWLEDGE-INDEX" onclick="loadDocument('MASTER-SPT-KNOWLEDGE-INDEX')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT Knowledge Base - Master Index (UPDATED)</span>
                            </button>
                            <button class="nav-item" data-doc="PROFILE-BOT-AID-FIX" onclick="loadDocument('PROFILE-BOT-AID-FIX')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">Profile Bot Aid=0 Issue - Complete Solution</span>
                            </button>
                            <button class="nav-item" data-doc="README" onclick="loadDocument('README')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">FriendlyPMC Knowledge Base - Complete Reference</span>
                            </button>
                            <button class="nav-item" data-doc="SPT-404-ROOT-CAUSE-SOLVED" onclick="loadDocument('SPT-404-ROOT-CAUSE-SOLVED')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT 404 "UNHANDLED RESPONSE" - Root Cause SOLVED</span>
                            </button>
                            <button class="nav-item" data-doc="SPT-COMPRESSION-EXPLAINED" onclick="loadDocument('SPT-COMPRESSION-EXPLAINED')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT Request/Response Compression - Complete Guide</span>
                            </button>
                            <button class="nav-item" data-doc="SPT-CONTROLLERS-REFERENCE" onclick="loadDocument('SPT-CONTROLLERS-REFERENCE')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT Controllers Complete API Reference</span>
                            </button>
                            <button class="nav-item" data-doc="SPT-DATABASE-ACCESS" onclick="loadDocument('SPT-DATABASE-ACCESS')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT Database Access - Complete Guide</span>
                            </button>
                            <button class="nav-item" data-doc="SPT-DEPENDENCY-INJECTION" onclick="loadDocument('SPT-DEPENDENCY-INJECTION')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT Dependency Injection System - Complete Guide</span>
                            </button>
                            <button class="nav-item" data-doc="SPT-FRIEND-PARTY-INVITE-SYSTEM" onclick="loadDocument('SPT-FRIEND-PARTY-INVITE-SYSTEM')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT Friend, Party & Invite System - Complete Reference</span>
                            </button>
                            <button class="nav-item" data-doc="SPT-MOD-LIFECYCLE" onclick="loadDocument('SPT-MOD-LIFECYCLE')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT Mod Lifecycle & Load Order - Complete Guide</span>
                            </button>
                            <button class="nav-item" data-doc="SPT-PMC-SPAWN-SYSTEM" onclick="loadDocument('SPT-PMC-SPAWN-SYSTEM')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT PMC Spawn System - Complete Reference</span>
                            </button>
                            <button class="nav-item" data-doc="SPT-ROUTING-ARCHITECTURE" onclick="loadDocument('SPT-ROUTING-ARCHITECTURE')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT Server Routing Architecture - Complete Source Analysis</span>
                            </button>
                            <button class="nav-item" data-doc="SPT-SERVER-SOURCE-ANALYSIS" onclick="loadDocument('SPT-SERVER-SOURCE-ANALYSIS')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT Server C# Source Analysis - Complete Report</span>
                            </button>
                            <button class="nav-item" data-doc="SPT-WORKING-PATTERNS" onclick="loadDocument('SPT-WORKING-PATTERNS')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">SPT Working Patterns - Verified From Source</span>
                            </button>
                            <button class="nav-item" data-doc="WTT-CommonLib-TechnicalDocumentation" onclick="loadDocument('WTT-CommonLib-TechnicalDocumentation')">
                                <span class="doc-icon">üìÑ</span>
                                <span class="doc-title">WTT-CommonLib Technical Documentation</span>
                            </button>
                        </div>
                    </div>
                </nav>
                <div class="sidebar-footer">
                    <div class="stats">
                        <div class="stat">
                            <span class="stat-value">48</span>
                            <span class="stat-label">Documents</span>
                        </div>
                        <div class="stat">
                            <span class="stat-value">5</span>
                            <span class="stat-label">Categories</span>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- Main Content -->
            <main class="main-content">
                <div class="welcome-screen" id="welcomeScreen">
                    <div class="welcome-content">
                        <h1>üöÄ Welcome to the FriendlyPMC Knowledge Base</h1>
                        <p class="subtitle">Comprehensive documentation for building AI-powered Tarkov mods</p>
                        
                        <div class="feature-cards">
                            <div class="feature-card" onclick="loadDocument('13-BIGBRAIN-ARCHITECTURE')" style="cursor: pointer;">
                                <div class="feature-icon">üß†</div>
                                <h3>BigBrain Foundation</h3>
                                <p>Complete AI layer system architecture and implementation guides</p>
                            </div>
                            <div class="feature-card" onclick="loadDocument('02-Bot-AI-Brain')" style="cursor: pointer;">
                                <div class="feature-icon">‚öôÔ∏è</div>
                                <h3>Core Systems</h3>
                                <p>Bot spawning, AI brain, party systems, voice commands, and more</p>
                            </div>
                            <div class="feature-card" onclick="loadDocument('11-INNOVATION-IMPLEMENTATION-GUIDES')" style="cursor: pointer;">
                                <div class="feature-icon">‚ú®</div>
                                <h3>5 Innovations</h3>
                                <p>Advanced features: formations, breaching, fire support, learning, and evac</p>
                            </div>
                            <div class="feature-card" onclick="loadDocument('INDEX')" style="cursor: pointer;">
                                <div class="feature-icon">üìñ</div>
                                <h3>SAIN Reference</h3>
                                <p>Production-proven patterns from SAIN v4.2.0 source code</p>
                            </div>
                        </div>

                        <div class="quick-start">
                            <h2>üéØ Quick Start</h2>
                            <div class="quick-links">
                                <button class="quick-link" onclick="loadDocument('README')">
                                    üìã Read the README
                                </button>
                                <button class="quick-link" onclick="loadDocument('00-INDEX')">
                                    üóÇÔ∏è Browse the Index
                                </button>
                                <button class="quick-link" onclick="loadDocument('13-BIGBRAIN-ARCHITECTURE')">
                                    üß† BigBrain Architecture
                                </button>
                                <button class="quick-link" onclick="loadDocument('11-INNOVATION-IMPLEMENTATION-GUIDES')">
                                    ‚ú® View Innovations
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="document-view" id="documentView" style="display: none;">
                    <div class="breadcrumb" id="breadcrumb"></div>
                    <article id="documentContent" class="document-content"></article>
                </div>
            </main>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>

        const documentsData = {"00-INDEX":{"title":"Tarkov API Knowledge Base - Index\r","category":"Core Systems","content":"# Tarkov API Knowledge Base - Index\r\n\r\n**Purpose**: Map decompiled Tarkov assembly APIs to FriendlyPMC design intent features\r\n\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\n## Resources Available\r\n- **ilspy-out/**: 41 decompiled .cs files (core APIs)\r\n- **decompiled_*/**: 97 decompiled directories (detailed implementations)\r\n- **SAIN_working/**: Working reference implementation\r\n- **FriendlyPMC 3.11**: Proven working patterns\r\n\r\n---\r\n\r\n## Knowledge Base Structure\r\n\r\n### ‚≠ê START HERE\r\n| File | Purpose | Size |\r\n|------|---------|------|\r\n| [README.md](README.md) | Complete overview, quick start, innovation summary | 150KB |\r\n| [00-INDEX.md](00-INDEX.md) | This file - master index and methodology | Updated |\r\n\r\n### Core Feature Areas (Mapped to Design Phases)\r\n\r\n| File | Phase | Feature Area | Status |\r\n|------|-------|--------------|--------|\r\n| [01-Bot-Spawning.md](01-Bot-Spawning.md) | Phase 5 | Friendly bot spawning, spawn points, faction alignment | ‚úÖ DONE (65KB) |\r\n| [02-Bot-AI-Brain.md](02-Bot-AI-Brain.md) | Phase 6 | BotOwner, BigBrain, perception, combat AI | ‚úÖ DONE (67KB) |\r\n| [03-Party-Friends-Messenger-System.md](03-Party-Friends-Messenger-System.md) | Phase 3+4 | Chatbot, friends, party, invites (CRITICAL) | ‚úÖ DONE (118KB) |\r\n| [04-Voice-Gesture-Commands.md](04-Voice-Gesture-Commands.md) | Phase 7 | Gesture menu, voice commands, Y-menu, bot control | ‚úÖ DONE (134KB) |\r\n| [07-Server-Routes-Patterns.md](07-Server-Routes-Patterns.md) | Phase 1 | HTTP routes, client-server communication | ‚úÖ DONE (143KB) |\r\n\r\n### Advanced Systems (Innovations & Phases 12+)\r\n\r\n| File | Phase | Feature Area | Status |\r\n|------|-------|--------------|--------|\r\n| [05-Health-Medical-System.md](05-Health-Medical-System.md) | Phase 12B+C | Health tracking, medic AI, downed states | ‚úÖ DONE (174KB) |\r\n| [06-Grenade-Explosive-System.md](06-Grenade-Explosive-System.md) | Phase 16 | Grenade throwing, flashbangs, breach tactics | ‚úÖ DONE (204KB) |\r\n| [08-Cover-Navigation-System.md](08-Cover-Navigation-System.md) | Multi | Cover finding, formations, tactical positioning | ‚úÖ DONE (222KB) |\r\n| [09-Item-Loot-System.md](09-Item-Loot-System.md) | Phase 10 | Item tracking, loot return, ammo management | ‚úÖ DONE (238KB) |\r\n\r\n### BigBrain Foundation (CRITICAL)\r\n\r\n| File | Purpose | Status |\r\n|------|---------|--------|\r\n| [13-BIGBRAIN-ARCHITECTURE.md](13-BIGBRAIN-ARCHITECTURE.md) | BigBrain system architecture and design | ‚úÖ DONE (389KB) |\r\n| [14-BIGBRAIN-API-REFERENCE.md](14-BIGBRAIN-API-REFERENCE.md) | Complete CustomLayer/CustomLogic/BrainManager API | ‚úÖ DONE (395KB) |\r\n| [15-BIGBRAIN-IMPLEMENTATION-GUIDE.md](15-BIGBRAIN-IMPLEMENTATION-GUIDE.md) | Practical examples and patterns | ‚úÖ DONE (403KB) |\r\n\r\n### Implementation Guides\r\n\r\n| File | Purpose | Status |\r\n|------|---------|--------|\r\n| [11-INNOVATION-IMPLEMENTATION-GUIDES.md](11-INNOVATION-IMPLEMENTATION-GUIDES.md) | 5 innovations with step-by-step plans | ‚úÖ DONE (249KB) |\r\n| [12-SAIN-INTEGRATION-GUIDE.md](12-SAIN-INTEGRATION-GUIDE.md) | SAIN AI pattern integration for FriendlyPMC | ‚úÖ DONE (303KB) |\r\n| [AGENT-BLOCKER-SOLUTIONS-VALIDATED.md](AGENT-BLOCKER-SOLUTIONS-VALIDATED.md) | AGENT1 blocker solutions (validated sources) | ‚úÖ DONE (356KB) |\r\n| [10-GClass-Mapping-Index.md](10-GClass-Mapping-Index.md) | GClass### ‚Üí Semantic name mappings | ‚úÖ DONE (137KB) |\r\n| [AGENT1-ACTION-ITEMS.md](AGENT1-ACTION-ITEMS.md) | Immediate bug fixes (MongoId vs Aid) | ‚úÖ DONE (7KB) |\r\n| [00-PATTERN-SEARCH-RESULTS.md](00-PATTERN-SEARCH-RESULTS.md) | Decompiled file mapping | ‚úÖ DONE (5KB) |\r\n\r\n### SAIN AI Reference (Subdirectory)\r\n\r\n| File | Purpose | Status |\r\n|------|---------|--------|\r\n| [AI/INDEX.md](AI/INDEX.md) | SAIN documentation index | ‚úÖ REFERENCE |\r\n| [AI/Architecture.md](AI/Architecture.md) | SAIN system architecture | ‚úÖ REFERENCE (31KB) |\r\n| [AI/AIDecisionSystem.md](AI/AIDecisionSystem.md) | SAIN decision logic | ‚úÖ REFERENCE (18KB) |\r\n| [AI/CoreComponents.md](AI/CoreComponents.md) | SAIN components | ‚úÖ REFERENCE (24KB) |\r\n| [AI/DataModels.md](AI/DataModels.md) | SAIN data structures | ‚úÖ REFERENCE (19KB) |\r\n| [AI/CombatSystems.md](AI/CombatSystems.md) | SAIN combat mechanics | ‚úÖ REFERENCE (17KB) |\r\n| [AI/SensorySystem.md](AI/SensorySystem.md) | SAIN vision/hearing | ‚úÖ REFERENCE (16KB) |\r\n| [AI/MovementSystem.md](AI/MovementSystem.md) | SAIN movement/pathfinding | ‚úÖ REFERENCE (17KB) |\r\n| [AI/PersonalityConfig.md](AI/PersonalityConfig.md) | SAIN personalities | ‚úÖ REFERENCE (15KB) |\r\n| [AI/PatchesIntegration.md](AI/PatchesIntegration.md) | SAIN SPT integration | ‚úÖ REFERENCE (16KB) |\r\n\r\n---\r\n\r\n## Research Methodology\r\n\r\n### 1. **Survey Phase** (Automated)\r\n- Scan all decompiled files for key patterns\r\n- Identify classes related to each feature area\r\n- Build initial class‚Üífeature mapping\r\n\r\n### 2. **Deep Dive Phase** (Manual + AI)\r\n- For each feature area:\r\n  - Read relevant decompiled code\r\n  - Document class hierarchy\r\n  - Extract method signatures\r\n  - Identify Harmony patch targets\r\n  - Note version-specific changes (SPT 4.0.5)\r\n\r\n### 3. **Documentation Phase**\r\n- Create feature guides with:\r\n  - **What**: What Tarkov API provides\r\n  - **Where**: Which classes/methods to use\r\n  - **How**: Code examples from decompiled source\r\n  - **Why**: Design rationale and gotchas\r\n\r\n### 4. **Validation Phase**\r\n- Cross-reference with working mods (SAIN, BigBrain)\r\n- Verify against SPT server examples\r\n- Test simple implementations\r\n\r\n---\r\n\r\n## Key Decompiled Files (Initial Survey)\r\n\r\n### Bot AI Core\r\n- `ilspy-out/AICoreLayerClass.decompiled.cs` - AI layer system\r\n- `ilspy-out/AICoreAgentClass.decompiled.cs` - Agent lifecycle\r\n- `ilspy-out/BaseLogicLayerAbstractClass.decompiled.cs` - Logic layer base\r\n- `ilspy-out/BotMemoryClass.decompiled.cs` - Bot memory/perception\r\n- `ilspy-out/GClass168.decompiled.cs` - Brain node system (now BotNodeAbstractClass)\r\n\r\n### Bot Management\r\n- `ilspy-out/BotRequestController.decompiled.cs` - Bot spawning/requests\r\n- `ilspy-out/BotGroupRequestController.decompiled.cs` - Group spawning\r\n- `ilspy-out/BotItemTaker.decompiled.cs` - Looting behavior\r\n- `ilspy-out/BotWeaponSelector.decompiled.cs` - Weapon selection\r\n- `ilspy-out/BotTalk.decompiled.cs` - Voice lines\r\n\r\n### UI/Dialogue\r\n- `ilspy-out/EFT.UI.DropdownItemSelector.decompiled.cs` - UI selection\r\n- `ilspy-out/GClass3387.decompiled.cs` - Likely UI controller\r\n- Need to find: DialogueController, ChatBot interface\r\n\r\n### Server/Backend\r\n- `ilspy-out/BackendConfigSettingsClass.decompiled.cs` - Config system\r\n- Need to find: Route registration, profile management\r\n\r\n---\r\n\r\n## Search Strategy\r\n\r\n### Pattern-Based Searches\r\n```bash\r\n# Find bot spawning\r\ngrep -r \"spawn\" --include=\"*.cs\" ilspy-out/\r\n\r\n# Find dialogue/chat\r\ngrep -r \"dialogue\\|chat\\|friend\" --include=\"*.cs\" ilspy-out/\r\n\r\n# Find gesture/voice\r\ngrep -r \"gesture\\|voice\" --include=\"*.cs\" ilspy-out/\r\n\r\n# Find party/group\r\ngrep -r \"party\\|group\\|invite\" --include=\"*.cs\" ilspy-out/\r\n```\r\n\r\n### Class Name Patterns\r\n- `BotOwner` - Main bot controller\r\n- `BotSpawner` - Spawn system\r\n- `DialogueController` - Messaging system\r\n- `GestureMenu` / `QuickGestureMenu` - Voice commands\r\n- `BotGenerator` / `BotCreator` - Bot creation\r\n- `BotsGroup` - Group management\r\n\r\n---\r\n\r\n## Next Actions\r\n\r\n1. ‚úÖ Create knowledge base structure\r\n2. üî¥ Run pattern searches to identify key files for each area\r\n3. üî¥ Build class mapping index (GClass### ‚Üí semantic names)\r\n4. üî¥ Document each feature area systematically\r\n5. üî¥ Create quick reference guides for common operations\r\n\r\n---\r\n\r\n## Notes\r\n\r\n- **Obfuscation**: Many classes use `GClass###` naming - map to semantic names as discovered\r\n- **Version Changes**: SPT 4.0.5 has breaking changes from 3.x - note differences\r\n- **Working References**: Use SAIN, BigBrain, server-mod-examples as validation\r\n- **Priority**: Focus on Phase 0-6 features first (foundation, spawning, AI)\r\n"},"01-Bot-Spawning":{"title":"Tarkov Bot Spawning System - API Documentation\r","category":"Core Systems","content":"# Tarkov Bot Spawning System - API Documentation\r\n\r\n**Phase**: 5 (Friendly Bot Spawning)\r\n**Priority**: CRITICAL - Foundation for getting bots in game\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\nBased on decompiled source code and working FriendlyPMC implementation.\r\n\r\n---\r\n\r\n## 1. Spawn Request Flow\r\n\r\n### Core Components\r\n\r\n**BotSpawner** (standard Tarkov class)\r\n- Manages bot creation and activation\r\n- Contains `BotCreator` for profile generation\r\n- Maintains `Groups` (spawn groups) and `AllPlayers` list\r\n- Has `GetClosestZone()` method to find spawn zones near positions\r\n\r\n**BotCreator** (Tarkov class)\r\n- `ActivateBot()` - Main method to spawn and activate a bot in the game world\r\n  - Parameters: Profile, Position (GClass682), BotZone, GroupAction callback, OnActivate callback, CancellationToken\r\n  - Returns: Task<bool>\r\n\r\n**BotsController** (Tarkov class)\r\n- Main controller for all bots in raid\r\n- `AddActivePLayer()` - Hook point when player enters raid\r\n- Owns the `BotSpawner` instance\r\n\r\n### Spawn Request Structure (from FriendlyPMC)\r\n\r\n```csharp\r\n// Profile fetching from server (BotsControllerPatch.cs line 268-331)\r\nprivate async Task<Profile> FetchMemberProfile(\r\n    string aid,                // Account ID or null\r\n    Profile boss,              // Player's profile\r\n    BotCreator botCreator,\r\n    EPlayerSide side,          // BEAR, USEC, or Savage\r\n    WildSpawnType role,        // pmcBEAR, pmcUSEC, assault, etc.\r\n    BotSpawnParams spawnParams // Group settings\r\n)\r\n{\r\n    IProfileData data = new IProfileData(side, role, BotDifficulty.hard, 0f, spawnParams);\r\n\r\n    // Call backend to generate bot profile\r\n    result = await profileEndpoint.method_3<Profile[]>(new LegacyParamsStruct\r\n    {\r\n        Url = gclass1200_0.Main + \"/client/game/bot/followergenerate\",\r\n        Params = new Dictionary<string, object>\r\n        {\r\n            { \"Info\",  new Class19<List<WaveInfoClass>>(limit) },\r\n            { \"MemberId\", aid },\r\n            { \"ScavId\", scavId},\r\n            { \"Custom\", customization }\r\n        },\r\n        Retries = new byte?(LegacyParamsStruct.DefaultRetries)\r\n    });\r\n\r\n    Profile profile = result.ToList().Random();\r\n\r\n    // Load assets\r\n    await Singleton<PoolManagerClass>.Instance.LoadBundlesAndCreatePools(...);\r\n\r\n    return profile;\r\n}\r\n```\r\n\r\n### Activation Flow (from FriendlyPMC)\r\n\r\n```csharp\r\n// From BotsControllerPatch.cs line 247-265\r\nprivate async Task<bool> ActivateBotFollower(\r\n    BotCreator botCreator,\r\n    Profile profile,\r\n    GClass682 position,  // Position with CorePointId\r\n    BotZone zone,\r\n    bool shallBeGroup,\r\n    Func<BotOwner, BotZone, BotsGroup> GroupAction,\r\n    Action<BotOwner> OnActivate,\r\n    CancellationToken token\r\n)\r\n{\r\n    try\r\n    {\r\n        await botCreator.ActivateBot(\r\n            profile,\r\n            position,\r\n            zone,\r\n            false,        // isStationary\r\n            GroupAction,  // Creates/assigns bot to group\r\n            OnActivate,   // Post-spawn configuration\r\n            token\r\n        );\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        Logger.LogError(\"Failed to activate bot follower\");\r\n        return false;\r\n    }\r\n\r\n    await Task.Yield();\r\n    return true;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 2. Group Spawning\r\n\r\n### Group Creation\r\n\r\n**BotsGroup** (Tarkov class)\r\n- Manages bot squads and their coordination\r\n- Has `TargetMembersCount` for group size\r\n- Tracked in `BotSpawner.Groups`\r\n\r\n**Custom Group Implementation** (FriendlyPMC - BotsControllerPatch.cs line 87-234)\r\n\r\n```csharp\r\nprivate BotsGroup GetPlayerGroup(\r\n    pitAIBossPlayer player,  // Player as \"boss\"\r\n    BotOwner bt,             // First bot in group\r\n    BotZone zn,              // Spawn zone\r\n    int groupSize = 0\r\n)\r\n{\r\n    if (player.bossGroup != null) return player.bossGroup;\r\n\r\n    BotSpawner botSpawnerClass = Controller.BotSpawner;\r\n    var botGame = botSpawnerClass.BotGame;\r\n    var spawnGroups = botSpawnerClass.Groups;\r\n\r\n    WildSpawnType roleh;\r\n    bool sameSideFriendly = false;\r\n\r\n    // Determine faction based on player side\r\n    if (player.realPlayer.Side == EPlayerSide.Bear)\r\n        roleh = WildSpawnType.pmcBEAR;\r\n    else if (player.realPlayer.Side == EPlayerSide.Usec)\r\n        roleh = WildSpawnType.pmcUSEC;\r\n    else\r\n        roleh = WildSpawnType.assault;\r\n\r\n    GetSameSideFriendly(roleh, player.realPlayer.Side, out sameSideFriendly);\r\n\r\n    EPlayerSide side = player.realPlayer.Side;\r\n    List<BotOwner> list = new List<BotOwner>();\r\n\r\n    // CRITICAL: Configure bot AI to not attack player\r\n    if (side != EPlayerSide.Savage)\r\n    {\r\n        bt.Settings.FileSettings.Mind.ENEMY_BY_GROUPS_PMC_PLAYERS = false;\r\n        bt.Settings.FileSettings.Mind.USE_ADD_TO_ENEMY_VALIDATION = true;\r\n        bt.Settings.FileSettings.Mind.VALID_REASONS_TO_ADD_ENEMY = new EBotEnemyCause[] { };\r\n        bt.Settings.FileSettings.Mind.DEFAULT_SAVAGE_BEHAVIOUR = EWarnBehaviour.AlwaysEnemies;\r\n\r\n        if (!sameSideFriendly)\r\n        {\r\n            // Bad guy mode - hostile to all PMCs\r\n            bt.Settings.FileSettings.Mind.DEFAULT_BEAR_BEHAVIOUR = EWarnBehaviour.AlwaysEnemies;\r\n            bt.Settings.FileSettings.Mind.DEFAULT_USEC_BEHAVIOUR = EWarnBehaviour.AlwaysEnemies;\r\n        }\r\n        else\r\n        {\r\n            // Friendly to same faction\r\n            bt.Settings.FileSettings.Mind.DEFAULT_BEAR_BEHAVIOUR =\r\n                bt.Side == EPlayerSide.Bear ? EWarnBehaviour.AlwaysFriends : EWarnBehaviour.AlwaysEnemies;\r\n            bt.Settings.FileSettings.Mind.DEFAULT_USEC_BEHAVIOUR =\r\n                bt.Side == EPlayerSide.Usec ? EWarnBehaviour.AlwaysFriends : EWarnBehaviour.AlwaysEnemies;\r\n        }\r\n\r\n        // Get potential enemies for group (bots not in friendly list)\r\n        foreach (BotOwner item2 in botSpawnerClass.method_5(bt))\r\n        {\r\n            if (!Props.friendlyBotTypes.Contains(item2.Profile.Info.Settings.Role))\r\n                list.Add(item2);\r\n        }\r\n\r\n        // Create custom player group\r\n        BotsGroup botsGroup = new BotsGroupPlayer(\r\n            zn,\r\n            botGame,\r\n            bt,\r\n            list,\r\n            botSpawnerClass.DeadBodiesController,\r\n            botSpawnerClass.AllPlayers,\r\n            player\r\n        );\r\n\r\n        if (groupSize != 0)\r\n            botsGroup.TargetMembersCount = groupSize;\r\n\r\n        // Register group\r\n        spawnGroups.AddNoKey(botsGroup, zn);\r\n\r\n        // Revert temporary settings\r\n        bt.Settings.FileSettings.Mind.USE_ADD_TO_ENEMY_VALIDATION = false;\r\n    }\r\n\r\n    return botsGroup;\r\n}\r\n```\r\n\r\n### Group ID Assignment (from FriendlyPMC - BotsControllerPatch.cs line 390-396)\r\n\r\n```csharp\r\n// Followers use same GroupId as player\r\nforeach (var item in profiles)\r\n{\r\n    Profile profile = item.Value;\r\n    profile.Info.GroupId = player.realPlayer.GroupId;\r\n    profile.Info.TeamId = player.realPlayer.Profile.Info.TeamId;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. Bot Configuration\r\n\r\n### Faction and Role Assignment\r\n\r\n```csharp\r\n// From BotsControllerPatch.cs SpawnGroupBots method (line 760-776)\r\nEPlayerSide side = player.Player().Side;\r\nWildSpawnType type;\r\n\r\nif (side == EPlayerSide.Bear)\r\n    type = WildSpawnType.pmcBEAR;\r\nelse if (side == EPlayerSide.Usec)\r\n    type = WildSpawnType.pmcUSEC;\r\nelse\r\n    type = WildSpawnType.assault;  // Scav\r\n\r\n// Create spawn parameters with group info\r\nBotSpawnParams @params = new BotSpawnParams();\r\n@params.ShallBeGroup = new ShallBeGroupParams(\r\n    true,              // isGroup\r\n    false,             // ?\r\n    memberCount + 1    // total members including player\r\n);\r\n\r\nIProfileData data = new IProfileData(side, type, BotDifficulty.hard, 0f, @params);\r\n```\r\n\r\n### Post-Spawn Configuration (from BotsControllerPatch.cs line 876-940)\r\n\r\n```csharp\r\nAction<BotOwner> OnActivate = new Action<BotOwner>((BotOwner owner) =>\r\n{\r\n    Stopwatch stopWatch = new Stopwatch();\r\n    stopWatch.Start();\r\n\r\n    Action<BotOwner> OnBotState = new Action<BotOwner>((BotOwner me) =>\r\n    {\r\n        // Clear from update watcher\r\n        BotOwnerManualUpdatePatch.BotOwnerUpdate.Remove(me.ProfileId);\r\n\r\n        try\r\n        {\r\n            // CRITICAL: Prevent attack of player on spawn\r\n            me.Memory.DeleteInfoAboutEnemy(player.Player());\r\n\r\n            // Full health\r\n            me.GetPlayer.ActiveHealthController.RestoreFullHealth();\r\n\r\n            // Set tactic\r\n            string tactic = profileTactic.TryGetValue(me.Profile.ProfileId, out tactic)\r\n                ? tactic : \"Default\";\r\n\r\n            // Register as follower\r\n            BossPlayers.AddFollower(me, player, true, botType, tactic);\r\n\r\n            // Enable voice\r\n            me.BotTalk.SetSilence(0f);\r\n\r\n            // Say ready after delay\r\n            Utils.SetTimeout(() =>\r\n            {\r\n                me.BotTalk.TrySay(EPhraseTrigger.Ready);\r\n            }, 2000);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Logger.LogError(\"Failed to add \" + me.Profile.Nickname + \" as follower\");\r\n        }\r\n    });\r\n\r\n    // Register update watcher\r\n    BotOwnerManualUpdatePatch.BotOwnerUpdate.Add(owner.ProfileId, OnBotState);\r\n\r\n    // Force player side on the bot\r\n    if (owner.Side != side)\r\n    {\r\n        owner.GetPlayer.Profile.Info.Side = side;\r\n    }\r\n\r\n    // Mark as follower type\r\n    BossPlayers.ShallBeFollower(owner);\r\n\r\n    // Finalize spawn\r\n    botSpawnerClass.method_11(owner, botsData,\r\n        (BotOwner follower) =>\r\n        {\r\n            Logger.LogInfo(\"Follower \" + follower.Profile.Nickname + \" spawned\");\r\n        },\r\n        shallBeGroup,\r\n        stopWatch\r\n    );\r\n});\r\n```\r\n\r\n---\r\n\r\n## 4. Spawn Timing\r\n\r\n### Raid Start Hook (from RaidStartPatch.cs line 36-269)\r\n\r\n```csharp\r\n// Patch Class308.SendRaidSettings (raid initialization)\r\ninternal class RaidStartPatch : ModulePatch\r\n{\r\n    protected override MethodBase GetTargetMethod()\r\n    {\r\n        return AccessTools.Method(typeof(Class308), \"SendRaidSettings\");\r\n    }\r\n\r\n    [PatchPostfix]\r\n    private static void PatchPostfix(Class308 __instance, RaidSettings settings)\r\n    {\r\n        // Clear previous spawn lists\r\n        SpawnHelper.spawnMemberIds.Clear();\r\n        SpawnHelper.spawnMemberIdsScav.Clear();\r\n        SpawnHelper.spawnMemberIdsBoss.Clear();\r\n\r\n        // Collect group members to spawn\r\n        if (MainMenuControllerPatch.GroupPlayers != null)\r\n        {\r\n            foreach (var player in MainMenuControllerPatch.GroupPlayers)\r\n            {\r\n                if (player.Id == \"677c4e0cc7a538c4210d4d47\")  // Knight\r\n                {\r\n                    SpawnHelper.spawnMemberIdsBoss.Add(WildSpawnType.bossKnight);\r\n                }\r\n                else if (!settings.IsPmc && SpawnHelper.ScavSquad)\r\n                {\r\n                    SpawnHelper.spawnMemberIdsScav.AddRange(\r\n                        MainMenuControllerPatch.GroupPlayers.Select(x => x.AccountId)\r\n                    );\r\n                }\r\n                else\r\n                {\r\n                    SpawnHelper.spawnMemberIds.AddRange(\r\n                        MainMenuControllerPatch.GroupPlayers.Select(x => x.AccountId)\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        // Server config sync\r\n        string pitConfig = RequestHandler.PostJson(\"/client/raid/pitconfig\", ...);\r\n\r\n        // Seed spawn lists from server squad if no client group\r\n        if (SpawnHelper.spawnMemberIds.Count == 0 && membersCount > 0)\r\n        {\r\n            SpawnHelper.spawnMemberIds.AddRange(config.Members);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Actual Bot Spawn Timing (from BotsControllerPatch.cs line 1103-1216)\r\n\r\n```csharp\r\ninternal class BotsEventsControllerSpawnPatch : ModulePatch\r\n{\r\n    protected override MethodBase GetTargetMethod()\r\n    {\r\n        // Patch the SpawnAction method - called after initial spawn wave\r\n        return AccessTools.Method(typeof(BotsEventsController), \"SpawnAction\");\r\n    }\r\n\r\n    [PatchPostfix]\r\n    private static void PatchPostfix(BotsEventsController __instance)\r\n    {\r\n        try\r\n        {\r\n            SpawnFollowers();\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            Logger.LogError(e);\r\n        }\r\n    }\r\n\r\n    public static void SpawnFollowers()\r\n    {\r\n        if (squadSpawned || BotsControllerPatch.Controller == null)\r\n            return;\r\n\r\n        squadSpawned = true;\r\n\r\n        List<Task> squadSpawners = new List<Task>();\r\n\r\n        // Spawn PMC followers\r\n        if (SpawnHelper.spawnMemberIds.Count > 0)\r\n        {\r\n            Logger.LogInfo(\"Start Squad Spawn\");\r\n\r\n            BotsControllerPatch.spawnedPlayers.ForEach(playerBoss =>\r\n            {\r\n                Task squadSpanner = BotsControllerPatch.Instance.SpawnGroupBots(playerBoss);\r\n                squadSpawners.Add(squadSpanner);\r\n            });\r\n\r\n            Task.WhenAll(squadSpawners).ContinueWith(t =>\r\n            {\r\n                BotsControllerPatch.alliesCreationTask.Clear();\r\n            }, TaskScheduler.FromCurrentSynchronizationContext()).HandleExceptions();\r\n        }\r\n        // Spawn boss followers (Knight, BigPipe, BirdEye)\r\n        else if (SpawnHelper.spawnMemberIdsBoss.Count > 0)\r\n        {\r\n            Logger.LogInfo(\"Start Boss Ally Spawn\");\r\n\r\n            // Block normal boss spawns\r\n            BotsControllerPatch.Controller.BotSpawner.SetBlockedRoles(\r\n                new string[] { \"bossKnight\", \"followerBirdEye\", \"followerBigPipe\" }\r\n            );\r\n\r\n            BotsControllerPatch.spawnedPlayers.ForEach(playerBoss =>\r\n            {\r\n                bossSpawners.Add(\r\n                    BotsControllerPatch.Instance.SpawnBossFollower(playerBoss, type)\r\n                );\r\n            });\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Player Registration (from BotsControllerPatch.cs line 974-1034)\r\n\r\n```csharp\r\n// BotsController.AddActivePLayer patch - called when player enters raid\r\n[PatchPostfix]\r\nprivate static void PatchPostfix(BotsController __instance, Player player)\r\n{\r\n    if (Controller == null)\r\n    {\r\n        // First time initialization\r\n        Controller = __instance;\r\n        Logger.LogInfo(\"Raid Started\");\r\n    }\r\n\r\n    // Register player as \"boss\" (squad leader)\r\n    pitAIBossPlayer playerBoss = BossPlayers.AddPlayerAsBoss(player, __instance);\r\n    spawnedPlayers.Add(playerBoss);\r\n\r\n    // Pre-fetch follower profiles for performance\r\n    if (friendlyPMC.botPrefetch.Value)\r\n    {\r\n        if (playerBoss.Player().Side != EPlayerSide.Savage)\r\n        {\r\n            if (SpawnHelper.spawnMemberIdsBoss.Count > 0)\r\n                Instance?.PreFetchBossProfiles(playerBoss);\r\n            else if (SpawnHelper.spawnMemberIds.Count > 0)\r\n                Instance?.CreateFollowerProfiles(playerBoss);\r\n        }\r\n        else if (SpawnHelper.ScavSquad)\r\n        {\r\n            Instance?.PreFetchScavProfiles(playerBoss);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 5. Integration Points\r\n\r\n### Harmony Patch Targets\r\n\r\n1. **Raid Initialization**: `Class308.SendRaidSettings`\r\n   - Purpose: Collect squad members before raid starts\r\n   - Timing: Pre-raid loading screen\r\n\r\n2. **Player Registration**: `BotsController.AddActivePLayer`\r\n   - Purpose: Register player and prepare follower data\r\n   - Timing: When player object created in raid\r\n\r\n3. **Spawn Trigger**: `BotsEventsController.SpawnAction`\r\n   - Purpose: Actually spawn the followers\r\n   - Timing: After initial bot spawn wave\r\n\r\n4. **Spawn Point Selection**: `SpawnSystemClass.SelectSpawnPoint`\r\n   - Purpose: Switch to coop spawn points for followers\r\n   - Implementation:\r\n   ```csharp\r\n   [PatchPrefix]\r\n   private static void PatchPrefix(ref ESpawnCategory category, ...)\r\n   {\r\n       // Switch to coop mode if player has followers\r\n       if (category == ESpawnCategory.Player && person == null)\r\n       {\r\n           if (SpawnHelper.spawnMemberIds.Count > 0 ||\r\n               SpawnHelper.spawnMemberIdsBoss.Count > 0)\r\n           {\r\n               category = ESpawnCategory.Coop;  // Spawn together\r\n           }\r\n       }\r\n   }\r\n   ```\r\n\r\n5. **Group Management**: Multiple patches to keep raid group in sync\r\n   - `MainMenuControllerClass.method_49` - Remove group before raid start\r\n   - `MatchmakerPlayerControllerClass.method_39` - Track group additions\r\n   - `MatchmakerPlayerControllerClass.method_21` - Clear on disband\r\n   - `MatchMakerAcceptScreen.Show` - Sync UI with group\r\n\r\n### Step-by-Step Spawn Flow\r\n\r\n```\r\n1. Pre-Raid (Main Menu)\r\n   - Player invites bots to group\r\n   - MainMenuControllerPatch.GroupPlayers tracks invited members\r\n\r\n2. Raid Settings (Loading Screen)\r\n   - RaidStartPatch.PatchPostfix fires\r\n   - Populates SpawnHelper.spawnMemberIds from group\r\n   - Syncs config with server\r\n\r\n3. Raid Start\r\n   - Player spawns in world\r\n   - BotsController.AddActivePLayer fires\r\n   - Creates pitAIBossPlayer (player as \"boss\")\r\n   - Pre-fetches follower profiles (optional performance optimization)\r\n\r\n4. Initial Spawn Wave\r\n   - Game spawns initial PMCs/Scavs\r\n   - BotsEventsController.SpawnAction fires\r\n\r\n5. Follower Spawn\r\n   - BotsEventsControllerSpawnPatch.SpawnFollowers fires\r\n   - For each spawnMemberId:\r\n     a. Fetch/create bot profile with player's faction\r\n     b. Set GroupId/TeamId to match player\r\n     c. Get closest spawn zone to player\r\n     d. Create BotsGroup with player as leader\r\n     e. ActivateBot with OnActivate callback\r\n     f. OnActivate: Delete player from enemy list, set follower role\r\n\r\n6. Post-Spawn\r\n   - Bots appear near player\r\n   - BigBrain AI layers take over for following behavior\r\n```\r\n\r\n---\r\n\r\n## 6. Key APIs and Signatures\r\n\r\n### Profile Creation\r\n```csharp\r\n// Server endpoint for custom follower generation\r\nPOST /client/game/bot/followergenerate\r\n{\r\n    \"Info\": Class19<List<WaveInfoClass>>,\r\n    \"MemberId\": string (nullable),\r\n    \"ScavId\": string (nullable),\r\n    \"Custom\": Dictionary<string, dynamic>\r\n}\r\nReturns: Profile[]\r\n```\r\n\r\n### Bot Activation\r\n```csharp\r\nTask ActivateBot(\r\n    Profile profile,\r\n    GClass682 position,        // { Vector3 position, int CorePointId, bool isOutside }\r\n    BotZone zone,\r\n    bool isStationary,\r\n    Func<BotOwner, BotZone, BotsGroup> groupAction,\r\n    Action<BotOwner> onActivate,\r\n    CancellationToken cancellationToken\r\n)\r\n```\r\n\r\n### Position Helper\r\n```csharp\r\n// Get closest cover point for spawn\r\nAICorePoint GetClosestCorePoint(BotsController controller, Vector3 position)\r\n{\r\n    var coversData = controller.CoversData;\r\n    var groupPoint = coversData.GetClosest(position);\r\n    return groupPoint.CorePointInGame;\r\n}\r\n\r\n// Get spawn zone\r\nBotZone zone = botSpawner.GetClosestZone(position, out float distance);\r\n```\r\n\r\n### Group Creation\r\n```csharp\r\nBotsGroup group = new BotsGroupPlayer(\r\n    BotZone zone,\r\n    IBotGame botGame,\r\n    BotOwner initialBot,\r\n    List<BotOwner> potentialEnemies,\r\n    DeadBodiesController deadBodies,\r\n    List<Player> allPlayers,\r\n    pitAIBossPlayer playerBoss\r\n);\r\n```\r\n\r\n---\r\n\r\n## 7. Working Code Example\r\n\r\nComplete example from FriendlyPMC (simplified):\r\n\r\n```csharp\r\npublic async Task SpawnSquadMember(\r\n    Player player,\r\n    string memberAccountId,\r\n    BotsController controller\r\n)\r\n{\r\n    // 1. Setup\r\n    BotSpawner botSpawner = controller.BotSpawner;\r\n    BotCreator botCreator = botSpawner.BotCreator;\r\n    EPlayerSide side = player.Side;\r\n    Vector3 position = player.Position;\r\n\r\n    // 2. Determine bot type (match player faction)\r\n    WildSpawnType type = side == EPlayerSide.Bear\r\n        ? WildSpawnType.pmcBEAR\r\n        : WildSpawnType.pmcUSEC;\r\n\r\n    // 3. Create spawn parameters\r\n    BotSpawnParams spawnParams = new BotSpawnParams();\r\n    spawnParams.ShallBeGroup = new ShallBeGroupParams(true, false, 2);  // Player + 1 bot\r\n\r\n    // 4. Fetch bot profile from server\r\n    Profile profile = await FetchMemberProfile(\r\n        memberAccountId,\r\n        player.Profile,\r\n        botCreator,\r\n        side,\r\n        type,\r\n        spawnParams\r\n    );\r\n\r\n    // 5. Set group/team IDs to match player\r\n    profile.Info.GroupId = player.GroupId;\r\n    profile.Info.TeamId = player.Profile.Info.TeamId;\r\n\r\n    // 6. Get spawn location\r\n    BotZone zone = botSpawner.GetClosestZone(position, out var dist);\r\n    var closestCorePoint = GetClosestCorePoint(controller, position);\r\n\r\n    // 7. Define group creation callback\r\n    Func<BotOwner, BotZone, BotsGroup> groupAction = (BotOwner bot, BotZone zn) =>\r\n    {\r\n        return GetPlayerGroup(playerBoss, bot, zn, 1);\r\n    };\r\n\r\n    // 8. Define post-spawn callback\r\n    Action<BotOwner> onActivate = (BotOwner bot) =>\r\n    {\r\n        // Prevent attacking player\r\n        bot.Memory.DeleteInfoAboutEnemy(player);\r\n\r\n        // Force same faction\r\n        bot.GetPlayer.Profile.Info.Side = side;\r\n\r\n        // Full health\r\n        bot.GetPlayer.ActiveHealthController.RestoreFullHealth();\r\n\r\n        // Register as follower (for BigBrain AI)\r\n        BossPlayers.AddFollower(bot, playerBoss, true, type, \"Default\");\r\n    };\r\n\r\n    // 9. Activate the bot\r\n    await botCreator.ActivateBot(\r\n        profile,\r\n        new GClass682(position, closestCorePoint.Id, false),\r\n        zone,\r\n        false,\r\n        groupAction,\r\n        onActivate,\r\n        CancellationToken.None\r\n    );\r\n}\r\n```\r\n\r\n---\r\n\r\n## 8. Critical Notes\r\n\r\n### Faction Configuration\r\n- **MUST** set `profile.Info.Side` to match player before/after spawn\r\n- **MUST** configure bot AI to not attack player:\r\n  ```csharp\r\n  bot.Settings.FileSettings.Mind.ENEMY_BY_GROUPS_PMC_PLAYERS = false;\r\n  bot.Memory.DeleteInfoAboutEnemy(player);\r\n  ```\r\n- **MUST** set same GroupId and TeamId as player\r\n\r\n### Spawn Point Selection\r\n- Use `ESpawnCategory.Coop` for followers (spawns near player)\r\n- Use `ESpawnCategory.Player` causes random distant spawns\r\n- SelectSpawnPointPatch shows how to intercept and modify spawn category\r\n\r\n### Timing Issues\r\n- Profile pre-fetching improves performance (avoid spawn lag)\r\n- Must wait for `BotsEventsController.SpawnAction` before spawning\r\n- Spawning too early causes issues with game initialization\r\n\r\n### Group Management\r\n- The group management patches are crucial for keeping raid mode as `Local` (offline)\r\n- Without them, game switches to online/coop mode which breaks SPT\r\n\r\n### Boss Followers\r\n- Knight, BigPipe, BirdEye have special handling\r\n- Must block their normal spawn waves to avoid duplicates\r\n- They use different AI brain layers (KnightFollowerBrain, etc.)\r\n\r\n---\r\n\r\n## 9. Server-Side Components\r\n\r\nFriendlyPMC has a server-side component for:\r\n- Squad member roster management\r\n- Custom bot profile generation (`/client/game/bot/followergenerate`)\r\n- Equipment/loadout configuration\r\n- Chat bot (Squad Manager)\r\n\r\nFor basic functionality, you can use standard bot generation endpoints, but custom appearance/gear requires server integration.\r\n\r\n---\r\n\r\n## Summary\r\n\r\nTo spawn friendly bots with the player:\r\n\r\n1. **Pre-Raid**: Track which squad members player invites\r\n2. **Raid Init**: Collect spawn list and sync with server\r\n3. **Player Spawn**: Register player as \"boss\" and pre-fetch profiles\r\n4. **Post-Initial Wave**: Actually spawn followers using:\r\n   - Fetch Profile (with player's faction)\r\n   - Set GroupId/TeamId to match player\r\n   - Configure AI to not attack player\r\n   - Use Coop spawn points (near player)\r\n   - ActivateBot with group/activation callbacks\r\n5. **Post-Spawn**: Delete player from enemy list, enable follower AI\r\n\r\nThe key is using the `BotCreator.ActivateBot` API with proper faction configuration, group assignment, and AI settings to ensure bots recognize the player as friendly and spawn nearby.\r\n"},"02-Bot-AI-Brain":{"title":"Tarkov Bot AI/Brain System - API Documentation\r","category":"Core Systems","content":"# Tarkov Bot AI/Brain System - API Documentation\r\n\r\n**Phase**: 6 (Cluster Perception & Basic AI Behavior)\r\n**Priority**: CRITICAL - Foundation for all bot behavior\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\nBased on the decompiled source code analysis, this document provides a comprehensive guide to the Tarkov Bot AI system for building custom bot AI (particularly for the FriendlyPMC mod with BigBrain integration).\r\n\r\n---\r\n\r\n## 1. BotMemoryClass - Bot Perception and Memory System\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\ilspy-out\\BotMemoryClass.decompiled.cs`\r\n\r\n### Class Overview\r\nThe core perception and memory management system for bots. Handles enemy tracking, cover behavior, damage processing, and combat state.\r\n\r\n### Key Fields\r\n\r\n#### Core References\r\n```csharp\r\npublic BotOwner BotOwner_0;              // Main bot controller reference\r\npublic BotsGroup BotsGroup_0;            // Group this bot belongs to\r\npublic EnemyInfo EnemyInfo_0;            // Current goal enemy (accessed via GoalEnemy property)\r\npublic EnemyInfo EnemyInfo_1;            // Last enemy (accessed via LastEnemy property)\r\n```\r\n\r\n#### Perception Data\r\n```csharp\r\npublic PlaceForCheck CurrentPlaceForCheck;           // Current place being checked\r\npublic DangerDataClass DangerData;                   // Danger point tracking\r\npublic BotCurrentCoverInfoClass BotCurrentCoverInfo; // Cover position info\r\npublic BotObserveDataClass botObserveData;           // Observation data\r\npublic GoalTargetClass GoalTarget;                   // Current goal/target\r\n```\r\n\r\n#### Combat State\r\n```csharp\r\npublic bool Bool_0;              // IsInCover backing field\r\npublic bool IsDamaged;           // Recently took damage\r\npublic bool IsUnderFire;         // Currently under fire\r\npublic float LastTimeHit;        // Timestamp of last hit\r\npublic Vector3 LastHitPos;       // Position of last hit\r\npublic float EnemySetTime;       // When current enemy was set\r\npublic float LastEnemyTimeSeen;  // Last time any enemy was seen\r\n```\r\n\r\n#### Cover Management\r\n```csharp\r\npublic CustomNavigationPoint CurCustomCoverPoint;  // Current cover point\r\npublic float ComeToCoverTime;                      // Time arrived at cover\r\npublic float LeaveCoverTime;                       // Time left cover\r\npublic bool IsInCover;                             // Currently in cover position\r\n```\r\n\r\n#### Peace/Combat State\r\n```csharp\r\npublic bool IsPeace;              // Bot is in peaceful state\r\npublic bool AttackImmediately;    // Should attack immediately\r\npublic bool ShallRunIfNoAmmo;     // Will run if out of ammo\r\n```\r\n\r\n### Key Properties\r\n\r\n#### GoalEnemy Property (Lines 320-369)\r\n**Critical**: This is THE main enemy target property. Setting this triggers cascading effects.\r\n\r\n```csharp\r\npublic EnemyInfo GoalEnemy\r\n{\r\n    get { return EnemyInfo_0; }\r\n    set\r\n    {\r\n        // Triggers multiple events when enemy changes:\r\n        // 1. Lose aim target if different enemy\r\n        // 2. Subscribe to enemy hit events\r\n        // 3. Fire OnGoalEnemyChanged event\r\n        // 4. Reset danger data\r\n        // 5. Update EnemySetTime\r\n    }\r\n}\r\n```\r\n\r\n**Usage Pattern**:\r\n```csharp\r\n// Setting goal enemy\r\nbotOwner.Memory.GoalEnemy = enemyInfo;\r\n\r\n// Clearing enemy\r\nbotOwner.Memory.GoalEnemy = null;\r\n\r\n// Checking for enemy\r\nif (botOwner.Memory.HaveEnemy)\r\n{\r\n    EnemyInfo enemy = botOwner.Memory.GoalEnemy;\r\n    if (enemy.IsVisible && enemy.CanShoot)\r\n    {\r\n        // Can engage\r\n    }\r\n}\r\n```\r\n\r\n### Critical Methods\r\n\r\n#### Constructor (Line 628)\r\n```csharp\r\npublic BotMemoryClass(BotOwner owner, BotsGroup botsGroup)\r\n```\r\nInitializes all sub-systems: GoalTarget, ObserveData, DangerData, CoverInfo.\r\n\r\n#### AddEnemy (Line 767)\r\n```csharp\r\npublic void AddEnemy([NotNull] IPlayer enemy, BotSettingsClass groupInfo, bool onActivation)\r\n```\r\n**Purpose**: Registers a new enemy to the bot's enemy list.\r\n\r\n**Key Logic**:\r\n- Validates enemy isn't self or group member\r\n- Creates EnemyInfo via `BotOwner_0.EnemiesController.AddNew()`\r\n- Subscribes to enemy death event\r\n- If close (<625 units) and can shoot, immediately sets as GoalEnemy\r\n- Fires `OnAddEnemy` event\r\n\r\n**Integration Point**: This is where you'd hook to add player followers to enemy lists.\r\n\r\n#### DeleteInfoAboutEnemy (Line 736)\r\n```csharp\r\npublic void DeleteInfoAboutEnemy(IPlayer gamePerson)\r\n```\r\nRemoves enemy from tracking, clears if current GoalEnemy or LastEnemy.\r\n\r\n#### GetHit (Line 841)\r\n```csharp\r\npublic void GetHit(DamageInfoStruct damageInfo)\r\n```\r\n**Purpose**: Processes damage received by the bot.\r\n\r\n**Key Features**:\r\n- Delays processing based on current state (peace vs combat)\r\n- Updates LastTimeHit, LastHitPos\r\n- Triggers medical system\r\n- Affects aiming system\r\n- May add danger points\r\n- Can trigger revenge against entire group if `REVENGE_TO_GROUP` enabled\r\n\r\n**Integration Point**: Critical for cluster-based damage sharing (Phase 6).\r\n\r\n#### SetUnderFire (Line 931)\r\n```csharp\r\npublic void SetUnderFire(IPlayer source)\r\n```\r\nTriggers voice lines, sets under fire timer, may switch to Ambush tactic.\r\n\r\n#### Spotted (Line 657)\r\n```csharp\r\npublic void Spotted(bool byHit, Vector3? from = null, float? secToBeSpotted = null)\r\n```\r\n**Purpose**: Called when bot's cover is compromised.\r\n\r\n**Key Logic**:\r\n- Marks cover points as spotted\r\n- Forces leave cover\r\n- May add danger points\r\n- Fires `OnSpottedByHit` event\r\n\r\n#### CheckIsPeace (Line 912)\r\n```csharp\r\npublic void CheckIsPeace()\r\n```\r\n**Purpose**: Determines if bot should be in peaceful state.\r\n\r\n**Conditions for Peace**:\r\n- No grenade threat\r\n- No close danger\r\n- No artillery danger\r\n- No current enemy\r\n- No danger points\r\n- No active goals\r\n- No dead bodies to check\r\n- No active requests\r\n\r\n**Effect**: Adjusts vision distance when peaceful.\r\n\r\n#### SetCoverPoints (Line 689)\r\n```csharp\r\npublic void SetCoverPoints(CustomNavigationPoint value, string debugdata = \"\")\r\n```\r\nSets new cover point, automatically marks as in cover if close enough (<1 unit).\r\n\r\n### Events\r\n\r\n#### OnAddEnemy\r\n```csharp\r\npublic event Action<IPlayer> OnAddEnemy\r\n```\r\nFired when new enemy added to tracking.\r\n\r\n#### OnGoalEnemyChanged\r\n```csharp\r\npublic event Action<BotOwner> OnGoalEnemyChanged\r\n```\r\n**Critical**: Fired when GoalEnemy changes (including to/from null).\r\n\r\n**Usage for BigBrain**:\r\n```csharp\r\nbotOwner.Memory.OnGoalEnemyChanged += (bot) =>\r\n{\r\n    // React to enemy changes\r\n    // Update custom layer logic\r\n    // Sync with cluster members\r\n};\r\n```\r\n\r\n#### OnInCoverChange\r\n```csharp\r\npublic event Action<bool, CustomNavigationPoint> OnInCoverChange\r\n```\r\nFired when IsInCover changes to true.\r\n\r\n#### OnPeaceChange\r\n```csharp\r\npublic event Action<bool> OnPeaceChange\r\n```\r\nFired when peace state changes.\r\n\r\n#### OnSpottedByHit\r\n```csharp\r\npublic event Action<Vector3?> OnSpottedByHit\r\n```\r\nFired when cover spotted by taking hit.\r\n\r\n#### OnBulletNear\r\n```csharp\r\npublic event Action<BotOwner, IPlayer> OnBulletNear\r\n```\r\nFired when bullets pass near bot.\r\n\r\n### Constants\r\n```csharp\r\npublic const float SDIST_TO_AFFECT_CLOSE_ENEMY = 625f;  // Squared distance for close enemy\r\npublic const float SDIST_CLOSE_COVER = 1.6f;            // Squared distance to be \"in cover\"\r\n```\r\n\r\n---\r\n\r\n## 2. AICoreLayerClass - AI Layer Base System\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\ilspy-out\\AICoreLayerClass.decompiled.cs`\r\n\r\n### Class Overview\r\nGeneric base class for all AI layers (the `T` is typically `BotLogicDecision`). This is what BigBrain layers extend.\r\n\r\n### Key Properties\r\n```csharp\r\npublic abstract int Priority { get; }  // Layer priority (higher = more important)\r\npublic bool IsActive { get; set; }     // Is this layer currently active\r\n```\r\n\r\n### Abstract Methods (Must Implement)\r\n\r\n#### GetDecision\r\n```csharp\r\npublic abstract AICoreActionResultStruct<T, GClass26> GetDecision();\r\n```\r\n**Purpose**: Returns what action/decision this layer wants the bot to take.\r\n\r\n**BigBrain Example**:\r\n```csharp\r\npublic override AICoreActionResultStruct<BotLogicDecision, GClass26> GetDecision()\r\n{\r\n    if (shouldFollowPlayer)\r\n    {\r\n        return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n            BotLogicDecision.followPlayer,\r\n            \"Following assigned player\"\r\n        );\r\n    }\r\n    // Return default/fallback decision\r\n}\r\n```\r\n\r\n#### ShallEndCurrentDecision\r\n```csharp\r\npublic abstract AICoreActionEndStruct ShallEndCurrentDecision(\r\n    AICoreActionResultStruct<T, GClass26> curDecision\r\n);\r\n```\r\n**Purpose**: Determines if current decision should end.\r\n\r\n**Returns**: `AICoreActionEndStruct` with `.Value = true` to end, `false` to continue.\r\n\r\n**Example**:\r\n```csharp\r\npublic override AICoreActionEndStruct ShallEndCurrentDecision(\r\n    AICoreActionResultStruct<BotLogicDecision, GClass26> curDecision\r\n)\r\n{\r\n    if (curDecision.Action == BotLogicDecision.followPlayer)\r\n    {\r\n        // End if player too far or enemy spotted\r\n        if (distanceToPlayer > maxFollowDistance)\r\n            return new AICoreActionEndStruct(\"Player too far\");\r\n\r\n        if (BotOwner_0.Memory.GoalEnemy != null)\r\n            return new AICoreActionEndStruct(\"Enemy spotted\");\r\n\r\n        // Continue following\r\n        return new AICoreActionEndStruct(); // .Value defaults to false\r\n    }\r\n}\r\n```\r\n\r\n#### ShallUseNow\r\n```csharp\r\npublic abstract bool ShallUseNow();\r\n```\r\n**Purpose**: Determines if this layer should be active right now.\r\n\r\n**Example**:\r\n```csharp\r\npublic override bool ShallUseNow()\r\n{\r\n    // Only active if assigned to follow and not dead\r\n    return hasAssignedPlayer && !BotOwner_0.IsDead;\r\n}\r\n```\r\n\r\n#### Name\r\n```csharp\r\npublic abstract string Name();\r\n```\r\nReturns layer name for debugging.\r\n\r\n### Virtual Methods (Can Override)\r\n\r\n#### GetCustomData\r\n```csharp\r\npublic virtual string GetCustomData()\r\n```\r\nReturns custom debug data string.\r\n\r\n#### ManualUpdate\r\n```csharp\r\npublic virtual void ManualUpdate()\r\n```\r\nCalled every frame for custom update logic.\r\n\r\n#### DecisionChanged\r\n```csharp\r\npublic virtual void DecisionChanged(\r\n    AICoreActionResultStruct<T, GClass26>? prevDecision,\r\n    AICoreActionResultStruct<T, GClass26> nextDecision\r\n)\r\n```\r\nCalled when decision changes - use for cleanup/setup.\r\n\r\n#### OnActivate\r\n```csharp\r\npublic virtual void OnActivate()\r\n```\r\nCalled when layer first becomes active.\r\n\r\n#### Dispose\r\n```csharp\r\npublic virtual void Dispose()\r\n```\r\nCleanup when layer destroyed.\r\n\r\n### Events\r\n\r\n#### OnEndCurDecision\r\n```csharp\r\npublic event Action<AICoreActionEndStruct> OnEndCurDecision\r\n```\r\nFired when current decision ends.\r\n\r\n#### OnStartCurDecision\r\n```csharp\r\npublic event Action<AICoreActionResultStruct<T, GClass26>> OnStartCurDecision\r\n```\r\nFired when new decision starts.\r\n\r\n### Update Flow (Line 106)\r\n```csharp\r\npublic AICoreActionResultStruct<T, GClass26>? Update(\r\n    AICoreActionResultStruct<T, GClass26>? prevDecision\r\n)\r\n{\r\n    if (!prevDecision.HasValue)\r\n    {\r\n        // First update - get initial decision\r\n        prevDecision = GetDecision();\r\n        return prevDecision.Value;\r\n    }\r\n\r\n    ManualUpdate();\r\n\r\n    // Check if should end current decision\r\n    AICoreActionEndStruct end = ShallEndCurrentDecision(prevDecision.Value);\r\n    if (end.Value)\r\n    {\r\n        // Fire end event\r\n        OnEndCurDecision?.Invoke(end);\r\n\r\n        // Get new decision\r\n        var decision = GetDecision();\r\n        DecisionChanged(prevDecision, decision);\r\n\r\n        // Fire start event\r\n        OnStartCurDecision?.Invoke(decision);\r\n\r\n        return decision;\r\n    }\r\n\r\n    return prevDecision; // Continue current decision\r\n}\r\n```\r\n\r\n**Key Insight**: The layer system is state-based. Each layer maintains a current decision until `ShallEndCurrentDecision` returns true.\r\n\r\n---\r\n\r\n## 3. BaseLogicLayerAbstractClass - Logic Layer Base\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\ilspy-out\\BaseLogicLayerAbstractClass.decompiled.cs`\r\n\r\n### Class Hierarchy\r\n```csharp\r\npublic abstract class BaseLogicLayerAbstractClass : AICoreLayerClass<BotLogicDecision>\r\n```\r\n\r\nExtends `AICoreLayerClass` with `BotLogicDecision` enum type.\r\n\r\n### Key Fields\r\n```csharp\r\npublic BotOwner BotOwner_0;                        // Bot reference\r\npublic bool Bool_1;                                 // Next frame decision flag\r\npublic int Int_0;                                   // Priority (sealed property)\r\npublic AICoreActionEndStruct AICoreActionEndStruct;     // Default end struct (false)\r\npublic AICoreActionEndStruct AICoreActionEndStruct_1;   // Continue end struct (false)\r\n```\r\n\r\n### Constructor\r\n```csharp\r\npublic BaseLogicLayerAbstractClass(BotOwner bot, int priority)\r\n{\r\n    Int_0 = priority;\r\n    BotOwner_0 = bot;\r\n}\r\n```\r\n\r\n### Static Helper Methods\r\n\r\n#### HoldOrCover (Line 32)\r\n```csharp\r\npublic static BotLogicDecision HoldOrCover(BotOwner owner)\r\n{\r\n    if (owner.Memory.IsInCover)\r\n        return BotLogicDecision.holdPosition;\r\n    return BotLogicDecision.goToCoverPoint;\r\n}\r\n```\r\n\r\n#### HoldOrCoverRun (Line 41)\r\n```csharp\r\npublic static BotLogicDecision HoldOrCoverRun(BotOwner owner)\r\n{\r\n    if (owner.Memory.IsInCover)\r\n        return BotLogicDecision.holdPosition;\r\n    return BotLogicDecision.runToCover;\r\n}\r\n```\r\n\r\n### DecisionChanged Override (Line 56)\r\nHandles cleanup when changing between decisions - notably drops stationary weapons when leaving certain states.\r\n\r\n### ShallEndCurrentDecision Override (Line 66)\r\n**Massive switch statement** routing to specific `End*` methods for each `BotLogicDecision` type.\r\n\r\n**Pattern**:\r\n```csharp\r\nswitch (curDecision.Action)\r\n{\r\n    case BotLogicDecision.holdPosition:\r\n        return EndHoldPosition();\r\n    case BotLogicDecision.shootFromPlace:\r\n        return EndShootFromPlace();\r\n    // ... 60+ cases\r\n}\r\n```\r\n\r\n### End Methods (Virtual)\r\nEach decision has a corresponding `End*` method you can override:\r\n\r\n```csharp\r\npublic virtual AICoreActionEndStruct EndHoldPosition()\r\npublic virtual AICoreActionEndStruct EndShootFromPlace()\r\npublic virtual AICoreActionEndStruct EndGoToCoverPoint()\r\npublic virtual AICoreActionEndStruct EndAttackMoving()\r\npublic virtual AICoreActionEndStruct EndFollowPlayer()\r\n// ... many more\r\n```\r\n\r\n**Default**: Most return `AICoreActionEndStruct` (which defaults to `.Value = false`, meaning \"don't end\").\r\n\r\n**Override Pattern**:\r\n```csharp\r\npublic override AICoreActionEndStruct EndFollowPlayer()\r\n{\r\n    // Check conditions to end following\r\n    if (targetPlayerDead)\r\n        return new AICoreActionEndStruct(\"Target dead\");\r\n\r\n    if (tooFarFromTarget)\r\n        return new AICoreActionEndStruct(\"Out of range\");\r\n\r\n    // Continue following\r\n    return AICoreActionEndStruct_1; // false - don't end\r\n}\r\n```\r\n\r\n### Important End Methods\r\n\r\n#### EndRepairMalfunction (Line 377)\r\n```csharp\r\npublic virtual AICoreActionEndStruct EndRepairMalfunction()\r\n{\r\n    if (BotOwner_0.WeaponManager.Malfunctions.HaveMalfunction())\r\n        return AICoreActionEndStruct_1; // Still malfunctioning\r\n    return AICoreActionEndStruct; // Fixed\r\n}\r\n```\r\n\r\n#### EndFlashed (Line 618)\r\n```csharp\r\npublic virtual AICoreActionEndStruct EndFlashed()\r\n{\r\n    if (BotOwner_0.FlashGrenade.IsFlashed)\r\n        return AICoreActionEndStruct_1; // Still flashed\r\n    return AICoreActionEndStruct; // Recovered\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. BaseLogicLayerSimpleAbstractClass - Enhanced Logic Layer\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\decompiled_BaseLogic.cs\\BaseLogicLayerSimpleAbstractClass.decompiled.cs`\r\n\r\n### Class Hierarchy\r\n```csharp\r\npublic abstract class BaseLogicLayerSimpleAbstractClass : BaseLogicLayerAbstractClass\r\n```\r\n\r\nMost custom layers extend this rather than `BaseLogicLayerAbstractClass`.\r\n\r\n### Key Fields\r\n```csharp\r\npublic AICoreActionResultStruct<BotLogicDecision, GClass26> Gstruct8_0;  // Last decision\r\npublic bool Bool_2;              // Is holding for time period\r\npublic float Float_2;            // Hold end time\r\npublic BotLogicDecision? Nullable_0;  // Next frame decision override\r\npublic bool Bool_3;              // Last melee can run state\r\n```\r\n\r\n### Static Utility Methods\r\n\r\n#### TryMoveToEnemy (Line 29)\r\n```csharp\r\npublic static BotLogicDecision TryMoveToEnemy(\r\n    BotOwner bot,\r\n    BotLogicDecision runDecision = BotLogicDecision.runToEnemy\r\n)\r\n```\r\n**Purpose**: Checks if path to enemy exists, returns appropriate decision.\r\n\r\n**Returns**:\r\n- `runDecision` if path exists\r\n- `HoldOrCover(bot)` if no path\r\n\r\n**Usage**:\r\n```csharp\r\nif (shouldPursue)\r\n{\r\n    return TryMoveToEnemy(BotOwner_0, BotLogicDecision.runToEnemy);\r\n}\r\n```\r\n\r\n#### CheckMedsToStop (Line 53)\r\n```csharp\r\npublic static bool CheckMedsToStop(BotOwner bot)\r\n```\r\nChecks if healing should be interrupted due to close/visible enemy.\r\n\r\n#### IsPointInsideDangerZone (Line 71)\r\n```csharp\r\npublic static bool IsPointInsideDangerZone(BotOwner bot, Vector3 point)\r\n```\r\nChecks if point is in active danger area.\r\n\r\n### Combat Logic Methods\r\n\r\n#### InFightLogic (Line 103)\r\n```csharp\r\npublic AICoreActionResultStruct<BotLogicDecision, GClass26>? InFightLogic()\r\n```\r\n**Purpose**: Core combat decision logic when enemy present.\r\n\r\n**Flow**:\r\n1. Check if should shoot immediately (`method_4()`)\r\n2. Check if can shoot from cover (`method_6()`)\r\n3. Check door scenarios\r\n4. Returns null if no combat decision applicable\r\n\r\n**Usage in Custom Layer**:\r\n```csharp\r\npublic override AICoreActionResultStruct<BotLogicDecision, GClass26> GetDecision()\r\n{\r\n    if (BotOwner_0.Memory.GoalEnemy != null)\r\n    {\r\n        var fightDecision = InFightLogic();\r\n        if (fightDecision.HasValue)\r\n            return fightDecision.Value;\r\n    }\r\n\r\n    // Custom logic when not in immediate combat\r\n}\r\n```\r\n\r\n#### method_4 - ShootImmediately Check (Line 127)\r\n```csharp\r\npublic bool method_4()\r\n```\r\nReturns true if should shoot immediately (very close enemy or group member shooting).\r\n\r\n#### method_6 - CanShootFromCover Check (Line 150)\r\n```csharp\r\npublic bool method_6(out string cause)\r\n```\r\n**Purpose**: Comprehensive check if can shoot from current cover.\r\n\r\n**Checks**:\r\n1. Is in cover\r\n2. Enough distance to shoot\r\n3. Can shoot to target from cover\r\n4. Stationary weapon not ending\r\n\r\n**Usage**:\r\n```csharp\r\nif (method_6(out string cause))\r\n{\r\n    // Can shoot from cover\r\n    return BotLogicDecision.shootFromCover;\r\n}\r\nelse\r\n{\r\n    // Cause contains reason why can't shoot\r\n}\r\n```\r\n\r\n### Hold Position Logic\r\n\r\n#### HoldFor (Line 190)\r\n```csharp\r\npublic virtual BotLogicDecision HoldFor(float sec)\r\n{\r\n    if (sec > 0f)\r\n    {\r\n        Float_2 = Time.time + sec;\r\n        Bool_2 = true;\r\n    }\r\n    return BotLogicDecision.holdPosition;\r\n}\r\n```\r\n**Purpose**: Hold position for specific duration.\r\n\r\n#### method_7 - Check Hold Ended (Line 176)\r\n```csharp\r\npublic bool method_7()\r\n{\r\n    if (Bool_2 && Float_2 < Time.time)\r\n    {\r\n        Bool_2 = false;\r\n        return true; // Hold period ended\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n### Cover Point Finding\r\n\r\n#### FindPoint (Line 98)\r\n```csharp\r\npublic virtual CustomNavigationPoint FindPoint(\r\n    CoverSearchData data,\r\n    Func<CoverSearchData, CustomNavigationPoint> p,\r\n    bool checkCurrent\r\n)\r\n```\r\nFinds appropriate cover point, optionally checking if current cover is good enough.\r\n\r\n### Combat State Checks\r\n\r\n#### method_3 - IsDogFighting (Line 93)\r\n```csharp\r\npublic bool method_3()\r\n{\r\n    return BotOwner_0.DogFight.DogFightState != BotDogFightStatus.none;\r\n}\r\n```\r\n\r\n#### method_5 - CanSeeEnemyPosition (Line 136)\r\n```csharp\r\npublic bool method_5(EnemyInfo info)\r\n```\r\nLine-of-sight check to enemy's last position.\r\n\r\n#### method_9 - NeedsReload (Line 217)\r\n```csharp\r\npublic bool method_9()\r\n{\r\n    return (float)BotOwner_0.WeaponManager.Reload.BulletCount /\r\n           (float)BotOwner_0.WeaponManager.Reload.MaxBulletCount <\r\n           BotOwner_0.Settings.FileSettings.Boss.PERCENT_BULLET_TO_RELOAD;\r\n}\r\n```\r\n\r\n#### method_12 - WasRecentlyHit (Line 572)\r\n```csharp\r\npublic bool method_12(float period)\r\n{\r\n    return Time.time - BotOwner_0.Memory.LastTimeHit < period;\r\n}\r\n```\r\n\r\n### Search Enemy Check\r\n\r\n#### CanSearchEnemy (Line 550)\r\n```csharp\r\npublic virtual bool CanSearchEnemy()\r\n```\r\n**Purpose**: Determines if bot should search for lost enemy.\r\n\r\n**Conditions**:\r\n- No current enemy OR\r\n- Not recently hit AND\r\n- Enemy not visible/shootable but searchable AND\r\n- In attack tactic OR enough time passed\r\n\r\n**Integration Point**: Override this for custom follower behavior (e.g., don't search if following player).\r\n\r\n### Enhanced End Methods\r\n\r\nMany end methods have enhanced logic:\r\n\r\n#### EndHoldPosition (Line 617)\r\n```csharp\r\npublic override AICoreActionEndStruct EndHoldPosition()\r\n{\r\n    if (method_7()) // Hold period ended\r\n        return new AICoreActionEndStruct(\"EndHol\");\r\n\r\n    if (!BotOwner_0.Memory.IsInCover)\r\n        return new AICoreActionEndStruct(\"IsInCover\");\r\n\r\n    if (goalEnemy == null)\r\n    {\r\n        if (CanSearchEnemy())\r\n            return new AICoreActionEndStruct(\"CanSearchEn\");\r\n    }\r\n    else if (goalEnemy.IsVisible && goalEnemy.CanShoot)\r\n    {\r\n        return new AICoreActionEndStruct(\"CanShoot\");\r\n    }\r\n\r\n    return AICoreActionEndStruct_1; // Continue holding\r\n}\r\n```\r\n\r\n#### EndGoToCoverPoint (Line 536)\r\n```csharp\r\npublic override AICoreActionEndStruct EndGoToCoverPoint()\r\n{\r\n    if (BotOwner_0.Memory.IsInCover)\r\n        return new AICoreActionEndStruct(\"IsInCover\");\r\n\r\n    if (goalEnemy != null && goalEnemy.IsVisible && goalEnemy.CanShoot)\r\n        return new AICoreActionEndStruct(\"VisibleCanS\");\r\n\r\n    return AICoreActionEndStruct_1; // Continue moving to cover\r\n}\r\n```\r\n\r\n### CalcActionNextFrame (Line 121)\r\n```csharp\r\npublic void CalcActionNextFrame(BotLogicDecision? nextLogic = null)\r\n{\r\n    Nullable_0 = nextLogic;\r\n    Bool_1 = true;\r\n}\r\n```\r\n**Purpose**: Forces decision recalculation next frame, optionally to specific logic.\r\n\r\n---\r\n\r\n## 5. BaseBrain - Brain/Strategy System\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\decompiled_BaseBrain.cs\\BaseBrain.decompiled.cs`\r\n\r\n### Class Hierarchy\r\n```csharp\r\npublic abstract class BaseBrain : AICoreStrategyAbstractClass<BotLogicDecision>\r\n```\r\n\r\nThe brain manages multiple layers and decides which is active.\r\n\r\n### Key Fields\r\n```csharp\r\npublic BotOwner Owner;        // Bot owner reference\r\npublic GClass71 Debug;        // Debug layer (priority 1000)\r\n```\r\n\r\n### Key Properties\r\n```csharp\r\npublic AICoreLayerClass<BotLogicDecision> CurLayerInfo => base.GClass35_0;\r\n```\r\n**Purpose**: Gets current active layer.\r\n\r\n### Constructor (Line 17)\r\n```csharp\r\npublic BaseBrain(BotOwner owner)\r\n{\r\n    Owner = owner;\r\n\r\n    // Setup debug layer if enabled\r\n    bool flag = DebugBotData.UseDebugData && DebugBotData.Instance.DebugBrain;\r\n    Debug = new GClass71(owner, 1000);\r\n    method_0(1000, Debug, flag); // Add layer\r\n\r\n    if (flag)\r\n        ActivateDebug(DebugBotData.Instance.DebugBotDesition);\r\n\r\n    method_5(owner); // Setup event layers\r\n}\r\n```\r\n\r\n### Layer Management\r\n\r\n#### ActivateLayers (Line 60)\r\n```csharp\r\npublic void ActivateLayers(List<int> layers)\r\n{\r\n    foreach (int layer in layers)\r\n        method_1(layer); // Activate by priority\r\n}\r\n```\r\n\r\n#### ActivateDebug (Line 30)\r\n```csharp\r\npublic void ActivateDebug(DebugBotDesition logic)\r\n```\r\nActivates debug layer with specific decision.\r\n\r\n#### DeactivateDebug (Line 42)\r\n```csharp\r\npublic void DeactivateDebug()\r\n```\r\nDeactivates debug layer.\r\n\r\n### Event Layer Setup (Line 82)\r\n\r\nThe `method_5` sets up event-driven layers based on priorities:\r\n\r\n```csharp\r\npublic void method_5(BotOwner owner)\r\n{\r\n    GClass671 gClass = EventsPriority();\r\n    if (gClass != null)\r\n    {\r\n        if (gClass.Khorovod > 0)\r\n            // Priority 503 - Christmas event\r\n\r\n        if (gClass.ForceAttack > 0)\r\n            // Priority 501 - Force attack layer\r\n\r\n        if (gClass.ForcePersuit > 0)\r\n            // Priority 502 - Force pursuit layer\r\n\r\n        if (gClass.FollowPlayer > 0)\r\n            // Priority 504 - Follow player layer (!!!!)\r\n\r\n        if (gClass.HalloweenHide > 0)\r\n            // Priority 506 - Halloween event\r\n\r\n        if (gClass.GoToGenerator > 0)\r\n            // Priority 507 - Go to generator\r\n    }\r\n}\r\n```\r\n\r\n**Key Insight**: `FollowPlayer` layer (Priority 504) already exists in base game! Can reference `GClass72` for implementation.\r\n\r\n### Abstract Methods\r\n\r\n```csharp\r\npublic abstract string ShortName();              // Brain name\r\npublic abstract GClass671 EventsPriority();      // Event layer priorities\r\n```\r\n\r\n### Cover Point Finding (Line 51)\r\n```csharp\r\npublic CustomNavigationPoint FindPoint(\r\n    CoverSearchData data,\r\n    Func<CoverSearchData, CustomNavigationPoint> getCoverPointMain2,\r\n    bool checkCurrent\r\n)\r\n```\r\nDelegates to current layer or falls back to default.\r\n\r\n---\r\n\r\n## 6. BotNodeAbstractClass - Node System\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\ilspy-out\\BotNodeAbstractClass.decompiled.cs`\r\n\r\n### Class Overview\r\nNodes are the actual behavior executors for decisions.\r\n\r\n```csharp\r\npublic abstract class BotNodeAbstractClass\r\n{\r\n    public abstract void UpdateNodeByMain(GClass26 lastResultData);\r\n\r\n    public virtual void Dispose() { }\r\n}\r\n```\r\n\r\n**Simple but powerful**: Each `BotLogicDecision` maps to a node that gets updated every frame.\r\n\r\n---\r\n\r\n## 7. AICoreAgentClass - Agent Controller\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\ilspy-out\\AICoreAgentClass.decompiled.cs`\r\n\r\n### Class Overview\r\nOrchestrates the entire AI system - connects strategy (brain), layers, and nodes.\r\n\r\n### Key Fields\r\n```csharp\r\npublic Dictionary<T, BotNodeAbstractClass> Dictionary_0;        // Decision -> Node mapping\r\npublic AICoreStrategyAbstractClass<T> Gclass309_0;              // Brain/Strategy\r\npublic AICoreActionResultStruct<T, GClass26> Gstruct8_0;        // Current decision\r\npublic AICoreLayerClass<T> Gclass35_0;                          // Current active layer\r\npublic AICoreControllerClass AICoreControllerClass;             // Controller\r\npublic Func<T, BotNodeAbstractClass> Func_0;                    // Lazy node getter\r\n```\r\n\r\n### Constructor (Line 34)\r\n```csharp\r\npublic AICoreAgentClass(\r\n    AICoreControllerClass aiCoreController,\r\n    AICoreStrategyAbstractClass<T> strategy,\r\n    Dictionary<T, BotNodeAbstractClass> nodesDictionary,\r\n    GameObject monoBehObject,\r\n    string name,\r\n    Func<T, BotNodeAbstractClass> lazyGetter\r\n)\r\n```\r\n\r\n### Update Flow (Line 63)\r\n```csharp\r\npublic override void Update()\r\n{\r\n    method_10(); // Manual update\r\n\r\n    // Get next decision from strategy\r\n    var result = Gclass309_0.Update(Gstruct8_0);\r\n\r\n    if (!result.HasValue) return;\r\n\r\n    T action = result.Value.Action;\r\n\r\n    // Get or create node for this action\r\n    if (Dictionary_0.TryGetValue(action, out var node))\r\n    {\r\n        node.UpdateNodeByMain(Gstruct8_0.Data);\r\n    }\r\n    else\r\n    {\r\n        // Lazy create node\r\n        var newNode = Func_0(action);\r\n        if (newNode != null)\r\n        {\r\n            Dictionary_0.Add(action, newNode);\r\n            newNode.UpdateNodeByMain(Gstruct8_0.Data);\r\n        }\r\n    }\r\n\r\n    Gstruct8_0 = result.Value; // Store as current\r\n}\r\n```\r\n\r\n### Layer Change Handling (Line 102)\r\n```csharp\r\npublic void method_6(AICoreLayerClass<T> obj)\r\n{\r\n    // Unsubscribe from old layer\r\n    if (Gclass35_0 != null)\r\n        method_7(Gclass35_0);\r\n\r\n    // Switch to new layer\r\n    Gclass35_0 = obj;\r\n    method_3(Gclass35_0.Name());\r\n\r\n    // Subscribe to new layer\r\n    method_8(Gclass35_0);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 8. Key Integration Points for BigBrain/FriendlyPMC\r\n\r\n### 8.1 Creating Custom Layer\r\n\r\n**Template**:\r\n```csharp\r\npublic class FollowerLayer : BaseLogicLayerSimpleAbstractClass\r\n{\r\n    private Player _targetPlayer;\r\n    private float _lastEnemyCheckTime;\r\n\r\n    public FollowerLayer(BotOwner bot, int priority) : base(bot, priority)\r\n    {\r\n    }\r\n\r\n    public override bool ShallUseNow()\r\n    {\r\n        // Active when assigned to follow and alive\r\n        return _targetPlayer != null && !BotOwner_0.IsDead;\r\n    }\r\n\r\n    public override string Name()\r\n    {\r\n        return \"FollowerLayer\";\r\n    }\r\n\r\n    public override AICoreActionResultStruct<BotLogicDecision, GClass26> GetDecision()\r\n    {\r\n        // Check for enemies first\r\n        if (BotOwner_0.Memory.GoalEnemy != null)\r\n        {\r\n            var combatDecision = InFightLogic();\r\n            if (combatDecision.HasValue)\r\n                return combatDecision.Value;\r\n\r\n            // Enemy exists but not in immediate combat\r\n            return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                BotLogicDecision.goToCoverPoint,\r\n                \"Enemy present - seeking cover\"\r\n            );\r\n        }\r\n\r\n        // No enemy - follow player\r\n        float distToPlayer = Vector3.Distance(\r\n            BotOwner_0.Position,\r\n            _targetPlayer.Position\r\n        );\r\n\r\n        if (distToPlayer > 10f)\r\n        {\r\n            return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                BotLogicDecision.followPlayer,\r\n                \"Following target player\"\r\n            );\r\n        }\r\n\r\n        // Close to player - hold position\r\n        return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n            BotLogicDecision.holdPosition,\r\n            \"Near player\"\r\n        );\r\n    }\r\n\r\n    public override AICoreActionEndStruct ShallEndCurrentDecision(\r\n        AICoreActionResultStruct<BotLogicDecision, GClass26> curDecision\r\n    )\r\n    {\r\n        // Always check base class logic first\r\n        var baseEnd = base.ShallEndCurrentDecision(curDecision);\r\n        if (baseEnd.Value)\r\n            return baseEnd;\r\n\r\n        // Custom end conditions\r\n        if (curDecision.Action == BotLogicDecision.followPlayer)\r\n        {\r\n            float distToPlayer = Vector3.Distance(\r\n                BotOwner_0.Position,\r\n                _targetPlayer.Position\r\n            );\r\n\r\n            if (distToPlayer < 5f)\r\n                return new AICoreActionEndStruct(\"Close enough to player\");\r\n\r\n            if (BotOwner_0.Memory.GoalEnemy != null)\r\n                return new AICoreActionEndStruct(\"Enemy spotted\");\r\n        }\r\n\r\n        return new AICoreActionEndStruct(); // Don't end\r\n    }\r\n\r\n    public override bool CanSearchEnemy()\r\n    {\r\n        // Followers should NOT search for enemies\r\n        // Stay with player instead\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n### 8.2 Hooking into Memory Events\r\n\r\n**Cluster Perception System**:\r\n```csharp\r\npublic class ClusterPerceptionManager\r\n{\r\n    private List<BotOwner> _clusterMembers = new List<BotOwner>();\r\n\r\n    public void RegisterBot(BotOwner bot)\r\n    {\r\n        _clusterMembers.Add(bot);\r\n\r\n        // Subscribe to memory events\r\n        bot.Memory.OnAddEnemy += (enemy) => ShareEnemyWithCluster(bot, enemy);\r\n        bot.Memory.OnGoalEnemyChanged += (bot) => OnClusterMemberEnemyChange(bot);\r\n    }\r\n\r\n    private void ShareEnemyWithCluster(BotOwner source, IPlayer enemy)\r\n    {\r\n        foreach (var member in _clusterMembers)\r\n        {\r\n            if (member == source) continue;\r\n\r\n            // Add enemy to other cluster members\r\n            if (!member.EnemiesController.EnemyInfos.ContainsKey(enemy))\r\n            {\r\n                member.Memory.AddEnemy(\r\n                    enemy,\r\n                    source.Settings,\r\n                    onActivation: false\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    private void OnClusterMemberEnemyChange(BotOwner bot)\r\n    {\r\n        if (bot.Memory.GoalEnemy != null)\r\n        {\r\n            // Cluster member engaged enemy\r\n            // Could notify others, adjust tactics, etc.\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 8.3 Damage Sharing (Phase 6)\r\n\r\n```csharp\r\n// Hook into GetHit to share damage info across cluster\r\nbot.Memory.GetHit += (damageInfo) =>\r\n{\r\n    // Share with cluster members\r\n    foreach (var member in cluster)\r\n    {\r\n        if (member == bot) continue;\r\n\r\n        // Make cluster aware of damage source\r\n        if (damageInfo.Player != null)\r\n        {\r\n            var attacker = damageInfo.Player.iPlayer;\r\n\r\n            // Add as enemy if not already\r\n            if (!member.EnemiesController.EnemyInfos.ContainsKey(attacker))\r\n            {\r\n                member.Memory.AddEnemy(attacker, settings, false);\r\n            }\r\n\r\n            // May set as goal enemy if close enough\r\n            float dist = Vector3.Distance(member.Position, attacker.Position);\r\n            if (dist < 50f && member.Memory.GoalEnemy == null)\r\n            {\r\n                var enemyInfo = member.EnemiesController.EnemyInfos[attacker];\r\n                member.Memory.GoalEnemy = enemyInfo;\r\n            }\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n### 8.4 BigBrain Registration\r\n\r\n```csharp\r\n// In your mod's postDBLoad or equivalent\r\npublic void RegisterCustomBrain()\r\n{\r\n    // Assuming BigBrain provides API like:\r\n    BigBrainHandler.RegisterBrain<MyCustomBrain>(\r\n        \"FriendlyPMC\",\r\n        brainType: BrainType.PMC,\r\n        priority: 100\r\n    );\r\n\r\n    // Or register specific layers\r\n    BigBrainHandler.RegisterLayer<FollowerLayer>(\r\n        priority: 600  // Higher than most combat layers\r\n    );\r\n}\r\n```\r\n\r\n---\r\n\r\n## 9. Common Patterns and Best Practices\r\n\r\n### 9.1 Checking Combat Capability\r\n```csharp\r\nif (BotOwner_0.Memory.GoalEnemy != null)\r\n{\r\n    var enemy = BotOwner_0.Memory.GoalEnemy;\r\n\r\n    if (enemy.IsVisible && enemy.CanShoot)\r\n    {\r\n        // Can engage immediately\r\n    }\r\n    else if (enemy.IsVisible)\r\n    {\r\n        // Can see but can't shoot (wrong weapon range, etc.)\r\n    }\r\n    else if (enemy.CanISearch)\r\n    {\r\n        // Lost sight but can search\r\n    }\r\n}\r\n```\r\n\r\n### 9.2 Cover Usage\r\n```csharp\r\n// Check if in cover\r\nif (BotOwner_0.Memory.IsInCover)\r\n{\r\n    var coverPoint = BotOwner_0.Memory.CurCustomCoverPoint;\r\n\r\n    // Check if can shoot from cover\r\n    if (coverPoint.CanShootToTargetCast(BotOwner_0, delta))\r\n    {\r\n        // Shoot from cover\r\n    }\r\n    else\r\n    {\r\n        // In cover but can't shoot - may need to change position\r\n    }\r\n}\r\n\r\n// Set new cover point\r\nBotOwner_0.Memory.SetCoverPoints(newCoverPoint);\r\n```\r\n\r\n### 9.3 State Transitions\r\n```csharp\r\n// Always clean up when transitioning\r\npublic override void DecisionChanged(\r\n    AICoreActionResultStruct<BotLogicDecision, GClass26>? prevDecision,\r\n    AICoreActionResultStruct<BotLogicDecision, GClass26> nextDecision\r\n)\r\n{\r\n    base.DecisionChanged(prevDecision, nextDecision);\r\n\r\n    if (prevDecision.HasValue)\r\n    {\r\n        // Cleanup from previous decision\r\n        switch (prevDecision.Value.Action)\r\n        {\r\n            case BotLogicDecision.followPlayer:\r\n                // Stop following\r\n                break;\r\n            case BotLogicDecision.shootFromCover:\r\n                // Reset aim\r\n                break;\r\n        }\r\n    }\r\n\r\n    // Setup for new decision\r\n    switch (nextDecision.Action)\r\n    {\r\n        case BotLogicDecision.followPlayer:\r\n            // Start following\r\n            break;\r\n    }\r\n}\r\n```\r\n\r\n### 9.4 Performance Considerations\r\n```csharp\r\n// Cache expensive calculations\r\nprivate float _nextPerceptionUpdate;\r\n\r\npublic override void ManualUpdate()\r\n{\r\n    if (Time.time < _nextPerceptionUpdate)\r\n        return;\r\n\r\n    _nextPerceptionUpdate = Time.time + 0.5f; // Update every 0.5s\r\n\r\n    // Expensive perception calculations here\r\n}\r\n```\r\n\r\n---\r\n\r\n## 10. Important Enums and Structs\r\n\r\n### AICoreActionResultStruct\r\n```csharp\r\npublic struct AICoreActionResultStruct<T, TData>\r\n{\r\n    public T Action;        // The decision/action\r\n    public string Reason;   // Debug reason\r\n    public TData Data;      // Optional data\r\n\r\n    public AICoreActionResultStruct(T action, string reason)\r\n    {\r\n        Action = action;\r\n        Reason = reason;\r\n        Data = default(TData);\r\n    }\r\n}\r\n```\r\n\r\n### AICoreActionEndStruct\r\n```csharp\r\npublic struct AICoreActionEndStruct\r\n{\r\n    public bool Value;      // Should end?\r\n    public string Reason;   // Why ending\r\n\r\n    public AICoreActionEndStruct(string reason)\r\n    {\r\n        Value = true;\r\n        Reason = reason;\r\n    }\r\n\r\n    public AICoreActionEndStruct()  // Default - don't end\r\n    {\r\n        Value = false;\r\n        Reason = \"\";\r\n    }\r\n}\r\n```\r\n\r\n### BotLogicDecision (Enum)\r\nKey values from the switch statement:\r\n- `holdPosition`\r\n- `goToCoverPoint`\r\n- `runToCover`\r\n- `shootFromPlace`\r\n- `shootFromCover`\r\n- `attackMoving`\r\n- `goToEnemy`\r\n- `runToEnemy`\r\n- `followPlayer` (**Important for followers!**)\r\n- `heal`\r\n- `search`\r\n- `simplePatrol`\r\n- `peaceful`\r\n- `runAwayGrenade`\r\n- And 60+ more...\r\n\r\n---\r\n\r\n## 11. Version Changes and Gotchas\r\n\r\n### SPT 4.0.5 Changes\r\nBased on project context, some method signatures changed:\r\n\r\n1. **Event handlers** - Some events changed parameter types\r\n2. **Perception methods** - LOS checking may have different signatures\r\n3. **Navigation** - Path finding APIs may have changed\r\n\r\n### Performance Gotchas\r\n\r\n1. **BotMemoryClass.CheckIsPeace()** - Called every 2 seconds, relatively expensive\r\n2. **Enemy LOS checks** - Use cached results when possible\r\n3. **NavMesh calculations** - Cache paths, don't recalculate every frame\r\n4. **Event subscriptions** - Always unsubscribe in Dispose() to prevent memory leaks\r\n\r\n### Common Mistakes\r\n\r\n1. **Forgetting to check IsAlive** before operations\r\n2. **Not handling null enemies** - always null-check GoalEnemy\r\n3. **Infinite decision loops** - ensure ShallEndCurrentDecision eventually returns true\r\n4. **Not calling base methods** - especially in End* methods\r\n5. **Missing Dispose cleanup** - unsubscribe events, clear references\r\n\r\n---\r\n\r\n## Summary\r\n\r\nThis AI system is based on a layered decision architecture:\r\n\r\n1. **BotOwner** - The bot instance\r\n2. **BotMemoryClass** - Perception, memory, combat state\r\n3. **BaseBrain** - Manages multiple layers, picks active one\r\n4. **Layers** (AICoreLayerClass) - Make decisions based on priority\r\n5. **Nodes** (BotNodeAbstractClass) - Execute the decisions\r\n6. **AICoreAgentClass** - Orchestrates the whole system\r\n\r\n**For FriendlyPMC mod**:\r\n- Create custom layer extending `BaseLogicLayerSimpleAbstractClass`\r\n- Hook into `BotMemoryClass` events for cluster perception\r\n- Override `CanSearchEnemy()` to keep followers close\r\n- Use `InFightLogic()` for combat decisions\r\n- Set high priority (500-600) to override default behaviors\r\n- Leverage existing `followPlayer` decision and node\r\n\r\nThe system is well-architected for modding - just need to respect the lifecycle and use the provided hooks!\r\n"},"03-Party-Friends-Messenger-System":{"title":"Tarkov Party/Invite/Friends/Messenger System Analysis\r","category":"Core Systems","content":"# Tarkov Party/Invite/Friends/Messenger System Analysis\r\n## FriendlyPMC Squad Member Integration Guide\r\n\r\n**Phases**: 3 (Squad Manager Chatbot) + 4 (Party/Invite Flow)\r\n**Priority**: CRITICAL - Foundation for getting bots into raids\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nThe FriendlyPMC mod creates **synthetic friend profiles** that appear in the player's Messenger as real contacts. Players right-click these \"friends\" and invite them to their party, which triggers the mod's follower spawning system to bring them into the raid as AI squadmates. This document details every aspect of this integration.\r\n\r\n---\r\n\r\n## 1. Friend Profile Creation System\r\n\r\n### 1.1 Core Data Structures\r\n\r\n#### GroupPlayerDataClass (Party Member)\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\decompiled_GroupPlayerData.cs\\GroupPlayerDataClass.decompiled.cs`\r\n\r\n```csharp\r\npublic class GroupPlayerDataClass : GInterface214\r\n{\r\n    [JsonProperty(\"aid\")]\r\n    public string AccountId = string.Empty;  // Account ID (integer as string)\r\n\r\n    [JsonProperty(\"_id\")]\r\n    public string Id = string.Empty;  // Profile/MongoId\r\n\r\n    [JsonProperty(\"lookingGroup\")]\r\n    public bool LookingForGroup;\r\n\r\n    [JsonProperty(\"IsLeader\")]\r\n    public bool IsLeader;\r\n\r\n    [JsonProperty(\"IsReady\")]\r\n    public bool IsReady;\r\n\r\n    [JsonProperty(\"Info\")]\r\n    public GClass1410 Info;  // Nickname, Side, Level, etc.\r\n\r\n    [JsonProperty(\"PlayerVisualRepresentation\")]\r\n    public GClass2214 Gclass2214_0;\r\n\r\n    [JsonIgnore]\r\n    public LastPlayerStateClass PlayerVisualRepresentation;\r\n\r\n    // Interface implementation\r\n    string GInterface214.ProfileId => Id;\r\n    string GInterface214.Nickname => Info.Nickname;\r\n    EPlayerSide GInterface214.Side => Info.Side;\r\n    int GInterface214.PrestigeLevel => Info.PrestigeLevel;\r\n}\r\n```\r\n\r\n#### GClass1410 (Profile Info)\r\n```csharp\r\npublic class GClass1410\r\n{\r\n    public string Nickname;\r\n    public string LowerNickname;\r\n    public EPlayerSide Side;  // Bear, Usec, Savage\r\n    public int Level;\r\n    public int PrestigeLevel;\r\n    public EMemberCategory MemberCategory;  // Default, Developer, Sherpa, System, etc.\r\n    public EMemberCategory SelectedMemberCategory;\r\n}\r\n```\r\n\r\n#### LastPlayerStateClass (Visual Representation)\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\ilspy-out\\LastPlayerStateClass.decompiled.cs`\r\n\r\n```csharp\r\npublic class LastPlayerStateClass\r\n{\r\n    public readonly GClass1410 Info;\r\n    public readonly GClass2197 Customization;  // Body/Head/Feet customization\r\n    public readonly InventoryEquipment Equipment;\r\n\r\n    public LastPlayerStateClass(GClass1410 info, GClass2197 customization, InventoryEquipment equipment)\r\n    {\r\n        Info = info;\r\n        Customization = customization;\r\n        Equipment = equipment;\r\n    }\r\n}\r\n```\r\n\r\n### 1.2 Friend Profile Creation Workflow\r\n\r\n**Server-Side Implementation**: `E:\\AppDev\\LTsTarkovAI\\LTFriendlyPMC\\server-csharp\\SquadManagerChatBot.cs` (Lines 337-414)\r\n\r\n```csharp\r\nprivate void AddSquadMember(MongoId sessionId, string nickname)\r\n{\r\n    var trimmed = (nickname ?? string.Empty).Trim();\r\n    if (string.IsNullOrWhiteSpace(trimmed))\r\n    {\r\n        SendText(sessionId, \"Usage: /add nickname\");\r\n        return;\r\n    }\r\n\r\n    try\r\n    {\r\n        // 1. Get owner's PMC profile for reference\r\n        var ownerPmc = _profileHelper.GetPmcProfile(sessionId);\r\n\r\n        // 2. Generate unique identifiers\r\n        var memberId = new MongoId();  // Unique profile ID\r\n        var memberAid = GenerateAid();  // 7-digit account ID\r\n\r\n        // 3. Create profile info (inherits owner's side/level/category)\r\n        var pmcInfo = new SPTarkov.Server.Core.Models.Eft.Common.Tables.Info\r\n        {\r\n            Nickname = trimmed,\r\n            LowerNickname = trimmed.ToLowerInvariant(),\r\n            Side = ownerPmc?.Info?.Side ?? \"Usec\",\r\n            Level = ownerPmc?.Info?.Level ?? 1,\r\n            MemberCategory = ownerPmc?.Info?.MemberCategory ?? MemberCategory.Default,\r\n            SelectedMemberCategory = ownerPmc?.Info?.SelectedMemberCategory ?? MemberCategory.Default\r\n        };\r\n\r\n        // 4. Create PMC data structure\r\n        var pmc = new PmcData\r\n        {\r\n            Id = memberId,\r\n            Aid = memberAid,\r\n            Info = pmcInfo\r\n        };\r\n\r\n        // 5. Create full SPT profile\r\n        var sptProfile = new SptProfile\r\n        {\r\n            ProfileInfo = new SPTarkov.Server.Core.Models.Eft.Profile.Info\r\n            {\r\n                ProfileId = memberId,\r\n                Aid = memberAid,\r\n                Username = trimmed,\r\n                IsWiped = false,\r\n                Edition = ownerPmc?.Info?.GameVersion ?? \"friendlypmc_squad\"\r\n            },\r\n            CharacterData = new Characters\r\n            {\r\n                PmcData = pmc,\r\n                ScavData = new PmcData()  // Empty scav data\r\n            }\r\n        };\r\n\r\n        // 6. Register profile in SaveServer\r\n        _saveServer.AddProfile(sptProfile);\r\n\r\n        // 7. Add to owner's friends list (CRITICAL)\r\n        var ownerProfile = _saveServer.GetProfile(sessionId);\r\n        ownerProfile.FriendProfileIds ??= new HashSet<MongoId>();\r\n        ownerProfile.FriendProfileIds.Add(memberId);\r\n\r\n        // 8. Create bidirectional dialogue\r\n        EnsureDialogue(ownerProfile, memberId, pmcInfo, ownerPmc);\r\n\r\n        // 9. Add friend relationship from member's side\r\n        var memberProfile = _saveServer.GetProfile(memberId);\r\n        memberProfile.FriendProfileIds ??= new HashSet<MongoId>();\r\n        memberProfile.FriendProfileIds.Add(sessionId);\r\n        EnsureDialogue(memberProfile, sessionId, ownerPmc?.Info, ownerPmc);\r\n\r\n        // 10. Track in squad service\r\n        _squadService.AddMember(sessionId, trimmed, memberId.ToString());\r\n\r\n        SendText(sessionId, $\"Added squad member: {trimmed}\");\r\n    }\r\n    catch\r\n    {\r\n        // Fallback: Track in squad list only (no friend integration)\r\n        _squadService.AddMember(sessionId, trimmed);\r\n        SendText(sessionId, $\"Added squad member (squad only): {trimmed}\");\r\n    }\r\n}\r\n\r\nprivate static int GenerateAid()\r\n{\r\n    // Generate reasonably unique 7-digit account ID\r\n    return Random.Shared.Next(1_000_000, 9_999_999);\r\n}\r\n```\r\n\r\n### 1.3 Dialogue System Integration\r\n\r\n**Critical for Messenger visibility**: Both parties need dialogue records pointing to each other.\r\n\r\n```csharp\r\nprivate void EnsureDialogue(\r\n    SptProfile profile,\r\n    MongoId otherPartyId,\r\n    SPTarkov.Server.Core.Models.Eft.Common.Tables.Info? otherInfo,\r\n    PmcData? otherPmc)\r\n{\r\n    if (profile.DialogueRecords == null)\r\n    {\r\n        profile.DialogueRecords = new Dictionary<MongoId, Dialogue>();\r\n    }\r\n\r\n    if (profile.DialogueRecords.ContainsKey(otherPartyId))\r\n    {\r\n        return;  // Already exists\r\n    }\r\n\r\n    var ownerInfo = profile.CharacterData?.PmcData?.Info;\r\n\r\n    // Create dialogue with BOTH users\r\n    var users = new List<UserDialogInfo>\r\n    {\r\n        // Self\r\n        new UserDialogInfo\r\n        {\r\n            Id = profile.ProfileInfo?.ProfileId ?? MongoId.Empty(),\r\n            Aid = profile.ProfileInfo?.Aid ?? 0,\r\n            Info = new UserDialogDetails\r\n            {\r\n                Nickname = ownerInfo?.Nickname ?? profile.ProfileInfo?.Username ?? \"Player\",\r\n                Side = ownerInfo?.Side ?? \"Usec\",\r\n                Level = ownerInfo?.Level,\r\n                MemberCategory = ownerInfo?.MemberCategory,\r\n                SelectedMemberCategory = ownerInfo?.SelectedMemberCategory\r\n            }\r\n        },\r\n        // Other party\r\n        new UserDialogInfo\r\n        {\r\n            Id = otherPartyId,\r\n            Aid = otherPmc?.Aid ?? 0,\r\n            Info = new UserDialogDetails\r\n            {\r\n                Nickname = otherInfo?.Nickname ?? \"Squadmate\",\r\n                Side = otherInfo?.Side ?? \"Usec\",\r\n                Level = otherInfo?.Level,\r\n                MemberCategory = otherInfo?.MemberCategory,\r\n                SelectedMemberCategory = otherInfo?.SelectedMemberCategory\r\n            }\r\n        }\r\n    };\r\n\r\n    profile.DialogueRecords[otherPartyId] = new Dialogue\r\n    {\r\n        Id = otherPartyId,\r\n        Type = MessageType.UserMessage,\r\n        Users = users,\r\n        Messages = new List<Message>(),  // Empty message history\r\n        New = 0,\r\n        AttachmentsNew = 0,\r\n        Pinned = false\r\n    };\r\n}\r\n```\r\n\r\n---\r\n\r\n## 2. ChatBot System (Squad Manager)\r\n\r\n### 2.1 IDialogueChatBot Interface\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\SPT-ServerMod-Examples\\20CustomChatBot\\CustomChatBot.cs`\r\n\r\n```csharp\r\npublic interface IDialogueChatBot\r\n{\r\n    // Define chatbot identity\r\n    UserDialogInfo GetChatBot();\r\n\r\n    // Handle incoming messages\r\n    ValueTask<string> HandleMessage(MongoId sessionId, SendMessageRequest request);\r\n}\r\n```\r\n\r\n### 2.2 Squad Manager Implementation\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\LTFriendlyPMC\\server-csharp\\SquadManagerChatBot.cs`\r\n\r\n```csharp\r\npublic sealed class SquadManagerChatBot : IDialogueChatBot\r\n{\r\n    private readonly MailSendService _mailSendService;\r\n    private readonly SquadService _squadService;\r\n    private readonly ConfigServer _configServer;\r\n    private readonly DialogueController _dialogueController;\r\n    private readonly SaveServer _saveServer;\r\n    private readonly ProfileHelper _profileHelper;\r\n    private readonly ISptLogger<SquadManagerChatBot> _logger;\r\n\r\n    private MongoId _botId;\r\n    private bool _botIdInitialized;\r\n\r\n    public MongoId BotId => _botId;\r\n\r\n    public UserDialogInfo GetChatBot()\r\n    {\r\n        EnsureBotId();\r\n        return new UserDialogInfo\r\n        {\r\n            Id = _botId,\r\n            Aid = 9876543,  // Fixed aid for Squad Manager\r\n            Info = new UserDialogDetails\r\n            {\r\n                Level = 1,\r\n                Nickname = \"Squad Manager\",\r\n                Side = \"Usec\",\r\n                MemberCategory = MemberCategory.System,\r\n                SelectedMemberCategory = MemberCategory.System\r\n            }\r\n        };\r\n    }\r\n\r\n    public ValueTask<string> HandleMessage(MongoId sessionId, SendMessageRequest request)\r\n    {\r\n        var text = (request.Text ?? string.Empty).Trim();\r\n\r\n        if (text.StartsWith(\"/help\"))\r\n        {\r\n            SendHelp(sessionId);\r\n        }\r\n        else if (text.StartsWith(\"/add \"))\r\n        {\r\n            var parts = text.Split(' ', 2, StringSplitOptions.RemoveEmptyEntries);\r\n            if (parts.Length == 2)\r\n            {\r\n                AddSquadMember(sessionId, parts[1]);\r\n            }\r\n        }\r\n        else if (text.StartsWith(\"/delete \"))\r\n        {\r\n            var parts = text.Split(' ', 2, StringSplitOptions.RemoveEmptyEntries);\r\n            if (parts.Length == 2)\r\n            {\r\n                DeleteSquadMember(sessionId, parts[1]);\r\n            }\r\n        }\r\n        else if (text.StartsWith(\"/rename \"))\r\n        {\r\n            var parts = text.Split(' ', StringSplitOptions.RemoveEmptyEntries);\r\n            if (parts.Length == 3)\r\n            {\r\n                RenameSquadMember(sessionId, parts[1], parts[2]);\r\n            }\r\n        }\r\n        else if (text.StartsWith(\"/autojoin \"))\r\n        {\r\n            HandleAutoJoinCommand(sessionId, text);\r\n        }\r\n        // ... other commands\r\n\r\n        return new ValueTask<string>(request.DialogId);\r\n    }\r\n\r\n    private void SendText(MongoId sessionId, string text)\r\n    {\r\n        var details = new SendMessageDetails\r\n        {\r\n            RecipientId = sessionId,\r\n            Sender = MessageType.UserMessage,\r\n            DialogType = MessageType.UserMessage,\r\n            SenderDetails = GetChatBot(),\r\n            MessageText = text,\r\n            Items = new List<Item>()\r\n        };\r\n\r\n        _mailSendService.SendMessageToPlayer(details);\r\n    }\r\n}\r\n```\r\n\r\n### 2.3 ChatBot Registration\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\LTFriendlyPMC\\server-csharp\\FriendlyPmcChatbotOnLoad.cs`\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostSptModLoader)]\r\npublic sealed class FriendlyPmcChatbotOnLoad : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var provider = ServiceLocator.ServiceProvider;\r\n        var logger = provider?.GetService(typeof(ISptLogger<FriendlyPmcChatbotOnLoad>))\r\n            as ISptLogger<FriendlyPmcChatbotOnLoad>;\r\n\r\n        var dialogueController = provider.GetService(typeof(DialogueController))\r\n            as DialogueController;\r\n\r\n        var chatBot = CreateChatBot(provider, logger, dialogueController);\r\n\r\n        // CRITICAL: Register with DialogueController\r\n        dialogueController.RegisterChatBot(chatBot);\r\n\r\n        logger?.Info($\"Squad Manager chatbot registered botId={chatBot.BotId}\", null);\r\n\r\n        return Task.CompletedTask;\r\n    }\r\n\r\n    private static SquadManagerChatBot? CreateChatBot(...)\r\n    {\r\n        // Resolve all dependencies via ServiceProvider\r\n        var mailSendService = provider.GetService(typeof(MailSendService)) as MailSendService;\r\n        var squadService = provider.GetService(typeof(SquadService)) as SquadService;\r\n        // ... etc\r\n\r\n        return new SquadManagerChatBot(\r\n            mailSendService,\r\n            squadService,\r\n            configServer,\r\n            dialogueController,\r\n            saveServer,\r\n            profileHelper,\r\n            chatLogger);\r\n    }\r\n}\r\n```\r\n\r\n### 2.4 Bot ID Persistence\r\n\r\n```csharp\r\nprivate MongoId EnsureBotId(CoreConfig coreConfig)\r\n{\r\n    var features = coreConfig.Features.ChatbotFeatures;\r\n    const string key = \"friendlypmc_squadmanager\";\r\n\r\n    if (!features.Ids.TryGetValue(key, out var id))\r\n    {\r\n        id = new MongoId();\r\n        features.Ids[key] = id;  // Persist in core config\r\n    }\r\n\r\n    if (!features.EnabledBots.ContainsKey(id))\r\n    {\r\n        features.EnabledBots[id] = true;\r\n    }\r\n\r\n    return id;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. Party/Invite/Raid Flow\r\n\r\n### 3.1 Party System Overview\r\n\r\n**Key Classes**:\r\n- `MatchmakerPlayerControllerClass`: Manages party composition\r\n- `GroupPlayerViewModelClass`: Individual party member representation\r\n- `MainMenuControllerClass`: Orchestrates pre-raid flow\r\n\r\n### 3.2 Invite ‚Üí Party Flow\r\n\r\n**Client-Side (Auto-Invite)**: `E:\\AppDev\\LTsTarkovAI\\LTFriendlyPMC\\client\\Patches\\SocialPatch.cs` (Lines 119-152)\r\n\r\n```csharp\r\nprivate static async void SendInvite(UpdatableChatMember playerToInvite)\r\n{\r\n    await Task.Delay(1000);  // Wait for Squad Manager response\r\n\r\n    MatchmakerPlayerControllerClass matchPlayer = friendlyPMC.application.MatchmakerPlayerControllerClass;\r\n\r\n    // Check if already in party\r\n    bool found = false;\r\n    foreach (var player in matchPlayer.GroupPlayers)\r\n    {\r\n        if (player.AccountId == playerToInvite.AccountId)\r\n        {\r\n            found = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (found)\r\n    {\r\n        return;  // Already invited\r\n    }\r\n\r\n    // Get auto-join list from server\r\n    string json = RequestHandler.GetJson(\"/singleplayer/pendingauto\");\r\n    var ids = Json.Deserialize<List<string>>(json);\r\n\r\n    if (ids == null || ids.Count == 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    // Send invite if on auto-join list\r\n    if (ids.Contains(playerToInvite.AccountId))\r\n    {\r\n        matchPlayer.SendInvite(playerToInvite.AccountId, true, null);\r\n    }\r\n}\r\n```\r\n\r\n### 3.3 Party Management Patches\r\n\r\n**Remove Non-Player Members Before Raid Start**:\r\n```csharp\r\ninternal class MainMenuControllerPatch : ModulePatch\r\n{\r\n    public static playerGroup GroupPlayers = new playerGroup();\r\n\r\n    protected override MethodBase GetTargetMethod()\r\n    {\r\n        return AccessTools.Method(typeof(MainMenuControllerClass), \"method_49\");\r\n    }\r\n\r\n    [PatchPrefix]\r\n    private static void PatchPrefix(MainMenuControllerClass __instance)\r\n    {\r\n        if (RaidStartPatch.HasFika())\r\n        {\r\n            return;  // Let FIKA handle it\r\n        }\r\n\r\n        MatchmakerPlayerControllerClass matchmakerPlayerControllerClass =\r\n            __instance.MatchmakerPlayersController;\r\n\r\n        var removeGroup = new playerGroup();\r\n\r\n        // Remove all non-current-player members from official group\r\n        foreach (var item in matchmakerPlayerControllerClass.GroupPlayers)\r\n        {\r\n            if (item != matchmakerPlayerControllerClass.CurrentPlayer)\r\n                removeGroup.Add(item);\r\n        }\r\n\r\n        foreach (var item in removeGroup)\r\n        {\r\n            matchmakerPlayerControllerClass.GroupPlayers.Remove(item);\r\n        }\r\n\r\n        // Force local raid mode\r\n        RaidSettings raidSettings_0 = __instance.RaidSettings_0;\r\n        raidSettings_0.RaidMode = ERaidMode.Local;\r\n    }\r\n}\r\n```\r\n\r\n**Track Party Additions**:\r\n```csharp\r\ninternal class MatchmakerPlayerControllerClassAddMemberPatch : ModulePatch\r\n{\r\n    [PatchPostfix]\r\n    private static void PatchPostfix(\r\n        MatchmakerPlayerControllerClass __instance,\r\n        GroupPlayerViewModelClass player)\r\n    {\r\n        if (RaidStartPatch.HasFika())\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Track in shadow group\r\n        if (__instance.CurrentPlayer != player &&\r\n            !MainMenuControllerPatch.GroupPlayers.Contains(player))\r\n        {\r\n            MainMenuControllerPatch.GroupPlayers.Add(player);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3.4 Raid Start Configuration\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\LTFriendlyPMC\\client\\Patches\\RaidStartPatch.cs` (Lines 40-269)\r\n\r\n```csharp\r\n[PatchPostfix]\r\nprivate static void PatchPostfix(Class308 __instance, RaidSettings settings)\r\n{\r\n    if (HasFika())\r\n    {\r\n        return;  // Let FIKA handle multiplayer\r\n    }\r\n\r\n    // Clear previous raid state\r\n    Utils.SpawnHelper.spawnMemberIds.Clear();\r\n    Utils.SpawnHelper.spawnMemberIdsScav.Clear();\r\n    Utils.SpawnHelper.spawnMemberIdsBoss.Clear();\r\n\r\n    // Build spawn lists from party members\r\n    if (MainMenuControllerPatch.GroupPlayers != null)\r\n    {\r\n        foreach (var player in MainMenuControllerPatch.GroupPlayers)\r\n        {\r\n            if (player.Id == \"677c4e0cc7a538c4210d4d47\")\r\n            {\r\n                // Special boss handling (Knight)\r\n                Utils.SpawnHelper.spawnMemberIdsBoss.Add(WildSpawnType.bossKnight);\r\n            }\r\n            else if (player.Id == \"677c4e0cc7a538c4210d4d48\")\r\n            {\r\n                SpawnHelper.spawnMemberIdsBoss.Add(WildSpawnType.followerBigPipe);\r\n            }\r\n            else if (player.Id == \"677c4e0cc7a538c4210d4d49\")\r\n            {\r\n                SpawnHelper.spawnMemberIdsBoss.Add(WildSpawnType.followerBirdEye);\r\n            }\r\n            else\r\n            {\r\n                // Regular squad members\r\n                if (!settings.IsPmc)\r\n                {\r\n                    if (Utils.SpawnHelper.ScavSquad)\r\n                        Utils.SpawnHelper.spawnMemberIdsScav.AddRange(\r\n                            MainMenuControllerPatch.GroupPlayers.Select(x => x.AccountId));\r\n                }\r\n                else\r\n                    Utils.SpawnHelper.spawnMemberIds.AddRange(\r\n                        MainMenuControllerPatch.GroupPlayers.Select(x => x.AccountId));\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    Profile profile = __instance.GetProfileBySide(ESideType.Pmc);\r\n\r\n    // Request server configuration\r\n    string pitConfig = RequestHandler.PostJson(\"/client/raid/pitconfig\", new\r\n    {\r\n        Config = new Dictionary<string, object>\r\n        {\r\n            { \"friendlyPMC\", friendlyPMC.friendlyPMCFLAG.Value },\r\n            { \"badGuy\", badGuy },\r\n            { \"pmcArmbands\", friendlyPMC.pmcArmbands.Value },\r\n            { \"englishBear\", friendlyPMC.englishBear.Value },\r\n            { \"location\", settings.LocationId }\r\n        }\r\n    }.ToJson(_defaultJsonConverters));\r\n\r\n    PitConfig config = Json.Deserialize<PitConfig>(pitConfig);\r\n\r\n    Utils.SpawnHelper.ScavSquad = config.ScavSquad;\r\n    Utils.SpawnHelper.ScavSquadSize = config.ScavSquadSize;\r\n    Utils.SpawnHelper.Pickups = config.Pickups;\r\n    Utils.SpawnHelper.Restrictions = config.Restrictions;\r\n\r\n    // Seed spawnMemberIds from server if client didn't select anyone\r\n    if (Utils.SpawnHelper.spawnMemberIds.Count == 0 && config.Members?.Length > 0)\r\n    {\r\n        friendlyPMC.Log.LogInfo(\r\n            $\"RaidStartPatch seeding spawnMemberIds from squad members \" +\r\n            $\"(members={config.Members.Length})\");\r\n        Utils.SpawnHelper.spawnMemberIds.AddRange(config.Members);\r\n    }\r\n\r\n    friendlyPMC.Log.LogInfo(\r\n        $\"RaidStartPatch summary isPmc={settings.IsPmc}, \" +\r\n        $\"spawnMemberIds={Utils.SpawnHelper.spawnMemberIds.Count}, \" +\r\n        $\"spawnMemberIdsBoss={Utils.SpawnHelper.spawnMemberIdsBoss.Count}, \" +\r\n        $\"scavSquad={Utils.SpawnHelper.ScavSquad}\");\r\n}\r\n```\r\n\r\n### 3.5 Spawn Point Adjustment\r\n\r\n```csharp\r\n[PatchPrefix]\r\nprivate static void PatchPrefix(\r\n    ref ESpawnCategory category,\r\n    EPlayerSide side,\r\n    string groupId,\r\n    string teamId,\r\n    IPlayer person,\r\n    string infiltration,\r\n    string profileId)\r\n{\r\n    if (!friendlyPMC.spawnPoint.Value)\r\n    {\r\n        return;\r\n    }\r\n\r\n    // Switch to coop spawn if player has followers\r\n    if (category == ESpawnCategory.Player && person == null)\r\n    {\r\n        if (SpawnHelper.spawnMemberIds.Count > 0 ||\r\n            SpawnHelper.spawnMemberIdsBoss.Count > 0)\r\n        {\r\n            category = ESpawnCategory.Coop;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. Server Route Specifications\r\n\r\n### 4.1 Route Registration\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\LTFriendlyPMC\\server-csharp\\FriendlyPmcServerMod.cs`\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton, null, OnLoadOrder.PostDBModLoader)]\r\npublic sealed class FriendlyPmcStaticRouter : StaticRouter\r\n{\r\n    private static List<RouteAction> GetRoutes(...)\r\n    {\r\n        return new List<RouteAction>\r\n        {\r\n            // Follower profile generation\r\n            new RouteAction(\r\n                \"/client/game/bot/followergenerate\",\r\n                async (url, body, sessionId, output) =>\r\n                {\r\n                    var followerService = ResolveService<FollowerService>(logger);\r\n                    return await followerService.GenerateFollowersAsync(body, sessionId);\r\n                }),\r\n\r\n            // Auto-join member list\r\n            new RouteAction(\r\n                \"/singleplayer/pendingauto\",\r\n                async (url, body, sessionId, output) =>\r\n                {\r\n                    var squadService = ResolveService<SquadService>(logger);\r\n                    var squad = squadService.GetOrCreateSquad(sessionId);\r\n\r\n                    var autoJoinIds = squadService.GetAutoJoin(sessionId)\r\n                        .Where(id => !string.IsNullOrWhiteSpace(id))\r\n                        .Distinct(StringComparer.Ordinal)\r\n                        .ToArray();\r\n\r\n                    return await ValueTask.FromResult<object>(autoJoinIds);\r\n                }),\r\n\r\n            // Raid configuration\r\n            new RouteAction(\r\n                \"/client/raid/pitconfig\",\r\n                async (url, body, sessionId, output) =>\r\n                {\r\n                    var squadService = ResolveService<SquadService>(logger);\r\n                    var squad = squadService.GetOrCreateSquad(sessionId);\r\n\r\n                    var response = new\r\n                    {\r\n                        ScavSquad = squad.ScavSquadEnabled,\r\n                        ScavSquadSize = squad.ScavSquadSize,\r\n                        Pickups = squad.Pickups,\r\n                        Restrictions = false,\r\n                        Members = squad.Members.Select(m => m.Nickname).ToArray()\r\n                    };\r\n\r\n                    return await ValueTask.FromResult<object>(response);\r\n                }),\r\n\r\n            // Raid end cleanup\r\n            new RouteAction(\r\n                \"/singleplayer/pitraidend\",\r\n                async (url, body, sessionId, output) =>\r\n                {\r\n                    var squadService = ResolveService<SquadService>(logger);\r\n                    squadService?.ClearRaidState(sessionId);\r\n                    return await ValueTask.FromResult<object>(new { });\r\n                })\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 5. Data Flow Diagram\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  Player Types   ‚îÇ\r\n‚îÇ  /add Buddy     ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n         ‚îÇ\r\n         ‚ñº\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  Squad Manager ChatBot    ‚îÇ\r\n‚îÇ  - Creates MongoId        ‚îÇ\r\n‚îÇ  - Generates Aid          ‚îÇ\r\n‚îÇ  - Creates PmcData        ‚îÇ\r\n‚îÇ  - Creates SptProfile     ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n         ‚îÇ\r\n         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n         ‚îÇ                      ‚îÇ\r\n         ‚ñº                      ‚ñº\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  SaveServer     ‚îÇ    ‚îÇ  SquadService   ‚îÇ\r\n‚îÇ  AddProfile()   ‚îÇ    ‚îÇ  AddMember()    ‚îÇ\r\n‚îÇ  FriendIds ‚Üî    ‚îÇ    ‚îÇ  Persist JSON   ‚îÇ\r\n‚îÇ  DialogueRecords‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n         ‚îÇ\r\n         ‚ñº\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  Player Friends List     ‚îÇ\r\n‚îÇ  (Messenger UI)          ‚îÇ\r\n‚îÇ  \"Buddy\" appears         ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n         ‚îÇ\r\n         ‚îÇ  [Player right-clicks ‚Üí Invite]\r\n         ‚îÇ\r\n         ‚ñº\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  MatchmakerController    ‚îÇ\r\n‚îÇ  SendInvite()            ‚îÇ\r\n‚îÇ  GroupPlayers.Add()      ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n         ‚îÇ\r\n         ‚îÇ  [Tracked in Shadow Group]\r\n         ‚îÇ\r\n         ‚ñº\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  Raid Start (Class308)   ‚îÇ\r\n‚îÇ  - Query GroupPlayers    ‚îÇ\r\n‚îÇ  - POST /pitconfig       ‚îÇ\r\n‚îÇ  - Build spawnMemberIds  ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n         ‚îÇ\r\n         ‚ñº\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  In-Raid Spawn           ‚îÇ\r\n‚îÇ  - BotsController        ‚îÇ\r\n‚îÇ  - FetchMemberProfile    ‚îÇ\r\n‚îÇ  - SpawnGroupBots        ‚îÇ\r\n‚îÇ  - Activate followers    ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n```\r\n\r\n---\r\n\r\n## 6. Critical Implementation Notes\r\n\r\n### 6.1 MongoId vs AccountId\r\n\r\n- **ProfileId (MongoId)**: Unique 24-character hex string, used for friend lookups\r\n- **AccountId**: Same as MongoId string representation in squad members\r\n- **Aid**: Integer account ID (7 digits), used in profile data\r\n- Friends list uses **ProfileId/MongoId**, NOT Aid\r\n\r\n### 6.2 Bidirectional Relationships\r\n\r\n**CRITICAL**: Both profiles must have:\r\n1. Each other in `FriendProfileIds` set\r\n2. Dialogue record with both users listed\r\n3. Matching profile IDs in dialogue `Users` array\r\n\r\n### 6.3 FIKA Compatibility\r\n\r\nAlways check for FIKA before applying patches:\r\n```csharp\r\nprivate static bool HasFika()\r\n{\r\n    return AppDomain.CurrentDomain.GetAssemblies()\r\n        .Any(a => a.GetName().Name.StartsWith(\"Fika\", StringComparison.OrdinalIgnoreCase));\r\n}\r\n```\r\n\r\nIf FIKA present, skip:\r\n- Party management patches\r\n- Raid mode forcing\r\n- Group spawn logic\r\n\r\n### 6.4 Raid Mode Enforcement\r\n\r\nMust set `ERaidMode.Local` to prevent online checks:\r\n```csharp\r\nRaidSettings raidSettings_0 = __instance.RaidSettings_0;\r\nraidSettings_0.RaidMode = ERaidMode.Local;\r\n```\r\n\r\n### 6.5 Group vs Shadow Group\r\n\r\n- **GroupPlayers**: Official Tarkov party (must be empty except player)\r\n- **MainMenuControllerPatch.GroupPlayers**: Shadow tracking of squad members\r\n- Transfer shadow ‚Üí official only during loading screen\r\n\r\n### 6.6 Routes vs DI Overrides - When to Use Which\r\n\r\n**Two Valid Architectural Patterns for SPT 4.x Mods**:\r\n\r\n| Approach | Use Case | Example |\r\n|----------|----------|---------|\r\n| **Custom Routes** | Custom client-server features | FriendlyPMC auto-join, follower generation |\r\n| **DI Overrides** | Alter vanilla server behavior | SVM raid modifiers, trader changes |\r\n\r\n#### When to Use Custom Routes (FriendlyPMC Pattern):\r\n\r\n‚úÖ **Use routes when:**\r\n- You have **client patches** that need to communicate with server\r\n- Implementing **custom features** vanilla doesn't know about (auto-join, squad manager)\r\n- Need **request/response** between patched client and custom server logic\r\n- Building a **hybrid mod** (client + server components)\r\n\r\n**Example**: Auto-join functionality\r\n```csharp\r\n// Client patch explicitly calls custom route\r\nstring json = RequestHandler.GetJson(\"/singleplayer/pendingauto\");\r\n\r\n// Server handles custom request\r\nnew RouteAction(\"/singleplayer/pendingauto\", (url, body, sessionId, output) =>\r\n{\r\n    return squadService.GetAutoJoinIds(sessionId);  // Custom logic\r\n})\r\n```\r\n\r\n**Why this works**: You control both the client (calls route) and server (handles route).\r\n\r\n#### When to Use DI Overrides (SVM Pattern):\r\n\r\n‚úÖ **Use DI overrides when:**\r\n- **Pure server-side** mod (no client component)\r\n- Intercepting **vanilla client behavior** without patching client\r\n- Modifying **core SPT flows** (match callbacks, raid generation, trader assorts)\r\n- Want **zero client-side changes**\r\n\r\n**Example**: Auto-inserting squad members into vanilla match flow\r\n```csharp\r\n[Injectable]\r\npublic class FriendlyPmcMatchCallbacks : MatchCallbacks\r\n{\r\n    public override async Task OnGroupCreate(...)\r\n    {\r\n        var result = await base.OnGroupCreate(...);\r\n\r\n        // Auto-inject squad members into vanilla group flow\r\n        var autoJoinMembers = _squadService.GetAutoJoinMembers(sessionId);\r\n        result.GroupMembers.AddRange(autoJoinMembers);\r\n\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n**Why this works**: SPT's DI system replaces the vanilla `MatchCallbacks` with your override.\r\n\r\n#### FriendlyPMC's Hybrid Approach:\r\n\r\n**Uses Routes For**:\r\n- `/singleplayer/pendingauto` - Custom auto-join feature (client asks server)\r\n- `/client/game/bot/followergenerate` - Custom bot generation (client requests profiles)\r\n- `/client/raid/pitconfig` - Custom squad config sync (client fetches settings)\r\n\r\n**Uses DI For**:\r\n- `IDialogueChatBot` registration - Squad Manager chatbot (modern SPT pattern)\r\n- Service injection - SquadService, FollowerService (modern SPT pattern)\r\n- `IOnLoad` lifecycle hooks - Initialization (modern SPT pattern)\r\n\r\n**Could Add DI Overrides For** (Optional Alternative):\r\n- Override `MatchCallbacks` to auto-insert invites ‚Üí eliminates client auto-invite patch\r\n- Override `ProfileController` for friend management ‚Üí could reduce some server routes\r\n- **Tradeoff**: More complex, less clear separation of concerns, still need client patches for UI\r\n\r\n**Recommendation**: Start with routes for custom features (clear, proven pattern), consider DI overrides later if you want to reduce client patching surface.\r\n\r\n### 6.7 ‚ö†Ô∏è CRITICAL: ID Type Mismatch Bug\r\n\r\n**Most Common Implementation Bug**: Returning wrong ID types from routes.\r\n\r\n#### The ID Types:\r\n\r\n```csharp\r\n// THREE different IDs per squad member:\r\nvar memberId = new MongoId();      // ProfileId: \"507f1f77bcf86cd799439011\" (24-char hex)\r\nvar memberAid = GenerateAid();     // Aid: 1234567 (7-digit integer)\r\nvar accountId = memberAid.ToString(); // AccountId: \"1234567\" (Aid as string)\r\n```\r\n\r\n#### Usage Matrix:\r\n\r\n| ID Type | Used For | Example |\r\n|---------|----------|---------|\r\n| **MongoId (ProfileId)** | Friend lookups, dialogue, SaveServer | `profile.FriendProfileIds.Add(memberId)` |\r\n| **Aid (int)** | Profile data, internal storage | `pmc.Aid = memberAid` |\r\n| **AccountId (string)** | Party invites, client comparisons | `player.AccountId == \"1234567\"` |\r\n\r\n#### The Bug:\r\n\r\n```csharp\r\n// ‚ùå WRONG - Returns MongoIds (24-char hex strings)\r\npublic List<string> GetAutoJoin(MongoId sessionId)\r\n{\r\n    return squad.Members\r\n        .Where(m => m.AutoJoin)\r\n        .Select(m => m.ProfileId)  // \"507f1f77bcf86cd799439011\"\r\n        .ToList();\r\n}\r\n\r\n// Client comparison FAILS:\r\n// playerToInvite.AccountId = \"1234567\"\r\n// autoJoinIds contains \"507f1f77bcf86cd799439011\"\r\n// Result: Never matches, auto-join doesn't work!\r\n```\r\n\r\n#### The Fix:\r\n\r\n```csharp\r\n// ‚úÖ CORRECT - Returns Aid as strings\r\npublic List<string> GetAutoJoin(MongoId sessionId)\r\n{\r\n    return squad.Members\r\n        .Where(m => m.AutoJoin)\r\n        .Select(m => m.Aid.ToString())  // \"1234567\"\r\n        .ToList();\r\n}\r\n\r\n// Client comparison SUCCEEDS:\r\n// playerToInvite.AccountId = \"1234567\"\r\n// autoJoinIds contains \"1234567\"\r\n// Result: Match! Auto-invite triggers.\r\n```\r\n\r\n#### Data Model Must Store Both:\r\n\r\n```csharp\r\npublic class SquadMember\r\n{\r\n    public string ProfileId { get; set; }  // MongoId for SaveServer/friends\r\n    public int Aid { get; set; }           // Aid for party/invites\r\n    public string Nickname { get; set; }\r\n    public bool AutoJoin { get; set; }\r\n\r\n    // Helper for client comparisons\r\n    public string GetAccountId() => Aid.ToString();\r\n}\r\n```\r\n\r\n#### When Creating Friends:\r\n\r\n```csharp\r\n// Generate BOTH IDs\r\nvar memberId = new MongoId();\r\nvar memberAid = GenerateAid();\r\n\r\n// Store in SquadMember\r\nvar member = new SquadMember\r\n{\r\n    ProfileId = memberId.ToString(),  // For friend lookups\r\n    Aid = memberAid,                  // For party invites\r\n    Nickname = nickname,\r\n    AutoJoin = false\r\n};\r\n\r\n// Use ProfileId for SaveServer\r\nownerProfile.FriendProfileIds.Add(memberId);\r\n\r\n// Use Aid for party/client responses\r\nprofile.Info.Aid = memberAid;\r\n```\r\n\r\n#### Debugging Checklist:\r\n\r\n1. **Log what you return**:\r\n   ```csharp\r\n   var aids = GetAutoJoin(sessionId);\r\n   logger.LogInfo($\"pendingauto returning: [{string.Join(\", \", aids)}]\");\r\n   // Expected: [\"1234567\", \"2345678\"]\r\n   // NOT: [\"507f1f77bcf86cd799439011\", \"507f191e810c19729de860ea\"]\r\n   ```\r\n\r\n2. **Log client comparisons**:\r\n   ```csharp\r\n   logger.LogInfo($\"Comparing playerToInvite.AccountId={playerToInvite.AccountId} \" +\r\n                  $\"against autoJoinIds={string.Join(\", \", ids)}\");\r\n   ```\r\n\r\n3. **Verify ID format**:\r\n   ```csharp\r\n   // Aid should be 7 digits\r\n   if (aid.Length == 7 && int.TryParse(aid, out _))\r\n       logger.LogInfo(\"‚úì Correct Aid format\");\r\n   else\r\n       logger.LogError($\"‚úó Wrong Aid format: {aid} (expected 7-digit number)\");\r\n   ```\r\n\r\n---\r\n\r\n## 7. Common Pitfalls\r\n\r\n1. **Missing Bidirectional Friends**: Profile appears in friends list but can't be invited\r\n2. **Wrong ID Type**: Using Aid instead of MongoId for friend lookups\r\n3. **Empty Dialogue Users**: Messenger shows \"Unknown\" instead of nickname\r\n4. **RaidMode Not Local**: Game tries to connect to online servers\r\n5. **GroupPlayers Not Cleared**: Raid fails to start or switches to online\r\n6. **No Shadow Group Tracking**: Squad members don't spawn in raid\r\n7. **FIKA Detection Failed**: Mod conflicts with FIKA multiplayer\r\n8. **Profile Not in SaveServer**: Follower generation returns empty array\r\n9. **ChatBot Not Registered**: Squad Manager doesn't respond to commands\r\n10. **Friend List Not Refreshed**: UI doesn't update after `/add`/`/delete`\r\n\r\n---\r\n\r\n## Summary\r\n\r\nThis system creates **synthetic friends** that integrate seamlessly with Tarkov's existing social/party systems. The key innovation is treating squad members as **real profiles** with friend relationships and dialogue records, allowing the native party invite mechanism to drive follower spawning. The chatbot provides a clean interface for management, while server-side tracking ensures persistence across raids.\r\n\r\n**The flow**:\r\n1. Player types `/add Buddy` to Squad Manager chatbot\r\n2. Server creates fake profile with friend relationships\r\n3. \"Buddy\" appears in Messenger friends list\r\n4. Player right-clicks Buddy ‚Üí Invite to Group\r\n5. Party system adds Buddy to pre-raid party\r\n6. Raid starts ‚Üí spawns Buddy as AI follower\r\n"},"04-Voice-Gesture-Commands":{"title":"Tarkov Voice/Gesture Command System - API Documentation\r","category":"Core Systems","content":"# Tarkov Voice/Gesture Command System - API Documentation\r\n\r\n**Phase**: 7 (Voice Commands - Gesture Menu Integration)\r\n**Priority**: HIGH - Critical for gameplay control\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\nBased on analysis of Tarkov's gesture/voice menu system and FriendlyPMC implementation.\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nTarkov's Y-menu (gesture/voice system) allows players to issue commands that control follower bots. The system uses a global event broadcaster (`BotEventHandler`) that all bots receive. Custom `FollowerReceiver` implementations intercept these events, filter for boss commands, and translate them into bot AI behaviors via request queuing and brain state changes.\r\n\r\n---\r\n\r\n## 1. System Architecture\r\n\r\n### Core Components\r\n\r\n**Gesture Menu System:**\r\n- **GesturesMenu** - Main Y-menu controller (Y-key)\r\n- **GesturesAudioItem** - Voice command categories (ENEMY, TEAM STATUS, etc.)\r\n- **GestureBaseItem** - Individual gesture/voice line items\r\n- **EPhraseTrigger** - Enum of all voice commands (100+ values)\r\n- **EInteraction** - Enum of all gesture commands\r\n\r\n**Event Broadcasting:**\r\n- **BotEventHandler** (Singleton) - Global event broadcaster\r\n  - `OnPhraseSay` - Fires when voice command used\r\n  - `OnGestusShow` - Fires when gesture performed\r\n- **BotReceiver** - Base class for command receivers\r\n  - Each bot has a receiver instance\r\n  - Subscribes to BotEventHandler events\r\n  - Filters and processes relevant commands\r\n\r\n### Event Flow\r\n\r\n```\r\nPlayer presses Y ‚Üí GesturesMenu opens\r\nPlayer selects command ‚Üí Menu triggers event\r\n  ‚Üì\r\nBotEventHandler.Instance broadcasts:\r\n  - OnPhraseSay (voice)\r\n  - OnGestusShow (gesture)\r\n  ‚Üì\r\nAll BotReceiver instances receive event\r\n  ‚Üì\r\nFollowerReceiver filters:\r\n  - Is requester the boss?\r\n  - Is command relevant?\r\n  - Is bot in valid state?\r\n  ‚Üì\r\nCommand translated to:\r\n  - BotRequest (queued action)\r\n  - Brain state change (tactics/distance)\r\n  - Bot response (voice/gesture)\r\n```\r\n\r\n---\r\n\r\n## 2. Command Detection System\r\n\r\n### Subscribing to Events\r\n\r\n```csharp\r\npublic class FollowerReceiver : BotReceiver\r\n{\r\n    private readonly BotOwner botOwner;\r\n\r\n    public FollowerReceiver(BotOwner owner) : base(owner)\r\n    {\r\n        botOwner = owner;\r\n        Receivers.AddReceiver(owner.ProfileId, this);\r\n    }\r\n\r\n    public virtual void Initiate()\r\n    {\r\n        // Subscribe to events\r\n        Singleton<BotEventHandler>.Instance.OnGestusShow += GestusShown;\r\n        Singleton<BotEventHandler>.Instance.OnPhraseSay += PhraseSaid;\r\n    }\r\n\r\n    public virtual void Destroy()\r\n    {\r\n        // Cleanup\r\n        Singleton<BotEventHandler>.Instance.OnGestusShow -= GestusShown;\r\n        Singleton<BotEventHandler>.Instance.OnPhraseSay -= PhraseSaid;\r\n        Receivers.RemoveReceiver(this);\r\n    }\r\n}\r\n```\r\n\r\n### Event Data Structures\r\n\r\n**Voice Command Event**:\r\n```csharp\r\nBotEventHandler.GClass692 info\r\n{\r\n    EPhraseTrigger phrase;      // Command type (e.g., FollowMe, Stop)\r\n    IPlayer PlayerRequester;    // Who issued command\r\n    // Additional fields...\r\n}\r\n```\r\n\r\n**Gesture Command Event**:\r\n```csharp\r\nGClass532 data\r\n{\r\n    EInteraction Gesture;       // Gesture type (e.g., HoldGesture, ComeWithMeGesture)\r\n    IPlayer Player;            // Who performed gesture\r\n    // Additional fields...\r\n}\r\n```\r\n\r\n### Patching BotReceiver\r\n\r\n**Replace vanilla receiver with custom implementation**:\r\n```csharp\r\ninternal class BotReceiverInitPatch : ModulePatch\r\n{\r\n    protected override MethodBase GetTargetMethod()\r\n    {\r\n        return AccessTools.Method(typeof(BotReceiver), \"Init\");\r\n    }\r\n\r\n    [PatchPrefix]\r\n    private static bool PatchPrefix(BotReceiver __instance)\r\n    {\r\n        BotOwner botOwner = GetBotOwner(__instance);\r\n\r\n        // Only use custom receiver for followers\r\n        if (botOwner != null && IsFollower(botOwner))\r\n        {\r\n            FollowerReceiver receiver = new FollowerReceiver(botOwner);\r\n            receiver.Initiate();\r\n            return false; // Skip vanilla Init\r\n        }\r\n\r\n        return true; // Use vanilla for non-followers\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. EPhraseTrigger Voice Commands\r\n\r\n### Combat Commands\r\n\r\n| Command | Value | Description | Typical Use |\r\n|---------|-------|-------------|-------------|\r\n| `Suppress` | - | Suppressive fire | Bot lays down covering fire |\r\n| `CoverMe` | - | Follow close and protect | Bot stays near player, prioritizes threats |\r\n| `Spreadout` | - | Take cover positions | Bots find random cover points |\r\n| `Fire` | - | Open fire | Engage current target |\r\n| `GoForward` | - | Push forward/advance | Bot moves toward enemy or ahead |\r\n| `GetBack` | - | Fall back/increase distance | Bot increases follow distance to 20m |\r\n\r\n### Movement Commands\r\n\r\n| Command | Value | Description | Typical Use |\r\n|---------|-------|-------------|-------------|\r\n| `FollowMe` | - | Resume following | Cancel hold, follow player |\r\n| `Stop` | - | Hold position immediately | Stop in place |\r\n| `HoldPosition` | - | Defensive stance | Switch to \"Defend\" tactic |\r\n| `Regroup` | - | Return to player | Come back to player position |\r\n| `Gogogo` | - | Resume normal tactics | Reset to default behavior |\r\n| `NeedHelp` | - | Closest bot assists | Nearest bot comes to player |\r\n\r\n### Tactical Commands\r\n\r\n| Command | Value | Description | Typical Use |\r\n|---------|-------|-------------|-------------|\r\n| `Look` / `Attention` | - | Reset bot state | Clear enemy, unstuck, force layer end |\r\n| `Silence` | - | Stop talking | Mute for 120 seconds |\r\n| `OnRepeatedContact` | - | Scan ahead | Look for enemies in direction |\r\n| `OpenDoor` | - | Open nearby door | Closest bot to door opens it |\r\n| `LootGeneric` | - | Loot item | Closest bot loots targeted item |\r\n| `LootWeapon` | - | Loot weapon | Closest bot loots weapon |\r\n\r\n### Coordination Commands\r\n\r\n| Command | Value | Description | Typical Use |\r\n|---------|-------|-------------|-------------|\r\n| `OnYourOwn` | - | Independent operation | Increase distance, enable patrol, stop protection |\r\n| `ExitLocated` | - | Regroup for extraction | Prepare to leave raid |\r\n\r\n### Directional Commands (Enemy Location)\r\n\r\n| Command | Value | Description | Vector |\r\n|---------|-------|-------------|--------|\r\n| `InTheFront` | - | Enemy ahead | Player position + forward * 20m |\r\n| `OnSix` | - | Enemy behind | Player position - forward * 20m |\r\n| `LeftFlank` | - | Enemy left | Player position + left * 20m |\r\n| `RightFlank` | - | Enemy right | Player position + right * 20m |\r\n\r\n### Custom Commands (FriendlyPMC)\r\n\r\n| Command | Value | Description |\r\n|---------|-------|-------------|\r\n| `CustomPhrases.TeamStatus` | 200 | Status report |\r\n| `CustomPhrases.OverThere` | 201 | Check boss's view direction |\r\n\r\n### Response Phrases\r\n\r\n| Phrase | Meaning |\r\n|--------|---------|\r\n| `Roger` | Acknowledged |\r\n| `Negative` | Cannot comply |\r\n| `DontKnow` | Uncertain/busy |\r\n| `Going` | Moving out |\r\n| `Covering` | Providing suppression |\r\n\r\n---\r\n\r\n## 4. EInteraction Gesture Commands\r\n\r\n### Gesture List\r\n\r\n| Gesture | Description | Targeting |\r\n|---------|-------------|-----------|\r\n| `HoldGesture` | Hold position | All bots in 15m range |\r\n| `ComeWithMeGesture` | Come here | Look-aim targeted bot |\r\n| `ThereGesture` | Go forward | Closest bot |\r\n| `OkGesture` | Acknowledge | Response only |\r\n| `FriendlyGesture` | Friendly/status check | All bots |\r\n| `NoGesture` | Negative response | Response only |\r\n| `CustomGestures.OverThere` | Face direction | All bots (201) |\r\n\r\n---\r\n\r\n## 5. Command Targeting System\r\n\r\n### 1. Look-Aim Targeting\r\n\r\n**Purpose**: Detect which bot the player is looking at for targeted commands.\r\n\r\n```csharp\r\n// Returns the bot being looked at (or null)\r\nprotected static Player IsRequesterLookingAtSomeone(Player requester, float magnitude = 27f)\r\n{\r\n    // Uses sphere cast from player's interaction ray\r\n    // Checks line-of-sight with CanShootToTarget\r\n    // Caches result for 0.5s to reduce raycasts\r\n\r\n    if (Time.time - lastLookCheckTime < 0.5f)\r\n        return cachedLookTarget;\r\n\r\n    // Raycast logic...\r\n    lastLookCheckTime = Time.time;\r\n    cachedLookTarget = target;\r\n    return target;\r\n}\r\n\r\n// Check if player is looking at specific bot\r\nprotected static bool IsRequesterLookingAt(BotOwner bot, Player requester, float distance = 27f)\r\n{\r\n    Player lookedAtPlayer = IsRequesterLookingAtSomeone(requester, distance);\r\n    return lookedAtPlayer != null &&\r\n           lookedAtPlayer.ProfileId == bot.ProfileId;\r\n}\r\n```\r\n\r\n**Commands Using Look-Aim**:\r\n- `ComeWithMeGesture` - Only bot being looked at responds\r\n- `FollowMe`, `Stop`, `HoldPosition`, `Gogogo`, `GetBack`, `OnYourOwn` - Looked-at bot OR all if none targeted\r\n- Directional commands (`InTheFront`, `OnSix`, `LeftFlank`, `RightFlank`) - Only targeted bot\r\n\r\n**Implementation Notes**:\r\n- 0.5s cache prevents excessive raycasts\r\n- Uses player's interaction ray (where crosshair points)\r\n- Checks line-of-sight (can't command bot through walls)\r\n- 27m default range (configurable)\r\n\r\n### 2. Closest Bot Targeting\r\n\r\n**Purpose**: Find nearest follower for context-sensitive commands.\r\n\r\n```csharp\r\nprotected static bool IsClosestBot(BotOwner bot, IPlayer requester)\r\n{\r\n    if (Time.time - lastClosestCheckTime < 0.5f)\r\n        return bot.ProfileId == cachedClosestBotId;\r\n\r\n    float minDistance = float.MaxValue;\r\n    BotOwner closestBot = null;\r\n\r\n    foreach (var follower in GetAllFollowers())\r\n    {\r\n        float dist = (follower.Position - requester.Position).sqrMagnitude;\r\n        if (dist < minDistance)\r\n        {\r\n            minDistance = dist;\r\n            closestBot = follower;\r\n        }\r\n    }\r\n\r\n    lastClosestCheckTime = Time.time;\r\n    cachedClosestBotId = closestBot?.ProfileId;\r\n\r\n    return bot.ProfileId == cachedClosestBotId;\r\n}\r\n```\r\n\r\n**Commands Using Closest**:\r\n- `ThereGesture` - Closest bot advances\r\n- `NeedHelp` - Closest bot assists\r\n- `OpenDoor` - Closest bot to door opens it\r\n- `LootGeneric/LootWeapon` - Closest bot to item loots\r\n\r\n### 3. Proximity-Based Responses\r\n\r\nMost commands require close proximity (15-23m) for bot to respond with acknowledgment voice/gesture, but commands execute at longer ranges.\r\n\r\n```csharp\r\nbool isClose = (botOwner.Position - requester.Position).magnitude < 23f;\r\n\r\nif (isClose && !isBusy)\r\n{\r\n    botOwner.BotTalk.TrySay(EPhraseTrigger.Roger, false);\r\n    botOwner.Gesture.TryGestus(EInteraction.OkGesture, true);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 6. Command ‚Üí Bot Behavior Mapping\r\n\r\n### Request System\r\n\r\nCommands create `BotRequest` objects that queue in the bot's request controller:\r\n\r\n| Command | Request Type | BotRequestType | Description |\r\n|---------|-------------|----------------|-------------|\r\n| `HoldGesture`, `Stop` | `FollowerHold` | `wait` | Stand ground, defensive |\r\n| `ComeWithMeGesture` | `FollowerGoCheck` | `followMe` | Come to player |\r\n| `ThereGesture` | `FollowerGoCheck` | `goToPoint` | Move forward |\r\n| `GoForward` (enemy) | `FollowerRushEnemy` | Custom | Advance on enemy |\r\n| `GoForward` (no enemy) | `FollowerGoCheck` | `goToPoint` | Move ahead |\r\n| `Spreadout` | `FollowerTakeCover` | Custom | Find random cover |\r\n| `Suppress` | `FollowerSuppress` | `suppressionFire` | Covering fire |\r\n| `Regroup`, `CoverMe`, `NeedHelp` | `FollowerRegroup` | `Regroup (30)` | Return to player |\r\n| `OpenDoor` | `FollowerOpenDoorRequest` | Custom | Open door |\r\n| `LootGeneric/LootWeapon` | `FollowerTakeLootRequest` | Custom | Loot item |\r\n\r\n### Brain State Changes\r\n\r\nCommands modify `FollowerBrain` properties:\r\n\r\n| Command | Brain Changes |\r\n|---------|---------------|\r\n| `HoldPosition` | `SetBossTactic(\"Defend\")` |\r\n| `Gogogo` | `SetBossTactic(null)` - Reset to default |\r\n| `CoverMe` | `ResetFollowDistance()`, `SetCanPatrol(false)`, `SetBossTactic(null)`, `SetBossNeedsProtection(true)` |\r\n| `GetBack` | `SetFollowDistance(20)` |\r\n| `FollowMe` | `SetCanPatrol(false)` |\r\n| `OnYourOwn` | `SetBossNeedsProtection(false)`, `SetBossTactic(null)`, `SetFollowDistance(20)`, `SetCanPatrol(true)` |\r\n| `Look` (Attention) | Clears enemy, resets stuck states, force layer end |\r\n\r\n### FollowerBrain API\r\n\r\n```csharp\r\npublic class FollowerBrain : BaseBrain\r\n{\r\n    // Tactic control\r\n    void SetBossTactic(string tactic)         // \"Defend\", \"Guard\", \"Marksman\", null (default)\r\n    void BossOrdersChanged()                   // Notify fight layer of new orders\r\n    void BossOrdersReset()                     // Cancel current orders\r\n\r\n    // Follow distance control\r\n    void SetFollowDistance(int distance)       // Distance in meters\r\n    void ResetFollowDistance()                 // Back to default (12m)\r\n\r\n    // Behavior flags\r\n    void SetCanPatrol(bool patrol)             // Enable/disable patrolling\r\n    void SetBossNeedsProtection(bool value)    // Cover player when under attack\r\n\r\n    // Utility\r\n    void HandsReset()                          // Reset hand state (unstuck)\r\n    void FakeShot(Vector3 position)           // Create fake gunshot to look at position\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7. Bot Response System\r\n\r\n### BotTalk API\r\n\r\n```csharp\r\n// Immediate speech (bypasses cooldowns)\r\nbotOwner.BotTalk.Say(EPhraseTrigger phrase, bool immediately, ETagStatus? mask);\r\n\r\n// Try to say (respects cooldowns and conditions)\r\nbotOwner.BotTalk.TrySay(EPhraseTrigger phrase, bool withGroupDelay, ETagStatus? mask);\r\n\r\n// Silence bot for duration\r\nbotOwner.BotTalk.SetSilence(float seconds);\r\n\r\n// Check if currently silenced\r\nbool isSilenced = botOwner.BotTalk.IsSilenced;\r\n```\r\n\r\n### Gesture API\r\n\r\n```csharp\r\n// Try to perform gesture\r\nbotOwner.Gesture.TryGestus(EInteraction gesture, bool forced);\r\n```\r\n\r\n### Typical Response Patterns\r\n\r\n**Acknowledged Command**:\r\n```csharp\r\nif (isClose && !isBusy)\r\n{\r\n    botOwner.BotTalk.TrySay(EPhraseTrigger.Roger, false);\r\n    botOwner.Gesture.TryGestus(EInteraction.OkGesture, true);\r\n}\r\n```\r\n\r\n**Cannot Comply**:\r\n```csharp\r\nif (isBusy || hasEnemy)\r\n{\r\n    botOwner.BotTalk.TrySay(EPhraseTrigger.Negative, false);\r\n    botOwner.Gesture.TryGestus(EInteraction.NoGesture, false);\r\n}\r\n```\r\n\r\n**Executing Movement**:\r\n```csharp\r\nbotOwner.BotTalk.TrySay(EPhraseTrigger.Going, false);\r\n```\r\n\r\n**Group Delay**: When using `TrySay(phrase, true, mask)` with groupDelay=true, only one bot in the group will speak to prevent spam.\r\n\r\n---\r\n\r\n## 8. Implementation Examples\r\n\r\n### Example 1: Hold Position Command\r\n\r\n```csharp\r\npublic virtual void PhraseSaid(BotEventHandler.GClass692 info)\r\n{\r\n    IPlayer requester = info.PlayerRequester;\r\n\r\n    // Filter: Must be boss requester\r\n    if (!IsBossRequester(requester)) return;\r\n\r\n    Player playerRequester = GetPlayer(requester);\r\n    bool isClose = (botOwner.Position - requester.Position).magnitude < 23f;\r\n\r\n    if (info.phrase == EPhraseTrigger.Stop)\r\n    {\r\n        // Deny if currently fighting\r\n        if (botOwner.Memory.HaveEnemy)\r\n        {\r\n            botOwner.BotTalk.Say(EPhraseTrigger.Negative, true, null);\r\n            return;\r\n        }\r\n\r\n        // Stop any current requests\r\n        StopCurrentRequest(botOwner, playerRequester, true);\r\n\r\n        // Create hold request\r\n        FollowerHold holdRequest = new FollowerHold(playerRequester);\r\n        holdRequest.AddPossibleExecutors(botOwner);\r\n\r\n        // Queue request\r\n        if (playerRequester.AIData.AskRequests.TryAdd(holdRequest, botOwner.BotsGroup.RequestsController))\r\n        {\r\n            // Acknowledge if close\r\n            if (isClose)\r\n            {\r\n                botOwner.Gesture.TryGestus(EInteraction.OkGesture, true);\r\n                botOwner.BotTalk.TrySay(EPhraseTrigger.Roger, false);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Example 2: Suppressive Fire Command\r\n\r\n```csharp\r\nif (info.phrase == EPhraseTrigger.Suppress)\r\n{\r\n    // Only if close and has enemy\r\n    if (!botOwner.Memory.HaveEnemy || !isClose) return;\r\n\r\n    // Stop current request\r\n    StopCurrentRequest(botOwner, playerRequester, true);\r\n\r\n    // Create suppression request\r\n    FollowerSuppress suppressRequest = new FollowerSuppress(requester);\r\n    suppressRequest.AddPossibleExecutors(botOwner);\r\n\r\n    // Queue request\r\n    if (playerRequester.AIData.AskRequests.TryAdd(suppressRequest, botOwner.BotsGroup.RequestsController))\r\n    {\r\n        botOwner.BotTalk.TrySay(EPhraseTrigger.Covering, false);\r\n    }\r\n}\r\n```\r\n\r\n### Example 3: Come With Me Gesture (Look-Aim)\r\n\r\n```csharp\r\npublic virtual void GestusShown(GClass532 data)\r\n{\r\n    EInteraction gesture = data.Gesture;\r\n    IPlayer requester = data.Player;\r\n\r\n    if (!IsBossRequester(requester)) return;\r\n\r\n    Player playerRequester = GetPlayer(requester);\r\n\r\n    if (gesture == EInteraction.ComeWithMeGesture)\r\n    {\r\n        // Only if player is looking at this bot\r\n        if (IsRequesterLookingAt(botOwner, playerRequester))\r\n        {\r\n            StopCurrentRequest(botOwner, playerRequester);\r\n\r\n            // Create follow request\r\n            FollowerGoCheck goRequest = new FollowerGoCheck(\r\n                data.Player,\r\n                BotRequestType.followMe\r\n            );\r\n            goRequest.AddPossibleExecutors(botOwner);\r\n\r\n            // Queue request\r\n            if (playerRequester.AIData.AskRequests.TryAdd(goRequest, botOwner.BotsGroup.RequestsController))\r\n            {\r\n                botOwner.Gesture.TryGestus(EInteraction.OkGesture, false);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Example 4: Cover Me (Brain State Change)\r\n\r\n```csharp\r\nif (info.phrase == EPhraseTrigger.CoverMe)\r\n{\r\n    FollowerBrain brain = botOwner.Brain.BaseBrain as FollowerBrain;\r\n\r\n    if (brain != null)\r\n    {\r\n        // Modify brain state\r\n        brain.ResetFollowDistance();           // Close follow\r\n        brain.SetCanPatrol(false);             // No wandering\r\n        brain.SetBossTactic(null);             // Default tactic\r\n        brain.SetBossNeedsProtection(true);    // Prioritize protecting player\r\n        brain.BossOrdersChanged();             // Notify layers\r\n    }\r\n\r\n    // Create regroup request to get close\r\n    FollowerRegroup regroupRequest = new FollowerRegroup(requester);\r\n    regroupRequest.AddPossibleExecutors(botOwner);\r\n\r\n    if (playerRequester.AIData.AskRequests.TryAdd(regroupRequest, botOwner.BotsGroup.RequestsController))\r\n    {\r\n        if (isClose)\r\n        {\r\n            botOwner.BotTalk.TrySay(EPhraseTrigger.Roger, false);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 9. Custom Request Types\r\n\r\n### Base Request Template\r\n\r\n```csharp\r\ninternal class FollowerHold : BotRequest\r\n{\r\n    public FollowerHold(Player requester) : base(requester, BotRequestType.wait)\r\n    {\r\n    }\r\n\r\n    public override EBotRequestMode RequestMode => EBotRequestMode.Fight;\r\n\r\n    public override bool CanRequest(BotOwner requester) => true;\r\n\r\n    public override bool CanProceed() => true;\r\n\r\n    public override bool CanStartExecute(BotOwner executor) => true;\r\n}\r\n```\r\n\r\n### Suppression Request (Custom Logic)\r\n\r\n```csharp\r\ninternal class FollowerSuppress : BotRequest\r\n{\r\n    public FollowerSuppress(IPlayer requester) : base(requester, BotRequestType.suppressionFire)\r\n    {\r\n    }\r\n\r\n    public override EBotRequestMode RequestMode => EBotRequestMode.Fight;\r\n\r\n    public override bool CanRequest(BotOwner requester)\r\n    {\r\n        // Must have enemy\r\n        return requester.Memory.HaveEnemy;\r\n    }\r\n\r\n    public override bool CanStartExecute(BotOwner executor)\r\n    {\r\n        // Must still have enemy when executing\r\n        return executor.Memory.HaveEnemy;\r\n    }\r\n}\r\n```\r\n\r\n### Regroup Request (Custom Request Type)\r\n\r\n```csharp\r\ninternal class FollowerRegroup : BotRequest\r\n{\r\n    public const int CustomBotRequestType_Regroup = 30;\r\n\r\n    public FollowerRegroup(IPlayer requester)\r\n        : base(requester, (BotRequestType)CustomBotRequestType_Regroup)\r\n    {\r\n    }\r\n\r\n    public override EBotRequestMode RequestMode => EBotRequestMode.Fight;\r\n\r\n    public override bool CanProceed()\r\n    {\r\n        // Can proceed if not at boss yet\r\n        float distToBoss = (Executor.Position - Requester.Position).magnitude;\r\n        return distToBoss > 5f;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 10. Special Features\r\n\r\n### 1. Attention/Look Command (Reset Stuck Bot)\r\n\r\nThe `EPhraseTrigger.Look` command resets a stuck bot:\r\n\r\n```csharp\r\nif (info.phrase == EPhraseTrigger.Look)\r\n{\r\n    // Stop any active requests\r\n    StopCurrentRequest(botOwner, playerRequester, true);\r\n\r\n    // Force current layer to end\r\n    AccessTools.Field(typeof(BaseLogicLayerAbstractClass), \"bool_1\")\r\n        .SetValue(botOwner.Brain.BaseBrain.CurLayerInfo, true);\r\n\r\n    // Unstuck from item interactions\r\n    InteractableObjects.RemoveTaker(botOwner);\r\n    InteractableObjects.RemoveOpener(botOwner);\r\n\r\n    // Clear enemy target\r\n    if (botOwner.Memory.HaveEnemy)\r\n    {\r\n        botOwner.Memory.GoalEnemy.GroupInfo.EnemyLastSeenTimeSense = 0f;\r\n        botOwner.Memory.GoalEnemy.GroupInfo.IsHaveSeen = false;\r\n        botOwner.Memory.GoalEnemy = null;\r\n    }\r\n\r\n    // Reset hands state\r\n    FollowerBrain brain = botOwner.Brain.BaseBrain as FollowerBrain;\r\n    brain?.HandsReset();\r\n\r\n    // Reset brain orders\r\n    brain?.BossOrdersReset();\r\n}\r\n```\r\n\r\n### 2. Directional Enemy Alerts (Fake Gunshot)\r\n\r\n```csharp\r\nif (info.phrase == EPhraseTrigger.InTheFront)\r\n{\r\n    FollowerBrain brain = botOwner.Brain.BaseBrain as FollowerBrain;\r\n\r\n    // Calculate target position 20m ahead of player\r\n    Vector3 targetPos = playerRequester.MainParts[BodyPartType.head].Position +\r\n                        playerRequester.LookDirection * 20f;\r\n\r\n    // Create fake gunshot to make bot look there\r\n    brain?.FakeShot(targetPos);\r\n}\r\n\r\n// Similar for other directions:\r\n// OnSix: playerPos - lookDir * 20f\r\n// LeftFlank: playerPos - rightDir * 20f  (negative right = left)\r\n// RightFlank: playerPos + rightDir * 20f\r\n```\r\n\r\n### 3. Silence Command (Mute Bot)\r\n\r\n```csharp\r\nif (info.phrase == EPhraseTrigger.Silence)\r\n{\r\n    // Silence for 120 seconds\r\n    botOwner.BotTalk.SetSilence(120f);\r\n\r\n    // Acknowledge silently with gesture only\r\n    if (isClose)\r\n    {\r\n        botOwner.Gesture.TryGestus(EInteraction.OkGesture, true);\r\n    }\r\n}\r\n```\r\n\r\n### 4. Teleport to Player (Custom - Not Voice Command)\r\n\r\n```csharp\r\n// Triggered via hotkey, not voice command\r\npublic void TeleportToPlayer()\r\n{\r\n    Vector3 playerPos = GetBossPosition();\r\n    Vector3 offset = GetRandomOffset(2f, 5f);  // Random offset to avoid stacking\r\n\r\n    botOwner.Teleport(playerPos + offset);\r\n\r\n    // Clear any movement requests after teleport\r\n    StopCurrentRequest(botOwner, playerRequester, true);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 11. Adding Custom Commands\r\n\r\n### Step 1: Define Custom Enum Value\r\n\r\n```csharp\r\npublic enum CustomPhrases\r\n{\r\n    TeamStatus = 200,\r\n    OverThere = 201,\r\n    RequestAmmo = 202\r\n}\r\n```\r\n\r\n### Step 2: Patch Menu to Add Items\r\n\r\n```csharp\r\ninternal class GesturesMenuPatch : ModulePatch\r\n{\r\n    protected override MethodBase GetTargetMethod()\r\n    {\r\n        return AccessTools.Method(typeof(GesturesMenu), \"InitPhraseGroups\");\r\n    }\r\n\r\n    [PatchPostfix]\r\n    private static void PatchPostfix(GesturesMenu __instance)\r\n    {\r\n        var list_0 = (List<GesturesAudioItem>)AccessTools.Field(typeof(GesturesMenu), \"list_0\")\r\n            .GetValue(__instance);\r\n        var list_1 = (List<GestureBaseItem>)AccessTools.Field(typeof(GesturesMenu), \"list_1\")\r\n            .GetValue(__instance);\r\n\r\n        // Find \"TEAM STATUS\" category\r\n        list_0.ForEach(item =>\r\n        {\r\n            if (item.gameObject.name == \"TEAM STATUS\")\r\n            {\r\n                // Create menu item handler\r\n                GestureMenuItem menuItem = new GestureMenuItem();\r\n                menuItem.gesturesMenu_0 = __instance;\r\n                menuItem.isSituational = false;\r\n\r\n                // Create new phrase entry\r\n                GestureBaseItem gestureItem = item.CreateNewPhrase(\r\n                    (EPhraseTrigger)CustomPhrases.TeamStatus,\r\n                    false\r\n                );\r\n\r\n                // Wire up click handler\r\n                gestureItem.OnPointerClicked.Subscribe(\r\n                    new Action<GestureAction>(menuItem.method_0)\r\n                );\r\n\r\n                list_1.Add(gestureItem);\r\n            }\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n### Step 3: Add to Available Phrases\r\n\r\n```csharp\r\n[PatchPostfix]\r\nprivate static void PatchPostfix_Available(GesturesMenu __instance)\r\n{\r\n    var hashSet_1 = (HashSet<EPhraseTrigger>)AccessTools.Field(typeof(GesturesMenu), \"hashSet_1\")\r\n        .GetValue(__instance);\r\n\r\n    hashSet_1.Add((EPhraseTrigger)CustomPhrases.TeamStatus);\r\n    hashSet_1.Add((EPhraseTrigger)CustomPhrases.OverThere);\r\n    hashSet_1.Add((EPhraseTrigger)CustomPhrases.RequestAmmo);\r\n}\r\n```\r\n\r\n### Step 4: Patch Display Name\r\n\r\n```csharp\r\ninternal class EnumToStringPatch : ModulePatch\r\n{\r\n    protected override MethodBase GetTargetMethod()\r\n    {\r\n        return AccessTools.Method(typeof(Enum), \"ToString\", new Type[] { });\r\n    }\r\n\r\n    [PatchPrefix]\r\n    private static bool PatchPrefix(Enum __instance, ref string __result)\r\n    {\r\n        if (__instance is EPhraseTrigger trigger)\r\n        {\r\n            switch ((int)trigger)\r\n            {\r\n                case (int)CustomPhrases.TeamStatus:\r\n                    __result = \"Team Status\";\r\n                    return false;\r\n                case (int)CustomPhrases.OverThere:\r\n                    __result = \"Over There\";\r\n                    return false;\r\n                case (int)CustomPhrases.RequestAmmo:\r\n                    __result = \"Request Ammo\";\r\n                    return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n### Step 5: Handle Custom Command\r\n\r\n```csharp\r\npublic virtual void PhraseSaid(BotEventHandler.GClass692 info)\r\n{\r\n    // ... existing command handling\r\n\r\n    if (info.phrase == (EPhraseTrigger)CustomPhrases.TeamStatus)\r\n    {\r\n        // Bot reports status\r\n        ReportStatus(botOwner, playerRequester);\r\n    }\r\n    else if (info.phrase == (EPhraseTrigger)CustomPhrases.RequestAmmo)\r\n    {\r\n        // Bot gives ammo to player\r\n        ShareAmmo(botOwner, playerRequester);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 12. Integration with BigBrain Layers\r\n\r\n### Notifying Layers of Command Changes\r\n\r\n```csharp\r\npublic class FollowerFightLayer : BaseLogicLayerSimpleAbstractClass\r\n{\r\n    private bool _forceNewDecision;\r\n\r\n    public void OrdersChanged()\r\n    {\r\n        // Force re-evaluation next frame\r\n        _forceNewDecision = true;\r\n    }\r\n\r\n    public void OrdersReset()\r\n    {\r\n        // Clear any command-driven behavior\r\n        _currentCommand = null;\r\n        _forceNewDecision = true;\r\n    }\r\n\r\n    public override AICoreActionResultStruct<BotLogicDecision, GClass26> GetDecision()\r\n    {\r\n        if (_forceNewDecision)\r\n        {\r\n            _forceNewDecision = false;\r\n            // Re-evaluate based on new brain state\r\n        }\r\n\r\n        FollowerBrain brain = BotOwner_0.Brain.BaseBrain as FollowerBrain;\r\n\r\n        // Check brain tactic\r\n        if (brain.BossTactic == \"Defend\")\r\n        {\r\n            return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                BotLogicDecision.holdPosition,\r\n                \"Boss ordered defensive\"\r\n            );\r\n        }\r\n\r\n        // Check if boss needs protection\r\n        if (brain.BossNeedsProtection && IsPlayerThreatened())\r\n        {\r\n            return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                BotLogicDecision.coverPlayer,\r\n                \"Protecting boss\"\r\n            );\r\n        }\r\n\r\n        // Normal combat logic...\r\n    }\r\n}\r\n```\r\n\r\n### Request Processing in Layers\r\n\r\n```csharp\r\npublic override AICoreActionEndStruct ShallEndCurrentDecision(\r\n    AICoreActionResultStruct<BotLogicDecision, GClass26> curDecision)\r\n{\r\n    // Check if there's a pending request\r\n    if (BotOwner_0.BotsGroup.RequestsController.HasActiveRequest(BotOwner_0))\r\n    {\r\n        var request = BotOwner_0.BotsGroup.RequestsController.GetActiveRequest(BotOwner_0);\r\n\r\n        // End current decision to process request\r\n        if (request.RequestType == BotRequestType.wait)\r\n        {\r\n            return new AICoreActionEndStruct(\"Hold position requested\");\r\n        }\r\n    }\r\n\r\n    return base.ShallEndCurrentDecision(curDecision);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 13. Important Implementation Notes\r\n\r\n### 1. Command Priority and Busy State\r\n\r\n**Ignore List**: Some commands should be ignored when bot is busy:\r\n\r\n```csharp\r\nprivate static readonly List<EPhraseTrigger> BossBusyIgnore = new List<EPhraseTrigger>\r\n{\r\n    EPhraseTrigger.Stop,\r\n    EPhraseTrigger.HoldPosition,\r\n    EPhraseTrigger.Gogogo,\r\n    EPhraseTrigger.OnYourOwn\r\n};\r\n\r\npublic bool IsBusy()\r\n{\r\n    return botOwner.Memory.HaveEnemy &&\r\n           botOwner.Memory.GoalEnemy.IsVisible;\r\n}\r\n\r\n// In command handler:\r\nif (IsBusy() && BossBusyIgnore.Contains(info.phrase))\r\n{\r\n    botOwner.BotTalk.Say(EPhraseTrigger.Negative, true, null);\r\n    return;\r\n}\r\n```\r\n\r\n### 2. Request Cleanup\r\n\r\n**Always stop current request before adding new one**:\r\n\r\n```csharp\r\nprotected static void StopCurrentRequest(\r\n    BotOwner botOwner,\r\n    Player playerRequester,\r\n    bool forced = false)\r\n{\r\n    var requestsController = botOwner.BotsGroup.RequestsController;\r\n\r\n    if (requestsController.HasActiveRequest(botOwner))\r\n    {\r\n        var currentRequest = requestsController.GetActiveRequest(botOwner);\r\n        requestsController.RemoveRequest(currentRequest, forced);\r\n    }\r\n}\r\n```\r\n\r\n### 3. Distance and Line-of-Sight\r\n\r\n**Check both distance and LOS for responses**:\r\n\r\n```csharp\r\nbool isClose = (botOwner.Position - requester.Position).magnitude < 23f;\r\nbool hasLOS = botOwner.LookSensor.CanShootToTarget(requester.Position);\r\n\r\nif (isClose && hasLOS)\r\n{\r\n    // Respond with voice/gesture\r\n}\r\n```\r\n\r\n### 4. Silence Management\r\n\r\n**Respect silence state for auto-responses**:\r\n\r\n```csharp\r\nif (!botOwner.BotTalk.IsSilenced && isClose)\r\n{\r\n    botOwner.BotTalk.TrySay(EPhraseTrigger.Roger, false);\r\n}\r\n```\r\n\r\n### 5. Caching for Performance\r\n\r\n**Cache expensive calculations**:\r\n\r\n```csharp\r\nprivate static float _lastLookCheckTime;\r\nprivate static Player _cachedLookTarget;\r\nprivate static float _lastClosestCheckTime;\r\nprivate static string _cachedClosestBotId;\r\n\r\n// Cache for 0.5s to reduce raycasts/distance checks\r\n```\r\n\r\n### 6. Group Delay for Voice Responses\r\n\r\n**Prevent all bots speaking at once**:\r\n\r\n```csharp\r\n// Only one bot in group will speak with groupDelay=true\r\nbotOwner.BotTalk.TrySay(EPhraseTrigger.Roger, true, null);\r\n```\r\n\r\n### 7. Command Execution Range vs Response Range\r\n\r\n- **Response Range**: 15-23m (bot gives voice/gesture acknowledgment)\r\n- **Execution Range**: Often unlimited (command executes but no verbal response)\r\n\r\n```csharp\r\n// Command always executes\r\nExecuteCommand(command);\r\n\r\n// But only respond if close\r\nif (isClose)\r\n{\r\n    Acknowledge();\r\n}\r\n```\r\n\r\n---\r\n\r\n## 14. Common Pitfalls\r\n\r\n1. **Not filtering for boss requester** - All bots will try to respond to any player's commands\r\n2. **Missing request cleanup** - Old requests interfere with new commands\r\n3. **Excessive raycasts** - Not caching look-aim results causes performance issues\r\n4. **Not checking busy state** - Bots respond to commands while fighting\r\n5. **Wrong targeting method** - Using closest when should use look-aim (or vice versa)\r\n6. **Not calling BossOrdersChanged()** - Fight layers don't know about brain state changes\r\n7. **Missing silence check** - Bots talk even when told to be quiet\r\n8. **No LOS check** - Bots respond through walls\r\n9. **Forgetting group delay** - All bots yell \"Roger!\" simultaneously\r\n10. **Not handling null values** - Player or requester might be null/dead\r\n\r\n---\r\n\r\n## Summary\r\n\r\nThe voice/gesture command system provides rich player-bot interaction via Tarkov's native Y-menu. Key components:\r\n\r\n1. **BotEventHandler** broadcasts all commands globally\r\n2. **Custom FollowerReceiver** filters and translates commands\r\n3. **BotRequest** system queues bot actions\r\n4. **FollowerBrain state** modifies ongoing behavior\r\n5. **BotTalk/Gesture** provides feedback to player\r\n\r\n**Integration requires**:\r\n- Patching BotReceiver to use custom receiver\r\n- Implementing command handlers (PhraseSaid, GestusShown)\r\n- Creating custom BotRequest types\r\n- Notifying BigBrain layers of command changes\r\n- Providing bot acknowledgment responses\r\n\r\nThe system is extensible - custom commands can be added by patching the menu and enum, then handling in FollowerReceiver.\r\n"},"05-Health-Medical-System":{"title":"Tarkov Health & Medical System - API Documentation\r","category":"Core Systems","content":"# Tarkov Health & Medical System - API Documentation\r\n\r\n**Priority**: CRITICAL - Enables Innovations #3, #5, Phases 12B+C\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\nBased on analysis of Tarkov health system and SAIN medical implementations.\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nTarkov's health system tracks damage by body part, status effects (bleeding, fractures, pain), and provides medical item usage for treatment. This document provides complete API reference for implementing medic AI, casualty evacuation, and downed enemy states.\r\n\r\n---\r\n\r\n## 1. Health Controller API\r\n\r\n### 1.1 Accessing Health Controller\r\n\r\n**From Player:**\r\n```csharp\r\nPlayer player = bot.GetPlayer;\r\nActiveHealthController healthController = player.ActiveHealthController;\r\nIHealthController iHealthController = player.HealthController;\r\n```\r\n\r\n**From BotOwner:**\r\n```csharp\r\nBotOwner botOwner;\r\nIHealthController healthController = botOwner.HealthController;\r\n\r\n// Check if alive\r\nbool isAlive = botOwner.HealthController.IsAlive;\r\nbool isDead = botOwner.IsDead;\r\n```\r\n\r\n### 1.2 Core Health Controller Interface (GInterface381)\r\n\r\n```csharp\r\n// Get body part health\r\nValueStruct bodyPartHealth = healthController.GetBodyPartHealth(EBodyPart.Head, false);\r\n\r\n// ValueStruct structure:\r\npublic struct ValueStruct\r\n{\r\n    public float Current;    // Current health points\r\n    public float Maximum;    // Maximum health points\r\n    public float Minimum;    // Minimum threshold\r\n    public float Normalized; // Current/Maximum (0.0 to 1.0)\r\n}\r\n```\r\n\r\n### 1.3 ActiveHealthController Methods\r\n\r\n```csharp\r\n// Restore full health (all body parts to max)\r\nactiveHealthController.RestoreFullHealth();\r\n\r\n// Restore specific body part\r\nactiveHealthController.RestoreBodyPart(EBodyPart.LeftLeg, 1f); // 1f = full restore\r\nactiveHealthController.RestoreBodyPart(EBodyPart.Chest, 0.5f); // 0.5f = 50% restore\r\n\r\n// Check if body part is destroyed\r\nbool isDestroyed = healthController.IsBodyPartDestroyed(EBodyPart.Chest);\r\n```\r\n\r\n### 1.4 Health Status (Player.HealthStatus)\r\n\r\n```csharp\r\n// Get overall health status\r\nETagStatus healthStatus = player.HealthStatus;\r\n\r\n// Health status enum values:\r\n// 1024 (0x400) = Healthy\r\n// 2048 (0x800) = Injured\r\n// 4096 (0x1000) = BadlyInjured\r\n// 8192 (0x2000) = Dying\r\n\r\npublic bool Healthy => (int)HealthStatus == 1024;\r\npublic bool Injured => (int)HealthStatus == 2048;\r\npublic bool BadlyInjured => (int)HealthStatus == 4096;\r\npublic bool Dying => (int)HealthStatus == 8192;\r\n```\r\n\r\n---\r\n\r\n## 2. Damage System\r\n\r\n### 2.1 DamageInfoStruct\r\n\r\n```csharp\r\npublic struct DamageInfoStruct\r\n{\r\n    public float Damage;           // Amount of damage dealt\r\n    public EDamageType DamageType; // Type of damage\r\n    public Vector3 HitPoint;       // World position of hit\r\n    public Vector3 MasterOrigin;   // Origin of damage source\r\n    public IPlayerOwner Player;    // Attacker (can be null)\r\n    public Weapon Weapon;          // Weapon used (can be null)\r\n}\r\n```\r\n\r\n### 2.2 Damage Types (EDamageType)\r\n\r\n```csharp\r\npublic enum EDamageType\r\n{\r\n    Undefined,\r\n    Bullet,       // Gunshot\r\n    Melee,        // Melee attack\r\n    Explosion,    // Grenade/explosive\r\n    Barbed,       // Barbed wire\r\n    Flame,        // Fire\r\n    Blunt,        // Blunt trauma\r\n    Fall,         // Fall damage\r\n    Exhaustion,   // Stamina exhaustion\r\n    // ... and more\r\n}\r\n```\r\n\r\n### 2.3 Receiving Damage Events\r\n\r\n```csharp\r\n// Subscribe to damage events\r\nplayer.BeingHitAction += OnGetHit;\r\n\r\nvoid OnGetHit(DamageInfoStruct damageInfo, EBodyPart bodyPart, float damageValue)\r\n{\r\n    // Handle damage\r\n    Vector3 hitPosition = damageInfo.HitPoint;\r\n    IPlayerOwner attacker = damageInfo.Player;\r\n    float damage = damageInfo.Damage;\r\n    EDamageType type = damageInfo.DamageType;\r\n\r\n    Console.WriteLine($\"Hit on {bodyPart}: {damage} {type} damage\");\r\n}\r\n\r\n// From BotMemory\r\nbotOwner.Memory.GetHit(damageInfoStruct);\r\n```\r\n\r\n### 2.4 Damage Tracking (BotMemoryClass)\r\n\r\n```csharp\r\n// Last time hit\r\npublic float LastTimeHit { get; set; }\r\npublic Vector3 LastHitPos { get; set; }\r\n\r\n// Check if recently damaged\r\npublic bool IsDamaged => Float_1 > Time.time; // Internal timer\r\n\r\n// Check time since last hit\r\nfloat timeSinceHit = Time.time - botOwner.Memory.LastTimeHit;\r\nbool recentlyHit = timeSinceHit < 3f; // Within 3 seconds\r\n```\r\n\r\n### 2.5 Overdamage System\r\n\r\n**From BackendConfigSettingsClass.decompiled.cs**:\r\n\r\nWhen a body part is destroyed, excess damage spreads to other parts with multipliers:\r\n\r\n```csharp\r\npublic Dictionary<EBodyPart, float> OverDamageFactor = new Dictionary<EBodyPart, float>\r\n{\r\n    { EBodyPart.Head, 1f },         // 100% (instant kill)\r\n    { EBodyPart.Chest, 1f },        // 100% (instant kill)\r\n    { EBodyPart.Stomach, 1.5f },    // 150% (spreads more)\r\n    { EBodyPart.LeftArm, 0.7f },    // 70%\r\n    { EBodyPart.RightArm, 0.7f },   // 70%\r\n    { EBodyPart.LeftLeg, 1f },      // 100%\r\n    { EBodyPart.RightLeg, 1f },     // 100%\r\n    { EBodyPart.Common, 1f }\r\n};\r\n```\r\n\r\n**Implication for Downed States**: Limb shots are more likely to down (less overdamage) than torso/head shots.\r\n\r\n---\r\n\r\n## 3. Medical System\r\n\r\n### 3.1 Medical Items Discovery (SAIN Pattern)\r\n\r\n```csharp\r\n// Get available healing items\r\nprivate List<MedsItemClass> _availableHealingItems = new List<MedsItemClass>();\r\n\r\npublic void FindHealingItems(BotOwner botOwner)\r\n{\r\n    _availableHealingItems.Clear();\r\n\r\n    // Search equipment slots\r\n    botOwner.GetPlayer.InventoryController.GetAcceptableItemsNonAlloc<MedsItemClass>(\r\n        allSlots,\r\n        _availableHealingItems,\r\n        null,\r\n        null\r\n    );\r\n}\r\n\r\n// Equipment slots to search:\r\nprivate static readonly EquipmentSlot[] allSlots = {\r\n    EquipmentSlot.Pockets,\r\n    EquipmentSlot.TacticalVest,\r\n    EquipmentSlot.SecuredContainer,\r\n    EquipmentSlot.Backpack\r\n};\r\n```\r\n\r\n### 3.2 Medical Item Categories\r\n\r\n```csharp\r\npublic enum EDamageEffectType\r\n{\r\n    HeavyBleeding = 0,  // Requires surgery/hemostatic\r\n    LightBleeding = 1,  // Requires bandage\r\n    Fracture = 2,       // Requires splint\r\n    Pain = 7,           // Requires painkiller\r\n    // ... other types\r\n}\r\n\r\n// Map items to effect types\r\npublic Dictionary<EDamageEffectType, MedsItemClass> Meds { get; }\r\n```\r\n\r\n### 3.3 Using Medical Items\r\n\r\n```csharp\r\npublic bool TryUseMedItem(BotOwner botOwner)\r\n{\r\n    MedsItemClass medItem = SelectItemToUse(botOwner);\r\n    if (medItem == null) return false;\r\n\r\n    // Apply to bot (SAIN pattern)\r\n    ((GClass485)botOwner.Medecine.FirstAid).CurUsingMeds = medItem;\r\n    ((GClass485)botOwner.Medecine.FirstAid).Nullable_0 = EBodyPart.Chest; // Target body part\r\n    botOwner.Medecine.FirstAid.method_3(null, null);\r\n\r\n    return true;\r\n}\r\n\r\nprivate MedsItemClass SelectItemToUse(BotOwner botOwner)\r\n{\r\n    Player player = botOwner.GetPlayer;\r\n\r\n    // Priority 1: Heavy bleeding (life-threatening)\r\n    if (player.HealthController.FindExistingEffect<GInterface340>(EBodyPart.Common) != null\r\n        && Meds.TryGetValue(EDamageEffectType.HeavyBleeding, out var item))\r\n    {\r\n        return item;\r\n    }\r\n\r\n    // Priority 2: Light bleeding\r\n    if (player.HealthController.FindExistingEffect<GInterface339>(EBodyPart.Common) != null\r\n        && Meds.TryGetValue(EDamageEffectType.LightBleeding, out item))\r\n    {\r\n        return item;\r\n    }\r\n\r\n    // Priority 3: Pain (affects aim)\r\n    if (player.HealthController.FindExistingEffect<GInterface357>(EBodyPart.Common) != null\r\n        && Meds.TryGetValue(EDamageEffectType.Pain, out item))\r\n    {\r\n        return item;\r\n    }\r\n\r\n    return null;\r\n}\r\n```\r\n\r\n### 3.4 Surgery System\r\n\r\n```csharp\r\npublic class BotSurgery\r\n{\r\n    public bool SurgeryStarted { get; set; }\r\n    public float SurgeryStartTime { get; private set; }\r\n    public bool AreaClearForSurgery { get; private set; }\r\n\r\n    public bool CheckCanStartUsingKit(BotOwner botOwner)\r\n    {\r\n        BotMedecine medecine = botOwner.Medecine;\r\n\r\n        // Check if bleeding (requires surgery)\r\n        if (medecine.FirstAid.IsBleeding == false)\r\n        {\r\n            // Check if surgery kit available\r\n            GClass489 surgicalKit = medecine.SurgicalKit;\r\n            return surgicalKit != null && surgicalKit.ShallStartUse();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public void ApplySurgery(BotOwner botOwner, Action onComplete)\r\n    {\r\n        GClass489 surgicalKit = botOwner.Medecine.SurgicalKit;\r\n\r\n        if (!surgicalKit.Using && surgicalKit.ShallStartUse())\r\n        {\r\n            SurgeryStarted = true;\r\n            SurgeryStartTime = Time.time;\r\n            surgicalKit.ApplyToCurrentPart(onComplete);\r\n        }\r\n    }\r\n}\r\n\r\n// Surgery-capable body parts\r\nprivate static readonly EBodyPart[] SurgeryParts = {\r\n    EBodyPart.Head,\r\n    EBodyPart.Chest,\r\n    EBodyPart.Stomach,\r\n    EBodyPart.LeftArm,\r\n    EBodyPart.RightArm\r\n};\r\n```\r\n\r\n### 3.5 FirstAid System Access\r\n\r\n```csharp\r\n// Access first aid controller\r\nBotFirstAidClass firstAid = botOwner.Medecine.FirstAid;\r\n\r\n// Check bleeding status\r\nbool isBleeding = firstAid.IsBleeding;\r\n\r\n// Cancel current healing\r\nbotOwner.Medecine.FirstAid.method_3(null, null);\r\n\r\n// Event hooks\r\nbotOwner.Medecine.FirstAid.OnEndApply += OnHealingComplete;\r\n\r\nvoid OnHealingComplete()\r\n{\r\n    // Treatment finished\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. Body Part Health Access\r\n\r\n### 4.1 EBodyPart Enum\r\n\r\n```csharp\r\npublic enum EBodyPart\r\n{\r\n    Head = 0,\r\n    Chest = 1,      // Thorax\r\n    Stomach = 2,\r\n    LeftArm = 3,\r\n    RightArm = 4,\r\n    LeftLeg = 5,\r\n    RightLeg = 6,\r\n    Common = 7      // Overall health pool\r\n}\r\n```\r\n\r\n### 4.2 Querying All Body Parts\r\n\r\n```csharp\r\npublic Dictionary<EBodyPart, float> GetAllBodyPartHealth(IHealthController health)\r\n{\r\n    Dictionary<EBodyPart, float> healthMap = new Dictionary<EBodyPart, float>();\r\n\r\n    foreach (EBodyPart part in Enum.GetValues(typeof(EBodyPart)))\r\n    {\r\n        if (part == EBodyPart.Common) continue;\r\n\r\n        ValueStruct partHealth = health.GetBodyPartHealth(part, false);\r\n        healthMap[part] = partHealth.Normalized; // Store as percentage\r\n    }\r\n\r\n    return healthMap;\r\n}\r\n\r\n// Usage\r\nvar healthStatus = GetAllBodyPartHealth(player.HealthController);\r\nConsole.WriteLine($\"Head: {healthStatus[EBodyPart.Head]:P0}\");    // \"Head: 85%\"\r\nConsole.WriteLine($\"Chest: {healthStatus[EBodyPart.Chest]:P0}\");  // \"Chest: 100%\"\r\n```\r\n\r\n### 4.3 Body Part Injury Severity (SAIN Pattern)\r\n\r\n```csharp\r\npublic enum EInjurySeverity\r\n{\r\n    None,           // > 75% health\r\n    Injury,         // 40-75% health\r\n    HeavyInjury,    // 1-40% health\r\n    Destroyed       // <= 0% health (blacked out)\r\n}\r\n\r\npublic class BodyPartStatus\r\n{\r\n    private readonly EBodyPart _bodyPart;\r\n    private IHealthController _healthController;\r\n\r\n    public EInjurySeverity InjurySeverity\r\n    {\r\n        get\r\n        {\r\n            float normalized = PartHealthNormalized;\r\n            if (normalized > 0.75f) return EInjurySeverity.None;\r\n            if (normalized > 0.4f) return EInjurySeverity.Injury;\r\n            if (normalized > 0.01f) return EInjurySeverity.HeavyInjury;\r\n            return EInjurySeverity.Destroyed;\r\n        }\r\n    }\r\n\r\n    public float PartHealth =>\r\n        ((GInterface381)_healthController).GetBodyPartHealth(_bodyPart, false).Current;\r\n\r\n    public float PartHealthNormalized\r\n    {\r\n        get\r\n        {\r\n            ValueStruct health = ((GInterface381)_healthController).GetBodyPartHealth(_bodyPart, false);\r\n            return health.Normalized;\r\n        }\r\n    }\r\n\r\n    public bool PartDestroyed => _healthController.IsBodyPartDestroyed(_bodyPart);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 5. Status Effects\r\n\r\n### 5.1 Effect Detection\r\n\r\n```csharp\r\n// Generic effect detection\r\nIEffect effect = player.HealthController.FindExistingEffect<TEffectType>(EBodyPart.Common);\r\n\r\n// Specific effect checks:\r\n\r\n// Heavy bleeding (requires surgery/hemostatic)\r\nGInterface340 heavyBleeding = player.HealthController.FindExistingEffect<GInterface340>(EBodyPart.Common);\r\nbool hasHeavyBleeding = heavyBleeding != null;\r\n\r\n// Light bleeding (requires bandage)\r\nGInterface339 lightBleeding = player.HealthController.FindExistingEffect<GInterface339>(EBodyPart.Common);\r\nbool hasLightBleeding = lightBleeding != null;\r\n\r\n// Pain (requires painkiller)\r\nGInterface357 pain = player.HealthController.FindExistingEffect<GInterface357>(EBodyPart.Common);\r\nbool hasPain = pain != null;\r\n\r\n// Fracture (broken limb - specific to body part)\r\nGInterface342 fracture = player.HealthController.FindExistingEffect<GInterface342>(bodyPart);\r\nbool hasFracture = fracture != null;\r\n```\r\n\r\n### 5.2 Effect Started Event\r\n\r\n```csharp\r\n// Subscribe to health effect events\r\nplayer.HealthController.EffectStartedEvent += OnHealthEffectStarted;\r\n\r\nvoid OnHealthEffectStarted(IEffect effect)\r\n{\r\n    // Check for fracture\r\n    if (effect is GInterface342)\r\n    {\r\n        EBodyPart bodyPart = effect.BodyPart;\r\n\r\n        switch (bodyPart)\r\n        {\r\n            case EBodyPart.LeftLeg:\r\n            case EBodyPart.RightLeg:\r\n                // Leg broken\r\n                botOwner.BotTalk.TrySay(EPhraseTrigger.LegBroken);\r\n                break;\r\n\r\n            case EBodyPart.LeftArm:\r\n            case EBodyPart.RightArm:\r\n                // Arm broken\r\n                botOwner.BotTalk.TrySay(EPhraseTrigger.HandBroken);\r\n                break;\r\n        }\r\n    }\r\n\r\n    // Check for bleeding\r\n    if (effect is GInterface340) // Heavy bleeding\r\n    {\r\n        OnStartBleedingHeavy();\r\n    }\r\n    else if (effect is GInterface339) // Light bleeding\r\n    {\r\n        OnStartBleeding();\r\n    }\r\n}\r\n```\r\n\r\n### 5.3 Pain Killer Status\r\n\r\n```csharp\r\n// Check if on painkillers\r\nMovementContext movementContext = player.MovementContext;\r\nbool onPainKillers = movementContext != null &&\r\n                     movementContext.PhysicalConditionIs(EPhysicalCondition.OnPainKillers);\r\n```\r\n\r\n---\r\n\r\n## 6. Critical State Detection\r\n\r\n### 6.1 Overall Health Check\r\n\r\n```csharp\r\n// Check if player/bot is critically wounded\r\npublic bool IsCriticallyWounded(Player player)\r\n{\r\n    ValueStruct commonHealth = player.HealthController.GetBodyPartHealth(EBodyPart.Common, false);\r\n    return commonHealth.Normalized < 0.2f; // < 20% total health\r\n}\r\n\r\n// From BotMemoryClass pattern\r\nValueStruct bodyPartHealth = botOwner.GetPlayer.HealthController.GetBodyPartHealth(EBodyPart.Common);\r\nif (bodyPartHealth.Current / bodyPartHealth.Maximum < 0.2f)\r\n{\r\n    botOwner.BotTalk.TrySay(EPhraseTrigger.HurtNearDeath);\r\n}\r\n```\r\n\r\n### 6.2 Body Part Critical State\r\n\r\n```csharp\r\n// Check if any critical body part is below 30%\r\npublic bool HasCriticalInjury(IHealthController healthController)\r\n{\r\n    EBodyPart[] criticalParts = { EBodyPart.Head, EBodyPart.Chest, EBodyPart.Stomach };\r\n\r\n    foreach (var part in criticalParts)\r\n    {\r\n        ValueStruct health = healthController.GetBodyPartHealth(part, false);\r\n        if (health.Normalized < 0.3f) // < 30%\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// Check specific vital part\r\npublic bool IsVitalPartCritical(IHealthController health, EBodyPart part)\r\n{\r\n    ValueStruct partHealth = health.GetBodyPartHealth(part, false);\r\n    return partHealth.Normalized < 0.3f;\r\n}\r\n```\r\n\r\n### 6.3 Bleeding Out Detection\r\n\r\n```csharp\r\n// Check if bot is bleeding and needs immediate treatment\r\npublic bool IsBleedingOut(BotOwner botOwner)\r\n{\r\n    BotFirstAidClass firstAid = botOwner.Medecine?.FirstAid;\r\n    if (firstAid == null) return false;\r\n\r\n    // Check bleeding status\r\n    bool isBleeding = firstAid.IsBleeding;\r\n\r\n    // Check if health is critical\r\n    ValueStruct health = botOwner.HealthController.GetBodyPartHealth(EBodyPart.Common, false);\r\n    bool criticalHealth = health.Normalized < 0.3f;\r\n\r\n    return isBleeding && criticalHealth;\r\n}\r\n\r\n// More comprehensive check\r\npublic bool RequiresImmediateTreatment(Player player)\r\n{\r\n    // Heavy bleeding = immediate\r\n    if (player.HealthController.FindExistingEffect<GInterface340>(EBodyPart.Common) != null)\r\n        return true;\r\n\r\n    // Critical health + any bleeding = immediate\r\n    ValueStruct health = player.HealthController.GetBodyPartHealth(EBodyPart.Common, false);\r\n    if (health.Normalized < 0.3f &&\r\n        player.HealthController.FindExistingEffect<GInterface339>(EBodyPart.Common) != null)\r\n        return true;\r\n\r\n    // Vital part destroyed = immediate\r\n    if (player.HealthController.IsBodyPartDestroyed(EBodyPart.Chest) ||\r\n        player.HealthController.IsBodyPartDestroyed(EBodyPart.Head))\r\n        return true;\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n### 6.4 Death Detection\r\n\r\n```csharp\r\n// Check if alive\r\nbool isAlive = player.HealthController.IsAlive;\r\nbool isDead = botOwner.IsDead;\r\n\r\n// Subscribe to death event\r\nplayer.HealthController.DiedEvent += OnDeath;\r\n\r\nvoid OnDeath(EDamageType damageType)\r\n{\r\n    Console.WriteLine($\"Player died from: {damageType}\");\r\n\r\n    // Cleanup, notify squad, etc.\r\n}\r\n\r\n// Unsubscribe on cleanup\r\nplayer.HealthController.DiedEvent -= OnDeath;\r\n```\r\n\r\n---\r\n\r\n## 7. Implementation Examples\r\n\r\n### 7.1 Advanced Medic AI (Phase 12B)\r\n\r\n```csharp\r\npublic class MedicAIHealthMonitor : MonoBehaviour\r\n{\r\n    private BotOwner medicBot;\r\n    private List<Player> squadMembers;\r\n\r\n    public void Update()\r\n    {\r\n        // Find highest priority patient\r\n        Player patient = FindHighestPriorityPatient();\r\n\r\n        if (patient != null)\r\n        {\r\n            // Check if safe to treat\r\n            if (IsSafeToTreat())\r\n            {\r\n                MoveAndTreat(patient);\r\n            }\r\n            else\r\n            {\r\n                // Suppress enemies first, coordinate cover\r\n                CoordinateCoveringFire();\r\n            }\r\n        }\r\n    }\r\n\r\n    private Player FindHighestPriorityPatient()\r\n    {\r\n        Player highestPriority = null;\r\n        float highestScore = 0f;\r\n\r\n        foreach (var member in squadMembers)\r\n        {\r\n            if (!member.HealthController.IsAlive) continue;\r\n\r\n            float score = CalculateTreatmentPriority(member);\r\n\r\n            if (score > highestScore)\r\n            {\r\n                highestScore = score;\r\n                highestPriority = member;\r\n            }\r\n        }\r\n\r\n        return highestPriority;\r\n    }\r\n\r\n    private float CalculateTreatmentPriority(Player patient)\r\n    {\r\n        float priority = 0f;\r\n        IHealthController health = patient.HealthController;\r\n\r\n        // Critical health = highest priority\r\n        ValueStruct commonHealth = health.GetBodyPartHealth(EBodyPart.Common, false);\r\n        if (commonHealth.Normalized < 0.2f)\r\n            priority += 100f; // Near death\r\n        else if (commonHealth.Normalized < 0.5f)\r\n            priority += 50f;  // Wounded\r\n\r\n        // Heavy bleeding = very high priority (life-threatening)\r\n        if (health.FindExistingEffect<GInterface340>(EBodyPart.Common) != null)\r\n            priority += 80f;\r\n\r\n        // Light bleeding = medium priority\r\n        if (health.FindExistingEffect<GInterface339>(EBodyPart.Common) != null)\r\n            priority += 30f;\r\n\r\n        // Destroyed vital parts = high priority\r\n        if (health.IsBodyPartDestroyed(EBodyPart.Chest))\r\n            priority += 70f;\r\n        if (health.IsBodyPartDestroyed(EBodyPart.Head))\r\n            priority += 90f;\r\n\r\n        // Distance factor (closer = higher priority)\r\n        float distance = Vector3.Distance(medicBot.Position, patient.Position);\r\n        priority -= distance * 0.1f;\r\n\r\n        // If it's the player, add bonus priority\r\n        if (patient == GetPlayerCharacter())\r\n            priority += 25f;\r\n\r\n        return priority;\r\n    }\r\n\r\n    private bool IsSafeToTreat()\r\n    {\r\n        // Check if medic is under fire\r\n        if (medicBot.Memory.IsUnderFire)\r\n            return false;\r\n\r\n        // Check if enemies are nearby and visible\r\n        if (medicBot.Memory.GoalEnemy != null && medicBot.Memory.GoalEnemy.IsVisible)\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    private void MoveAndTreat(Player patient)\r\n    {\r\n        float distance = Vector3.Distance(medicBot.Position, patient.Position);\r\n\r\n        if (distance < 2f)\r\n        {\r\n            // In range, apply treatment\r\n            ApplyTreatment(patient);\r\n        }\r\n        else\r\n        {\r\n            // Move closer\r\n            medicBot.Mover.GoToPoint(patient.Position);\r\n\r\n            // Say \"Coming to help\"\r\n            medicBot.BotTalk.TrySay(EPhraseTrigger.OnYourWay);\r\n        }\r\n    }\r\n\r\n    private void ApplyTreatment(Player patient)\r\n    {\r\n        IHealthController health = patient.HealthController;\r\n\r\n        // Stop heavy bleeding first\r\n        if (health.FindExistingEffect<GInterface340>(EBodyPart.Common) != null)\r\n        {\r\n            // Use hemostatic/surgery\r\n            medicBot.BotTalk.TrySay(EPhraseTrigger.Heal); // \"Healing you\"\r\n            ApplyHemostaticTreatment(patient);\r\n            return;\r\n        }\r\n\r\n        // Stop light bleeding\r\n        if (health.FindExistingEffect<GInterface339>(EBodyPart.Common) != null)\r\n        {\r\n            ApplyBandage(patient);\r\n            return;\r\n        }\r\n\r\n        // Restore health\r\n        if (patient.ActiveHealthController != null)\r\n        {\r\n            // Partial restoration (50% of max)\r\n            patient.ActiveHealthController.RestoreBodyPart(EBodyPart.Chest, 0.5f);\r\n            patient.ActiveHealthController.RestoreBodyPart(EBodyPart.Stomach, 0.5f);\r\n\r\n            medicBot.BotTalk.TrySay(EPhraseTrigger.Heal);\r\n        }\r\n    }\r\n\r\n    private void ApplyHemostaticTreatment(Player patient)\r\n    {\r\n        // Apply hemostatic item to stop heavy bleeding\r\n        // Would use medical item system\r\n        Console.WriteLine($\"Applying hemostatic to {patient.Profile.Nickname}\");\r\n    }\r\n\r\n    private void ApplyBandage(Player patient)\r\n    {\r\n        // Apply bandage to stop light bleeding\r\n        Console.WriteLine($\"Applying bandage to {patient.Profile.Nickname}\");\r\n    }\r\n\r\n    private void CoordinateCoveringFire()\r\n    {\r\n        // Order other squad members to suppress\r\n        // While medic prepares to treat patient\r\n    }\r\n}\r\n```\r\n\r\n### 7.2 Casualty Evacuation System (Innovation #5)\r\n\r\n```csharp\r\npublic class CasualtyEvacuationSystem\r\n{\r\n    private BotOwner rescuerBot;\r\n    private Player woundedPlayer;\r\n    private Vector3 coverPosition;\r\n\r\n    public bool ShouldEvacuate(Player wounded)\r\n    {\r\n        bool isCritical = IsCriticallyWounded(wounded);\r\n        bool isUnderFire = IsPlayerUnderFire(wounded);\r\n\r\n        return isCritical && isUnderFire;\r\n    }\r\n\r\n    private bool IsCriticallyWounded(Player wounded)\r\n    {\r\n        IHealthController health = wounded.HealthController;\r\n\r\n        // Check overall health < 30%\r\n        ValueStruct commonHealth = health.GetBodyPartHealth(EBodyPart.Common, false);\r\n        if (commonHealth.Normalized < 0.3f)\r\n            return true;\r\n\r\n        // Check vital parts < 40%\r\n        ValueStruct chest = health.GetBodyPartHealth(EBodyPart.Chest, false);\r\n        ValueStruct head = health.GetBodyPartHealth(EBodyPart.Head, false);\r\n\r\n        if (chest.Normalized < 0.4f || head.Normalized < 0.5f)\r\n            return true;\r\n\r\n        // Check heavy bleeding\r\n        if (health.FindExistingEffect<GInterface340>(EBodyPart.Common) != null)\r\n            return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    private bool IsPlayerUnderFire(Player wounded)\r\n    {\r\n        BotOwner bot = wounded.AIData?.BotOwner;\r\n        if (bot != null)\r\n        {\r\n            return bot.Memory.IsUnderFire ||\r\n                   Time.time - bot.Memory.LastTimeHit < 3f;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public void StartEvacuation(BotOwner rescuer, Player wounded, Vector3 cover)\r\n    {\r\n        rescuerBot = rescuer;\r\n        woundedPlayer = wounded;\r\n        coverPosition = cover;\r\n\r\n        // Phase 1: Move to wounded\r\n        rescuerBot.Mover.GoToPoint(wounded.Position);\r\n        rescuerBot.BotTalk.TrySay(EPhraseTrigger.OnYourWay); // \"On my way\"\r\n\r\n        // Phase 2: Drag to cover (would require drag mechanics)\r\n        // DragWoundedToCover();\r\n\r\n        // Phase 3: Apply emergency treatment\r\n        // ApplyEmergencyTreatment();\r\n    }\r\n\r\n    private void ApplyEmergencyTreatment()\r\n    {\r\n        IHealthController health = woundedPlayer.HealthController;\r\n\r\n        // Stop bleeding first\r\n        if (health.FindExistingEffect<GInterface340>(EBodyPart.Common) != null)\r\n        {\r\n            // Apply hemostatic\r\n            rescuerBot.BotTalk.TrySay(EPhraseTrigger.Heal);\r\n        }\r\n\r\n        // Restore critical body parts to safe level\r\n        ActiveHealthController activeHealth = woundedPlayer.ActiveHealthController;\r\n        if (activeHealth != null)\r\n        {\r\n            // 30% restoration (stabilize, not full heal)\r\n            activeHealth.RestoreBodyPart(EBodyPart.Chest, 0.3f);\r\n            activeHealth.RestoreBodyPart(EBodyPart.Head, 0.3f);\r\n            activeHealth.RestoreBodyPart(EBodyPart.Stomach, 0.3f);\r\n        }\r\n\r\n        rescuerBot.BotTalk.TrySay(EPhraseTrigger.Possible); // \"Done\"\r\n    }\r\n}\r\n```\r\n\r\n### 7.3 Downed Enemy State System (Phase 12C)\r\n\r\n```csharp\r\npublic class DownedEnemySystem : MonoBehaviour\r\n{\r\n    private Dictionary<Player, DownedState> downedEnemies = new Dictionary<Player, DownedState>();\r\n\r\n    private class DownedState\r\n    {\r\n        public float TimeDown;\r\n        public float BleedOutTime;\r\n        public bool IsCrawling;\r\n        public Vector3 DownedPosition;\r\n        public float HealthAtDown;\r\n    }\r\n\r\n    public void OnEnemyDamaged(Player enemy, DamageInfoStruct damageInfo)\r\n    {\r\n        // Check if should enter downed state instead of dying\r\n        if (ShouldEnterDownedState(enemy, damageInfo))\r\n        {\r\n            EnterDownedState(enemy);\r\n        }\r\n    }\r\n\r\n    private bool ShouldEnterDownedState(Player enemy, DamageInfoStruct damageInfo)\r\n    {\r\n        // Don't down on headshot or chest explosion\r\n        if (damageInfo.DamageType == EDamageType.Bullet &&\r\n            damageInfo.HitPoint.y > enemy.Position.y + 1.5f) // Rough head height\r\n        {\r\n            return false; // Headshot = instant kill\r\n        }\r\n\r\n        if (damageInfo.DamageType == EDamageType.Explosion)\r\n        {\r\n            return false; // Explosion = instant kill\r\n        }\r\n\r\n        IHealthController health = enemy.HealthController;\r\n        ValueStruct commonHealth = health.GetBodyPartHealth(EBodyPart.Common, false);\r\n\r\n        // Downed range: 1-20% health\r\n        if (commonHealth.Normalized > 0f && commonHealth.Normalized < 0.2f)\r\n        {\r\n            // 30% chance to down instead of kill\r\n            return Random.Range(0f, 1f) < 0.3f;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private void EnterDownedState(Player enemy)\r\n    {\r\n        IHealthController health = enemy.HealthController;\r\n        ValueStruct commonHealth = health.GetBodyPartHealth(EBodyPart.Common, false);\r\n\r\n        var state = new DownedState\r\n        {\r\n            TimeDown = Time.time,\r\n            BleedOutTime = Time.time + 60f, // 60 seconds to bleed out\r\n            IsCrawling = false,\r\n            DownedPosition = enemy.Position,\r\n            HealthAtDown = commonHealth.Current\r\n        };\r\n\r\n        downedEnemies[enemy] = state;\r\n\r\n        // Set downed pose and behavior\r\n        SetDownedPose(enemy);\r\n        DisableCombatAI(enemy);\r\n\r\n        // Voice line\r\n        BotOwner bot = enemy.AIData?.BotOwner;\r\n        if (bot != null)\r\n        {\r\n            bot.BotTalk.TrySay(EPhraseTrigger.HurtNearDeath);\r\n        }\r\n    }\r\n\r\n    private void SetDownedPose(Player player)\r\n    {\r\n        BotOwner bot = player.AIData?.BotOwner;\r\n        if (bot != null)\r\n        {\r\n            // Force prone position\r\n            bot.Mover.SetTargetPose(0f); // Prone\r\n        }\r\n    }\r\n\r\n    private void DisableCombatAI(Player player)\r\n    {\r\n        BotOwner bot = player.AIData?.BotOwner;\r\n        if (bot != null)\r\n        {\r\n            // Drop weapon\r\n            bot.WeaponManager.StopShooting();\r\n\r\n            // Clear enemies\r\n            bot.Memory.GoalEnemy = null;\r\n\r\n            // Disable aggression\r\n            bot.Memory.IsPeace = true;\r\n        }\r\n    }\r\n\r\n    private void Update()\r\n    {\r\n        List<Player> toRemove = new List<Player>();\r\n\r\n        foreach (var kvp in downedEnemies)\r\n        {\r\n            Player player = kvp.Key;\r\n            DownedState state = kvp.Value;\r\n\r\n            // Check bleed out time\r\n            if (Time.time >= state.BleedOutTime)\r\n            {\r\n                KillDownedPlayer(player);\r\n                toRemove.Add(player);\r\n                continue;\r\n            }\r\n\r\n            // Apply bleeding damage (slow health drain)\r\n            ApplyBleedOutDamage(player, state);\r\n\r\n            // Allow crawling toward cover\r\n            if (!state.IsCrawling && Time.time - state.TimeDown > 2f)\r\n            {\r\n                state.IsCrawling = true;\r\n                EnableCrawling(player);\r\n            }\r\n\r\n            // Check for rescue by allies\r\n            if (CheckForEnemyRescue(player))\r\n            {\r\n                RescueDownedEnemy(player);\r\n                toRemove.Add(player);\r\n            }\r\n        }\r\n\r\n        foreach (var player in toRemove)\r\n        {\r\n            downedEnemies.Remove(player);\r\n        }\r\n    }\r\n\r\n    private void ApplyBleedOutDamage(Player player, DownedState state)\r\n    {\r\n        // Slow health drain (1 HP/sec)\r\n        float damagePerSecond = 1f;\r\n        float damageThisFrame = damagePerSecond * Time.deltaTime;\r\n\r\n        // Would need damage application API\r\n        // player.HealthController.ApplyDamage(damageThisFrame, EBodyPart.Common, ...);\r\n    }\r\n\r\n    private void EnableCrawling(Player player)\r\n    {\r\n        BotOwner bot = player.AIData?.BotOwner;\r\n        if (bot != null)\r\n        {\r\n            // Find nearest cover\r\n            CustomNavigationPoint cover = FindNearestCover(player.Position);\r\n            if (cover != null)\r\n            {\r\n                // Crawl toward cover slowly\r\n                bot.Mover.SetTargetMoveSpeed(0.3f); // 30% speed\r\n                bot.Mover.GoToPoint(cover.Position);\r\n            }\r\n        }\r\n    }\r\n\r\n    private CustomNavigationPoint FindNearestCover(Vector3 position)\r\n    {\r\n        // Use cover finding API from Bot AI docs\r\n        return null; // Placeholder\r\n    }\r\n\r\n    private bool CheckForEnemyRescue(Player downed)\r\n    {\r\n        // Check if enemy squad members are nearby\r\n        // and attempting rescue\r\n        return false;\r\n    }\r\n\r\n    private void RescueDownedEnemy(Player enemy)\r\n    {\r\n        // Enemy was rescued by allies\r\n        ActiveHealthController health = enemy.ActiveHealthController;\r\n        if (health != null)\r\n        {\r\n            health.RestoreBodyPart(EBodyPart.Common, 0.3f);\r\n        }\r\n\r\n        // Re-enable AI\r\n        SetDownedPose(enemy); // Stand up\r\n        EnableCombatAI(enemy);\r\n    }\r\n\r\n    private void EnableCombatAI(Player player)\r\n    {\r\n        BotOwner bot = player.AIData?.BotOwner;\r\n        if (bot != null)\r\n        {\r\n            bot.Mover.SetTargetPose(1f); // Standing\r\n            bot.Memory.IsPeace = false;\r\n        }\r\n    }\r\n\r\n    private void KillDownedPlayer(Player player)\r\n    {\r\n        // Player has bled out\r\n        Console.WriteLine($\"{player.Profile.Nickname} has bled out\");\r\n\r\n        // Would trigger death\r\n        // player.HealthController.Kill(EDamageType.Exhaustion);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 8. Integration with BigBrain Layers\r\n\r\n### 8.1 Health-Aware Combat Layer\r\n\r\n```csharp\r\npublic class HealthAwareFollowerLayer : BaseLogicLayerSimpleAbstractClass\r\n{\r\n    public override AICoreActionResultStruct<BotLogicDecision, GClass26> GetDecision()\r\n    {\r\n        // Check self health\r\n        ValueStruct myHealth = BotOwner_0.HealthController.GetBodyPartHealth(EBodyPart.Common, false);\r\n\r\n        // If critically wounded, prioritize survival\r\n        if (myHealth.Normalized < 0.3f)\r\n        {\r\n            // Retreat to cover and heal\r\n            if (!BotOwner_0.Memory.IsInCover)\r\n            {\r\n                return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                    BotLogicDecision.runToCover,\r\n                    \"Critically wounded - seeking cover\"\r\n                );\r\n            }\r\n\r\n            // In cover, attempt healing\r\n            if (BotOwner_0.Medecine.FirstAid.IsBleeding || myHealth.Normalized < 0.5f)\r\n            {\r\n                return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                    BotLogicDecision.firstAid,\r\n                    \"Healing wounds\"\r\n                );\r\n            }\r\n        }\r\n\r\n        // Normal combat logic\r\n        if (BotOwner_0.Memory.GoalEnemy != null)\r\n        {\r\n            var combatDecision = InFightLogic();\r\n            if (combatDecision.HasValue)\r\n                return combatDecision.Value;\r\n        }\r\n\r\n        // Follow player if healthy\r\n        return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n            BotLogicDecision.followPlayer,\r\n            \"Following boss\"\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Summary: Key APIs Quick Reference\r\n\r\n### Checking Health\r\n```csharp\r\nValueStruct health = healthController.GetBodyPartHealth(EBodyPart.Chest, false);\r\nfloat percent = health.Normalized; // 0.0 to 1.0\r\n```\r\n\r\n### Detecting Effects\r\n```csharp\r\nbool heavyBleeding = healthController.FindExistingEffect<GInterface340>(EBodyPart.Common) != null;\r\nbool lightBleeding = healthController.FindExistingEffect<GInterface339>(EBodyPart.Common) != null;\r\nbool pain = healthController.FindExistingEffect<GInterface357>(EBodyPart.Common) != null;\r\n```\r\n\r\n### Healing\r\n```csharp\r\nactiveHealthController.RestoreFullHealth();\r\nactiveHealthController.RestoreBodyPart(EBodyPart.Chest, 0.5f); // 50% restore\r\n```\r\n\r\n### Medical Items\r\n```csharp\r\nplayer.InventoryController.GetAcceptableItemsNonAlloc<MedsItemClass>(slots, list, null, null);\r\nbotOwner.Medecine.FirstAid.IsBleeding;\r\n```\r\n\r\n### Events\r\n```csharp\r\nplayer.BeingHitAction += OnHit;\r\nhealthController.EffectStartedEvent += OnEffectStarted;\r\nhealthController.DiedEvent += OnDeath;\r\n```\r\n\r\n---\r\n\r\n**With this documentation, you can implement: Advanced Medic AI, Casualty Evacuation, Downed Enemy States, and Health-Aware Squad Tactics!**\r\n"},"06-Grenade-Explosive-System":{"title":"Tarkov Grenade & Explosive System - API Documentation\r","category":"Core Systems","content":"# Tarkov Grenade & Explosive System - API Documentation\r\n\r\n**Priority**: HIGH - Enables Innovation #2 (Door Breaching), Phase 16\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\nBased on analysis of SAIN grenade implementation and Tarkov grenade APIs.\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nTarkov's grenade system provides comprehensive APIs for throwing grenades, detecting incoming grenades, calculating trajectories, and coordinating bot avoidance behaviors. This system can be leveraged for tactical operations including door breaching, suppressive grenades, and coordinated squad assaults.\r\n\r\n---\r\n\r\n## 1. Core Components\r\n\r\n### BotGrenadeManager\r\n**Location**: BotComponent.Grenade\r\n\r\n```csharp\r\npublic class BotGrenadeManager : BotComponentClassBase\r\n{\r\n    public ThrowWeapItemClass MyGrenade { get; set; }\r\n    public Vector3? GrenadeDangerPoint => GrenadeReactionClass.GrenadeDangerPoint;\r\n    public GrenadeThrowDecider GrenadeThrowDecider { get; }\r\n    public GrenadeReactionClass GrenadeReactionClass { get; }\r\n}\r\n```\r\n\r\n### BotOwner Grenade Controller\r\n\r\n**Access**: `BotOwner.WeaponManager.Grenades` (BotGrenadeController)\r\n\r\n**Key Properties**:\r\n```csharp\r\nbool HaveGrenade;           // Bot has grenades in inventory\r\nbool ThrowindNow;           // Currently throwing\r\nbool ReadyToThrow;          // Throw data set and ready\r\nfloat MaxPower;             // Maximum throw power\r\nAIGreanageThrowData AIGreanageThrowData;  // Current throw trajectory\r\n```\r\n\r\n**Key Methods**:\r\n```csharp\r\nvoid DoThrow();                               // Execute throw\r\nvoid SetThrowData(AIGreanageThrowData data);  // Set trajectory\r\n```\r\n\r\n---\r\n\r\n## 2. Grenade Throwing System\r\n\r\n### Configuration Parameters\r\n\r\n```csharp\r\n// Grenade Settings (loaded from preset)\r\nprivate bool _canThrowGrenades = true;\r\nprivate bool _canThrowAtVisEnemies = false;        // Can throw at visible enemies\r\nprivate bool _canThrowWhileSprint = false;\r\nprivate float _timeSinceSeenBeforeThrow = 3f;      // Delay after last sight\r\nprivate float _minEnemyDistToThrow = 8f;           // Min distance to target (meters)\r\nprivate float _maxEnemyDistToCheckThrow = 75f;     // Max throw distance\r\nprivate float _minFriendlyDistToThrow = 8f;        // Min friendly distance (safety)\r\nprivate float _throwGrenadeFreq = 5f;              // Min time between throws\r\nprivate float _throwGrenadeFreqMax = 10f;          // Max time between throws\r\n\r\n// Dispersion (accuracy)\r\nprivate const float MIN_THROW_DISPERSION = 0.5f;\r\nprivate const float MAX_THROW_DISPERSION = 5f;\r\n```\r\n\r\n### Decision Flow\r\n\r\n**Main Decision Method**:\r\n```csharp\r\npublic bool GetDecision(Enemy enemy, out string reason)\r\n{\r\n    // 1. Check if bot vs bot grenades allowed\r\n    if (enemy.IsAI && !BotBase.GlobalSettings.General.BotVsBotGrenade)\r\n        return false;\r\n\r\n    // 2. Check if already throwing\r\n    if (BotOwner.WeaponManager.Grenades.ThrowindNow)\r\n        return true;\r\n\r\n    // 3. Check general throw conditions\r\n    if (!checkCanThrow(out reason))\r\n        return false;\r\n\r\n    // 4. Check enemy-specific conditions\r\n    if (!canThrowAtEnemy(enemy, out reason))\r\n        return false;\r\n\r\n    // 5. Check inventory\r\n    if (!BotOwner.WeaponManager.Grenades.HaveGrenade)\r\n    {\r\n        sayNeedNades(); // \"Need grenades!\"\r\n        return false;\r\n    }\r\n\r\n    // 6. Find target and throw\r\n    if (findThrowTarget(enemy) && tryThrowGrenade())\r\n    {\r\n        _nextPosibleAttempt = Time.time + Random.Range(_throwGrenadeFreq, _throwGrenadeFreqMax);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n### Throw Conditions\r\n\r\n**General Conditions**:\r\n```csharp\r\nprivate bool checkCanThrow(out string reason)\r\n{\r\n    // Grenades globally disabled\r\n    if (!_grenadesEnabled) return false;\r\n\r\n    // Changing weapon\r\n    if (weaponManager.Selector.IsChanging) return false;\r\n\r\n    // Reloading\r\n    if (weaponManager.Reload.Reloading) return false;\r\n\r\n    // Cooldown not met\r\n    if (_nextPosibleAttempt > Time.time) return false;\r\n\r\n    // Running (if disabled for sprint)\r\n    if (!_canThrowWhileSprint && (Player.IsSprintEnabled || Bot.Mover.Running))\r\n        return false;\r\n\r\n    // Hands busy\r\n    if (Player.HandsController.IsInInteractionStrictCheck())\r\n        return false;\r\n\r\n    return true;\r\n}\r\n```\r\n\r\n**Enemy-Specific Conditions**:\r\n```csharp\r\nprivate bool canThrowAtEnemy(Enemy enemy, out string reason)\r\n{\r\n    // Can't throw at visible enemies (setting)\r\n    if (!_canThrowAtVisEnemies && (enemy.IsVisible || enemy.InLineOfSight))\r\n        return false;\r\n\r\n    // Too recent sighting\r\n    if (enemy.TimeSinceSeen < _timeSinceSeenBeforeThrow)\r\n        return false;\r\n\r\n    // Last known position too old\r\n    if (enemy.TimeSinceLastKnownUpdated > _maxTimeSinceUpdatedCanThrow)\r\n        return false;\r\n\r\n    // No last known position\r\n    if (enemy.KnownPlaces.LastKnownPlace == null)\r\n        return false;\r\n\r\n    // Distance checks\r\n    float distance = enemy.KnownPlaces.LastKnownPlace.DistanceToBot;\r\n    if (distance > _maxEnemyDistToCheckThrow) return false; // Too far\r\n    if (distance < _minEnemyDistToThrow) return false;      // Too close\r\n\r\n    return true;\r\n}\r\n```\r\n\r\n### Trajectory Calculation\r\n\r\n**Throw Angles** (Arc Selection):\r\n```csharp\r\n// Indoor: Lower arcs to avoid ceiling\r\nprivate static AIGreandeAng[] _indoorAngles = new AIGreandeAng[]\r\n{\r\n    AIGreandeAng.Low,\r\n    AIGreandeAng.Middle\r\n};\r\n\r\n// Outdoor: Varied arcs for obstacles\r\nprivate static AIGreandeAng[] _outdoorAngles = new AIGreandeAng[]\r\n{\r\n    AIGreandeAng.Low,\r\n    AIGreandeAng.Middle,\r\n    AIGreandeAng.High,\r\n    AIGreandeAng.VeryHigh\r\n};\r\n```\r\n\r\n**Trajectory Physics**:\r\n```csharp\r\nprivate bool canThrowAGrenade(Vector3 from, Vector3 target,\r\n    params AIGreandeAng[] possibleAngles)\r\n{\r\n    // Safety check\r\n    if (!checkFriendlyDistances(target))\r\n        return false;\r\n\r\n    // Pick random angle\r\n    AIGreandeAng angle = GClass2066.PickRandom<AIGreandeAng>(possibleAngles);\r\n\r\n    // Calculate trajectory using Tarkov's built-in physics\r\n    AIGreanageThrowData throwData = GClass577.CanThrowGrenade2(\r\n        from,                    // Start position\r\n        target,                  // Target position\r\n        _maxPower * 0.9f,       // Throw power (90% of max)\r\n        angle,                   // Throw angle\r\n        -1f,                     // Time (auto-calculate)\r\n        _minThrowDistPercent     // Min distance ratio (0.66)\r\n    );\r\n\r\n    if (!throwData.CanThrow)\r\n        return false;\r\n\r\n    // Check for immediate obstruction (1.5m)\r\n    if (Physics.Raycast(from, throwData.Direction, 1.5f,\r\n        LayerMaskClass.HighPolyWithTerrainMask))\r\n    {\r\n        return false; // Blocked\r\n    }\r\n\r\n    // Set throw data\r\n    BotOwner.WeaponManager.Grenades.SetThrowData(throwData);\r\n    return true;\r\n}\r\n```\r\n\r\n**AIGreanageThrowData Structure**:\r\n```csharp\r\npublic struct AIGreanageThrowData\r\n{\r\n    public bool CanThrow;           // Trajectory is valid\r\n    public Vector3 Direction;       // Throw direction vector\r\n    public float Power;             // Throw power\r\n    public float Time;              // Flight time (seconds)\r\n    public Vector3 TargetPosition;  // Predicted landing position\r\n\r\n    public bool IsUpToDate();       // Data still valid\r\n}\r\n```\r\n\r\n### Dispersion (Accuracy)\r\n\r\n**Dynamic by Distance**:\r\n```csharp\r\nprivate float getThrowDispersion(Vector3 target, Vector3 directionNormal, float range)\r\n{\r\n    // Close range: high accuracy\r\n    if (range <= 10f)\r\n        return MIN_THROW_DISPERSION; // 0.5m\r\n\r\n    // Long range: low accuracy\r\n    if (range >= 50f)\r\n        return MAX_THROW_DISPERSION; // 5m\r\n\r\n    // Interpolate between 10m and 50m\r\n    range = Mathf.Clamp(range, 10f, 50f);\r\n    float t = (range - 10f) / 40f;\r\n    return Mathf.Lerp(MIN_THROW_DISPERSION, MAX_THROW_DISPERSION, t);\r\n}\r\n```\r\n\r\n**Applying Randomization**:\r\n```csharp\r\nprivate Vector3 randomize(Vector3 target, Vector3 directionNormal, float dispersion)\r\n{\r\n    // Add random offset along throw direction\r\n    return target + directionNormal * Random.Range(-dispersion, dispersion);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. Grenade Detection and Tracking\r\n\r\n### Global Grenade Controller\r\n\r\n**Location**: `BotManagerComponent.Instance.GrenadeController`\r\n\r\n```csharp\r\npublic class GrenadeController : BotManagerBase\r\n{\r\n    // Active grenades being tracked\r\n    public readonly Dictionary<Throwable, List<PlayerComponent>> ActiveGrenades;\r\n\r\n    // Events\r\n    public event Action<Grenade, float> OnGrenadeCollision;\r\n    public event Action<Grenade, Vector3, string> OnGrenadeThrown;\r\n    public event Action<Grenade, Vector3> OnGrenadeDangerUpdated;\r\n}\r\n```\r\n\r\n**Subscribing to Events**:\r\n```csharp\r\nGrenadeController grenadeController = BotManagerComponent.Instance.GrenadeController;\r\ngrenadeController.OnGrenadeCollision += GrenadeCollision;\r\ngrenadeController.OnGrenadeThrown += EnemyGrenadeThrown;\r\ngrenadeController.OnGrenadeDangerUpdated += GrenadeDangerUpdated;\r\n```\r\n\r\n### Grenade Thrown Event\r\n\r\n```csharp\r\nprivate void GrenadeThrown(Grenade grenade, Vector3 position,\r\n    Vector3 force, float mass)\r\n{\r\n    Player thrower = GameWorldInfo.GetAlivePlayer(grenade.ProfileId);\r\n    if (thrower == null || !thrower.HealthController.IsAlive)\r\n        return;\r\n\r\n    // Calculate predicted landing position\r\n    Vector3 dangerPoint = Vector.DangerPoint(position, force, mass);\r\n\r\n    // Subscribe to destruction\r\n    grenade.DestroyEvent += grenadeDestroyed;\r\n\r\n    // Play audio for nearby bots\r\n    BotEventHandler.Instance?.PlaySound(\r\n        thrower,\r\n        grenade.transform.position,\r\n        20f,                    // Audible range: 20m\r\n        AISoundType.Grenade\r\n    );\r\n\r\n    // Broadcast event\r\n    OnGrenadeThrown?.Invoke(grenade, dangerPoint, grenade.ProfileId);\r\n\r\n    // Start tracking\r\n    StartCoroutine(GrenadeTracker(grenade, throwerComponent,\r\n        relevantBots, dangerPoint));\r\n}\r\n```\r\n\r\n### Danger Point Calculation\r\n\r\n**Physics-Based Prediction**:\r\n```csharp\r\npublic static Vector3 DangerPoint(Vector3 position, Vector3 force, float mass)\r\n{\r\n    // Normalize force by mass\r\n    force /= mass;\r\n\r\n    // Calculate trajectory endpoint\r\n    Vector3 endpoint = CalculateForce(position, force);\r\n\r\n    // Get midpoint for arc raycast\r\n    Vector3 midPoint = (position + endpoint) / 2f;\r\n\r\n    // Raycast arc to find actual landing\r\n    CheckThreePoints(position, midPoint, endpoint, out Vector3 hitPos);\r\n\r\n    return hitPos;\r\n}\r\n\r\nprivate static Vector3 CalculateForce(Vector3 from, Vector3 force)\r\n{\r\n    // Horizontal velocity\r\n    Vector3 horizontal = new Vector3(force.x, 0f, force.z);\r\n    Vector2 velocity = new Vector2(horizontal.magnitude, force.y);\r\n\r\n    // Projectile motion: range = 2 * vx * vy / g\r\n    float range = 2f * velocity.x * velocity.y / HelpersGClass.Gravity;\r\n\r\n    if (velocity.y < 0f)\r\n        range = -range;\r\n\r\n    return horizontal.normalized * range + from;\r\n}\r\n```\r\n\r\n### Per-Bot Grenade Tracking\r\n\r\n**GrenadeTrackerClass**:\r\n```csharp\r\npublic class GrenadeTrackerClass\r\n{\r\n    public Grenade Grenade { get; private set; }\r\n    public Vector3 DangerPoint { get; set; }\r\n    public float GrenadeDistance { get; private set; }\r\n\r\n    private bool Spotted { get; set; }          // Bot has spotted grenade\r\n    public float TimeSinceSpotted { get; }      // Time since spotted\r\n    private float TimeSpotted { get; set; }\r\n\r\n    private readonly float _reactionTime;       // Delay before reacting\r\n\r\n    public bool CanReact => Spotted && TimeSinceSpotted > _reactionTime;\r\n}\r\n```\r\n\r\n**Creating Tracker**:\r\n```csharp\r\npublic GrenadeTrackerClass(BotComponent bot, Grenade grenade,\r\n    Vector3 dangerPoint, float reactionTime)\r\n{\r\n    _bot = bot;\r\n    _reactionTime = reactionTime;\r\n    DangerPoint = dangerPoint;\r\n    Grenade = grenade;\r\n\r\n    // Auto-spot if very close (10m)\r\n    float distance = Vector3.Distance(grenade.transform.position, bot.Position);\r\n    if (distance < 10f)\r\n    {\r\n        SetSpotted();\r\n    }\r\n}\r\n```\r\n\r\n**Tracker Update**:\r\n```csharp\r\npublic void Update()\r\n{\r\n    if (BotOwner == null || BotOwner.IsDead || Grenade == null || _sentToBot)\r\n        return;\r\n\r\n    // Ready to send to BotOwner?\r\n    if (!_sentToBot && CanReact)\r\n    {\r\n        _sentToBot = true;\r\n\r\n        // Determine grenade type by collision sound\r\n        EPhraseTrigger phrase = (Grenade.GrenadeSettings.CollisionSound == 0)\r\n            ? EPhraseTrigger.OnBeingHit    // Frag grenade\r\n            : EPhraseTrigger.OnFight;       // Flash/smoke\r\n\r\n        // Announce\r\n        _bot.Talk.GroupSay(phrase, ETagStatus.Combat,\r\n            withGroupDelay: false, 100f);\r\n\r\n        // Send danger to BotOwner AI\r\n        BotOwner.BewareGrenade.AddGrenadeDanger(DangerPoint, Grenade);\r\n    }\r\n    else if (!Spotted)\r\n    {\r\n        // Update distance\r\n        GrenadeDistance = Vector3.Distance(\r\n            Grenade.transform.position,\r\n            BotOwner.Position\r\n        );\r\n\r\n        // Auto-spot if very close\r\n        if (GrenadeDistance < 3f)\r\n        {\r\n            SetSpotted();\r\n        }\r\n        // Check visibility\r\n        else if (_nextCheckRaycastTime < Time.time)\r\n        {\r\n            _nextCheckRaycastTime = Time.time + 0.05f; // 50ms interval\r\n            if (CheckVisibility())\r\n            {\r\n                SetSpotted();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Visibility Check**:\r\n```csharp\r\nprivate bool CheckVisibility()\r\n{\r\n    Vector3 weaponRoot = _bot.Transform.WeaponRoot;\r\n    Vector3 lookDirection = _bot.LookDirection;\r\n\r\n    // Grenade position (slightly above ground)\r\n    Vector3 grenadePos = Grenade.transform.position + Vector3.up * 0.05f;\r\n    Vector3 direction = grenadePos - weaponRoot;\r\n\r\n    // Check if in field of view (dot product > 0.25)\r\n    if (Vector3.Dot(lookDirection, direction.normalized) < 0.25f)\r\n        return false;\r\n\r\n    // Raycast to check line of sight\r\n    return !Physics.Raycast(weaponRoot, direction, 1f,\r\n        LayerMaskClass.HighPolyWithTerrainMaskAI);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. Flashbang Mechanics\r\n\r\n### Flash State Detection\r\n\r\n**Built-in Tarkov Property**:\r\n```csharp\r\n// Check if bot is currently flashed\r\nif (BotOwner.FlashGrenade.IsFlashed)\r\n{\r\n    // Bot is blinded by flashbang\r\n    // Vision severely limited\r\n    // Can't toggle NVG or tactical lights\r\n}\r\n```\r\n\r\n### Flash Effects on Bots\r\n\r\n**Vision Impairment**:\r\n```csharp\r\nprivate void UpdateVisionDistance()\r\n{\r\n    // Update frequency changes when flashed\r\n    _nextUpdateVisibleDist = Time.time +\r\n        (BotOwner.FlashGrenade.IsFlashed\r\n            ? VISIONDISTANCE_UPDATE_FREQ_FLASHED   // 0.5s (update often)\r\n            : VISIONDISTANCE_UPDATE_FREQ);          // 5s (normal)\r\n\r\n    // Vision distance drastically reduced when flashed\r\n    // Exact reduction handled internally by Tarkov\r\n}\r\n```\r\n\r\n**Equipment Restrictions**:\r\n```csharp\r\n// Can't toggle night vision while flashed\r\nif (BotOwner.FlashGrenade.IsFlashed)\r\n{\r\n    // Block NVG toggle\r\n    // Block tactical light toggle\r\n}\r\n```\r\n\r\n### Grenade Type Detection\r\n\r\n```csharp\r\n// Determine grenade type by collision sound setting\r\nEPhraseTrigger phrase =\r\n    (Grenade.GrenadeSettings.CollisionSound == 0)\r\n        ? EPhraseTrigger.OnBeingHit    // Frag: \"Grenade!\"\r\n        : EPhraseTrigger.OnFight;       // Flash/Smoke: \"Flashbang!\"\r\n\r\n// CollisionSound values:\r\n// 0 = Explosive (frag grenade)\r\n// Non-0 = Flash/smoke/stun\r\n```\r\n\r\n### Flash Duration\r\n\r\n**Estimated Duration**:\r\n- Direct flash (facing): ~7 seconds\r\n- Peripheral flash: ~3-5 seconds\r\n- Behind/protected: ~1-3 seconds\r\n\r\n**Recovery**: Automatic - `IsFlashed` property updates internally\r\n\r\n---\r\n\r\n## 5. Door Breaching Integration\r\n\r\n### Door System Overview\r\n\r\n**Key API Points**:\r\n```csharp\r\n// Door interaction types\r\npublic enum EInteractionType\r\n{\r\n    Open = 0,      // Normal open\r\n    Close = 1,     // Close door\r\n    Breach = 3,    // Kick/breach\r\n}\r\n\r\n// Door states\r\npublic enum EDoorState\r\n{\r\n    Open = 2,\r\n    Closed = 4,\r\n}\r\n```\r\n\r\n### Breaching Doors\r\n\r\n**Breach Decision**:\r\n```csharp\r\npublic bool ShallKickOpen(Door door, EInteractionType interactionType)\r\n{\r\n    // Only breach when opening\r\n    if (interactionType != EInteractionType.Open)\r\n        return false;\r\n\r\n    // Check if bot wants to breach\r\n    if (!WantToKick())\r\n        return false;\r\n\r\n    // Get breach parameters and roll success\r\n    GStruct436 breachParams = door.GetBreakInParameters(Bot.Position);\r\n    return door.BreachSuccessRoll(breachParams.InteractionPosition);\r\n}\r\n\r\nprivate bool WantToKick()\r\n{\r\n    Enemy goalEnemy = Bot.GoalEnemy;\r\n    if (goalEnemy == null)\r\n        return false;\r\n\r\n    // Always kick (personality setting)\r\n    if (Bot.Info.PersonalitySettings.General.KickOpenAllDoors)\r\n        return true;\r\n\r\n    // Under fire\r\n    if (BotOwner.Memory.IsUnderFire)\r\n        return true;\r\n\r\n    // Enemy seen recently (< 3s)\r\n    if (goalEnemy.TimeSinceSeen < 3f)\r\n        return true;\r\n\r\n    // Enemy visible and close (< 5s)\r\n    if (goalEnemy.TimeSinceSeen < 5f && goalEnemy.InLineOfSight)\r\n        return true;\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n**Door Interaction**:\r\n```csharp\r\nprivate bool InteractWithDoor(ref DoorDataStruct data, EInteractionType type)\r\n{\r\n    if (data.Door == null)\r\n        return false;\r\n\r\n    // Validate door state\r\n    EDoorState doorState = data.Door.DoorState;\r\n    if (doorState != EDoorState.Closed && doorState != EDoorState.Open)\r\n        return false;\r\n\r\n    // Update timing\r\n    data.LastInteractTime = Time.time;\r\n\r\n    // Reset prop state\r\n    Player.MovementContext.ResetCanUsePropState();\r\n\r\n    // Perform interaction\r\n    GStruct156<InteractionResult> result = Door.Interact(Player, type);\r\n\r\n    if (result.Succeeded)\r\n    {\r\n        if (type == EInteractionType.Breach)\r\n        {\r\n            // Breach/kick animation\r\n            Player.vmethod_0(data.Door, result.Value, null);\r\n        }\r\n        else\r\n        {\r\n            // Normal open/close\r\n            Player.vmethod_1(data.Door, result.Value);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 6. Implementation Examples\r\n\r\n### Example 1: Flashbang Door Breach Sequence\r\n\r\n```csharp\r\npublic class FlashbreachAction\r\n{\r\n    private enum BreachState\r\n    {\r\n        SelectDoor,\r\n        StackOnDoor,\r\n        ThrowFlash,\r\n        WaitForFlash,\r\n        Breach,\r\n        Entry,\r\n        Complete\r\n    }\r\n\r\n    private BreachState _state = BreachState.SelectDoor;\r\n    private Door _targetDoor;\r\n    private float _flashThrowTime;\r\n\r\n    public void Update()\r\n    {\r\n        switch (_state)\r\n        {\r\n            case BreachState.SelectDoor:\r\n                if (SelectNearbyDoor(out _targetDoor))\r\n                {\r\n                    _state = BreachState.StackOnDoor;\r\n                }\r\n                break;\r\n\r\n            case BreachState.StackOnDoor:\r\n                if (StackOnDoor(_targetDoor))\r\n                {\r\n                    _state = BreachState.ThrowFlash;\r\n                }\r\n                break;\r\n\r\n            case BreachState.ThrowFlash:\r\n                if (ThrowFlashbangAtDoor(_targetDoor))\r\n                {\r\n                    _flashThrowTime = Time.time;\r\n                    _state = BreachState.WaitForFlash;\r\n\r\n                    // Announce\r\n                    BotOwner.BotTalk.Say(EPhraseTrigger.ThrowGrenade); // \"Throwing flash!\"\r\n                }\r\n                break;\r\n\r\n            case BreachState.WaitForFlash:\r\n                // Wait 2 seconds for flash detonation\r\n                if (Time.time - _flashThrowTime > 2f)\r\n                {\r\n                    _state = BreachState.Breach;\r\n                }\r\n                break;\r\n\r\n            case BreachState.Breach:\r\n                if (BreachDoor(_targetDoor))\r\n                {\r\n                    _state = BreachState.Entry;\r\n                }\r\n                break;\r\n\r\n            case BreachState.Entry:\r\n                // Move through doorway\r\n                Vector3 entryPoint = GetEntryPoint(_targetDoor);\r\n                if (MoveToPosition(entryPoint))\r\n                {\r\n                    _state = BreachState.Complete;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    private bool ThrowFlashbangAtDoor(Door door)\r\n    {\r\n        // Check have flashbang\r\n        if (!BotOwner.WeaponManager.Grenades.HaveGrenade)\r\n            return false;\r\n\r\n        // Calculate throw position (above door, inside room)\r\n        Vector3 doorPos = door.transform.position;\r\n        Vector3 doorForward = door.transform.forward;\r\n        Vector3 throwTarget = doorPos + doorForward * 2f + Vector3.up * 1.5f;\r\n\r\n        // Calculate trajectory\r\n        Vector3 weaponRoot = BotOwner.Transform.WeaponRoot;\r\n        float maxPower = BotOwner.WeaponManager.Grenades.MaxPower;\r\n\r\n        AIGreanageThrowData throwData = GClass577.CanThrowGrenade2(\r\n            weaponRoot,\r\n            throwTarget,\r\n            maxPower * 0.8f,     // 80% power for accuracy\r\n            AIGreandeAng.Middle,\r\n            -1f,\r\n            0.5f\r\n        );\r\n\r\n        if (!throwData.CanThrow)\r\n            return false;\r\n\r\n        // Execute throw\r\n        BotOwner.WeaponManager.Grenades.SetThrowData(throwData);\r\n        return BotOwner.WeaponManager.Grenades.DoThrow();\r\n    }\r\n\r\n    private bool BreachDoor(Door door)\r\n    {\r\n        // Kick door open\r\n        DoorDataStruct doorData = new DoorDataStruct(door.NavMeshLink);\r\n\r\n        return InteractWithDoor(\r\n            ref doorData,\r\n            EInteractionType.Breach  // Kick\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n### Example 2: Coordinated Grenade + Advance\r\n\r\n```csharp\r\npublic class CoordinatedGrenadeAssault\r\n{\r\n    private bool _grenadeThrown;\r\n    private float _throwTime;\r\n\r\n    public void Execute(BotOwner bot, Enemy enemy)\r\n    {\r\n        if (!_grenadeThrown)\r\n        {\r\n            // Throw grenade\r\n            if (bot.Grenade.GrenadeThrowDecider.GetDecision(enemy, out _))\r\n            {\r\n                _grenadeThrown = true;\r\n                _throwTime = Time.time;\r\n\r\n                // Announce to squad\r\n                bot.BotTalk.Say(EPhraseTrigger.ThrowGrenade);\r\n\r\n                // Signal squad to advance after explosion\r\n                ScheduleSquadAdvance(3.5f); // After explosion\r\n            }\r\n        }\r\n        else if (Time.time - _throwTime > 3.5f)\r\n        {\r\n            // Grenade exploded, advance now\r\n            AdvanceOnPosition(enemy.LastSeenPosition);\r\n        }\r\n    }\r\n\r\n    private void ScheduleSquadAdvance(float delay)\r\n    {\r\n        // Queue advance commands for squad\r\n        // Implementation depends on squad system\r\n    }\r\n}\r\n```\r\n\r\n### Example 3: Grenade Reaction with Cover\r\n\r\n```csharp\r\npublic void EnemyGrenadeThrown(Grenade grenade, Vector3 dangerPoint,\r\n    string profileId)\r\n{\r\n    // Ignore own grenades\r\n    if (profileId == Bot.ProfileId || !Bot.BotActive)\r\n        return;\r\n\r\n    // Only track if close (< 125m)\r\n    Enemy enemy = Bot.EnemyController.GetEnemy(profileId, false);\r\n    if (enemy != null && enemy.RealDistance <= 125f)\r\n    {\r\n        // Create tracker with reaction time\r\n        float reactionTime = GetReactionTime(); // 0.2-1.0s\r\n\r\n        GrenadeTrackerClass tracker = new GrenadeTrackerClass(\r\n            Bot,\r\n            grenade,\r\n            dangerPoint,\r\n            reactionTime\r\n        );\r\n\r\n        EnemyGrenadesList.Add(grenade, tracker);\r\n        grenade.DestroyEvent += RemoveGrenade;\r\n    }\r\n    else\r\n    {\r\n        // Too far for detailed tracking\r\n        BotOwner.BewareGrenade.AddGrenadeDanger(dangerPoint, grenade);\r\n    }\r\n}\r\n\r\n// Reaction time calculation\r\npublic float GetReactionTime()\r\n{\r\n    // Base 0.25s / difficulty, randomized ¬±25%, clamped 0.2-1.0s\r\n    return Mathf.Clamp(\r\n        0.25f / Bot.Info.Profile.DifficultyModifier\r\n            * Random.Range(0.75f, 1.25f),\r\n        0.2f,\r\n        1f\r\n    );\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7. Safety and Friendly Fire Prevention\r\n\r\n### Friendly Distance Checks\r\n\r\n**Before every throw**:\r\n```csharp\r\nprivate bool checkFriendlyDistances(Vector3 targetPosition)\r\n{\r\n    Dictionary<string, BotComponent> members = Bot.Squad.Members;\r\n\r\n    // Solo or no squad\r\n    if (members == null || members.Count <= 1)\r\n        return true;\r\n\r\n    float minDistSqr = _minFriendlyDistToThrow * _minFriendlyDistToThrow;\r\n\r\n    foreach (BotComponent member in members.Values)\r\n    {\r\n        if (member == null)\r\n            continue;\r\n\r\n        // Check distance from member to throw target\r\n        float distSqr = (member.Position - targetPosition).sqrMagnitude;\r\n\r\n        if (distSqr < minDistSqr)\r\n        {\r\n            // Friendly too close to target (< 8m)\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n```\r\n\r\n### Throw Validation Checklist\r\n\r\n**Before throwing grenade**:\r\n```csharp\r\n// 1. Bot has grenades\r\nif (!BotOwner.WeaponManager.Grenades.HaveGrenade)\r\n    return false;\r\n\r\n// 2. Not changing weapons\r\nif (BotOwner.WeaponManager.Selector.IsChanging)\r\n    return false;\r\n\r\n// 3. Not reloading\r\nif (BotOwner.WeaponManager.Reload.Reloading)\r\n    return false;\r\n\r\n// 4. Not in interaction\r\nif (Player.HandsController.IsInInteractionStrictCheck())\r\n    return false;\r\n\r\n// 5. Trajectory is clear (1.5m obstruction check)\r\nif (Physics.Raycast(from, throwData.Direction, 1.5f,\r\n    LayerMaskClass.HighPolyWithTerrainMask))\r\n    return false;\r\n\r\n// 6. Friendlies are safe (>8m)\r\nif (!checkFriendlyDistances(target))\r\n    return false;\r\n\r\n// 7. Enemy distance appropriate (8m-75m)\r\nif (distance < _minEnemyDistToThrow) return false;\r\nif (distance > _maxEnemyDistToCheckThrow) return false;\r\n\r\n// 8. Cooldown met\r\nif (_nextPosibleAttempt > Time.time)\r\n    return false;\r\n```\r\n\r\n### Cooldown Management\r\n\r\n```csharp\r\nprivate float _throwGrenadeFreq = 5f;        // Min wait\r\nprivate float _throwGrenadeFreqMax = 10f;    // Max wait\r\nprivate float _nextPosibleAttempt;\r\n\r\n// After successful throw\r\n_nextPosibleAttempt = Time.time +\r\n    Random.Range(_throwGrenadeFreq, _throwGrenadeFreqMax);\r\n\r\n// Before throw check\r\nif (_nextPosibleAttempt > Time.time)\r\n    return false; // Still on cooldown\r\n```\r\n\r\n---\r\n\r\n## 8. Voice Communication\r\n\r\n### Grenade Voice Lines\r\n\r\n| Trigger | Value | When Used | Who |\r\n|---------|-------|-----------|-----|\r\n| `ThrowGrenade` | 22 | Announcing throw | Thrower |\r\n| `OnBeingHit` | 11 | Frag detected | Squad |\r\n| `OnFight` | 35 | Flash/smoke detected | Squad |\r\n| `NeedHelp` | 85 | Need grenades | Thrower |\r\n\r\n**Usage Patterns**:\r\n```csharp\r\n// Announce throw to nearby squad\r\nif (Bot.Squad.BotInGroup && Bot.Talk.GroupTalk.FriendIsClose)\r\n{\r\n    Bot.Talk.Say(EPhraseTrigger.ThrowGrenade); // \"Throwing grenade!\"\r\n}\r\n\r\n// Warn squad of incoming\r\nBot.Talk.GroupSay(\r\n    EPhraseTrigger.OnBeingHit,  // \"Grenade!\"\r\n    ETagStatus.Combat,\r\n    withGroupDelay: false,       // Immediate\r\n    100f                         // 100% chance\r\n);\r\n\r\n// Request grenades\r\nBot.Talk.GroupSay(\r\n    EPhraseTrigger.NeedHelp,    // \"Need grenades!\"\r\n    null,\r\n    withGroupDelay: true,        // Stagger\r\n    5f                           // 5% chance\r\n);\r\n```\r\n\r\n---\r\n\r\n## Summary: Key APIs Quick Reference\r\n\r\n### Throwing\r\n```csharp\r\n// Calculate trajectory\r\nAIGreanageThrowData data = GClass577.CanThrowGrenade2(\r\n    from, target, power, angle, time, minDistPercent);\r\n\r\n// Set and throw\r\nBotOwner.WeaponManager.Grenades.SetThrowData(data);\r\nbool success = BotOwner.WeaponManager.Grenades.DoThrow();\r\n```\r\n\r\n### Detection\r\n```csharp\r\n// Subscribe to events\r\nGrenadeController controller = BotManagerComponent.Instance.GrenadeController;\r\ncontroller.OnGrenadeThrown += HandleThrow;\r\n\r\n// Calculate danger\r\nVector3 dangerPoint = Vector.DangerPoint(position, force, mass);\r\n```\r\n\r\n### Avoidance\r\n```csharp\r\n// Send danger to AI\r\nBotOwner.BewareGrenade.AddGrenadeDanger(dangerPoint, grenade);\r\n\r\n// Check flash state\r\nif (BotOwner.FlashGrenade.IsFlashed) { }\r\n```\r\n\r\n### Door Breach\r\n```csharp\r\n// Check should breach\r\nbool shouldBreach = doorOpener.ShallKickOpen(door, EInteractionType.Open);\r\n\r\n// Execute breach\r\nbool success = InteractWithDoor(doorData, EInteractionType.Breach);\r\n```\r\n\r\n---\r\n\r\n**With this documentation, you can implement: Tactical Grenades, Door Breaching, Flashbang Entry, Grenade Avoidance, and Coordinated Assaults!**\r\n"},"07-Server-Routes-Patterns":{"title":"SPT Server Routes - Complete Guide (SOURCE-VERIFIED)\r","category":"Core Systems","content":"# SPT Server Routes - Complete Guide (SOURCE-VERIFIED)\r\n\r\n**Source**: SPT v4.0.x C# Source Code\r\n**Status**: ‚úÖ SOURCE-VERIFIED - Replaces previous version\r\n**Previous Version**: ‚ùå ARCHIVED - Contained inaccuracies\r\n\r\n---\r\n\r\n## ‚ö†Ô∏è CRITICAL NOTICE\r\n\r\n**This document completely replaces the previous version which contained inaccuracies.**\r\n\r\n**Key corrections from previous version**:\r\n- ‚ùå OLD: \"Return `ValueTask.FromResult<object>(response)`\"\r\n- ‚úÖ NEW: \"Return `jsonUtil.Serialize(response)` (must be string!)\"\r\n\r\n**Reason**: HttpRouter casts results `as string`. Objects fail the cast and cause 404 errors.\r\n\r\n**See**: `SPT-404-ROOT-CAUSE-SOLVED.md` for complete explanation\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [Router Types](#router-types)\r\n2. [RouteAction Variants](#routeaction-variants)\r\n3. [Response Requirements](#response-requirements)\r\n4. [Common Patterns](#common-patterns)\r\n5. [Request/Response Flow](#requestresponse-flow)\r\n6. [Testing Routes](#testing-routes)\r\n7. [Error Handling](#error-handling)\r\n\r\n---\r\n\r\n## Router Types\r\n\r\n### StaticRouter - Exact URL Matching\r\n\r\n**Use when**: Routes have exact, known paths\r\n\r\n**Base class**: `SPTarkov.Server.Core/DI/Router.cs:66`\r\n\r\n```csharp\r\npublic abstract class StaticRouter(JsonUtil jsonUtil, IEnumerable<RouteAction> routes) : Router\r\n{\r\n    public async ValueTask<object> HandleStatic(string url, string? body, MongoId sessionId, string output)\r\n    {\r\n        var action = routes.Single(route => route.url == url);  // Exact match\r\n        // ... execute handler\r\n        return result;  // Returns as object\r\n    }\r\n}\r\n```\r\n\r\n**Matching**: Uses `route.url == url` (exact string comparison)\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable]\r\npublic class MyStaticRouter(JsonUtil jsonUtil, ISptLogger<MyStaticRouter> logger)\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/client/game/start\",  // Matches ONLY \"/client/game/start\"\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                logger.Info(\"Game start!\");\r\n                return jsonUtil.Serialize(new { status = \"started\" });\r\n            }\r\n        )\r\n    ])\r\n{ }\r\n```\r\n\r\n---\r\n\r\n### DynamicRouter - Partial URL Matching\r\n\r\n**Use when**: Routes have variable parts (IDs, dynamic segments)\r\n\r\n**Base class**: `SPTarkov.Server.Core/DI/Router.cs:91`\r\n\r\n```csharp\r\npublic abstract class DynamicRouter(JsonUtil jsonUtil, IEnumerable<RouteAction> routes) : Router\r\n{\r\n    public async ValueTask<object> HandleDynamic(string url, string? body, MongoId sessionId, string output)\r\n    {\r\n        var action = routes.First(r => url.Contains(r.url));  // Partial match\r\n        // ... execute handler\r\n        return result;  // Returns as object\r\n    }\r\n}\r\n```\r\n\r\n**Matching**: Uses `url.Contains(route.url)` (substring match)\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable]\r\npublic class MyDynamicRouter(JsonUtil jsonUtil, ISptLogger<MyDynamicRouter> logger)\r\n    : DynamicRouter(jsonUtil,\r\n    [\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/api/trader/\",  // Matches \"/api/trader/54cb50c76803fa8b248b4571\"\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                var traderId = url.Split('/').Last();\r\n                logger.Info($\"Trader: {traderId}\");\r\n                return jsonUtil.Serialize(new { traderId = traderId });\r\n            }\r\n        )\r\n    ])\r\n{ }\r\n```\r\n\r\n---\r\n\r\n## RouteAction Variants\r\n\r\n**Location**: `SPTarkov.Server.Core/DI/Router.cs:182-186`\r\n\r\n### Non-Generic RouteAction\r\n\r\n```csharp\r\npublic record RouteAction(\r\n    string url,\r\n    Func<string, IRequestData, MongoId, string?, ValueTask<object>> action,\r\n    Type? bodyType = null\r\n);\r\n```\r\n\r\n**Signature**:\r\n```csharp\r\nasync (string url, IRequestData info, MongoId sessionId, string? output) => ValueTask<object>\r\n```\r\n\r\n**Use when**: No request body or manual deserialization needed\r\n\r\n**Example**:\r\n```csharp\r\nnew RouteAction(\r\n    \"/my/route\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        // info is IRequestData (base type)\r\n        // Must serialize result to string!\r\n        return jsonUtil.Serialize(new { status = \"ok\" });\r\n    }\r\n)\r\n```\r\n\r\n---\r\n\r\n### Generic RouteAction<TRequest>\r\n\r\n```csharp\r\npublic record RouteAction<TRequest>(\r\n    string url,\r\n    Func<string, TRequest, MongoId, string?, ValueTask<string>> typedAction\r\n)\r\n    : RouteAction(...)\r\n    where TRequest : class;\r\n```\r\n\r\n**Signature**:\r\n```csharp\r\nasync (string url, TRequest info, MongoId sessionId, string? output) => ValueTask<string>\r\n```\r\n\r\n**Use when**: Typed request body (RECOMMENDED)\r\n\r\n**Example**:\r\n```csharp\r\nnew RouteAction<MyRequestData>(\r\n    \"/my/route\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        // info is MyRequestData (auto-deserialized!)\r\n        // Compiler enforces string return!\r\n        return jsonUtil.Serialize(new { received = info.Value });\r\n    }\r\n)\r\n```\r\n\r\n**Advantages**:\r\n- ‚úÖ Auto-deserializes request body to `TRequest`\r\n- ‚úÖ Compiler enforces `string` return type\r\n- ‚úÖ Type-safe, less error-prone\r\n\r\n---\r\n\r\n## Response Requirements\r\n\r\n### ‚ö†Ô∏è CRITICAL: All Handlers MUST Return String!\r\n\r\n**Source**: `SPTarkov.Server.Core/Routers/HttpRouter.cs:54,58`\r\n\r\n```csharp\r\n// HttpRouter casts result to string\r\nwrapper.Output = await (route as StaticRouter).HandleStatic(...) as string;\r\n//                                                                ^^^^^^^^^\r\n//                                               If not string, returns null!\r\n```\r\n\r\n**What happens if you return an object**:\r\n```\r\n1. Handler returns object: new { status = \"ok\" }\r\n2. StaticRouter.HandleStatic returns it as object\r\n3. HttpRouter: (object){status=\"ok\"} as string ‚Üí null\r\n4. SptHttpListener: if (output == null) ‚Üí Generate 404!\r\n```\r\n\r\n### ‚úÖ CORRECT Pattern\r\n\r\n```csharp\r\nnew RouteAction(\r\n    \"/my/route\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        var response = new { status = \"ok\", data = someData };\r\n        return jsonUtil.Serialize(response);  // ‚úÖ Returns string!\r\n    }\r\n)\r\n```\r\n\r\n### ‚ùå WRONG Pattern\r\n\r\n```csharp\r\nnew RouteAction(\r\n    \"/my/route\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        var response = new { status = \"ok\" };\r\n        return response;  // ‚ùå Returns object ‚Üí 404 error!\r\n    }\r\n)\r\n```\r\n\r\n**See**: `SPT-404-ROOT-CAUSE-SOLVED.md` for detailed explanation\r\n\r\n---\r\n\r\n## Common Patterns\r\n\r\n### Pattern 1: Simple GET Endpoint\r\n\r\n```csharp\r\nnew RouteAction<EmptyRequestData>(\r\n    \"/mymod/status\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        logger.Info($\"Status check for session {sessionId}\");\r\n\r\n        var status = new\r\n        {\r\n            online = true,\r\n            version = \"1.0.0\",\r\n            timestamp = DateTime.UtcNow\r\n        };\r\n\r\n        return jsonUtil.Serialize(status);\r\n    }\r\n)\r\n```\r\n\r\n---\r\n\r\n### Pattern 2: POST with Request Body\r\n\r\n```csharp\r\npublic class SaveDataRequest : IRequestData\r\n{\r\n    public string? Key { get; set; }\r\n    public object? Value { get; set; }\r\n}\r\n\r\nnew RouteAction<SaveDataRequest>(\r\n    \"/mymod/save\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        logger.Info($\"Saving: {info.Key} = {info.Value}\");\r\n\r\n        // Process request\r\n        SaveToDatabase(info.Key, info.Value, sessionId);\r\n\r\n        return jsonUtil.Serialize(new { success = true });\r\n    }\r\n)\r\n```\r\n\r\n---\r\n\r\n### Pattern 3: SPT Standard Response Format\r\n\r\n```csharp\r\nprivate static object CreateSuccessResponse(object data)\r\n{\r\n    return new Dictionary<string, object>\r\n    {\r\n        { \"err\", 0 },\r\n        { \"errmsg\", string.Empty },\r\n        { \"data\", data }\r\n    };\r\n}\r\n\r\nprivate static object CreateErrorResponse(int errorCode, string message)\r\n{\r\n    return new Dictionary<string, object>\r\n    {\r\n        { \"err\", errorCode },\r\n        { \"errmsg\", message },\r\n        { \"data\", new { } }\r\n    };\r\n}\r\n\r\n// Usage:\r\nnew RouteAction<EmptyRequestData>(\r\n    \"/mymod/data\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        try\r\n        {\r\n            var data = GetData(sessionId);\r\n            return jsonUtil.Serialize(CreateSuccessResponse(data));\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            logger.Error($\"Error: {ex.Message}\");\r\n            return jsonUtil.Serialize(CreateErrorResponse(500, ex.Message));\r\n        }\r\n    }\r\n)\r\n```\r\n\r\n**Why**: EFT client expects `{ err, errmsg, data }` format\r\n\r\n---\r\n\r\n### Pattern 4: Accessing Injected Services in Routes\r\n\r\n**Problem**: Routes are static, how to access services?\r\n\r\n**Solution 1: Closure Over Constructor Parameters**\r\n```csharp\r\n[Injectable]\r\npublic class MyRouter(\r\n    JsonUtil jsonUtil,\r\n    DatabaseService databaseService,  // Captured in closure\r\n    ISptLogger<MyRouter> logger)\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/mymod/items\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                // databaseService available via closure!\r\n                var items = databaseService.GetItems();\r\n                return jsonUtil.Serialize(new { count = items.Count });\r\n            }\r\n        )\r\n    ])\r\n{ }\r\n```\r\n\r\n**Solution 2: ServiceLocator (Deprecated, use Solution 1)**\r\n```csharp\r\n// ‚ö†Ô∏è DEPRECATED - Will be removed in future SPT version\r\nprivate static T? ResolveService<T>() where T : class\r\n{\r\n    return ServiceLocator.ServiceProvider?.GetService(typeof(T)) as T;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Request/Response Flow\r\n\r\n### Complete Flow Diagram\r\n\r\n```\r\n[1] Client sends request\r\n    POST /mymod/configure\r\n    Body: {\"setting\": \"value\"}\r\n    ‚Üì\r\n[2] SptHttpListener.Handle()\r\n    ‚Ä¢ Decompresses body (if POST/PUT)\r\n    ‚Ä¢ Calls GetResponse()\r\n    ‚Üì\r\n[3] SptHttpListener.GetResponse()\r\n    ‚Ä¢ Calls httpRouter.GetResponse()\r\n    ‚Ä¢ Checks if null ‚Üí generates 404 if null\r\n    ‚Üì\r\n[4] HttpRouter.GetResponse()\r\n    ‚Ä¢ Creates ResponseWrapper\r\n    ‚Ä¢ Tries StaticRouters\r\n    ‚Ä¢ Falls back to DynamicRouters\r\n    ‚Üì\r\n[5] HttpRouter.HandleRoute()\r\n    ‚Ä¢ Loops through routers\r\n    ‚Ä¢ Checks route.CanHandle(url)\r\n    ‚Ä¢ Calls HandleStatic/HandleDynamic\r\n    ‚Ä¢ Casts result as string ‚ö†Ô∏è CRITICAL!\r\n    ‚Üì\r\n[6] StaticRouter.HandleStatic()\r\n    ‚Ä¢ Finds exact match route\r\n    ‚Ä¢ Deserializes body to bodyType\r\n    ‚Ä¢ Calls your handler\r\n    ‚Ä¢ Returns result as object\r\n    ‚Üì\r\n[7] Your Handler\r\n    ‚Ä¢ Processes request\r\n    ‚Ä¢ MUST return string (serialized JSON)!\r\n    ‚Üì\r\n[8] Back up the chain\r\n    ‚Ä¢ StaticRouter returns object (containing string)\r\n    ‚Ä¢ HttpRouter casts: (object)\"json\" as string ‚Üí \"json\" ‚úÖ\r\n    ‚Ä¢ SptHttpListener receives string\r\n    ‚Ä¢ Compresses with ZLib\r\n    ‚Ä¢ Sends HTTP response\r\n    ‚Üì\r\n[9] Client receives response\r\n    ‚Ä¢ Decompresses\r\n    ‚Ä¢ Parses JSON\r\n    ‚Ä¢ Uses data\r\n```\r\n\r\n---\r\n\r\n## Testing Routes\r\n\r\n### Using curl\r\n\r\n**Standard request (compressed)**:\r\n```bash\r\ncurl http://localhost:6969/mymod/status\r\n# Response is ZLib-compressed\r\n```\r\n\r\n**Debug request (uncompressed)**:\r\n```bash\r\ncurl -H \"responsecompressed: 0\" http://localhost:6969/mymod/status\r\n# Response is readable JSON\r\n```\r\n\r\n**POST with uncompressed request/response**:\r\n```bash\r\ncurl -X POST \\\r\n  -H \"Content-Type: application/json\" \\\r\n  -H \"requestcompressed: 0\" \\\r\n  -H \"responsecompressed: 0\" \\\r\n  -d '{\"key\": \"value\"}' \\\r\n  http://localhost:6969/mymod/save\r\n```\r\n\r\n**See**: `SPT-COMPRESSION-EXPLAINED.md` for details\r\n\r\n---\r\n\r\n### Using Postman\r\n\r\n1. **Create request**: POST `http://localhost:6969/mymod/configure`\r\n2. **Add headers**:\r\n   - `requestcompressed: 0`\r\n   - `responsecompressed: 0`\r\n3. **Add body** (raw JSON):\r\n   ```json\r\n   {\"setting\": \"value\"}\r\n   ```\r\n4. **Send** - Response is readable JSON\r\n\r\n---\r\n\r\n### Verification Logging\r\n\r\n```csharp\r\n[Injectable]\r\npublic class MyRouter(JsonUtil jsonUtil, ISptLogger<MyRouter> logger)\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        new RouteAction<MyRequestData>(\r\n            \"/mymod/test\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                logger.Info(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\");\r\n                logger.Info($\"Route: {url}\");\r\n                logger.Info($\"Session: {sessionId}\");\r\n                logger.Info($\"Request: {jsonUtil.Serialize(info)}\");\r\n\r\n                var response = new { status = \"ok\" };\r\n                var serialized = jsonUtil.Serialize(response);\r\n\r\n                logger.Info($\"Response: {serialized}\");\r\n                logger.Info($\"Type: {serialized.GetType().Name}\");  // Should be \"String\"\r\n                logger.Info(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\");\r\n\r\n                return serialized;\r\n            }\r\n        )\r\n    ])\r\n{\r\n    logger.Success(\"MyRouter registered with 1 route\");\r\n}\r\n```\r\n\r\n**Server log output**:\r\n```\r\n[Info] MyRouter registered with 1 route\r\n[Info] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n[Info] Route: /mymod/test\r\n[Info] Session: 507f1f77bcf86cd799439011\r\n[Info] Request: {\"Key\":\"value\"}\r\n[Info] Response: {\"status\":\"ok\"}\r\n[Info] Type: String\r\n[Info] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n```\r\n\r\n---\r\n\r\n## Error Handling\r\n\r\n### Pattern 1: Try-Catch with Error Response\r\n\r\n```csharp\r\nnew RouteAction<DataRequest>(\r\n    \"/mymod/process\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        try\r\n        {\r\n            var result = ProcessData(info);\r\n            return jsonUtil.Serialize(new\r\n            {\r\n                err = 0,\r\n                errmsg = string.Empty,\r\n                data = result\r\n            });\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            logger.Error($\"Processing failed: {ex.Message}\");\r\n            logger.Error($\"Stack: {ex.StackTrace}\");\r\n\r\n            return jsonUtil.Serialize(new\r\n            {\r\n                err = 500,\r\n                errmsg = ex.Message,\r\n                data = new { }\r\n            });\r\n        }\r\n    }\r\n)\r\n```\r\n\r\n### Pattern 2: Validation\r\n\r\n```csharp\r\nnew RouteAction<SaveRequest>(\r\n    \"/mymod/save\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        // Validate required fields\r\n        if (string.IsNullOrWhiteSpace(info.Key))\r\n        {\r\n            return jsonUtil.Serialize(new\r\n            {\r\n                err = 400,\r\n                errmsg = \"Key is required\",\r\n                data = new { }\r\n            });\r\n        }\r\n\r\n        // Process valid request\r\n        Save(info.Key, info.Value);\r\n\r\n        return jsonUtil.Serialize(new { err = 0, data = new { saved = true } });\r\n    }\r\n)\r\n```\r\n\r\n---\r\n\r\n## Route Registration Examples\r\n\r\n### Example 1: Multiple Routes in One Router\r\n\r\n```csharp\r\n[Injectable]\r\npublic class GameRouter(\r\n    JsonUtil jsonUtil,\r\n    DatabaseService databaseService,\r\n    SaveServer saveServer,\r\n    ISptLogger<GameRouter> logger)\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        // Route 1: Get game version\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/client/game/version\",\r\n            async (url, info, sessionId, output) =>\r\n                jsonUtil.Serialize(new { version = \"1.0.0\" })\r\n        ),\r\n\r\n        // Route 2: Get player info\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/client/game/profile/info\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                var profile = saveServer.GetProfile(sessionId);\r\n                return jsonUtil.Serialize(new\r\n                {\r\n                    nickname = profile.CharacterData.PmcData.Info.Nickname,\r\n                    level = profile.CharacterData.PmcData.Info.Level\r\n                });\r\n            }\r\n        ),\r\n\r\n        // Route 3: Get item count\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/client/game/items/count\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                var items = databaseService.GetItems();\r\n                return jsonUtil.Serialize(new { count = items.Count });\r\n            }\r\n        )\r\n    ])\r\n{\r\n    logger.Info(\"GameRouter registered with 3 routes\");\r\n}\r\n```\r\n\r\n---\r\n\r\n### Example 2: Router with Custom Service\r\n\r\n```csharp\r\n// Custom service\r\n[Injectable(InjectionType.Singleton)]\r\npublic class ConfigService(ISptLogger<ConfigService> logger)\r\n{\r\n    private readonly Dictionary<string, string> _config = new();\r\n\r\n    public void Set(string key, string value)\r\n    {\r\n        _config[key] = value;\r\n        logger.Info($\"Config set: {key} = {value}\");\r\n    }\r\n\r\n    public string? Get(string key)\r\n    {\r\n        return _config.TryGetValue(key, out var value) ? value : null;\r\n    }\r\n}\r\n\r\n// Router using service\r\n[Injectable]\r\npublic class ConfigRouter(\r\n    JsonUtil jsonUtil,\r\n    ConfigService configService,\r\n    ISptLogger<ConfigRouter> logger)\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        new RouteAction<GetConfigRequest>(\r\n            \"/mymod/config/get\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                var value = configService.Get(info.Key);\r\n                return jsonUtil.Serialize(new { key = info.Key, value = value });\r\n            }\r\n        ),\r\n\r\n        new RouteAction<SetConfigRequest>(\r\n            \"/mymod/config/set\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                configService.Set(info.Key, info.Value);\r\n                return jsonUtil.Serialize(new { success = true });\r\n            }\r\n        )\r\n    ])\r\n{ }\r\n\r\npublic class GetConfigRequest : IRequestData\r\n{\r\n    public string? Key { get; set; }\r\n}\r\n\r\npublic class SetConfigRequest : IRequestData\r\n{\r\n    public string? Key { get; set; }\r\n    public string? Value { get; set; }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Common Issues & Solutions\r\n\r\n### Issue 1: Routes Return 404\r\n\r\n**Symptom**: `{\"err\": 404, \"errmsg\": \"UNHANDLED RESPONSE: /your/route\"}`\r\n\r\n**Causes**:\r\n1. Handler returns object instead of string\r\n2. Route not registered (no `[Injectable]`)\r\n3. URL mismatch (typo, case-sensitive!)\r\n4. Handler throws exception\r\n\r\n**Solution**:\r\n```csharp\r\n// ‚úÖ Always serialize to string\r\nreturn jsonUtil.Serialize(response);\r\n\r\n// ‚úÖ Add [Injectable]\r\n[Injectable]\r\npublic class MyRouter : StaticRouter { }\r\n\r\n// ‚úÖ Log route registration\r\nlogger.Info($\"Registered route: /my/route\");\r\n```\r\n\r\n**See**: `SPT-404-ROOT-CAUSE-SOLVED.md`\r\n\r\n---\r\n\r\n### Issue 2: Request Body is Null\r\n\r\n**Symptom**: `info` parameter is null or `EmptyRequestData`\r\n\r\n**Causes**:\r\n1. Client not sending body\r\n2. Wrong content-type header\r\n3. Body not being deserialized\r\n\r\n**Solution**:\r\n```csharp\r\n// Check if request has data\r\nnew RouteAction<MyRequestData>(\r\n    \"/mymod/save\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        if (info == null || string.IsNullOrEmpty(info.Key))\r\n        {\r\n            return jsonUtil.Serialize(new { err = 400, errmsg = \"No data provided\" });\r\n        }\r\n\r\n        // Process valid request\r\n        return jsonUtil.Serialize(new { success = true });\r\n    }\r\n)\r\n```\r\n\r\n---\r\n\r\n### Issue 3: Service Not Found in Routes\r\n\r\n**Symptom**: `NullReferenceException` when accessing service\r\n\r\n**Cause**: Service not injected (static routes can't use this.field)\r\n\r\n**Solution**: Capture service in closure\r\n```csharp\r\n[Injectable]\r\npublic class MyRouter(\r\n    JsonUtil jsonUtil,\r\n    MyService myService)  // ‚Üê Capture in constructor\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/mymod/data\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                // myService available via closure\r\n                var data = myService.GetData(sessionId);\r\n                return jsonUtil.Serialize(data);\r\n            }\r\n        )\r\n    ])\r\n{ }\r\n```\r\n\r\n---\r\n\r\n## Complete Working Example\r\n\r\n**Minimal functional mod**:\r\n\r\n```csharp\r\nusing SPTarkov.DI.Annotations;\r\nusing SPTarkov.Server.Core.DI;\r\nusing SPTarkov.Server.Core.Models.Common;\r\nusing SPTarkov.Server.Core.Models.Spt.Mod;\r\nusing SPTarkov.Server.Core.Models.Utils;\r\nusing SPTarkov.Server.Core.Services;\r\nusing SPTarkov.Server.Core.Utils;\r\n\r\nnamespace MinimalWorkingMod;\r\n\r\n// 1. Metadata (Required)\r\npublic sealed record ModMetadata : AbstractModMetadata\r\n{\r\n    public override string ModGuid { get; init; } = \"com.example.minimal\";\r\n    public override string Name { get; init; } = \"Minimal Working Mod\";\r\n    public override string Author { get; init; } = \"Your Name\";\r\n    public override SemanticVersioning.Version Version { get; init; } = new(\"1.0.0\");\r\n    public override SemanticVersioning.Range SptVersion { get; init; } = new(\"~4.0.0\");\r\n    public override string? License { get; init; } = \"MIT\";\r\n    public override bool? IsBundleMod { get; init; } = null;\r\n    public override Dictionary<string, SemanticVersioning.Range>? ModDependencies { get; init; } = null;\r\n    public override string? Url { get; init; } = null;\r\n    public override List<string>? Contributors { get; init; } = null;\r\n    public override List<string>? Incompatibilities { get; init; } = null;\r\n}\r\n\r\n// 2. Router (Optional but common)\r\n[Injectable]\r\npublic class MinimalRouter(\r\n    JsonUtil jsonUtil,\r\n    DatabaseService databaseService,\r\n    ISptLogger<MinimalRouter> logger)\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/minimal/ping\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                logger.Info(\"Ping received!\");\r\n                return jsonUtil.Serialize(new { status = \"pong\" });\r\n            }\r\n        ),\r\n\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/minimal/items\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                var itemCount = databaseService.GetItems().Count;\r\n                return jsonUtil.Serialize(new { itemCount = itemCount });\r\n            }\r\n        )\r\n    ])\r\n{\r\n    logger.Success(\"MinimalRouter registered with 2 routes\");\r\n}\r\n\r\n// 3. Database Modification (Optional)\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MinimalDatabaseMod(\r\n    ISptLogger<MinimalDatabaseMod> logger,\r\n    DatabaseService databaseService\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var globals = databaseService.GetGlobals();\r\n        globals.Configuration.SavagePlayCooldown = 1;\r\n\r\n        logger.Success(\"Scav cooldown set to 1 second\");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n**Deploy**: Compile and copy `MinimalWorkingMod.dll` to `SPT/user/mods/MinimalWorkingMod/`\r\n\r\n**Test**:\r\n```bash\r\ncurl -H \"responsecompressed: 0\" http://localhost:6969/minimal/ping\r\n# Expected: {\"status\":\"pong\"}\r\n\r\ncurl -H \"responsecompressed: 0\" http://localhost:6969/minimal/items\r\n# Expected: {\"itemCount\":50000}\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\n### Critical Patterns ‚≠ê\r\n\r\n1. **ModMetadata class** - Required for mod discovery\r\n2. **[Injectable] attribute** - Auto-registers routers\r\n3. **Return `jsonUtil.Serialize()`** - MUST return string!\r\n4. **RouteAction<T>** - Type-safe request handling\r\n5. **Capture services in closures** - Access injected services in routes\r\n6. **Use TypePriority** - Control initialization order\r\n\r\n### Common Mistakes ‚ùå\r\n\r\n1. ~~Return objects~~ ‚Üí Serialize to string with `jsonUtil.Serialize()`\r\n2. ~~Use ServiceLocator~~ ‚Üí Use constructor injection and closures\r\n3. ~~Forget [Injectable]~~ ‚Üí Router won't be discovered\r\n4. ~~Wrong TypePriority~~ ‚Üí Database not available when needed\r\n5. ~~Direct locale assignment~~ ‚Üí Use `AddTransformer()` pattern\r\n\r\n### Verification Checklist ‚úÖ\r\n\r\n- [ ] ModMetadata class exists\r\n- [ ] Router has `[Injectable]` attribute\r\n- [ ] Router inherits `StaticRouter` or `DynamicRouter`\r\n- [ ] All handlers return `jsonUtil.Serialize(...)` (string!)\r\n- [ ] Request data classes implement `IRequestData`\r\n- [ ] Services injected via constructor\r\n- [ ] TypePriority set appropriately\r\n- [ ] Tested with `responsecompressed: 0` header\r\n\r\n---\r\n\r\n**Status**: ‚úÖ All patterns verified from working code\r\n**Sources**:\r\n- SPT-ServerMod-Examples (10+ official examples)\r\n- LTFriendlyPMC Server Mod (working mod)\r\n- SPT C# Source Code (routing internals)\r\n\r\n**Previous Version**: ‚ùå ARCHIVED - Contained inaccuracies about return types and casting\r\n"},"08-Cover-Navigation-System":{"title":"Tarkov Cover Finding & Navigation System - API Documentation\r","category":"Core Systems","content":"# Tarkov Cover Finding & Navigation System - API Documentation\r\n\r\n**Priority**: HIGH - Enables Innovations #1, #2, #5\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\nBased on analysis of SAIN movement system and FriendlyPMC cover utilities.\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nTarkov's cover and navigation system provides APIs for finding tactical positions, pathfinding, movement control, and spatial positioning. This document covers complete coverage for implementing dynamic formations, breach stacking, and coordinated squad movement.\r\n\r\n---\r\n\r\n## 1. Cover Point System\r\n\r\n### CustomNavigationPoint Structure\r\n\r\n**Tarkov's core cover point representation:**\r\n\r\n```csharp\r\npublic class CustomNavigationPoint\r\n{\r\n    public Vector3 Position { get; }          // Cover position\r\n    public CoverLevel CoverLevel { get; }     // Sit (low) or Stay (high)\r\n    public bool IsFreeById(int id) { }        // Check if occupied\r\n    public GroupPoint GroupPoint { get; }     // Associated Tarkov cover data\r\n    public bool IsSpotted { get; set; }       // Cover compromised\r\n    public Vector3 FirePosition { get; }      // Position to shoot from\r\n}\r\n\r\n// CoverLevel enum\r\npublic enum CoverLevel\r\n{\r\n    Sit = 0,    // Low cover (crouch required)\r\n    Stay = 1    // High cover (stand)\r\n}\r\n```\r\n\r\n### SAIN CoverPoint (Enhanced)\r\n\r\n**Extended cover point with scoring and path data:**\r\n\r\n```csharp\r\npublic class CoverPoint\r\n{\r\n    // Core Data\r\n    public Vector3 Position { get; }\r\n    public PathData PathData { get; }              // Navigation path to cover\r\n    public Collider Collider { get; }              // Physical cover collider\r\n    public SAINHardCoverData HardData { get; }     // Physical properties\r\n    public float CoverHeight { get; }              // Height of cover object\r\n    public bool Spotted { get; set; }              // Cover compromised\r\n    public Vector3 ProtectionDirection { get; }    // Direction cover protects from\r\n\r\n    // Distance Tracking\r\n    public float DistanceToBot { get; }\r\n    public DirectionData DirectionData { get; }\r\n\r\n    // Status\r\n    public CoverStatus StraightDistanceStatus { get; }  // InCover, CloseToCover, etc.\r\n    public CoverStatus PathDistanceStatus { get; }\r\n    public bool BotInThisCover { get; }\r\n\r\n    // Methods\r\n    public float GetDistance(Vector3 from) { }\r\n    public float GetDistanceSqr(Vector3 from) { }  // Faster\r\n    public bool ShallUpdate(string targetProfileId) { }\r\n    public void GetHit(DamageInfoStruct info, ...) { }\r\n    public void ResetGetHit() { }\r\n}\r\n```\r\n\r\n**CoverStatus Enum:**\r\n```csharp\r\npublic enum CoverStatus\r\n{\r\n    InCover,         // ‚â§ 1.25m\r\n    CloseToCover,    // ‚â§ 10m\r\n    MidRangeToCover, // ‚â§ 20m\r\n    FarFromCover     // > 20m\r\n}\r\n```\r\n\r\n### SAINHardCoverData\r\n\r\n**Physical cover properties:**\r\n```csharp\r\npublic class SAINHardCoverData\r\n{\r\n    public int Id { get; }           // Unique cover identifier\r\n    public float Height { get; }     // Collider height (y-axis)\r\n    public float Value { get; }      // Combined size metric (x+y+z)\r\n}\r\n```\r\n\r\n---\r\n\r\n## 2. Cover Search & Finding APIs\r\n\r\n### FriendlyPMC Cover Utilities (Proven Working)\r\n\r\n**File**: `LTFriendlyPMC/client/Utils/Covers.cs`\r\n\r\n#### GetClosestCoverPoint\r\n\r\n```csharp\r\npublic static CustomNavigationPoint GetClosestCoverPoint(\r\n    BotOwner botOwner,\r\n    Vector3 centerPosition,        // Search center\r\n    float searchRadius,            // Max search distance\r\n    Func<CustomNavigationPoint, bool> extraChecks = null  // Custom filter\r\n)\r\n{\r\n    // Get nearby covers from BotOwner\r\n    List<CustomNavigationPoint> nearbyCovers =\r\n        botOwner.Covers.GetClosePoints(centerPosition, searchRadius);\r\n\r\n    // Sort by squared distance (performance)\r\n    nearbyCovers = nearbyCovers\r\n        .OrderBy(cover => (cover.Position - centerPosition).sqrMagnitude)\r\n        .Take(MAX_COVERS_IRT)  // 20 points max\r\n        .ToList();\r\n\r\n    foreach (var point in nearbyCovers)\r\n    {\r\n        // Filter low-quality cover\r\n        if (point.CoverLevel != CoverLevel.Sit && point.CoverLevel != CoverLevel.Stay)\r\n            continue;\r\n\r\n        // Filter occupied\r\n        if (!point.IsFreeById(botOwner.Id))\r\n            continue;\r\n\r\n        // Filter too close to teammates (0.7m)\r\n        List<Vector3> teammatePositions = GetTeammatePositions(botOwner);\r\n        if (!Utils.IsDangerPositionFarEnough(point.Position, teammatePositions, 0.49f))\r\n            continue;\r\n\r\n        // Custom validation\r\n        if (extraChecks != null && !extraChecks(point))\r\n            continue;\r\n\r\n        return point;\r\n    }\r\n\r\n    return null;\r\n}\r\n```\r\n\r\n#### GetClosestCoverPointBetween\r\n\r\n```csharp\r\npublic static CustomNavigationPoint GetClosestCoverPointBetween(\r\n    BotOwner botOwner,\r\n    Vector3 pointA,               // Start (usually bot position)\r\n    Vector3 pointB,               // End (usually enemy position)\r\n    float safeDistance = 5f,      // Min distance from danger\r\n    Func<GroupPoint, bool> eligibilityCheck = null\r\n)\r\n{\r\n    List<CustomNavigationPoint> nearbyCovers =\r\n        botOwner.Covers.GetClosePoints(pointA, 50f);\r\n\r\n    nearbyCovers = nearbyCovers\r\n        .OrderBy(cover => (cover.Position - pointA).sqrMagnitude)\r\n        .Take(MAX_COVERS_IRT)\r\n        .ToList();\r\n\r\n    foreach (var point in nearbyCovers)\r\n    {\r\n        // Must be geometrically between A and B\r\n        if (!IsPointBetween(point.Position, pointA, pointB))\r\n            continue;\r\n\r\n        // Must maintain safe distance from danger (pointB)\r\n        if ((point.Position - pointB).sqrMagnitude < safeDistance * safeDistance)\r\n            continue;\r\n\r\n        // Quality and spacing filters\r\n        if (point.CoverLevel != CoverLevel.Sit && point.CoverLevel != CoverLevel.Stay)\r\n            continue;\r\n\r\n        if (!point.IsFreeById(botOwner.Id))\r\n            continue;\r\n\r\n        List<Vector3> teammatePositions = GetTeammatePositions(botOwner);\r\n        if (!Utils.IsDangerPositionFarEnough(point.Position, teammatePositions, 0.49f))\r\n            continue;\r\n\r\n        // Custom check\r\n        if (eligibilityCheck != null && !eligibilityCheck(point.GroupPoint))\r\n            continue;\r\n\r\n        return point;\r\n    }\r\n\r\n    return null;\r\n}\r\n```\r\n\r\n#### IsPointBetween\r\n\r\n```csharp\r\nprivate static bool IsPointBetween(Vector3 point, Vector3 A, Vector3 B)\r\n{\r\n    float distAtoP = Vector3.Distance(A, point);\r\n    float distPtoB = Vector3.Distance(point, B);\r\n    float distAtoB = Vector3.Distance(A, B);\r\n\r\n    // Point is between if sum of segments ‚âà total distance\r\n    return (distAtoP + distPtoB) <= (distAtoB + 2f);  // 2m tolerance\r\n}\r\n```\r\n\r\n#### GetCoverPoints (Multiple Results)\r\n\r\n```csharp\r\npublic static List<CustomNavigationPoint> GetCoverPoints(\r\n    BotOwner botOwner,\r\n    Vector3 centerPosition,\r\n    float searchRadius,\r\n    Func<CustomNavigationPoint, bool> eligibilityCheck = null,\r\n    int iterations = -1  // Max points (-1 = use MAX_COVERS_IRT)\r\n)\r\n{\r\n    List<CustomNavigationPoint> results = new List<CustomNavigationPoint>();\r\n\r\n    // Grid-based search (15x15x3m cells)\r\n    Vector3 targetArea = new Vector3(\r\n        Mathf.Floor(centerPosition.x / 15f) * 15f,\r\n        Mathf.Floor(centerPosition.y / 3f) * 3f,\r\n        Mathf.Floor(centerPosition.z / 15f) * 15f\r\n    );\r\n\r\n    // Get covers in grid cell\r\n    List<CustomNavigationPoint> nearbyCovers =\r\n        botOwner.Covers.GetClosePoints(targetArea, searchRadius);\r\n\r\n    int maxIterations = iterations > 0 ? iterations : MAX_COVERS_IRT;\r\n\r\n    nearbyCovers = nearbyCovers\r\n        .OrderBy(cover => (cover.Position - centerPosition).sqrMagnitude)\r\n        .Take(maxIterations)\r\n        .ToList();\r\n\r\n    foreach (var point in nearbyCovers)\r\n    {\r\n        // Standard filters\r\n        if (point.CoverLevel != CoverLevel.Sit && point.CoverLevel != CoverLevel.Stay)\r\n            continue;\r\n\r\n        if (!point.IsFreeById(botOwner.Id))\r\n            continue;\r\n\r\n        List<Vector3> teammatePositions = GetTeammatePositions(botOwner);\r\n        if (!Utils.IsDangerPositionFarEnough(point.Position, teammatePositions, 0.49f))\r\n            continue;\r\n\r\n        // Custom check\r\n        if (eligibilityCheck != null && !eligibilityCheck(point))\r\n            continue;\r\n\r\n        results.Add(point);\r\n    }\r\n\r\n    return results;\r\n}\r\n```\r\n\r\n#### FindShootPosition (Flanking)\r\n\r\n```csharp\r\npublic static Vector3? FindShootPosition(\r\n    BotOwner botOwner,\r\n    float minDistance,           // Min distance from target\r\n    float maxRadius,            // Max search radius\r\n    Func<Vector3, bool> eligibleCheck = null,\r\n    Vector3? manualTarget = null\r\n)\r\n{\r\n    Vector3 target = manualTarget ?? botOwner.Memory.GoalEnemy.CurrPosition;\r\n\r\n    // 72-step circular scan (5¬∞ increments)\r\n    for (int i = 0; i < 72; i++)\r\n    {\r\n        float angle = i * 5f;\r\n        Quaternion rotation = Quaternion.Euler(0, angle, 0);\r\n        Vector3 offset = rotation * Vector3.forward * minDistance;\r\n        Vector3 candidatePos = target + offset;\r\n\r\n        // NavMesh validation\r\n        NavMeshHit hit;\r\n        if (!NavMesh.SamplePosition(candidatePos, out hit, maxRadius, -1))\r\n            continue;\r\n\r\n        Vector3 navPos = hit.position;\r\n\r\n        // Distance check\r\n        float dist = Vector3.Distance(navPos, target);\r\n        if (dist < minDistance)\r\n            continue;\r\n\r\n        // Line-of-sight check\r\n        if (!CanShootToHead(botOwner, navPos, target))\r\n            continue;\r\n\r\n        // Custom eligibility\r\n        if (eligibleCheck != null && !eligibleCheck(navPos))\r\n            continue;\r\n\r\n        return navPos;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nprivate static bool CanShootToHead(BotOwner botOwner, Vector3 from, Vector3 enemyPos)\r\n{\r\n    Vector3 headHeight = Vector3.up * 1.6f;\r\n    Vector3 toHead = (enemyPos + headHeight) - (from + Vector3.up);\r\n\r\n    RaycastHit hit;\r\n    return !Physics.Raycast(from + Vector3.up, toHead.normalized,\r\n        out hit, toHead.magnitude, botOwner.LookSensor.Mask);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. Navigation & Movement Control\r\n\r\n### SAINMoverClass API\r\n\r\n**File**: `SAIN.SAINComponent.Classes.Mover.SAINMoverClass`\r\n\r\n#### Primary Movement Methods\r\n\r\n**RunToPoint:**\r\n```csharp\r\npublic bool RunToPoint(\r\n    Vector3 point,\r\n    bool mustHaveCompletePath = true,\r\n    float reachDist = -1f,              // -1 uses default 0.5m\r\n    ESprintUrgency urgency = ESprintUrgency.Low,\r\n    bool checkSameWay = true            // Try updating existing path\r\n)\r\n```\r\n\r\n**WalkToPoint:**\r\n```csharp\r\npublic bool WalkToPoint(\r\n    Vector3 point,\r\n    bool mustHaveCompletePath = true,\r\n    float reachDist = -1f,\r\n    bool checkSameWay = true\r\n)\r\n```\r\n\r\n**Go To Cover (Integrated):**\r\n```csharp\r\npublic bool GoToCoverPoint(\r\n    CoverPoint point,\r\n    bool sprint,\r\n    ESprintUrgency urgency = ESprintUrgency.Low\r\n)\r\n```\r\n\r\n#### Movement Control\r\n\r\n**Stop & Pause:**\r\n```csharp\r\nvoid Stop()                           // Cancel all movement\r\nvoid PauseMovement(float forDuration) // Temporarily pause\r\nvoid RecalcPath()                     // Request path recalc\r\n```\r\n\r\n**Pose Control:**\r\n```csharp\r\nbool SetTargetPose(float pose)        // 0=prone, 0.5=crouch, 1=stand\r\nvoid SetTargetMoveSpeed(float speed)  // Movement speed multiplier (0.0-1.0)\r\n```\r\n\r\n**Sprint Urgency:**\r\n```csharp\r\npublic enum ESprintUrgency\r\n{\r\n    None,    // Walk only\r\n    Low,     // Jog/slow sprint\r\n    Medium,  // Standard sprint\r\n    High     // Emergency sprint (combat)\r\n}\r\n```\r\n\r\n### PathData - Navigation Path\r\n\r\n**Properties:**\r\n```csharp\r\npublic class PathData\r\n{\r\n    public NavMeshPath Path { get; }           // Unity NavMesh path\r\n    public float PathLength { get; }           // Total distance\r\n    public int RoundedPathLength { get; }      // Floored distance\r\n    public float TimeSinceLastUpdated { get; } // Cache age\r\n}\r\n```\r\n\r\n**Path Calculation:**\r\n```csharp\r\npublic void CalcPath(Vector3 origin, Vector3 destination)\r\n{\r\n    Path.ClearCorners();\r\n    NavMesh.CalculatePath(origin, destination, -1, Path);\r\n\r\n    if (Path.status == NavMeshPathStatus.PathComplete)\r\n    {\r\n        PathLength = GClass371.CalculatePathLength(Path);\r\n        RoundedPathLength = Mathf.FloorToInt(PathLength);\r\n    }\r\n    else\r\n    {\r\n        PathLength = float.MaxValue;  // Unreachable\r\n    }\r\n\r\n    TimeLastUpdated = Time.time;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. Formation & Positioning Utilities\r\n\r\n### Spacing & Collision Prevention\r\n\r\n**IsDangerPositionFarEnough** (FriendlyPMC):\r\n```csharp\r\npublic static bool IsDangerPositionFarEnough(\r\n    Vector3 positionToCheck,\r\n    IEnumerable<Vector3> positionsIMustCare,\r\n    float minSDistToEnemy  // SQUARED distance!\r\n)\r\n{\r\n    foreach (var pos in positionsIMustCare)\r\n    {\r\n        if ((pos - positionToCheck).sqrMagnitude < minSDistToEnemy)\r\n            return false;  // Too close!\r\n    }\r\n    return true;\r\n}\r\n\r\n// Usage\r\nList<Vector3> teammatePositions = GetTeammatePositions();\r\nfloat minSpacing = 2f;\r\nfloat minSpacingSqr = minSpacing * minSpacing;\r\n\r\nif (!IsDangerPositionFarEnough(candidatePos, teammatePositions, minSpacingSqr))\r\n{\r\n    // Reject - too close to teammates\r\n}\r\n```\r\n\r\n### Formation Position Calculations\r\n\r\n**Circular Formation:**\r\n```csharp\r\npublic static Vector3 GetFormationOffset(\r\n    Vector3 leaderPosition,\r\n    Vector3 leaderForward,\r\n    int memberIndex,\r\n    int totalMembers,\r\n    float radius\r\n)\r\n{\r\n    float angleStep = 360f / totalMembers;\r\n    float angle = memberIndex * angleStep;\r\n\r\n    Quaternion rotation = Quaternion.Euler(0, angle, 0);\r\n    Vector3 offset = rotation * (leaderForward * radius);\r\n\r\n    return leaderPosition + offset;\r\n}\r\n```\r\n\r\n**Wedge Formation:**\r\n```csharp\r\npublic static Vector3 GetWedgePosition(\r\n    Vector3 leaderPos,\r\n    Vector3 leaderForward,\r\n    int memberIndex,  // 0=leader, 1-2=flanks, 3-4=rear\r\n    float spacing = 3f\r\n)\r\n{\r\n    if (memberIndex == 0) return leaderPos;\r\n\r\n    Vector3 right = Vector3.Cross(Vector3.up, leaderForward).normalized;\r\n\r\n    int side = (memberIndex % 2 == 0) ? 1 : -1;  // Alternate left/right\r\n    int row = (memberIndex + 1) / 2;             // Row depth\r\n\r\n    Vector3 lateralOffset = right * (side * spacing * row);\r\n    Vector3 depthOffset = -leaderForward * (spacing * (row - 1));\r\n\r\n    return leaderPos + lateralOffset + depthOffset;\r\n}\r\n```\r\n\r\n**Line Formation:**\r\n```csharp\r\npublic static Vector3 GetLinePosition(\r\n    Vector3 leaderPos,\r\n    Vector3 leaderForward,\r\n    int memberIndex,\r\n    float spacing = 2.5f\r\n)\r\n{\r\n    Vector3 right = Vector3.Cross(Vector3.up, leaderForward).normalized;\r\n\r\n    // 0=center, 1=right, 2=left, 3=right2, etc.\r\n    int offset = (memberIndex + 1) / 2;\r\n    int side = (memberIndex % 2 == 0) ? 1 : -1;\r\n\r\n    return leaderPos + (right * side * spacing * offset);\r\n}\r\n```\r\n\r\n**Column Formation:**\r\n```csharp\r\npublic static Vector3 GetColumnPosition(\r\n    Vector3 leaderPos,\r\n    Vector3 leaderForward,\r\n    int memberIndex,\r\n    float spacing = 2f\r\n)\r\n{\r\n    // File formation - straight line behind leader\r\n    return leaderPos - (leaderForward * spacing * memberIndex);\r\n}\r\n```\r\n\r\n### Position Validation & Correction\r\n\r\n**Validate NavMesh Position:**\r\n```csharp\r\npublic static bool ValidateAndCorrectPosition(\r\n    ref Vector3 position,\r\n    float sampleRange = 1.5f\r\n)\r\n{\r\n    NavMeshHit hit;\r\n    if (NavMesh.SamplePosition(position, out hit, sampleRange, -1))\r\n    {\r\n        position = hit.position;  // Snap to navmesh\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n**Formation Position with Fallback:**\r\n```csharp\r\npublic static Vector3? GetValidFormationPosition(\r\n    Vector3 idealPosition,\r\n    Vector3 fallbackDirection,\r\n    List<Vector3> occupiedPositions,\r\n    float minSpacing = 2f\r\n)\r\n{\r\n    // Try ideal position\r\n    if (ValidateAndCorrectPosition(ref idealPosition) &&\r\n        IsDangerPositionFarEnough(idealPosition, occupiedPositions,\r\n            minSpacing * minSpacing))\r\n    {\r\n        return idealPosition;\r\n    }\r\n\r\n    // Try fallback positions in arc (¬±15¬∞, ¬±30¬∞, ¬±45¬∞)\r\n    for (int angle = 15; angle <= 45; angle += 15)\r\n    {\r\n        Vector3 leftPos = RotatePointAroundPivot(idealPosition,\r\n            fallbackDirection, angle);\r\n        Vector3 rightPos = RotatePointAroundPivot(idealPosition,\r\n            fallbackDirection, -angle);\r\n\r\n        if (ValidateAndCorrectPosition(ref leftPos) &&\r\n            IsDangerPositionFarEnough(leftPos, occupiedPositions,\r\n                minSpacing * minSpacing))\r\n        {\r\n            return leftPos;\r\n        }\r\n\r\n        if (ValidateAndCorrectPosition(ref rightPos) &&\r\n            IsDangerPositionFarEnough(rightPos, occupiedPositions,\r\n                minSpacing * minSpacing))\r\n        {\r\n            return rightPos;\r\n        }\r\n    }\r\n\r\n    return null;  // No valid position\r\n}\r\n\r\nprivate static Vector3 RotatePointAroundPivot(\r\n    Vector3 point,\r\n    Vector3 forward,\r\n    float angleDegrees\r\n)\r\n{\r\n    Quaternion rotation = Quaternion.Euler(0, angleDegrees, 0);\r\n    return rotation * forward;\r\n}\r\n```\r\n\r\n**IsNavigablePoint** (FriendlyPMC):\r\n```csharp\r\npublic static bool IsNavigablePoint(\r\n    Vector3 botPosition,\r\n    Vector3 point,\r\n    float maxDistance,\r\n    NavMeshPath existingMesh = null\r\n)\r\n{\r\n    NavMeshPath navMeshPath = existingMesh ?? new NavMeshPath();\r\n    navMeshPath.ClearCorners();\r\n\r\n    if (NavMesh.CalculatePath(botPosition, point, -1, navMeshPath) &&\r\n        navMeshPath.status == NavMeshPathStatus.PathComplete)\r\n    {\r\n        float dist = navMeshPath.CalculatePathLength();\r\n        return dist <= maxDistance;\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 5. Tactical Geometry Calculations\r\n\r\n### DirectionData Structure\r\n\r\n**Comprehensive directional analysis:**\r\n\r\n```csharp\r\npublic struct DirectionData\r\n{\r\n    public Vector3 Position;\r\n    public Vector3 Direction;              // Raw direction vector\r\n    public Vector3 DirectionNormalized;    // Unit vector\r\n    public float Distance;                 // Euclidean distance\r\n    public float Dot;                      // Dot product with look direction\r\n    public float HorizontalAngle;          // Yaw angle (degrees)\r\n    public float VerticalAngle;            // Pitch angle (degrees)\r\n    public float YDifference;              // Height difference\r\n\r\n    public void Update(Vector3 Origin)\r\n    {\r\n        Direction = Position - Origin;\r\n        DirectionNormalized = Direction.normalized;\r\n        Distance = Direction.magnitude;\r\n    }\r\n\r\n    public void UpdateDotProduct(Vector3 LookDirection)\r\n    {\r\n        Dot = Vector3.Dot(LookDirection, DirectionNormalized);\r\n    }\r\n}\r\n```\r\n\r\n### Angle Utilities\r\n\r\n**Horizontal Angle (Yaw):**\r\n```csharp\r\npublic static float CalcHorizontalAngle(Vector3 targetDir, Vector3 lookDir)\r\n{\r\n    targetDir.y = 0f;\r\n    lookDir.y = 0f;\r\n    return Vector3.SignedAngle(lookDir, targetDir, Vector3.up);\r\n}\r\n```\r\n\r\n**Vertical Angle (Pitch):**\r\n```csharp\r\npublic static float CalcVerticalAngle(\r\n    Vector3 targetDir,\r\n    Vector3 lookDir,\r\n    out float yDiff\r\n)\r\n{\r\n    Vector3 flatTarget = new Vector3(lookDir.x, targetDir.y, lookDir.z);\r\n    yDiff = (flatTarget.y - lookDir.y).Round100();\r\n\r\n    if (yDiff == 0f) return 0f;\r\n\r\n    return Vector3.Angle(lookDir, flatTarget);\r\n}\r\n```\r\n\r\n**Angle to Point:**\r\n```csharp\r\npublic float AngleToPoint(Vector3 point, Vector3 weaponRoot, Vector3 lookDir)\r\n{\r\n    Vector3 dirToPoint = (point - weaponRoot).normalized;\r\n    return Vector3.Angle(lookDir, dirToPoint);\r\n}\r\n```\r\n\r\n### Sector Calculations\r\n\r\n**Point in Sector Check:**\r\n```csharp\r\npublic static bool IsPointInSector(\r\n    Vector3 point,\r\n    Vector3 sectorOrigin,\r\n    Vector3 sectorDirection,\r\n    float sectorHalfAngle,   // Half-angle in degrees (e.g., 45¬∞ = 90¬∞ sector)\r\n    float maxDistance\r\n)\r\n{\r\n    Vector3 toPoint = point - sectorOrigin;\r\n\r\n    // Distance check (squared for performance)\r\n    if (toPoint.sqrMagnitude > maxDistance * maxDistance)\r\n        return false;\r\n\r\n    // Angle check\r\n    Vector3 toPointNorm = toPoint.normalized;\r\n    float angle = Vector3.Angle(sectorDirection, toPointNorm);\r\n\r\n    return angle <= sectorHalfAngle;\r\n}\r\n```\r\n\r\n**Breach Entry Sectors:**\r\n```csharp\r\npublic enum BreachSector\r\n{\r\n    Left,       // Left stack position\r\n    Right,      // Right stack position\r\n    Center,     // Center (point man/breacher)\r\n    RearLeft,   // Left support\r\n    RearRight   // Right support\r\n}\r\n\r\npublic static Vector3 GetBreachPosition(\r\n    Vector3 doorPosition,\r\n    Vector3 doorForward,\r\n    BreachSector sector,\r\n    float stackDistance = 0.75f\r\n)\r\n{\r\n    Vector3 right = Vector3.Cross(Vector3.up, doorForward).normalized;\r\n    Vector3 back = -doorForward;\r\n\r\n    switch (sector)\r\n    {\r\n        case BreachSector.Left:\r\n            return doorPosition + (right * stackDistance) + (back * 0.5f);\r\n\r\n        case BreachSector.Right:\r\n            return doorPosition + (-right * stackDistance) + (back * 0.5f);\r\n\r\n        case BreachSector.Center:\r\n            return doorPosition + (back * 0.3f);\r\n\r\n        case BreachSector.RearLeft:\r\n            return doorPosition + (right * stackDistance * 1.5f) + (back * stackDistance);\r\n\r\n        case BreachSector.RearRight:\r\n            return doorPosition + (-right * stackDistance * 1.5f) + (back * stackDistance);\r\n\r\n        default:\r\n            return doorPosition + (back * 0.5f);\r\n    }\r\n}\r\n```\r\n\r\n### Distance Utilities\r\n\r\n**Squared Distance (Fast):**\r\n```csharp\r\npublic static bool IsWithinDistance(Vector3 a, Vector3 b, float maxDist)\r\n{\r\n    return (a - b).sqrMagnitude <= maxDist * maxDist;\r\n}\r\n```\r\n\r\n**Path Distance:**\r\n```csharp\r\npublic static float GetNavDistance(Vector3 point1, Vector3 point2,\r\n    NavMeshPath existingMesh = null)\r\n{\r\n    NavMeshPath navMeshPath = existingMesh ?? new NavMeshPath();\r\n    navMeshPath.ClearCorners();\r\n\r\n    if (NavMesh.CalculatePath(point1, point2, -1, navMeshPath) &&\r\n        navMeshPath.status == NavMeshPathStatus.PathComplete)\r\n    {\r\n        return navMeshPath.CalculatePathLength();\r\n    }\r\n\r\n    // Fallback to straight-line\r\n    return Vector3.Distance(point2, point1);\r\n}\r\n```\r\n\r\n**Path Length Extension:**\r\n```csharp\r\npublic static float CalculatePathLength(this NavMeshPath path)\r\n{\r\n    float length = 0f;\r\n    for (int i = 1; i < path.corners.Length; i++)\r\n    {\r\n        length += Vector3.Distance(path.corners[i - 1], path.corners[i]);\r\n    }\r\n    return length;\r\n}\r\n```\r\n\r\n### Line-of-Sight\r\n\r\n**CanShootToTarget:**\r\n```csharp\r\npublic static bool CanShootToTarget(\r\n    ShootPointClass shootToPoint,\r\n    Vector3 firePos,\r\n    LayerMask mask,\r\n    bool doubleSide = false\r\n)\r\n{\r\n    if (shootToPoint == null) return false;\r\n\r\n    Vector3 direction = shootToPoint.Point - firePos;\r\n    float distance = direction.magnitude;\r\n\r\n    RaycastHit[] hits = new RaycastHit[1];\r\n\r\n    // Forward raycast\r\n    if (Physics.RaycastNonAlloc(new Ray(firePos, direction), hits,\r\n        distance * shootToPoint.DistCoef, mask) == 0)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    // Reverse check if double-sided\r\n    if (doubleSide && Physics.RaycastNonAlloc(\r\n        new Ray(shootToPoint.Point, -direction), hits, distance, mask) == 0)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 6. Performance Optimization Tips\r\n\r\n### 1. Always Use Squared Distance\r\n\r\n```csharp\r\n// ‚ùå BAD - Expensive sqrt\r\nif (Vector3.Distance(a, b) < maxDist)\r\n\r\n// ‚úÖ GOOD - Squared (3x faster)\r\nif ((a - b).sqrMagnitude < maxDist * maxDist)\r\n```\r\n\r\n### 2. Reuse NavMeshPath Objects\r\n\r\n```csharp\r\n// Reuse to avoid allocations\r\nprivate NavMeshPath _cachedPath = new NavMeshPath();\r\n\r\npublic bool FindPath(Vector3 start, Vector3 end)\r\n{\r\n    _cachedPath.ClearCorners();\r\n    return NavMesh.CalculatePath(start, end, -1, _cachedPath);\r\n}\r\n```\r\n\r\n### 3. Throttle Cover Search\r\n\r\n```csharp\r\nprivate float _nextCoverSearchTime;\r\nprivate const float COVER_SEARCH_INTERVAL = 0.5f;\r\n\r\nif (Time.time < _nextCoverSearchTime) return;\r\n_nextCoverSearchTime = Time.time + COVER_SEARCH_INTERVAL;\r\n```\r\n\r\n### 4. Limit Iterations\r\n\r\n```csharp\r\n// Only check closest 20 covers\r\nnearbyCovers.OrderBy(c => (c.Position - pos).sqrMagnitude)\r\n            .Take(20)\r\n            .ToList();\r\n```\r\n\r\n### 5. Early Exit Filters\r\n\r\n```csharp\r\n// Cheapest checks first\r\nif (!point.IsFreeById(id)) return false;           // Bool check\r\nif ((point.Position - pos).sqrMagnitude > maxSqr) return false;  // Distance\r\nif (!IsNavigablePoint(pos, point.Position, max)) return false;   // Expensive\r\n```\r\n\r\n### 6. Grid-Based Spatial Partitioning\r\n\r\n```csharp\r\nconst float GRID_SIZE = 15f;\r\n\r\nVector3 GridKey(Vector3 position)\r\n{\r\n    return new Vector3(\r\n        Mathf.Floor(position.x / GRID_SIZE) * GRID_SIZE,\r\n        Mathf.Floor(position.y / 3f) * 3f,\r\n        Mathf.Floor(position.z / GRID_SIZE) * GRID_SIZE\r\n    );\r\n}\r\n\r\n// Only update when changing cells\r\nif (GridKey(currentPos) != GridKey(lastPos))\r\n{\r\n    UpdateCoverSearch();\r\n}\r\n```\r\n\r\n### 7. Pre-Calculate Values\r\n\r\n```csharp\r\n// Cache frequently used values\r\nprivate Vector3 _cachedEnemyDirection;\r\nprivate float _cachedEnemyDistance;\r\nprivate float _nextCacheUpdate;\r\n\r\nvoid UpdateCache()\r\n{\r\n    if (Time.time < _nextCacheUpdate) return;\r\n    _nextCacheUpdate = Time.time + 0.1f;\r\n\r\n    Vector3 toEnemy = enemyPos - botPos;\r\n    _cachedEnemyDirection = toEnemy.normalized;\r\n    _cachedEnemyDistance = toEnemy.magnitude;\r\n}\r\n```\r\n\r\n### 8. Batch Raycasts\r\n\r\n```csharp\r\n// Reuse array to avoid allocations\r\nprivate RaycastHit[] _raycastHits = new RaycastHit[1];\r\n\r\nbool QuickRaycast(Vector3 from, Vector3 to, LayerMask mask)\r\n{\r\n    Vector3 dir = to - from;\r\n    return Physics.RaycastNonAlloc(\r\n        from, dir.normalized, _raycastHits, dir.magnitude, mask\r\n    ) == 0;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Summary: Key APIs Quick Reference\r\n\r\n### Finding Cover\r\n```csharp\r\nCustomNavigationPoint cover = Covers.GetClosestCoverPoint(botOwner, centerPos, radius, filter);\r\nVector3? flankPos = Covers.FindShootPosition(botOwner, minDist, maxRadius, filter);\r\n```\r\n\r\n### Movement\r\n```csharp\r\nSAINMoverClass mover = GetSAINMover(botOwner);\r\nmover.RunToPoint(position, urgency: ESprintUrgency.High);\r\nmover.WalkToPoint(position, reachDist: 1f);\r\nmover.SetTargetPose(0.5f);  // Crouch\r\n```\r\n\r\n### Formation\r\n```csharp\r\nVector3 pos = GetWedgePosition(leaderPos, leaderForward, index, spacing);\r\nbool valid = ValidateAndCorrectPosition(ref pos);\r\n```\r\n\r\n### Navigation\r\n```csharp\r\nNavMeshPath path = new NavMeshPath();\r\nNavMesh.CalculatePath(start, end, -1, path);\r\nfloat length = path.CalculatePathLength();\r\n```\r\n\r\n### Spacing\r\n```csharp\r\nbool farEnough = IsDangerPositionFarEnough(pos, teammates, minSpacingSqr);\r\n```\r\n\r\n---\r\n\r\n**With this documentation, you can implement: Dynamic Formations, Breach Stacking, Bounding Overwatch, Casualty Evacuation Routes, and Coordinated Movement!**\r\n"},"09-Item-Loot-System":{"title":"Tarkov Item, Inventory & Loot System - API Documentation\r","category":"Core Systems","content":"# Tarkov Item, Inventory & Loot System - API Documentation\r\n\r\n**Priority**: MEDIUM - Enables Phase 10, Innovation #3 (Ammo Sharing)\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\nBased on analysis of BotItemTaker, FriendlyPMC loot implementation, and SAIN magazine management.\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nTarkov's item and inventory system provides APIs for tracking loot, manipulating inventories, transferring items, and managing ammo/magazines. This document covers complete implementation for loot return systems and tactical ammo management.\r\n\r\n---\r\n\r\n## 1. Item Class Structure\r\n\r\n### Core Item Types\r\n\r\n```csharp\r\n// Base Item Class (EFT.InventoryLogic)\r\npublic class Item\r\n{\r\n    public string Id { get; }                    // Unique instance ID\r\n    public string TemplateId { get; }            // Item template/type\r\n    public string Name { get; }                  // Item name\r\n    public ItemTemplate Template { get; }        // Template definition\r\n    public List<IItemComponent> Components { get; }\r\n    public bool IsUnremovable { get; }\r\n    public ItemAddress Address { get; }          // Location in inventory\r\n    public IContainer Parent { get; }            // Parent container\r\n\r\n    // Methods\r\n    public Item CloneItem();                     // Create copy\r\n    public T GetItemComponent<T>();              // Get component\r\n}\r\n```\r\n\r\n**Specialized Item Classes**:\r\n```csharp\r\npublic class MagazineItemClass : Item\r\n{\r\n    public int Count { get; }                    // Current ammo\r\n    public int MaxCount { get; }                 // Capacity\r\n    public AmmoTemplate CurrentAmmoTemplate { get; }\r\n}\r\n\r\npublic class AmmoItemClass : Item\r\n{\r\n    public int Count { get; }                    // Stack count\r\n    public AmmoTemplate AmmoTemplate { get; }\r\n}\r\n\r\npublic class Weapon : Item\r\n{\r\n    public Slot GetMagazineSlot();\r\n    public MagazineItemClass GetCurrentMagazine();\r\n    public Slot[] Slots { get; }                 // Attachments\r\n}\r\n\r\npublic class MedsItemClass : Item { }\r\npublic class ThrowWeapItemClass : Item { }      // Grenades\r\npublic class BackpackItemClass : SearchableItemItemClass { }\r\npublic class VestItemClass : SearchableItemItemClass { }\r\npublic class ArmorItemClass : Item { }\r\npublic class HeadwearItemClass : Item { }\r\n\r\npublic class SearchableItemItemClass : Item\r\n{\r\n    public StashGridClass[] Grids { get; }      // Interior grids\r\n    public List<Item> GetAllItems();            // Get all items recursively\r\n}\r\n```\r\n\r\n---\r\n\r\n## 2. Inventory Controller API\r\n\r\n### InventoryController Class\r\n\r\n```csharp\r\npublic class InventoryController : TraderControllerClass\r\n{\r\n    public InventoryEquipment Inventory { get; }\r\n    public Player GetPlayer { get; }\r\n\r\n    // Finding Space\r\n    public ItemAddress FindSlotToPickUp(Item item);\r\n    public ItemAddress FindGridToPickUp(Item item);\r\n\r\n    // Item Queries\r\n    public void GetReachableItemsOfTypeNonAlloc<T>(\r\n        IList<T> list,\r\n        Predicate<T> predicate = null);\r\n\r\n    // Magazine Validation\r\n    public void StrictCheckMagazine(\r\n        MagazineItemClass magazine,\r\n        bool status = false);\r\n\r\n    // Transactions\r\n    public void RunNetworkTransaction(\r\n        IRaiseEvents operation,\r\n        Callback<IResult> callback = null);\r\n\r\n    public GStruct<GInterface424> TryRunNetworkTransaction(\r\n        GStruct<GInterface424> operation,\r\n        Callback callback = null);\r\n}\r\n```\r\n\r\n### Equipment Slots\r\n\r\n```csharp\r\npublic enum EquipmentSlot\r\n{\r\n    FirstPrimaryWeapon,      // Main weapon\r\n    SecondPrimaryWeapon,     // Secondary weapon\r\n    Holster,                 // Sidearm\r\n    Backpack,                // Main storage\r\n    TacticalVest,            // Vest/rig\r\n    ArmorVest,               // Body armor\r\n    Headwear,                // Helmet\r\n    Earpiece,                // Headset\r\n    FaceCover,               // Face mask\r\n    Eyewear,                 // Glasses\r\n    ArmBand,                 // Armband\r\n    Pockets,                 // Pocket storage\r\n    SecuredContainer,        // Gamma/secure\r\n    Dogtag,                  // Dogtag\r\n    Scabbard                 // Knife\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. BotItemTaker System\r\n\r\n**File**: `ilspy-out/BotItemTaker.decompiled.cs` (12KB)\r\n\r\n### Key Properties\r\n\r\n```csharp\r\npublic class BotItemTaker : GClass429\r\n{\r\n    public HashSet<LootItem> ThrownItems { get; }      // Lootable items\r\n    public HashSet<LootItem> PreThrownItems { get; }   // Being evaluated\r\n    public LootItem ItemToTake { get; }                // Current target\r\n\r\n    public bool IsCome { get; }                 // At item location\r\n    public float TimeToTake { get; }            // Pickup timestamp\r\n    public bool CanPickUpMeds { get; }\r\n    public bool CanPickUpWeapons { get; }\r\n\r\n    // Events\r\n    public event Action<Item, IPlayer> OnItemTaken;\r\n\r\n    // Methods\r\n    public void Activate();\r\n    public bool HaveItemToTake();\r\n    public void RefreshClosestItems();\r\n    public void ManualUpdate();\r\n}\r\n```\r\n\r\n### Item Detection\r\n\r\n**Pickup Distance**:\r\n```csharp\r\nconst float SDIST_TO_TAKE = 2.25f;  // 1.5m pickup range (squared)\r\n```\r\n\r\n**Closest Item Selection**:\r\n```csharp\r\n// Called every 2 seconds\r\npublic void RefreshClosestItems()\r\n{\r\n    ItemToTake = null;\r\n    float minDist = float.MaxValue;\r\n\r\n    foreach (LootItem loot in ThrownItems)\r\n    {\r\n        // Skip physics items (still moving)\r\n        if (loot.IsPhysicsOn)\r\n            continue;\r\n\r\n        // Check pathable\r\n        if (!IsReachable(loot.transform.position))\r\n            continue;\r\n\r\n        // Check can fit\r\n        if (!CanFitInInventory(loot.Item))\r\n            continue;\r\n\r\n        // Check not being taken by teammate\r\n        if (IsBeingTakenByTeammate(loot))\r\n            continue;\r\n\r\n        // Check distance\r\n        float distSqr = (loot.transform.position - botPosition).sqrMagnitude;\r\n        if (distSqr < minDist)\r\n        {\r\n            minDist = distSqr;\r\n            ItemToTake = loot;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. Item Transfer System\r\n\r\n### InteractionsHandlerClass\r\n\r\n**Primary API for item movement**:\r\n\r\n```csharp\r\n// Quick find space and create move operation\r\npublic static GStruct154<GInterface424> QuickFindAppropriatePlace(\r\n    Item item,\r\n    InventoryController targetInventory,\r\n    IEnumerable<InventoryEquipment> searchTargets,\r\n    EMoveItemOrder moveOrder,\r\n    bool simulate\r\n);\r\n\r\n// Create move operation\r\npublic static GStruct<GInterface424> Move(\r\n    Item item,\r\n    ItemAddress destination,\r\n    InventoryController targetInventory,\r\n    bool simulate\r\n);\r\n\r\n// Move priority orders\r\npublic enum EMoveItemOrder\r\n{\r\n    PickUp,                    // General pickup\r\n    PrioritizeTargetsOrder,    // Special items (grenades, meds, mags)\r\n    SortingTable,              // Organizing\r\n    Loot                       // Raid loot\r\n}\r\n```\r\n\r\n### Complete Pickup Flow\r\n\r\n```csharp\r\n// 1. Find appropriate space\r\nvar gStruct = InteractionsHandlerClass.QuickFindAppropriatePlace(\r\n    item,\r\n    inventoryController,\r\n    equipment.ToEnumerable<InventoryEquipment>(),\r\n    InteractionsHandlerClass.EMoveItemOrder.PickUp,\r\n    simulate: true  // Dry run\r\n);\r\n\r\n// 2. Check if space found\r\nif (gStruct.Succeeded)\r\n{\r\n    // 3. Execute transaction\r\n    inventoryController.RunNetworkTransaction(\r\n        gStruct.Value,  // The operation\r\n        (IResult result) =>\r\n        {\r\n            if (result.Succeed)\r\n            {\r\n                // Success\r\n                OnItemPickedUp(item);\r\n            }\r\n        });\r\n}\r\n```\r\n\r\n---\r\n\r\n## 5. Ammo & Magazine Management\r\n\r\n### Magazine Refill System (SAIN)\r\n\r\n```csharp\r\npublic static bool RefillMags(\r\n    BotComponent bot,\r\n    BotWeaponInfo weapon,\r\n    int numberToRefill = -1,      // -1 = all\r\n    bool includeActiveMag = false)\r\n{\r\n    Slot magazineSlot = weapon.weapon.GetMagazineSlot();\r\n    if (magazineSlot?.ContainedItem is not MagazineItemClass activeMag)\r\n        return false;\r\n\r\n    // Collect all magazines\r\n    _preAllocMagList.Clear();\r\n    bot.Player.InventoryController.GetReachableItemsOfTypeNonAlloc(\r\n        _preAllocMagList,\r\n        null);\r\n\r\n    if (_preAllocMagList.Count == 0)\r\n        return false;\r\n\r\n    int refilled = 0, full = 0;\r\n\r\n    foreach (MagazineItemClass mag in _preAllocMagList)\r\n    {\r\n        // Check compatibility\r\n        if (!GClass3124.CanAccept(magazineSlot, mag))\r\n            continue;\r\n\r\n        // Refill if not full\r\n        if (mag.Count < mag.MaxCount)\r\n        {\r\n            weapon.Reload.method_2(weapon.weapon, mag);\r\n            refilled++;\r\n        }\r\n        else\r\n        {\r\n            full++;\r\n        }\r\n\r\n        if (numberToRefill >= 0 && refilled >= numberToRefill)\r\n            break;\r\n    }\r\n\r\n    _preAllocMagList.Clear();\r\n    return refilled > 0 || full >= numberToRefill;\r\n}\r\n```\r\n\r\n### Ammo Ratio Calculation\r\n\r\n```csharp\r\npublic static float GetAmmoRatio(MagazineItemClass magazine)\r\n{\r\n    if (magazine == null)\r\n        return 0f;\r\n\r\n    return (float)magazine.Count / (float)magazine.MaxCount;\r\n}\r\n\r\n// Usage\r\nWeapon weapon = botOwner.WeaponManager.CurrentWeapon;\r\nMagazineItemClass mag = weapon.GetCurrentMagazine();\r\nfloat ratio = GetAmmoRatio(mag);\r\n\r\nif (ratio < 0.3f)\r\n{\r\n    // Low on ammo - reload or share\r\n}\r\n```\r\n\r\n---\r\n\r\n## 6. Equipment Locking System\r\n\r\n### Prevent Player Looting Bot Equipment\r\n\r\n**FriendlyPMC Pattern**:\r\n```csharp\r\npublic static void StoreEquipment(Profile profile)\r\n{\r\n    var equipment = profile.Inventory.Equipment;\r\n    List<string> itemIds = new List<string>();\r\n\r\n    foreach (EquipmentSlot slotType in Enum.GetValues(typeof(EquipmentSlot)))\r\n    {\r\n        // Skip lootable slots\r\n        if (slotType is EquipmentSlot.Dogtag or\r\n                        EquipmentSlot.SecuredContainer or\r\n                        EquipmentSlot.Pockets or\r\n                        EquipmentSlot.ArmBand or\r\n                        EquipmentSlot.Scabbard)\r\n            continue;\r\n\r\n        Slot botSlot = equipment.GetSlot(slotType);\r\n        if (botSlot.IsSpecial || botSlot.ContainedItem == null)\r\n            continue;\r\n\r\n        Item contained = botSlot.ContainedItem;\r\n\r\n        // Add unlootable component\r\n        var components = AccessTools.Field(typeof(Item), \"Components\")\r\n            .GetValue(contained) as List<IItemComponent>;\r\n        components.Add(new UnlootableComponent(contained, contained.Template));\r\n\r\n        itemIds.Add(contained.Id);\r\n\r\n        // Lock weapon mods (except magazines)\r\n        if (contained is Weapon weapon)\r\n        {\r\n            foreach (Slot modSlot in weapon.Slots)\r\n            {\r\n                if (modSlot.Locked || modSlot.ContainedItem == null)\r\n                    continue;\r\n\r\n                if (modSlot.ContainedItem is MagazineItemClass or AmmoItemClass)\r\n                    continue;  // Ammo is lootable\r\n\r\n                itemIds.Add(modSlot.ContainedItem.Id);\r\n            }\r\n        }\r\n    }\r\n\r\n    _followersEquipment[profile.ProfileId] = itemIds;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7. Phase 10: Loot Return Implementation\r\n\r\n### Complete Workflow\r\n\r\n**Step 1: Track Items Bot Picks Up**:\r\n```csharp\r\n// Hook into pickup event\r\nbotItemTaker.OnItemTaken += (item, lastOwner) =>\r\n{\r\n    // Don't track items player dropped (prevent duplication)\r\n    if (lastOwner != null && lastOwner.ProfileId == playerProfileId)\r\n        return;\r\n\r\n    // Store item ID for this bot\r\n    InteractableObjects.StoreItem(botOwner, item);\r\n};\r\n```\r\n\r\n**Step 2: Gather Items on Extraction**:\r\n```csharp\r\nprivate void GatherItems()\r\n{\r\n    _toSendItems.Clear();\r\n\r\n    foreach (var bot in GetAllFollowers())\r\n    {\r\n        if (!bot.HealthController.IsAlive)\r\n            continue;  // Dead bots don't return loot\r\n\r\n        var storedItems = InteractableObjects.GetStoredItems(bot.ProfileId);\r\n        if (storedItems == null || storedItems.Count == 0)\r\n            continue;\r\n\r\n        var inventoryController = bot.GetPlayer.InventoryController;\r\n\r\n        foreach (var itemId in storedItems)\r\n        {\r\n            // Search all containers\r\n            Item found = FindItemInInventory(inventoryController, itemId);\r\n            if (found != null)\r\n            {\r\n                _toSendItems.Add(found.CloneItem());\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Step 3: Convert and Send to Server**:\r\n```csharp\r\nprivate bool SendLootToServer()\r\n{\r\n    GatherItems();\r\n\r\n    // Convert tree structure to flat array\r\n    var flatItems = Singleton<ItemFactoryClass>.Instance\r\n        .TreeToFlatItems(_toSendItems);\r\n\r\n    if (flatItems != null && flatItems.Any())\r\n    {\r\n        RequestHandler.PutJson(\"/singleplayer/returnitems\", new\r\n        {\r\n            items = flatItems,\r\n        }.ToJson(_defaultJsonConverters));\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n### Item Search Utility\r\n\r\n```csharp\r\nprivate Item FindItemInInventory(InventoryController controller, string itemId)\r\n{\r\n    var equipment = controller.Inventory.Equipment;\r\n\r\n    // Check all equipment slots\r\n    foreach (var slot in equipment.Slots)\r\n    {\r\n        if (slot.ContainedItem?.Id == itemId)\r\n            return slot.ContainedItem;\r\n\r\n        // Search containers\r\n        if (slot.ContainedItem is SearchableItemItemClass searchable)\r\n        {\r\n            var found = searchable.GetAllItems()\r\n                .FirstOrDefault(i => i.Id == itemId);\r\n\r\n            if (found != null)\r\n                return found;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 8. Code Examples\r\n\r\n### Example 1: Complete Loot Pickup\r\n\r\n**File**: `LTFriendlyPMC/client/Actions/FollowerTakeLoot.cs`\r\n\r\n```csharp\r\nprivate async Task PickupLoot()\r\n{\r\n    Item item = _lootItem.Item;\r\n    InventoryController inventoryController = botOwner.GetPlayer.InventoryController;\r\n    InventoryEquipment equipment = inventoryController.Inventory.Equipment;\r\n\r\n    bool wasTransferred = false;\r\n\r\n    // Priority 1: Special items (grenades, meds, magazines)\r\n    List<Type> specialTypes = new List<Type> {\r\n        typeof(ThrowWeapItemClass),\r\n        typeof(MedicalItemClass),\r\n        typeof(MagazineItemClass)\r\n    };\r\n\r\n    if (specialTypes.Any(t => item.GetType() == t))\r\n    {\r\n        var gStruct = InteractionsHandlerClass.QuickFindAppropriatePlace(\r\n            item,\r\n            inventoryController,\r\n            equipment.ToEnumerable<InventoryEquipment>(),\r\n            InteractionsHandlerClass.EMoveItemOrder.PrioritizeTargetsOrder,\r\n            true);\r\n\r\n        if (gStruct.Succeeded)\r\n        {\r\n            botOwner.ItemTaker.method_1(\r\n                botOwner.GetPlayer,\r\n                gStruct.Value,\r\n                _lootItem.ItemOwner.RootItem,\r\n                _lootItem.LastOwner);\r\n\r\n            wasTransferred = true;\r\n\r\n            // Validate magazine\r\n            if (item is MagazineItemClass mag)\r\n            {\r\n                inventoryController.StrictCheckMagazine(mag, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Priority 2: Equipment\r\n    if (!wasTransferred && (item is BackpackItemClass or\r\n                           ArmorItemClass or\r\n                           VestItemClass or\r\n                           HeadwearItemClass))\r\n    {\r\n        ItemAddress slotLocation = inventoryController.FindSlotToPickUp(item);\r\n        if (slotLocation != null)\r\n        {\r\n            var gstruct = InteractionsHandlerClass.Move(\r\n                item, slotLocation, inventoryController, true);\r\n\r\n            if (gstruct.Succeeded)\r\n            {\r\n                wasTransferred = true;\r\n                await inventoryController.TryRunNetworkTransaction(gstruct, null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Priority 3: Weapons\r\n    if (!wasTransferred && item is Weapon weapon)\r\n    {\r\n        ItemAddress location = inventoryController.FindSlotToPickUp(weapon);\r\n\r\n        if (location != null)\r\n        {\r\n            var gstruct = InteractionsHandlerClass.Move(\r\n                weapon, location, inventoryController, true);\r\n\r\n            if (gstruct.Succeeded)\r\n            {\r\n                wasTransferred = true;\r\n                await inventoryController.TryRunNetworkTransaction(gstruct, null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Track for loot return\r\n    if (wasTransferred)\r\n    {\r\n        InteractableObjects.StoreItem(botOwner, item);\r\n    }\r\n}\r\n```\r\n\r\n### Example 2: Ammo Sharing Between Teammates\r\n\r\n```csharp\r\npublic static bool ShareAmmoBetweenTeammates(\r\n    BotOwner giver,\r\n    BotOwner receiver)\r\n{\r\n    // Find spare magazines\r\n    List<MagazineItemClass> spareMags = new List<MagazineItemClass>();\r\n    giver.GetPlayer.InventoryController.GetReachableItemsOfTypeNonAlloc(\r\n        spareMags, null);\r\n\r\n    // Exclude active magazine\r\n    Weapon currentWeapon = giver.WeaponManager.CurrentWeapon;\r\n    MagazineItemClass activeMag = currentWeapon?.GetCurrentMagazine();\r\n    spareMags.Remove(activeMag);\r\n\r\n    if (spareMags.Count == 0)\r\n        return false;\r\n\r\n    // Find transferable magazine\r\n    MagazineItemClass magToTransfer = null;\r\n    foreach (var mag in spareMags)\r\n    {\r\n        if (mag.Count > 0 &&\r\n            receiver.GetPlayer.InventoryController.FindSlotToPickUp(mag) != null)\r\n        {\r\n            magToTransfer = mag;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (magToTransfer == null)\r\n        return false;\r\n\r\n    // Execute transfer\r\n    ItemAddress destSlot = receiver.GetPlayer.InventoryController\r\n        .FindSlotToPickUp(magToTransfer);\r\n\r\n    if (destSlot != null)\r\n    {\r\n        var moveOp = InteractionsHandlerClass.Move(\r\n            magToTransfer,\r\n            destSlot,\r\n            receiver.GetPlayer.InventoryController,\r\n            simulate: true);\r\n\r\n        if (moveOp.Succeeded)\r\n        {\r\n            receiver.GetPlayer.InventoryController\r\n                .RunNetworkTransaction(moveOp.Value);\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n### Example 3: Magazine Refill (SAIN)\r\n\r\n```csharp\r\npublic static bool RefillMags(\r\n    BotComponent bot,\r\n    BotWeaponInfo weapon,\r\n    int numberToRefill = -1,\r\n    bool includeActiveMag = false)\r\n{\r\n    Slot magazineSlot = weapon.weapon.GetMagazineSlot();\r\n    if (magazineSlot?.ContainedItem is not MagazineItemClass activeMag)\r\n        return false;\r\n\r\n    // Collect magazines\r\n    _preAllocMagList.Clear();\r\n    bot.Player.InventoryController.GetReachableItemsOfTypeNonAlloc(\r\n        _preAllocMagList, null);\r\n\r\n    if (_preAllocMagList.Count == 0)\r\n        return false;\r\n\r\n    int refilled = 0, full = 0;\r\n\r\n    foreach (MagazineItemClass mag in _preAllocMagList)\r\n    {\r\n        // Check compatibility\r\n        if (!GClass3124.CanAccept(magazineSlot, mag))\r\n            continue;\r\n\r\n        // Check if needs refill\r\n        if (mag.Count < mag.MaxCount)\r\n        {\r\n            weapon.Reload.method_2(weapon.weapon, mag);\r\n            refilled++;\r\n        }\r\n        else\r\n        {\r\n            full++;\r\n        }\r\n\r\n        if (numberToRefill >= 0 && refilled >= numberToRefill)\r\n            break;\r\n    }\r\n\r\n    _preAllocMagList.Clear();\r\n    return refilled > 0 || full >= numberToRefill;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Summary: Key APIs Quick Reference\r\n\r\n### Item Tracking\r\n```csharp\r\nbotItemTaker.OnItemTaken += (item, lastOwner) => TrackItem(item);\r\nInteractableObjects.StoreItem(botOwner, item);\r\n```\r\n\r\n### Inventory Queries\r\n```csharp\r\nList<MagazineItemClass> mags = new List<MagazineItemClass>();\r\ncontroller.GetReachableItemsOfTypeNonAlloc(mags, null);\r\n```\r\n\r\n### Item Transfer\r\n```csharp\r\nvar op = InteractionsHandlerClass.Move(item, destination, controller, true);\r\ncontroller.RunNetworkTransaction(op.Value, callback);\r\n```\r\n\r\n### Ammo Management\r\n```csharp\r\nMagazineItemClass mag = weapon.GetCurrentMagazine();\r\nfloat ratio = (float)mag.Count / mag.MaxCount;\r\nRefillMags(bot, weapon, 3, false);\r\n```\r\n\r\n### Loot Return\r\n```csharp\r\nvar flatItems = ItemFactoryClass.Instance.TreeToFlatItems(items);\r\nRequestHandler.PutJson(\"/singleplayer/returnitems\", { items: flatItems });\r\n```\r\n\r\n---\r\n\r\n**With this documentation, you can implement: Loot Return System (Phase 10), Ammo Sharing (Innovation #3), and Equipment Management!**\r\n"},"10-GClass-Mapping-Index":{"title":"GClass Obfuscation Mapping Index\r","category":"Core Systems","content":"# GClass Obfuscation Mapping Index\r\n\r\n**Purpose**: Map obfuscated `GClass###` names to their actual meanings\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\n## How to Use This Index\r\n\r\nTarkov's code is heavily obfuscated. When you encounter a `GClass###` in error messages or decompiled code, reference this index to understand what it actually is.\r\n\r\n**Example**:\r\n```\r\nError: Cannot convert GClass1410 to String\r\n```\r\nLook up `GClass1410` ‚Üí **Profile Info** (Nickname, Side, Level, etc.)\r\n\r\n---\r\n\r\n## Confirmed Mappings\r\n\r\n### Profile & Player Data\r\n\r\n| GClass | Actual Meaning | Fields/Purpose | Source |\r\n|--------|----------------|----------------|--------|\r\n| `GClass1410` | **Profile Info** | Nickname, LowerNickname, Side, Level, PrestigeLevel, MemberCategory | GroupPlayerData, Party system |\r\n| `GClass1055` | **Friends List Response** | Friends list data structure | Social network |\r\n| `GClass2197` | **Character Customization** | Body, Head, Feet customization data | Visual representation |\r\n| `GClass2214` | **Visual Representation Wrapper** | Serialized player visual state | GroupPlayerData |\r\n\r\n### Party & Matchmaking\r\n\r\n| GClass | Actual Meaning | Fields/Purpose | Source |\r\n|--------|----------------|----------------|--------|\r\n| `GClass692` | **Voice Command Event Data** | phrase (EPhraseTrigger), PlayerRequester, command info | BotEventHandler |\r\n| `GClass532` | **Gesture Event Data** | Gesture (EInteraction), Player, gesture info | BotEventHandler |\r\n| `GClass1200` | **Backend URL Helper** | Main URL, endpoint paths | ProfileEndpoint |\r\n| `GClass1321` | **Profile Endpoint Helper** | Backend communication helper | ProfileEndPoint |\r\n\r\n### Bot AI & Brain\r\n\r\n| GClass | Actual Meaning | Fields/Purpose | Source |\r\n|--------|----------------|----------------|--------|\r\n| `GClass168` | **BotNodeAbstractClass** (CONFIRMED) | Brain node system, base for decision execution | Bot AI system |\r\n| `GClass26` | **Node Result Data** | Generic result data for bot nodes | AI layer system |\r\n| `GClass35` | **AI Layer Base** | Base for AI layer implementations | AICoreLayerClass |\r\n| `GClass309` | **AI Strategy/Brain** | Strategy controller for AI layers | AICoreAgentClass |\r\n| `GClass71` | **Debug Brain Layer** | Debug layer (priority 1000) | BaseBrain |\r\n| `GClass671` | **Event Layer Priorities** | Khorovod, ForceAttack, ForcePersuit, FollowPlayer, etc. | BaseBrain |\r\n| `GClass72` | **Follow Player Layer** | Built-in follow player implementation | BaseBrain event setup |\r\n\r\n### Bot Groups & Requests\r\n\r\n| GClass | Actual Meaning | Fields/Purpose | Source |\r\n|--------|----------------|----------------|--------|\r\n| `GClass115` | **Group/Squad Related** | Group data or operations (6KB) | Pattern search |\r\n| `GClass600` | **Group/Squad Related** | Group data or operations (3KB) | Pattern search |\r\n\r\n### Spawn & Generation\r\n\r\n| GClass | Actual Meaning | Fields/Purpose | Source |\r\n|--------|----------------|----------------|--------|\r\n| `GClass682` | **Spawn Position Data** | Vector3 position, int CorePointId, bool isOutside | Bot spawning |\r\n| `GClass378` | **Bot Wave Optimizer** | OptimizeBotWaves method | Bot generation |\r\n| `GClass19<T>` | **Generic Data Wrapper** | Wraps List<WaveInfoClass> for backend calls | Bot generation |\r\n\r\n### UI & Interaction\r\n\r\n| GClass | Actual Meaning | Fields/Purpose | Source |\r\n|--------|----------------|----------------|--------|\r\n| `GClass1345` | **UI Component** | Dropdown or UI element (4KB) | UI system |\r\n| `GClass1416` | **UI Component** | UI element (2KB) | UI system |\r\n| `GClass3387` | **UI Controller** | UI controller (7KB) | UI system |\r\n| `GClass3388` | **UI Component** | UI element (279 bytes) | UI system |\r\n\r\n---\r\n\r\n## Partial/Suspected Mappings\r\n\r\n### Likely Group/Party Related\r\n\r\n| GClass | Suspected Meaning | Size | Notes |\r\n|--------|-------------------|------|-------|\r\n| `GClass170` | Group/Party component | 6KB | In party system area |\r\n| `GClass167` | Group/Party component | 706 bytes | Near GClass168 (BotNode) |\r\n| `GClass176<T>` | Generic group/party wrapper | - | Generic version |\r\n| `GClass177` | Group/Party component | - | Both generic and non-generic versions exist |\r\n| `GClass177<T>` | Generic group/party wrapper | - | |\r\n\r\n### Likely Bot AI Related\r\n\r\n| GClass | Suspected Meaning | Size | Notes |\r\n|--------|-------------------|------|-------|\r\n| `GClass193` | Bot AI component | - | AI system area |\r\n| `GClass212` | Bot AI component | - | AI system area |\r\n| `GClass231` | Bot AI component | - | AI system area |\r\n| `GClass269` | Bot AI component | - | AI system area |\r\n| `GClass271` | Bot AI component | - | AI system area |\r\n| `GClass274` | Bot AI component | - | AI system area |\r\n| `GClass420` | Bot AI component | - | AI system area |\r\n| `GClass429` | Bot AI component | 184 bytes | Tiny, likely enum or flags |\r\n| `GClass454` | Bot AI component | 1KB | AI system area |\r\n| `GClass507` | Bot AI component | 4KB | AI system area |\r\n\r\n### Likely Profile/Backend Related\r\n\r\n| GClass | Suspected Meaning | Size | Notes |\r\n|--------|-------------------|------|-------|\r\n| `GClass1950` | Profile/backend component | 197 bytes | Near profile classes |\r\n| `GClass1952` | Profile/backend component | 44 bytes | Extremely tiny, likely simple data |\r\n| `GClass2213` | Profile/backend component | 2KB | Profile area |\r\n| `GClass3398` | Backend component | 670 bytes | Backend area |\r\n| `GClass3399` | Backend component | 1KB | Backend area |\r\n| `GClass3400` | Backend component | 1KB | Backend area |\r\n| `GClass3672` | Backend component | 457 bytes | Backend area |\r\n| `GClass3682` | Backend component | 710 bytes | Backend area |\r\n| `GClass3683` | Backend component | 850 bytes | Backend area |\r\n| `GClass3684` | Backend component | 684 bytes | Backend area |\r\n\r\n### Likely Weapon/Item Related\r\n\r\n| GClass | Suspected Meaning | Size | Notes |\r\n|--------|-------------------|------|-------|\r\n| `GClass565` | Weapon/item component | 3KB | Item system area |\r\n| `GClass567` | Weapon/item component | 2KB | Item system area |\r\n\r\n### Small Data Classes (Likely DTOs)\r\n\r\n| GClass | Suspected Meaning | Size | Notes |\r\n|--------|-------------------|------|-------|\r\n| `GClass50` | Data transfer object | - | Small, likely DTO |\r\n| `GClass51` | Data transfer object | - | Small, likely DTO |\r\n| `GClass55` | Data transfer object | - | Small, likely DTO |\r\n| `GClass73` | Data transfer object | - | Small, likely DTO |\r\n\r\n---\r\n\r\n## Generic Pattern Recognition\r\n\r\n### Naming Conventions\r\n\r\n| Pattern | Likely Meaning |\r\n|---------|----------------|\r\n| `GClass1###` | Profile, UI, Backend systems (1000-1999) |\r\n| `GClass2###` | Visual, Customization, Player representation (2000-2999) |\r\n| `GClass3###` | UI, Backend, Server communication (3000-3999) |\r\n| `GClass1##` - `GClass9##` | Core AI, Bot, Group systems (1-999) |\r\n\r\n### Generic Classes\r\n\r\nMany classes have generic `<T>` versions:\r\n- `GClass176<T>` and `GClass176`\r\n- `GClass177<T>` and `GClass177`\r\n\r\nThese are often wrappers or containers for type-safe data passing.\r\n\r\n---\r\n\r\n## How to Discover New Mappings\r\n\r\n### 1. Look at Decompiled File Context\r\n\r\n```csharp\r\n// If you see:\r\npublic class SomeDecompiledClass\r\n{\r\n    private GClass999 field_0;\r\n\r\n    public void DoSomething(GClass999 data)\r\n    {\r\n        // Look at how it's used\r\n        string nickname = data.Nickname;  // Aha! It has a Nickname field\r\n        int level = data.Level;           // And a Level field\r\n    }\r\n}\r\n```\r\n\r\n**Conclusion**: `GClass999` is likely profile info or player data.\r\n\r\n### 2. Check Field Names and Types\r\n\r\n```csharp\r\npublic class GClass1234\r\n{\r\n    public string Nickname;\r\n    public EPlayerSide Side;\r\n    public int Level;\r\n}\r\n```\r\n\r\n**Pattern Match**: Looks like `GClass1410` (Profile Info) - probably a related class.\r\n\r\n### 3. Look at Method Signatures\r\n\r\n```csharp\r\npublic GClass555 CreateSomething(Profile profile, Vector3 position)\r\n{\r\n    return new GClass555(position, profile.Level);\r\n}\r\n```\r\n\r\n**Inference**: `GClass555` takes position + level, likely spawn-related.\r\n\r\n### 4. Check Inheritance\r\n\r\n```csharp\r\npublic class GClass777 : AICoreLayerClass<BotLogicDecision>\r\n```\r\n\r\n**Clear**: `GClass777` is an AI layer implementation.\r\n\r\n### 5. Look at Usage in Working Code\r\n\r\nSearch FriendlyPMC or SAIN for how they use a GClass:\r\n\r\n```csharp\r\n// In SAIN:\r\nvar info = (GClass692)eventData;\r\nEPhraseTrigger phrase = info.phrase;\r\n```\r\n\r\n**Confirmed**: `GClass692` is voice command event data.\r\n\r\n---\r\n\r\n## Version-Specific Notes\r\n\r\n### SPT 4.0.5 Changes\r\n\r\nSome GClass numbers changed from SPT 3.x:\r\n- `GClass168` ‚Üí Confirmed as `BotNodeAbstractClass` (was different number in 3.x)\r\n- Profile classes likely renumbered\r\n- UI classes may have shifted\r\n\r\n**Rule**: Always verify GClass numbers when upgrading SPT versions.\r\n\r\n---\r\n\r\n## Quick Reference by Feature Area\r\n\r\n### If You're Working On...\r\n\r\n**Bot Spawning**:\r\n- `GClass682` - Spawn position\r\n- `GClass378` - Wave optimizer\r\n- `GClass19<T>` - Wave wrapper\r\n\r\n**Bot AI/Brain**:\r\n- `GClass168` - BotNodeAbstractClass\r\n- `GClass26` - Node result data\r\n- `GClass671` - Event priorities\r\n- `GClass72` - Follow player layer\r\n\r\n**Party/Friends**:\r\n- `GClass1410` - Profile info\r\n- `GClass2214` - Visual representation\r\n- `GClass115`, `GClass600` - Group data\r\n\r\n**Voice Commands**:\r\n- `GClass692` - Voice event data\r\n- `GClass532` - Gesture event data\r\n\r\n**Backend/Server**:\r\n- `GClass1200` - URL helper\r\n- `GClass1321` - Endpoint helper\r\n\r\n---\r\n\r\n## Contributing New Mappings\r\n\r\nWhen you discover a new mapping:\r\n\r\n1. **Verify it's accurate** (check multiple uses)\r\n2. **Document the fields** it contains\r\n3. **Note the source** (which file/feature revealed it)\r\n4. **Add to this index** under \"Confirmed Mappings\"\r\n\r\n**Format**:\r\n```markdown\r\n| `GClassXXX` | **Actual Name** | Field1, Field2, Field3 | Feature area |\r\n```\r\n\r\n---\r\n\r\n## Common Errors and Their Meanings\r\n\r\n### Type Conversion Errors\r\n\r\n```\r\nCannot convert GClass1410 to System.String\r\n```\r\n**Meaning**: You're trying to use Profile Info object as a string. Use `profileInfo.Nickname` instead.\r\n\r\n```\r\nGClass692 does not contain a definition for 'Command'\r\n```\r\n**Meaning**: Voice event data uses `phrase` property, not `Command`.\r\n\r\n### Null Reference Errors\r\n\r\n```\r\nNullReferenceException in GClass168.method_0\r\n```\r\n**Meaning**: Bot node trying to execute but BotOwner or data is null.\r\n\r\n### Missing Method Errors\r\n\r\n```\r\nGClass1410 does not contain method 'GetLevel'\r\n```\r\n**Meaning**: Profile Info uses `Level` property directly, not a getter method.\r\n\r\n---\r\n\r\n## Summary\r\n\r\n- **100+ GClass names** in Tarkov codebase\r\n- **~20 confirmed mappings** documented here\r\n- **Size-based hints**: Tiny classes (< 500 bytes) are likely DTOs or enums\r\n- **Number ranges**: Higher numbers (1000+) tend to be UI/profile/backend\r\n- **Context is key**: Look at fields, methods, and usage to infer meaning\r\n\r\nWhen in doubt, search this index by feature area or check decompiled file context!\r\n"},"11-INNOVATION-IMPLEMENTATION-GUIDES":{"title":"Innovation Implementation Guides\r","category":"Core Systems","content":"# Innovation Implementation Guides\r\n\r\n**Purpose**: Step-by-step implementation plans for 5 proposed innovations\r\n**Status**: READY - All required APIs documented\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [Innovation #1: Dynamic Tactical Formations](#innovation-1-dynamic-tactical-formations)\r\n2. [Innovation #2: Multi-Stage Door Breaching](#innovation-2-multi-stage-door-breaching)\r\n3. [Innovation #3: Intelligent Fire Support](#innovation-3-intelligent-fire-support)\r\n4. [Innovation #4: Adaptive Enemy Learning](#innovation-4-adaptive-enemy-learning)\r\n5. [Innovation #5: Casualty Evacuation System](#innovation-5-casualty-evacuation-system)\r\n\r\n---\r\n\r\n## Innovation #1: Dynamic Tactical Formations\r\n\r\n**Alignment**: Enhances Phase 6 (AI), Phase 12A (Fireteams)\r\n**Complexity**: MEDIUM\r\n**API Coverage**: ‚úÖ 100% - Ready to implement\r\n\r\n### What It Does\r\n\r\nFollowers automatically adjust formation based on:\r\n- Terrain type (urban, forest, open)\r\n- Threat direction (enemy contact triggers defensive formation)\r\n- Movement state (traveling vs combat)\r\n- Squad size (2-man buddy teams, 3-man wedge, 5-man line)\r\n\r\n**Formations**:\r\n- **Wedge** - Default patrol (good visibility, fields of fire)\r\n- **Column** - Urban/tight spaces (file formation)\r\n- **Line** - Defensive (facing threat)\r\n- **Circle** - All-around defense (ambush response)\r\n- **Bounding Overwatch** - Alternating movement (combat advance)\r\n\r\n### Implementation Plan\r\n\r\n#### Step 1: Create Formation Manager Component\r\n\r\n**File**: `FormationManager.cs`\r\n\r\n```csharp\r\nusing Reference: 08-Cover-Navigation-System.md Section 4\r\n\r\npublic enum FormationType\r\n{\r\n    Wedge,\r\n    Column,\r\n    Line,\r\n    Circle,\r\n    BoundingOverwatch\r\n}\r\n\r\npublic class FormationManager : MonoBehaviour\r\n{\r\n    private BotOwner leader;\r\n    private List<BotOwner> squadMembers;\r\n    private FormationType currentFormation = FormationType.Wedge;\r\n\r\n    private const float SPACING = 3f;\r\n    private const float UPDATE_INTERVAL = 0.5f;\r\n    private float _nextUpdateTime;\r\n\r\n    private List<Vector3> _occupiedPositions = new List<Vector3>();\r\n\r\n    public void Update()\r\n    {\r\n        if (Time.time < _nextUpdateTime) return;\r\n        _nextUpdateTime = Time.time + UPDATE_INTERVAL;\r\n\r\n        // Select formation based on context\r\n        SelectFormation();\r\n\r\n        // Update positions\r\n        UpdateFormationPositions();\r\n    }\r\n\r\n    private void SelectFormation()\r\n    {\r\n        // Combat: defensive formations\r\n        if (leader.Memory.GoalEnemy != null)\r\n        {\r\n            currentFormation = FormationType.Line;  // Face threat\r\n            return;\r\n        }\r\n\r\n        // Urban: column\r\n        if (leader.Memory.Location.IsIndoors)\r\n        {\r\n            currentFormation = FormationType.Column;\r\n            return;\r\n        }\r\n\r\n        // Default: wedge\r\n        currentFormation = FormationType.Wedge;\r\n    }\r\n\r\n    private void UpdateFormationPositions()\r\n    {\r\n        Vector3 leaderPos = leader.Position;\r\n        Vector3 leaderForward = leader.LookDirection;\r\n\r\n        // If moving, use movement direction\r\n        if (leader.Mover.HavePath)\r\n        {\r\n            leaderForward = (leader.Mover.CurPathPoint - leaderPos).normalized;\r\n        }\r\n\r\n        _occupiedPositions.Clear();\r\n        _occupiedPositions.Add(leaderPos);\r\n\r\n        for (int i = 0; i < squadMembers.Count; i++)\r\n        {\r\n            BotOwner follower = squadMembers[i];\r\n            if (follower == leader) continue;\r\n\r\n            // Calculate ideal position\r\n            Vector3 idealPos = CalculateFormationPosition(\r\n                leaderPos,\r\n                leaderForward,\r\n                i,\r\n                currentFormation\r\n            );\r\n\r\n            // Validate and correct to navmesh\r\n            Vector3? validPos = GetValidFormationPosition(\r\n                idealPos,\r\n                leaderForward,\r\n                _occupiedPositions,\r\n                SPACING * 0.7f  // Allow slight overlap\r\n            );\r\n\r\n            if (validPos.HasValue)\r\n            {\r\n                // Move follower to position\r\n                MoveToFormationPosition(follower, validPos.Value);\r\n                _occupiedPositions.Add(validPos.Value);\r\n            }\r\n        }\r\n    }\r\n\r\n    private Vector3 CalculateFormationPosition(\r\n        Vector3 leaderPos,\r\n        Vector3 leaderForward,\r\n        int memberIndex,\r\n        FormationType formation)\r\n    {\r\n        switch (formation)\r\n        {\r\n            case FormationType.Wedge:\r\n                return GetWedgePosition(leaderPos, leaderForward, memberIndex + 1, SPACING);\r\n\r\n            case FormationType.Column:\r\n                return GetColumnPosition(leaderPos, leaderForward, memberIndex + 1, SPACING);\r\n\r\n            case FormationType.Line:\r\n                return GetLinePosition(leaderPos, leaderForward, memberIndex + 1, SPACING);\r\n\r\n            case FormationType.Circle:\r\n                return GetFormationOffset(leaderPos, leaderForward, memberIndex + 1,\r\n                    squadMembers.Count, SPACING);\r\n\r\n            default:\r\n                return GetWedgePosition(leaderPos, leaderForward, memberIndex + 1, SPACING);\r\n        }\r\n    }\r\n\r\n    private void MoveToFormationPosition(BotOwner bot, Vector3 position)\r\n    {\r\n        float distance = Vector3.Distance(bot.Position, position);\r\n\r\n        // Only move if far from position\r\n        if (distance > SPACING * 0.5f)\r\n        {\r\n            SAINMoverClass mover = GetSAINMover(bot);\r\n            if (mover != null)\r\n            {\r\n                // Walk if close, run if far\r\n                if (distance > SPACING * 2f)\r\n                {\r\n                    mover.RunToPoint(position, reachDist: SPACING * 0.3f,\r\n                        urgency: ESprintUrgency.Low);\r\n                }\r\n                else\r\n                {\r\n                    mover.WalkToPoint(position, reachDist: SPACING * 0.3f);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Helper: Get formation offset functions from 08-Cover-Navigation-System.md\r\n    // Copy implementations from Section 4\r\n}\r\n```\r\n\r\n**Implementation Time**: 2-3 days\r\n**Dependencies**: Cover/Navigation system (08)\r\n**Complexity**: Medium (mostly geometry/math)\r\n\r\n---\r\n\r\n## Innovation #2: Multi-Stage Door Breaching\r\n\r\n**Alignment**: Phase 12B+ (Advanced Maneuvers), Phase 16 (DESIGN_INTENT.md)\r\n**Complexity**: HIGH\r\n**API Coverage**: ‚úÖ 90% - Minor gaps in door API\r\n\r\n### What It Does\r\n\r\nCoordinated 3-5 person breach sequences:\r\n1. **Stack** - Bots position on door sides\r\n2. **Opener** - Designated bot opens/breaches door\r\n3. **Flashbang** (optional) - Throw flash through doorway\r\n4. **Entry** - Timed entry with sector assignments\r\n5. **Clear** - Room clearing with crossfire avoidance\r\n\r\n### Implementation Plan\r\n\r\n#### Step 1: Create Breach Coordinator\r\n\r\n**File**: `BreachCoordinator.cs`\r\n\r\n```csharp\r\nusing Reference: 06-Grenade-Explosive-System.md Section 7\r\nusing Reference: 08-Cover-Navigation-System.md Section 5\r\n\r\npublic enum BreachPhase\r\n{\r\n    SelectDoor,\r\n    StackOnDoor,\r\n    ThrowFlash,\r\n    WaitForFlash,\r\n    Breach,\r\n    Entry,\r\n    Clear,\r\n    Complete\r\n}\r\n\r\npublic class BreachCoordinator : MonoBehaviour\r\n{\r\n    private List<BotOwner> breachTeam;\r\n    private Door targetDoor;\r\n    private BreachPhase currentPhase = BreachPhase.SelectDoor;\r\n\r\n    private BotOwner breacher;      // Opens door\r\n    private BotOwner flasher;       // Throws flashbang\r\n    private BotOwner[] entryTeam;   // Entry team\r\n\r\n    private float phaseStartTime;\r\n    private const float FLASH_DELAY = 2f;   // Wait for flash detonation\r\n\r\n    public void StartBreach(Door door, List<BotOwner> team)\r\n    {\r\n        targetDoor = door;\r\n        breachTeam = team;\r\n\r\n        // Assign roles\r\n        AssignBreachRoles();\r\n\r\n        currentPhase = BreachPhase.StackOnDoor;\r\n        phaseStartTime = Time.time;\r\n    }\r\n\r\n    private void AssignBreachRoles()\r\n    {\r\n        // Breacher: Closest to door\r\n        breacher = breachTeam\r\n            .OrderBy(b => (b.Position - targetDoor.transform.position).sqrMagnitude)\r\n            .First();\r\n\r\n        // Flasher: Bot with grenades\r\n        flasher = breachTeam\r\n            .FirstOrDefault(b => b.WeaponManager.Grenades.HaveGrenade)\r\n            ?? breacher;  // Fallback to breacher\r\n\r\n        // Entry team: Everyone else\r\n        entryTeam = breachTeam\r\n            .Where(b => b != breacher && b != flasher)\r\n            .ToArray();\r\n    }\r\n\r\n    public void Update()\r\n    {\r\n        switch (currentPhase)\r\n        {\r\n            case BreachPhase.StackOnDoor:\r\n                if (StackOnDoor())\r\n                {\r\n                    currentPhase = BreachPhase.ThrowFlash;\r\n                    phaseStartTime = Time.time;\r\n                }\r\n                break;\r\n\r\n            case BreachPhase.ThrowFlash:\r\n                if (ThrowFlashbang())\r\n                {\r\n                    currentPhase = BreachPhase.WaitForFlash;\r\n                    phaseStartTime = Time.time;\r\n                }\r\n                break;\r\n\r\n            case BreachPhase.WaitForFlash:\r\n                if (Time.time - phaseStartTime > FLASH_DELAY)\r\n                {\r\n                    currentPhase = BreachPhase.Breach;\r\n                }\r\n                break;\r\n\r\n            case BreachPhase.Breach:\r\n                if (BreachDoor())\r\n                {\r\n                    currentPhase = BreachPhase.Entry;\r\n                    phaseStartTime = Time.time;\r\n                }\r\n                break;\r\n\r\n            case BreachPhase.Entry:\r\n                if (ExecuteEntry())\r\n                {\r\n                    currentPhase = BreachPhase.Clear;\r\n                }\r\n                break;\r\n\r\n            case BreachPhase.Clear:\r\n                if (ClearRoom())\r\n                {\r\n                    currentPhase = BreachPhase.Complete;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    private bool StackOnDoor()\r\n    {\r\n        // Get door position and orientation\r\n        Vector3 doorPos = targetDoor.transform.position;\r\n        Vector3 doorForward = targetDoor.transform.forward;\r\n\r\n        // Assign stack positions (from 08-Cover-Navigation Section 5)\r\n        BreachSector[] sectors = new BreachSector[]\r\n        {\r\n            BreachSector.Left,\r\n            BreachSector.Right,\r\n            BreachSector.Center,\r\n            BreachSector.RearLeft,\r\n            BreachSector.RearRight\r\n        };\r\n\r\n        bool allInPosition = true;\r\n\r\n        for (int i = 0; i < breachTeam.Count && i < sectors.Length; i++)\r\n        {\r\n            Vector3 stackPos = GetBreachPosition(\r\n                doorPos, doorForward, sectors[i], stackDistance: 0.75f);\r\n\r\n            if (ValidateAndCorrectPosition(ref stackPos))\r\n            {\r\n                SAINMoverClass mover = GetSAINMover(breachTeam[i]);\r\n\r\n                float dist = Vector3.Distance(breachTeam[i].Position, stackPos);\r\n\r\n                if (dist > 0.5f)  // Not in position yet\r\n                {\r\n                    allInPosition = false;\r\n\r\n                    if (dist > 5f)\r\n                        mover?.RunToPoint(stackPos, reachDist: 0.3f,\r\n                            urgency: ESprintUrgency.High);\r\n                    else\r\n                        mover?.WalkToPoint(stackPos, reachDist: 0.3f);\r\n                }\r\n            }\r\n        }\r\n\r\n        return allInPosition;\r\n    }\r\n\r\n    private bool ThrowFlashbang()\r\n    {\r\n        if (!flasher.WeaponManager.Grenades.HaveGrenade)\r\n        {\r\n            // No flashbang, skip to breach\r\n            return true;\r\n        }\r\n\r\n        // Calculate throw position (through doorway)\r\n        Vector3 doorPos = targetDoor.transform.position;\r\n        Vector3 doorForward = targetDoor.transform.forward;\r\n        Vector3 throwTarget = doorPos + doorForward * 3f + Vector3.up * 1f;\r\n\r\n        // Throw flashbang (from 06-Grenade Section 9)\r\n        return ThrowGrenadeAtPosition(flasher, throwTarget, AIGreandeAng.Low);\r\n    }\r\n\r\n    private bool BreachDoor()\r\n    {\r\n        // Breacher kicks/opens door\r\n        DoorOpener doorOpener = GetDoorOpener(breacher);\r\n\r\n        bool shouldKick = doorOpener.ShallKickOpen(targetDoor, EInteractionType.Open);\r\n\r\n        EInteractionType type = shouldKick ? EInteractionType.Breach : EInteractionType.Open;\r\n\r\n        return doorOpener.TryInteractWithDoor(\r\n            type,\r\n            Time.time,\r\n            new DoorDataStruct(targetDoor)\r\n        );\r\n    }\r\n\r\n    private bool ExecuteEntry()\r\n    {\r\n        // Entry team flows through door with sector assignments\r\n        Vector3 doorPos = targetDoor.transform.position;\r\n        Vector3 doorForward = targetDoor.transform.forward;\r\n\r\n        // Entry sectors (where to aim on entry)\r\n        Vector3[] entrySectors = new Vector3[]\r\n        {\r\n            doorForward,                           // Center\r\n            Quaternion.Euler(0, 45, 0) * doorForward,   // Right\r\n            Quaternion.Euler(0, -45, 0) * doorForward   // Left\r\n        };\r\n\r\n        bool allEntered = true;\r\n\r\n        for (int i = 0; i < entryTeam.Length && i < entrySectors.Length; i++)\r\n        {\r\n            Vector3 entryPos = doorPos + doorForward * 3f +\r\n                               entrySectors[i] * 2f;\r\n\r\n            float dist = Vector3.Distance(entryTeam[i].Position, entryPos);\r\n\r\n            if (dist > 1f)\r\n            {\r\n                allEntered = false;\r\n\r\n                SAINMoverClass mover = GetSAINMover(entryTeam[i]);\r\n                mover?.RunToPoint(entryPos, urgency: ESprintUrgency.High);\r\n            }\r\n        }\r\n\r\n        return allEntered;\r\n    }\r\n\r\n    private bool ClearRoom()\r\n    {\r\n        // Room clearing logic\r\n        // Check for enemies, engage, hold positions\r\n        return true;  // Simplified for now\r\n    }\r\n}\r\n```\r\n\r\n**Implementation Time**: 1 week\r\n**APIs Used**:\r\n- ‚úÖ Breach positions: `08-Cover-Navigation-System.md` Section 5\r\n- ‚úÖ Grenade throwing: `06-Grenade-Explosive-System.md` Section 9\r\n- ‚úÖ Door interaction: `06-Grenade-Explosive-System.md` Section 5\r\n- ‚úÖ Movement: `08-Cover-Navigation-System.md` Section 3\r\n\r\n**Testing Checklist**:\r\n- [ ] Team stacks on both sides of door\r\n- [ ] Flashbang thrown if available\r\n- [ ] Door breached/opened on cue\r\n- [ ] Entry team flows through with sectors\r\n- [ ] No friendly fire during entry\r\n\r\n---\r\n\r\n## Innovation #3: Intelligent Fire Support\r\n\r\n**Alignment**: Enhances Phase 6 (Combat AI), Support tactic\r\n**Complexity**: MEDIUM\r\n**API Coverage**: ‚úÖ 95% - Ready to implement\r\n\r\n### What It Does\r\n\r\nRealistic fire support mechanics:\r\n- **Sector Assignment** - Divide threat area into fire sectors\r\n- **Suppression Indicators** - Tracers show support fire\r\n- **Ammo Management** - Track consumption, conserve for suppression\r\n- **Coordinated Fire** - Alternating fire patterns\r\n- **Effect on Enemies** - Suppressed enemies stay in cover\r\n\r\n### Implementation Plan\r\n\r\n#### Step 1: Create Fire Support Layer\r\n\r\n**File**: `FireSupportLayer.cs`\r\n\r\n```csharp\r\nusing Reference: 02-Bot-AI-Brain.md Section 8.1\r\nusing Reference: 09-Item-Loot-System.md Section 5\r\n\r\npublic class FireSupportLayer : BaseLogicLayerSimpleAbstractClass\r\n{\r\n    private bool _suppressionActive;\r\n    private Vector3 _suppressionSector;\r\n    private float _suppressionEndTime;\r\n    private float _nextAmmoCheckTime;\r\n\r\n    private const float AMMO_THRESHOLD = 0.3f;  // Stop suppression at 30% ammo\r\n    private const float BURST_DURATION = 2f;    // 2s bursts\r\n    private const float BURST_COOLDOWN = 1f;    // 1s between bursts\r\n\r\n    public FireSupportLayer(BotOwner bot, int priority) : base(bot, priority)\r\n    {\r\n    }\r\n\r\n    public override bool ShallUseNow()\r\n    {\r\n        // Active when support tactic and enemy present\r\n        FollowerBrain brain = BotOwner_0.Brain.BaseBrain as FollowerBrain;\r\n        return brain?.BossTactic == \"Support\" &&\r\n               BotOwner_0.Memory.GoalEnemy != null;\r\n    }\r\n\r\n    public override string Name() => \"FireSupportLayer\";\r\n\r\n    public override AICoreActionResultStruct<BotLogicDecision, GClass26> GetDecision()\r\n    {\r\n        // Check ammo before suppression\r\n        if (Time.time > _nextAmmoCheckTime)\r\n        {\r\n            _nextAmmoCheckTime = Time.time + 2f;\r\n\r\n            if (!HasSufficientAmmo())\r\n            {\r\n                _suppressionActive = false;\r\n                return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                    HoldOrCover(BotOwner_0),\r\n                    \"Low ammo - conserving\"\r\n                );\r\n            }\r\n        }\r\n\r\n        // Suppression decision\r\n        if (_suppressionActive || ShouldStartSuppression())\r\n        {\r\n            _suppressionActive = true;\r\n            _suppressionSector = BotOwner_0.Memory.GoalEnemy.CurrPosition;\r\n            _suppressionEndTime = Time.time + BURST_DURATION;\r\n\r\n            return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                BotLogicDecision.shootFromCover,\r\n                \"Providing suppression fire\"\r\n            );\r\n        }\r\n\r\n        // Default combat behavior\r\n        var combatDecision = InFightLogic();\r\n        if (combatDecision.HasValue)\r\n            return combatDecision.Value;\r\n\r\n        return new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n            BotLogicDecision.goToCoverPoint,\r\n            \"Finding support position\"\r\n        );\r\n    }\r\n\r\n    private bool ShouldStartSuppression()\r\n    {\r\n        // Trigger conditions\r\n        if (BotOwner_0.Memory.GoalEnemy == null)\r\n            return false;\r\n\r\n        // Boss needs protection\r\n        FollowerBrain brain = BotOwner_0.Brain.BaseBrain as FollowerBrain;\r\n        if (brain?.BossNeedsProtection == true)\r\n            return true;\r\n\r\n        // Boss gave suppress command (would be set by voice command)\r\n        // Check if suppress request active\r\n        return false;  // Simplified\r\n    }\r\n\r\n    private bool HasSufficientAmmo()\r\n    {\r\n        Weapon weapon = BotOwner_0.WeaponManager.CurrentWeapon;\r\n        if (weapon == null) return false;\r\n\r\n        MagazineItemClass mag = weapon.GetCurrentMagazine();\r\n        if (mag == null) return false;\r\n\r\n        float ammoRatio = (float)mag.Count / mag.MaxCount;\r\n        return ammoRatio > AMMO_THRESHOLD;\r\n    }\r\n\r\n    public override AICoreActionEndStruct ShallEndCurrentDecision(\r\n        AICoreActionResultStruct<BotLogicDecision, GClass26> curDecision)\r\n    {\r\n        var baseEnd = base.ShallEndCurrentDecision(curDecision);\r\n        if (baseEnd.Value) return baseEnd;\r\n\r\n        if (_suppressionActive && Time.time > _suppressionEndTime)\r\n        {\r\n            _suppressionActive = false;\r\n            return new AICoreActionEndStruct(\"Suppression burst complete\");\r\n        }\r\n\r\n        return new AICoreActionEndStruct();\r\n    }\r\n}\r\n```\r\n\r\n#### Step 2: Add Suppression Effect on Enemies\r\n\r\n**File**: `SuppressionEffectPatch.cs`\r\n\r\n```csharp\r\nusing Reference: 02-Bot-AI-Brain.md Section 8.3 (Memory events)\r\n\r\ninternal class SuppressionEffectPatch : ModulePatch\r\n{\r\n    protected override MethodBase GetTargetMethod()\r\n    {\r\n        return AccessTools.Method(typeof(BotMemoryClass), \"OnBulletNear\");\r\n    }\r\n\r\n    [PatchPostfix]\r\n    private static void PatchPostfix(BotMemoryClass __instance, BotOwner bot, IPlayer player)\r\n    {\r\n        // If bullets from support bot pass near enemy, apply suppression\r\n        if (IsSupportBot(player.ProfileId))\r\n        {\r\n            // Set enemy under fire (keeps in cover)\r\n            __instance.SetUnderFire(player);\r\n\r\n            // Reduce vision when suppressed\r\n            ApplySuppressionPenalty(bot);\r\n        }\r\n    }\r\n\r\n    private static void ApplySuppressionPenalty(BotOwner bot)\r\n    {\r\n        // Suppressed bots stay in cover, reduced vision\r\n        // Implementation would modify bot vision/behavior\r\n    }\r\n}\r\n```\r\n\r\n**Implementation Time**: 1 week\r\n**APIs Used**:\r\n- ‚úÖ Ammo tracking: `09-Item-Loot-System.md` Section 5\r\n- ‚úÖ Suppression request: `04-Voice-Gesture-Commands.md` Section 6\r\n- ‚úÖ Memory events: `02-Bot-AI-Brain.md` Section 8.2\r\n- ‚úÖ Fire control: Weapon system (partially documented)\r\n\r\n---\r\n\r\n## Innovation #4: Adaptive Enemy Learning\r\n\r\n**Alignment**: Phase 12D (Enhanced Enemy PMC), emergent gameplay\r\n**Complexity**: MEDIUM\r\n**API Coverage**: ‚úÖ 100% - Ready to implement\r\n\r\n### What It Does\r\n\r\nFollowers observe and adapt to enemy tactics:\r\n- **Pattern Recognition** - Track enemy behaviors over raid\r\n- **Tactical Adaptation** - Counter observed patterns\r\n- **No LLM Required** - Pure observation + rules\r\n\r\n### Implementation Plan\r\n\r\n#### Step 1: Create Tactical Observation Tracker\r\n\r\n**File**: `TacticalObservationTracker.cs`\r\n\r\n```csharp\r\nusing Reference: 02-Bot-AI-Brain.md Section 8.2 (Memory events)\r\n\r\npublic class TacticalObservationTracker : MonoBehaviour\r\n{\r\n    private Dictionary<string, EnemyBehaviorPattern> _observedPatterns =\r\n        new Dictionary<string, EnemyBehaviorPattern>();\r\n\r\n    private class EnemyBehaviorPattern\r\n    {\r\n        public int FlankAttempts;\r\n        public int RetreatCount;\r\n        public int AggressivePushes;\r\n        public int SuppressionUse;\r\n\r\n        public float AvgRetreatDistance;\r\n        public float AvgEngagementDistance;\r\n    }\r\n\r\n    public void ObserveEnemyFlank(string enemyId, Vector3 flankDirection)\r\n    {\r\n        var pattern = GetOrCreatePattern(enemyId);\r\n        pattern.FlankAttempts++;\r\n\r\n        // If enemy flanks 3+ times, increase flank watch priority\r\n        if (pattern.FlankAttempts >= 3)\r\n        {\r\n            AdjustSquadTactics(TacticalTendency.Flanker);\r\n        }\r\n    }\r\n\r\n    public void ObserveEnemyRetreat(string enemyId, float distance)\r\n    {\r\n        var pattern = GetOrCreatePattern(enemyId);\r\n        pattern.RetreatCount++;\r\n\r\n        // Update average retreat distance\r\n        pattern.AvgRetreatDistance =\r\n            (pattern.AvgRetreatDistance * (pattern.RetreatCount - 1) + distance) /\r\n            pattern.RetreatCount;\r\n\r\n        // If enemy retreats often, increase pursuit aggressiveness\r\n        if (pattern.RetreatCount >= 2)\r\n        {\r\n            AdjustSquadTactics(TacticalTendency.Retreater);\r\n        }\r\n    }\r\n\r\n    public void ObserveAggressivePush(string enemyId)\r\n    {\r\n        var pattern = GetOrCreatePattern(enemyId);\r\n        pattern.AggressivePushes++;\r\n\r\n        // If enemy pushes often, use more defensive cover\r\n        if (pattern.AggressivePushes >= 2)\r\n        {\r\n            AdjustSquadTactics(TacticalTendency.Aggressive);\r\n        }\r\n    }\r\n\r\n    private void AdjustSquadTactics(TacticalTendency tendency)\r\n    {\r\n        foreach (var bot in GetSquadMembers())\r\n        {\r\n            FollowerBrain brain = bot.Brain.BaseBrain as FollowerBrain;\r\n\r\n            switch (tendency)\r\n            {\r\n                case TacticalTendency.Flanker:\r\n                    // Enemy flanks often - watch flanks more\r\n                    brain?.SetFlankWatchPriority(high: true);\r\n                    break;\r\n\r\n                case TacticalTendency.Retreater:\r\n                    // Enemy retreats when hit - pursue cautiously\r\n                    brain?.SetPursuitAggressiveness(0.7f);\r\n                    break;\r\n\r\n                case TacticalTendency.Aggressive:\r\n                    // Enemy rushes - use more cover, defensive\r\n                    brain?.SetCoverUsage(high: true);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npublic enum TacticalTendency\r\n{\r\n    Flanker,\r\n    Retreater,\r\n    Aggressive,\r\n    Defensive\r\n}\r\n```\r\n\r\n#### Step 2: Hook Enemy Movement Tracking\r\n\r\n**File**: `EnemyMovementObserver.cs`\r\n\r\n```csharp\r\npublic class EnemyMovementObserver : MonoBehaviour\r\n{\r\n    private Dictionary<string, Vector3> _lastEnemyPositions =\r\n        new Dictionary<string, Vector3>();\r\n\r\n    public void Update()\r\n    {\r\n        foreach (var bot in GetSquadMembers())\r\n        {\r\n            if (bot.Memory.GoalEnemy == null) continue;\r\n\r\n            Enemy enemy = GetEnemyInfo(bot.Memory.GoalEnemy);\r\n            string enemyId = enemy.ProfileId;\r\n\r\n            // Track position changes\r\n            if (_lastEnemyPositions.TryGetValue(enemyId, out var lastPos))\r\n            {\r\n                Vector3 currentPos = enemy.EnemyPosition;\r\n                float movementDist = Vector3.Distance(lastPos, currentPos);\r\n\r\n                // Detect flank if moved significantly to side\r\n                if (movementDist > 5f)\r\n                {\r\n                    Vector3 botPos = bot.Position;\r\n                    Vector3 lastDir = (lastPos - botPos).normalized;\r\n                    Vector3 currDir = (currentPos - botPos).normalized;\r\n\r\n                    float angle = Vector3.Angle(lastDir, currDir);\r\n\r\n                    if (angle > 45f)\r\n                    {\r\n                        // Enemy flanking\r\n                        TacticalObservationTracker.Instance\r\n                            .ObserveEnemyFlank(enemyId, currDir);\r\n                    }\r\n                }\r\n\r\n                // Detect retreat\r\n                float lastDist = Vector3.Distance(botPos, lastPos);\r\n                float currDist = Vector3.Distance(botPos, currentPos);\r\n\r\n                if (currDist > lastDist + 3f)\r\n                {\r\n                    // Enemy retreating\r\n                    TacticalObservationTracker.Instance\r\n                        .ObserveEnemyRetreat(enemyId, currDist - lastDist);\r\n                }\r\n                else if (currDist < lastDist - 3f)\r\n                {\r\n                    // Enemy pushing\r\n                    TacticalObservationTracker.Instance\r\n                        .ObserveAggressivePush(enemyId);\r\n                }\r\n            }\r\n\r\n            _lastEnemyPositions[enemyId] = enemy.EnemyPosition;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Implementation Time**: 3-4 days\r\n**APIs Used**:\r\n- ‚úÖ Enemy tracking: `02-Bot-AI-Brain.md` Section 1 (EnemyInfo)\r\n- ‚úÖ Memory events: `02-Bot-AI-Brain.md` Section 8.2\r\n- ‚úÖ Position tracking: Standard Unity Vector3\r\n\r\n**Testing Checklist**:\r\n- [ ] Detects enemy flanking attempts\r\n- [ ] Counts enemy retreats\r\n- [ ] Identifies aggressive pushes\r\n- [ ] Squad adjusts tactics accordingly\r\n- [ ] Reset between raids\r\n\r\n---\r\n\r\n## Innovation #5: Casualty Evacuation System\r\n\r\n**Alignment**: Phase 12B (Medic), Phase 12C (Downed States), realism\r\n**Complexity**: VERY HIGH\r\n**API Coverage**: ‚úÖ 80% - Some gaps in drag mechanics\r\n\r\n### What It Does\r\n\r\nBots evacuate wounded to cover:\r\n- **Detect Critical** - Monitor health thresholds\r\n- **Drag to Safety** - Move wounded to nearest cover\r\n- **Field Treatment** - Stabilize in cover\r\n- **Extract Coordination** - Help wounded reach extraction\r\n\r\n### Implementation Plan\r\n\r\n#### Step 1: Create Casualty Detection System\r\n\r\n**File**: `CasualtyDetectionSystem.cs`\r\n\r\n```csharp\r\nusing Reference: 05-Health-Medical-System.md Section 6\r\n\r\npublic class CasualtyDetectionSystem : MonoBehaviour\r\n{\r\n    private Dictionary<Player, CasualtyState> _casualties =\r\n        new Dictionary<Player, CasualtyState>();\r\n\r\n    private class CasualtyState\r\n    {\r\n        public float DetectionTime;\r\n        public bool UnderFire;\r\n        public EBodyPart CriticalPart;\r\n        public bool Evacuating;\r\n    }\r\n\r\n    public void Update()\r\n    {\r\n        // Monitor squad members\r\n        foreach (var bot in GetSquadMembers())\r\n        {\r\n            Player player = bot.GetPlayer;\r\n\r\n            if (IsCriticallyWounded(player))\r\n            {\r\n                if (!_casualties.ContainsKey(player))\r\n                {\r\n                    RegisterCasualty(player, bot);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                _casualties.Remove(player);\r\n            }\r\n        }\r\n\r\n        // Process evacuations\r\n        ProcessEvacuations();\r\n    }\r\n\r\n    private bool IsCriticallyWounded(Player player)\r\n    {\r\n        IHealthController health = player.HealthController;\r\n\r\n        // Check overall < 30%\r\n        ValueStruct commonHealth = health.GetBodyPartHealth(EBodyPart.Common, false);\r\n        if (commonHealth.Normalized < 0.3f)\r\n            return true;\r\n\r\n        // Check vital parts < 40%\r\n        ValueStruct chest = health.GetBodyPartHealth(EBodyPart.Chest, false);\r\n        ValueStruct head = health.GetBodyPartHealth(EBodyPart.Head, false);\r\n\r\n        if (chest.Normalized < 0.4f || head.Normalized < 0.5f)\r\n            return true;\r\n\r\n        // Check heavy bleeding\r\n        if (health.FindExistingEffect<GInterface340>(EBodyPart.Common) != null)\r\n            return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    private void RegisterCasualty(Player player, BotOwner bot)\r\n    {\r\n        var state = new CasualtyState\r\n        {\r\n            DetectionTime = Time.time,\r\n            UnderFire = bot.Memory.IsUnderFire,\r\n            CriticalPart = FindCriticalPart(player.HealthController),\r\n            Evacuating = false\r\n        };\r\n\r\n        _casualties[player] = state;\r\n\r\n        // Trigger evacuation\r\n        StartEvacuation(player, state);\r\n    }\r\n\r\n    private EBodyPart FindCriticalPart(IHealthController health)\r\n    {\r\n        // Find most damaged vital part\r\n        float minHealth = 1f;\r\n        EBodyPart criticalPart = EBodyPart.Chest;\r\n\r\n        foreach (EBodyPart part in new[] { EBodyPart.Head, EBodyPart.Chest, EBodyPart.Stomach })\r\n        {\r\n            ValueStruct partHealth = health.GetBodyPartHealth(part, false);\r\n            if (partHealth.Normalized < minHealth)\r\n            {\r\n                minHealth = partHealth.Normalized;\r\n                criticalPart = part;\r\n            }\r\n        }\r\n\r\n        return criticalPart;\r\n    }\r\n}\r\n```\r\n\r\n#### Step 2: Create Evacuation Executor\r\n\r\n**File**: `CasualtyEvacuationExecutor.cs`\r\n\r\n```csharp\r\nusing Reference: 05-Health-Medical-System.md Section 7.2\r\nusing Reference: 08-Cover-Navigation-System.md Section 4\r\n\r\npublic class CasualtyEvacuationExecutor\r\n{\r\n    private enum EvacPhase\r\n    {\r\n        FindCover,\r\n        MoveToWounded,\r\n        DragToCover,\r\n        ApplyTreatment,\r\n        Complete\r\n    }\r\n\r\n    private EvacPhase _phase = EvacPhase.FindCover;\r\n    private BotOwner _medic;\r\n    private Player _wounded;\r\n    private CustomNavigationPoint _evacCover;\r\n\r\n    public void StartEvacuation(BotOwner medic, Player wounded)\r\n    {\r\n        _medic = medic;\r\n        _wounded = wounded;\r\n        _phase = EvacPhase.FindCover;\r\n    }\r\n\r\n    public void Update()\r\n    {\r\n        switch (_phase)\r\n        {\r\n            case EvacPhase.FindCover:\r\n                if (FindEvacuationCover())\r\n                {\r\n                    _phase = EvacPhase.MoveToWounded;\r\n\r\n                    // Announce\r\n                    _medic.BotTalk.TrySay(EPhraseTrigger.OnYourWay);\r\n                }\r\n                break;\r\n\r\n            case EvacPhase.MoveToWounded:\r\n                if (MoveToWounded())\r\n                {\r\n                    _phase = EvacPhase.DragToCover;\r\n                }\r\n                break;\r\n\r\n            case EvacPhase.DragToCover:\r\n                if (DragToCover())\r\n                {\r\n                    _phase = EvacPhase.ApplyTreatment;\r\n                }\r\n                break;\r\n\r\n            case EvacPhase.ApplyTreatment:\r\n                if (ApplyEmergencyTreatment())\r\n                {\r\n                    _phase = EvacPhase.Complete;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    private bool FindEvacuationCover()\r\n    {\r\n        Vector3 woundedPos = _wounded.Position;\r\n        BotOwner woundedBot = _wounded.AIData?.BotOwner;\r\n\r\n        // Get danger direction\r\n        Vector3 dangerDirection = Vector3.zero;\r\n        if (woundedBot?.Memory.LastHitPos != null)\r\n        {\r\n            dangerDirection = (woundedBot.Memory.LastHitPos - woundedPos).normalized;\r\n        }\r\n\r\n        // Find cover away from danger (from 08-Cover-Navigation)\r\n        Vector3 retreatDirection = -dangerDirection;\r\n        Vector3 searchCenter = woundedPos + retreatDirection * 15f;\r\n\r\n        _evacCover = Covers.GetClosestCoverPoint(\r\n            _medic,\r\n            searchCenter,\r\n            25f,\r\n            point =>\r\n            {\r\n                // Must have path to wounded\r\n                NavMeshPath path = new NavMeshPath();\r\n                if (!NavMesh.CalculatePath(point.Position, woundedPos, -1, path))\r\n                    return false;\r\n\r\n                if (path.status != NavMeshPathStatus.PathComplete)\r\n                    return false;\r\n\r\n                float pathLength = path.CalculatePathLength();\r\n                return pathLength <= 30f;\r\n            }\r\n        );\r\n\r\n        return _evacCover != null;\r\n    }\r\n\r\n    private bool MoveToWounded()\r\n    {\r\n        float dist = Vector3.Distance(_medic.Position, _wounded.Position);\r\n\r\n        if (dist < 2f)\r\n        {\r\n            // In range\r\n            return true;\r\n        }\r\n\r\n        // Move to wounded\r\n        SAINMoverClass mover = GetSAINMover(_medic);\r\n        mover?.RunToPoint(_wounded.Position, reachDist: 1.5f,\r\n            urgency: ESprintUrgency.High);\r\n\r\n        return false;\r\n    }\r\n\r\n    private bool DragToCover()\r\n    {\r\n        // NOTE: Actual drag mechanic not in Tarkov API\r\n        // Workaround: Move medic to cover, teleport wounded after\r\n\r\n        float dist = Vector3.Distance(_medic.Position, _evacCover.Position);\r\n\r\n        if (dist < 1.5f)\r\n        {\r\n            // At cover, teleport wounded (simplified)\r\n            _wounded.Teleport(_evacCover.Position);\r\n            return true;\r\n        }\r\n\r\n        // Move to cover (slowly, \"dragging\")\r\n        SAINMoverClass mover = GetSAINMover(_medic);\r\n        mover?.WalkToPoint(_evacCover.Position, reachDist: 1f);\r\n        mover?.SetTargetMoveSpeed(0.3f);  // 30% speed (dragging)\r\n\r\n        return false;\r\n    }\r\n\r\n    private bool ApplyEmergencyTreatment()\r\n    {\r\n        IHealthController health = _wounded.HealthController;\r\n\r\n        // Stop heavy bleeding first\r\n        if (health.FindExistingEffect<GInterface340>(EBodyPart.Common) != null)\r\n        {\r\n            // Apply hemostatic\r\n            _medic.BotTalk.TrySay(EPhraseTrigger.Heal);\r\n            // Would use medical item here\r\n        }\r\n\r\n        // Partial restoration\r\n        ActiveHealthController activeHealth = _wounded.ActiveHealthController;\r\n        if (activeHealth != null)\r\n        {\r\n            activeHealth.RestoreBodyPart(EBodyPart.Chest, 0.3f);\r\n            activeHealth.RestoreBodyPart(EBodyPart.Head, 0.3f);\r\n            activeHealth.RestoreBodyPart(EBodyPart.Stomach, 0.3f);\r\n        }\r\n\r\n        _medic.BotTalk.TrySay(EPhraseTrigger.Possible); // \"Done\"\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n**Implementation Time**: 1.5 weeks\r\n**APIs Used**:\r\n- ‚úÖ Health monitoring: `05-Health-Medical-System.md` Section 6\r\n- ‚úÖ Cover finding: `08-Cover-Navigation-System.md` Section 2\r\n- ‚úÖ Movement: `08-Cover-Navigation-System.md` Section 3\r\n- ‚ö†Ô∏è Drag mechanics: Not in API (workaround with teleport/slow movement)\r\n\r\n**Testing Checklist**:\r\n- [ ] Detects critically wounded teammates\r\n- [ ] Finds safe evacuation cover\r\n- [ ] Moves to wounded location\r\n- [ ] \"Drags\" to cover (visual approximation)\r\n- [ ] Applies emergency treatment\r\n- [ ] Other bots provide covering fire\r\n\r\n---\r\n\r\n## Implementation Priority Recommendation\r\n\r\n### Tier 1: Quick Wins (Implement First)\r\n**After Phase 0-7 baseline complete**\r\n\r\n1. ‚úÖ **Innovation #4: Adaptive Learning** (3-4 days)\r\n   - 100% API coverage\r\n   - Pure logic, no complex systems\r\n   - High gameplay impact\r\n   - Demonstrates emergent behavior\r\n\r\n2. ‚úÖ **Innovation #1: Dynamic Formations** (2-3 days)\r\n   - 100% API coverage\r\n   - Mostly math/geometry\r\n   - Visual impact\r\n   - Foundation for other features\r\n\r\n**Combined Effort**: 1 week\r\n**Benefit**: Immediate gameplay enhancement, validates knowledge base\r\n\r\n---\r\n\r\n### Tier 2: High-Value Features (Implement Next)\r\n**After Tier 1 + Phase 8-9 complete**\r\n\r\n3. ‚úÖ **Innovation #3: Fire Support** (1 week)\r\n   - 95% API coverage\r\n   - Enhances Support tactic\r\n   - Tactical depth\r\n   - Builds on Phase 6 combat AI\r\n\r\n4. ‚úÖ **Innovation #2: Door Breaching** (1 week)\r\n   - 90% API coverage\r\n   - Signature cinematic feature\r\n   - Implements Phase 16\r\n   - Requires grenade + door systems\r\n\r\n**Combined Effort**: 2 weeks\r\n**Benefit**: Major tactical features, cinematic moments\r\n\r\n---\r\n\r\n### Tier 3: Advanced Systems (Implement Last)\r\n**After Tier 2 + Phase 10-11 complete**\r\n\r\n5. ‚ö†Ô∏è **Innovation #5: Casualty Evacuation** (1.5 weeks)\r\n   - 80% API coverage\r\n   - Requires workarounds (drag mechanic)\r\n   - Implements Phase 12B+C\r\n   - Ultimate immersion feature\r\n\r\n**Effort**: 1.5 weeks\r\n**Benefit**: Unique feature, ultimate realism\r\n\r\n---\r\n\r\n## Summary: Innovation Readiness Matrix\r\n\r\n| Innovation | Complexity | API Coverage | Dependencies | Est. Time | Gameplay Impact |\r\n|------------|-----------|--------------|--------------|-----------|-----------------|\r\n| **#1 Formations** | Medium | 100% | Cover/Nav | 2-3 days | High |\r\n| **#2 Door Breach** | High | 90% | Grenade, Door, Cover | 1 week | Very High |\r\n| **#3 Fire Support** | Medium | 95% | Ammo, Combat AI | 1 week | High |\r\n| **#4 Adaptive Learning** | Medium | 100% | Memory events | 3-4 days | Medium-High |\r\n| **#5 Casualty Evac** | Very High | 80% | Health, Cover, Movement | 1.5 weeks | Very High |\r\n\r\n---\r\n\r\n## API Cross-Reference by Innovation\r\n\r\n### Innovation #1 (Formations)\r\n- Formation calculations: `08-Cover-Navigation-System.md` Section 4\r\n- Position validation: `08-Cover-Navigation-System.md` Section 4\r\n- Movement control: `08-Cover-Navigation-System.md` Section 3\r\n- Spacing utilities: `08-Cover-Navigation-System.md` Section 4\r\n\r\n### Innovation #2 (Door Breach)\r\n- Breach positions: `08-Cover-Navigation-System.md` Section 5\r\n- Flashbang throwing: `06-Grenade-Explosive-System.md` Section 9 Example 1\r\n- Door interaction: `06-Grenade-Explosive-System.md` Section 5\r\n- Entry coordination: `08-Cover-Navigation-System.md` Section 3\r\n\r\n### Innovation #3 (Fire Support)\r\n- Ammo tracking: `09-Item-Loot-System.md` Section 5\r\n- Suppression request: `04-Voice-Gesture-Commands.md` Section 6\r\n- Memory events: `02-Bot-AI-Brain.md` Section 8.2\r\n- Sector calculations: `08-Cover-Navigation-System.md` Section 5\r\n\r\n### Innovation #4 (Learning)\r\n- Enemy tracking: `02-Bot-AI-Brain.md` Section 1\r\n- Memory events: `02-Bot-AI-Brain.md` Section 8.2\r\n- Position tracking: Unity Vector3 math\r\n- Tactical adjustments: Custom logic layer\r\n\r\n### Innovation #5 (Evac)\r\n- Health monitoring: `05-Health-Medical-System.md` Section 6\r\n- Critical detection: `05-Health-Medical-System.md` Section 7.2\r\n- Cover finding: `08-Cover-Navigation-System.md` Section 2\r\n- Movement: `08-Cover-Navigation-System.md` Section 3\r\n- Treatment: `05-Health-Medical-System.md` Section 3\r\n\r\n---\r\n\r\n## Development Timeline\r\n\r\n### Scenario: Complete Innovation Suite\r\n\r\n**Prerequisites**: Phases 0-7 complete (6-8 weeks)\r\n\r\n**Week 9**: Innovation #4 (Learning) + #1 (Formations)\r\n- 3 days: Adaptive learning system\r\n- 2 days: Formation manager\r\n- 2 days: Testing & polish\r\n\r\n**Week 10**: Innovation #3 (Fire Support)\r\n- 2 days: Fire support layer\r\n- 2 days: Ammo management integration\r\n- 3 days: Suppression effects & testing\r\n\r\n**Week 11**: Innovation #2 (Door Breach)\r\n- 3 days: Breach coordinator\r\n- 2 days: Flashbang integration\r\n- 2 days: Entry system & testing\r\n\r\n**Week 12-13**: Innovation #5 (Casualty Evac)\r\n- 3 days: Detection & cover finding\r\n- 3 days: Evacuation executor\r\n- 2 days: Treatment system\r\n- 2 days: Testing & polish\r\n\r\n**Total**: 4 weeks (after baseline)\r\n**Result**: Complete innovation suite with all 5 features\r\n\r\n---\r\n\r\n## Success Metrics\r\n\r\n### Innovation #1: Formations\r\n- [ ] Squad maintains wedge in open terrain\r\n- [ ] Switches to column in buildings\r\n- [ ] Forms defensive line when enemy spotted\r\n- [ ] Spacing maintained (2-3m between members)\r\n- [ ] Adjusts for obstacles automatically\r\n\r\n### Innovation #2: Door Breach\r\n- [ ] Team stacks on door correctly\r\n- [ ] Flashbang thrown through doorway\r\n- [ ] Door breached after flash detonation\r\n- [ ] Entry team flows through with sectors\r\n- [ ] No friendly fire during breach\r\n\r\n### Innovation #3: Fire Support\r\n- [ ] Support bot suppresses on command\r\n- [ ] Tracks ammo and conserves when low\r\n- [ ] Suppressed enemies stay in cover\r\n- [ ] Coordinates with squad advances\r\n- [ ] Ammo sharing when teammate low\r\n\r\n### Innovation #4: Learning\r\n- [ ] Detects enemy flanking (3+ attempts)\r\n- [ ] Detects enemy retreats (2+ times)\r\n- [ ] Detects aggressive pushes\r\n- [ ] Squad adapts tactics accordingly\r\n- [ ] Reset between raids (no persistence)\r\n\r\n### Innovation #5: Evac\r\n- [ ] Detects critical wounds (player/bot)\r\n- [ ] Finds safe evacuation cover\r\n- [ ] Medic reaches wounded location\r\n- [ ] Evacuates to cover\r\n- [ ] Applies emergency treatment\r\n- [ ] Squad provides covering fire\r\n\r\n---\r\n\r\n## Final Notes\r\n\r\n**All 5 innovations are implementable** using the documented APIs in the knowledge base:\r\n- `02-Bot-AI-Brain.md`\r\n- `05-Health-Medical-System.md`\r\n- `06-Grenade-Explosive-System.md`\r\n- `08-Cover-Navigation-System.md`\r\n- `09-Item-Loot-System.md`\r\n\r\n**Start with Tier 1** (Adaptive Learning + Formations) to:\r\n- Validate the knowledge base\r\n- Demonstrate value quickly\r\n- Build momentum\r\n\r\n**Then proceed through Tiers 2-3** for complete innovation suite.\r\n\r\n**Total Implementation**: ~13 weeks (Phases 0-7 + 4 weeks innovations)\r\n\r\n---\r\n\r\n**The knowledge base is complete. All systems documented. Ready to build!** üöÄ\r\n"},"12-SAIN-INTEGRATION-GUIDE":{"title":"SAIN AI Integration Guide for FriendlyPMC\r","category":"Core Systems","content":"# SAIN AI Integration Guide for FriendlyPMC\r\n\r\n**Purpose**: Technical guide for integrating SAIN AI patterns into FriendlyPMC\r\n**Last Updated**: 2025-11-21\r\n**SAIN Version**: 4.2.0+\r\n**FriendlyPMC Target**: SPT 4.0.5+\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nThe SAIN (SolarintAI Improvements) mod provides a **comprehensive AI enhancement framework** with 682 C# files implementing sophisticated bot behavior. This guide shows how FriendlyPMC can leverage SAIN's proven patterns without requiring SAIN as a dependency.\r\n\r\n**Integration Approaches**:\r\n1. **Pattern Adoption** - Use SAIN's architectural patterns (recommended)\r\n2. **Optional Dependency** - Detect and enhance if SAIN present\r\n3. **Standalone Implementation** - Implement SAIN-inspired systems independently\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [SAIN Architecture Overview](#1-sain-architecture-overview)\r\n2. [Integration Strategy](#2-integration-strategy)\r\n3. [Component-Based Design Pattern](#3-component-based-design-pattern)\r\n4. [Decision System Integration](#4-decision-system-integration)\r\n5. [Squad Coordination Patterns](#5-squad-coordination-patterns)\r\n6. [Event-Driven Updates](#6-event-driven-updates)\r\n7. [Performance Optimization Patterns](#7-performance-optimization-patterns)\r\n8. [Optional SAIN Enhancement](#8-optional-sain-enhancement)\r\n9. [Implementation Roadmap](#9-implementation-roadmap)\r\n\r\n---\r\n\r\n## 1. SAIN Architecture Overview\r\n\r\n### Component Hierarchy\r\n\r\n**From**: `knowledge/AI/Architecture.md`\r\n\r\n```\r\nGameWorldComponent (Singleton)\r\n    ‚îî‚îÄ‚îÄ BotManagerComponent (Singleton)\r\n            ‚îú‚îÄ‚îÄ JobManager (raycast jobs)\r\n            ‚îú‚îÄ‚îÄ CoverManager (global cover pooling)\r\n            ‚îî‚îÄ‚îÄ BotComponent (per bot)\r\n                    ‚îú‚îÄ‚îÄ SAINDecisionClass (master decision)\r\n                    ‚îú‚îÄ‚îÄ SAINEnemyController (enemy tracking)\r\n                    ‚îú‚îÄ‚îÄ SAINVisionClass (vision)\r\n                    ‚îú‚îÄ‚îÄ SAINHearingSensorClass (hearing)\r\n                    ‚îú‚îÄ‚îÄ SAINMoverClass (movement)\r\n                    ‚îú‚îÄ‚îÄ SAINCoverClass (cover system)\r\n                    ‚îú‚îÄ‚îÄ BotGrenadeManager (grenades)\r\n                    ‚îî‚îÄ‚îÄ 18+ other components\r\n```\r\n\r\n### Key Design Patterns\r\n\r\n**From**: `knowledge/AI/Architecture.md` Section 2\r\n\r\n1. **Component-Based Design** - Modular subsystems\r\n2. **Singleton Managers** - Global coordination\r\n3. **Strategy Pattern** - Multiple decision types\r\n4. **Observer Pattern** - Event-driven updates\r\n5. **Object Pooling** - Performance optimization\r\n6. **State Machine** - Tick rate management\r\n\r\n---\r\n\r\n## 2. Integration Strategy\r\n\r\n### Option A: Pattern Adoption (Recommended)\r\n\r\n**Adopt SAIN's proven patterns** without dependency:\r\n\r\n‚úÖ **Benefits**:\r\n- Proven architecture (SAIN ships and works)\r\n- No mod dependency (cleaner for users)\r\n- Full control over implementation\r\n- Can customize for followers specifically\r\n\r\n‚ùå **Tradeoffs**:\r\n- More code to write\r\n- Need to maintain implementations\r\n- Miss automatic SAIN improvements\r\n\r\n**Use For**:\r\n- FollowerAI component system\r\n- Decision-making architecture\r\n- Event-driven cluster perception\r\n- Tick rate optimization\r\n\r\n---\r\n\r\n### Option B: Optional Dependency\r\n\r\n**Detect SAIN and enhance** follower behavior:\r\n\r\n```csharp\r\npublic class FollowerSAINDetector\r\n{\r\n    public static bool IsSAINPresent()\r\n    {\r\n        return AppDomain.CurrentDomain.GetAssemblies()\r\n            .Any(a => a.GetName().Name.Contains(\"SAIN\"));\r\n    }\r\n\r\n    public static BotComponent GetSAINComponent(BotOwner botOwner)\r\n    {\r\n        if (!IsSAINPresent()) return null;\r\n\r\n        return botOwner.GetComponent<BotComponent>();\r\n    }\r\n}\r\n```\r\n\r\n**Enhanced Follower with SAIN**:\r\n```csharp\r\npublic void InitializeFollower(BotOwner follower)\r\n{\r\n    if (FollowerSAINDetector.IsSAINPresent())\r\n    {\r\n        // Use SAIN components\r\n        var sainBot = FollowerSAINDetector.GetSAINComponent(follower);\r\n        if (sainBot != null)\r\n        {\r\n            // Access SAIN's superior systems\r\n            sainBot.Decision.EnemyDecisions.ManualUpdate();\r\n            sainBot.Cover.FindCover();\r\n            sainBot.Mover.RunToPoint(targetPos);\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Fallback to vanilla AI\r\n    UseVanillaFollowerAI(follower);\r\n}\r\n```\r\n\r\n‚úÖ **Benefits**:\r\n- Best of both worlds\r\n- SAIN users get enhanced behavior\r\n- Non-SAIN users get functional mod\r\n- Leverage SAIN's complexity when available\r\n\r\n‚ùå **Tradeoffs**:\r\n- Need to maintain two code paths\r\n- Testing complexity (with/without SAIN)\r\n- SAIN API changes could break integration\r\n\r\n**Use For**:\r\n- Enhanced decision-making (SAIN's 3-layer system)\r\n- Superior cover finding (SAIN's CoverManager)\r\n- Advanced movement (SAINMoverClass)\r\n\r\n---\r\n\r\n### Option C: Standalone with SAIN-Inspired Design\r\n\r\n**Build standalone** using SAIN patterns as reference:\r\n\r\n‚úÖ **Benefits**:\r\n- Complete independence\r\n- Optimized for followers specifically\r\n- Simpler than full SAIN implementation\r\n- No compatibility issues\r\n\r\n‚ùå **Tradeoffs**:\r\n- Can't leverage SAIN's work directly\r\n- Reinventing some wheels\r\n- Miss SAIN community improvements\r\n\r\n**Use For**:\r\n- FollowerComponent architecture\r\n- Simplified decision system\r\n- Follower-specific optimizations\r\n\r\n---\r\n\r\n## 3. Component-Based Design Pattern\r\n\r\n### SAIN's Component Pattern\r\n\r\n**From**: `knowledge/AI/CoreComponents.md`\r\n\r\n```csharp\r\npublic class BotComponent : MonoBehaviour\r\n{\r\n    // Decision Systems\r\n    public SAINDecisionClass Decision { get; private set; }\r\n\r\n    // Sensory Systems\r\n    public SAINVisionClass Vision { get; private set; }\r\n    public SAINHearingSensorClass Hearing { get; private set; }\r\n\r\n    // Combat Systems\r\n    public SAINShootData Shoot { get; private set; }\r\n    public BotGrenadeManager Grenade { get; private set; }\r\n\r\n    // Movement Systems\r\n    public SAINMoverClass Mover { get; private set; }\r\n    public SAINCoverClass Cover { get; private set; }\r\n\r\n    // Enemy Management\r\n    public SAINEnemyController EnemyController { get; private set; }\r\n}\r\n```\r\n\r\n### FriendlyPMC Adaptation\r\n\r\n**Create FollowerComponent** inspired by SAIN:\r\n\r\n```csharp\r\npublic class FollowerComponent : MonoBehaviour\r\n{\r\n    // Core References\r\n    public BotOwner BotOwner { get; private set; }\r\n    public Player Player { get; private set; }\r\n    public FollowerBrain Brain { get; private set; }\r\n\r\n    // Follower-Specific\r\n    public FollowerLeaderTracker LeaderTracker { get; private set; }\r\n    public FollowerFormationManager FormationManager { get; private set; }\r\n    public FollowerCommandHandler CommandHandler { get; private set; }\r\n\r\n    // Decision System (simplified from SAIN)\r\n    public FollowerDecisionManager DecisionManager { get; private set; }\r\n\r\n    // Cluster Perception (Phase 6)\r\n    public ClusterPerceptionInterface ClusterPerception { get; private set; }\r\n\r\n    // Combat (reuse SAIN patterns)\r\n    public FollowerCombatController Combat { get; private set; }\r\n\r\n    // Movement (adopt SAIN movement patterns)\r\n    public FollowerMovementController Movement { get; private set; }\r\n\r\n    // Medical (Phase 12B)\r\n    public FollowerMedicController Medic { get; private set; }\r\n\r\n    public void Initialize(BotOwner botOwner, Player leader)\r\n    {\r\n        BotOwner = botOwner;\r\n        Player = botOwner.GetPlayer;\r\n\r\n        // Create components\r\n        LeaderTracker = new FollowerLeaderTracker(this, leader);\r\n        FormationManager = new FollowerFormationManager(this);\r\n        CommandHandler = new FollowerCommandHandler(this);\r\n        DecisionManager = new FollowerDecisionManager(this);\r\n        ClusterPerception = new ClusterPerceptionInterface(this);\r\n        Combat = new FollowerCombatController(this);\r\n        Movement = new FollowerMovementController(this);\r\n        Medic = new FollowerMedicController(this);\r\n\r\n        // Initialize all components\r\n        InitializeAllComponents();\r\n    }\r\n\r\n    private void InitializeAllComponents()\r\n    {\r\n        LeaderTracker.Init();\r\n        FormationManager.Init();\r\n        CommandHandler.Init();\r\n        DecisionManager.Init();\r\n        ClusterPerception.Init();\r\n        Combat.Init();\r\n        Movement.Init();\r\n        Medic.Init();\r\n    }\r\n\r\n    public void ManualUpdate()\r\n    {\r\n        // Tick components (SAIN pattern)\r\n        if (BotOwner.BotState != EBotState.Active)\r\n            return;\r\n\r\n        LeaderTracker.Update();\r\n        ClusterPerception.Update();\r\n        DecisionManager.Update();\r\n\r\n        if (BotOwner.Memory.GoalEnemy != null)\r\n        {\r\n            // In combat\r\n            Combat.Update();\r\n        }\r\n\r\n        Movement.Update();\r\n        FormationManager.Update();\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        // Cleanup all components\r\n        LeaderTracker?.Dispose();\r\n        FormationManager?.Dispose();\r\n        CommandHandler?.Dispose();\r\n        DecisionManager?.Dispose();\r\n        ClusterPerception?.Dispose();\r\n        Combat?.Dispose();\r\n        Movement?.Dispose();\r\n        Medic?.Dispose();\r\n    }\r\n}\r\n```\r\n\r\n**Benefits of Component Pattern**:\r\n- ‚úÖ Clear separation of concerns\r\n- ‚úÖ Easy to add/remove features\r\n- ‚úÖ Testable in isolation\r\n- ‚úÖ Follows SAIN's proven structure\r\n\r\n---\r\n\r\n## 4. Decision System Integration\r\n\r\n### SAIN's 3-Layer Decision System\r\n\r\n**From**: `knowledge/AI/AIDecisionSystem.md`\r\n\r\n```\r\nSAINDecisionClass\r\n    ‚îú‚îÄ‚îÄ EnemyDecisionClass ‚Üí ECombatDecision (16 types)\r\n    ‚îú‚îÄ‚îÄ SquadDecisionClass ‚Üí ESquadDecision (11 types)\r\n    ‚îî‚îÄ‚îÄ SelfActionDecisionClass ‚Üí ESelfActionType (6 types)\r\n```\r\n\r\n### FriendlyPMC Adaptation\r\n\r\n**Simplified Decision System** for followers:\r\n\r\n```csharp\r\npublic enum EFollowerDecision\r\n{\r\n    None,\r\n    FollowLeader,        // Stay close to leader\r\n    EngageEnemy,         // Combat enemy\r\n    SeekCover,           // Move to cover\r\n    ExecuteCommand,      // Voice command override\r\n    ProvideSupport,      // Support fire\r\n    HealLeader,          // Medic: treat leader\r\n    EvacuateCasualty,    // Medic: evacuate wounded\r\n    StackForBreach       // Breach: door stack\r\n}\r\n\r\npublic class FollowerDecisionManager\r\n{\r\n    private FollowerComponent _bot;\r\n\r\n    public EFollowerDecision CurrentDecision { get; private set; }\r\n    public float TimeSinceDecisionChange { get; private set; }\r\n\r\n    public EFollowerDecision GetDecision()\r\n    {\r\n        // Priority 1: Voice command override\r\n        if (HasActiveCommand())\r\n            return EFollowerDecision.ExecuteCommand;\r\n\r\n        // Priority 2: Medic actions (if medic role)\r\n        if (_bot.Medic.IsM edic)\r\n        {\r\n            if (_bot.Medic.LeaderNeedsTreatment())\r\n                return EFollowerDecision.HealLeader;\r\n\r\n            if (_bot.Medic.SquadHasCasualty())\r\n                return EFollowerDecision.EvacuateCasualty;\r\n        }\r\n\r\n        // Priority 3: Combat decisions (from SAIN pattern)\r\n        if (_bot.BotOwner.Memory.GoalEnemy != null)\r\n        {\r\n            Enemy enemy = _bot.BotOwner.Memory.GoalEnemy;\r\n\r\n            // Use SAIN-inspired combat logic\r\n            if (ShouldSeekCover(enemy))\r\n                return EFollowerDecision.SeekCover;\r\n\r\n            if (ShouldProvideSupport(enemy))\r\n                return EFollowerDecision.ProvideSupport;\r\n\r\n            return EFollowerDecision.EngageEnemy;\r\n        }\r\n\r\n        // Priority 4: Tactical positioning\r\n        if (_bot.FormationManager.RequiresRepositioning())\r\n            return EFollowerDecision.FollowLeader;\r\n\r\n        // Default: Follow leader\r\n        return EFollowerDecision.FollowLeader;\r\n    }\r\n\r\n    // Adopt SAIN's decision logic patterns\r\n    private bool ShouldSeekCover(Enemy enemy)\r\n    {\r\n        // From AIDecisionSystem.md - Cover Decision\r\n        if (_bot.BotOwner.Memory.IsInCover &&\r\n            _bot.BotOwner.Memory.CurCustomCoverPoint != null)\r\n            return false;  // Already in good cover\r\n\r\n        if (enemy.IsVisible && WasRecentlyHit())\r\n            return true;\r\n\r\n        float healthPercent = GetHealthPercent();\r\n        if (healthPercent < 0.5f)\r\n            return true;\r\n\r\n        return false;\r\n    }\r\n\r\n    private bool ShouldProvideSupport(Enemy enemy)\r\n    {\r\n        // Support tactic + leader in combat\r\n        if (_bot.Brain.BossTactic != \"Support\")\r\n            return false;\r\n\r\n        if (_bot.LeaderTracker.LeaderInCombat)\r\n            return true;\r\n\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n**Integration with BigBrain** (using SAIN pattern):\r\n\r\n```csharp\r\npublic class FollowerCombatLayer : BaseLogicLayerSimpleAbstractClass\r\n{\r\n    private FollowerComponent _follower;\r\n\r\n    public override AICoreActionResultStruct<BotLogicDecision, GClass26> GetDecision()\r\n    {\r\n        EFollowerDecision decision = _follower.DecisionManager.GetDecision();\r\n\r\n        // Map follower decisions to BotLogicDecision (SAIN pattern)\r\n        return decision switch\r\n        {\r\n            EFollowerDecision.FollowLeader => new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                BotLogicDecision.followPlayer, \"Following leader\"),\r\n\r\n            EFollowerDecision.EngageEnemy => InFightLogic() ?? new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                BotLogicDecision.shootFromCover, \"Engaging enemy\"),\r\n\r\n            EFollowerDecision.SeekCover => new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                BotLogicDecision.goToCoverPoint, \"Seeking cover\"),\r\n\r\n            EFollowerDecision.ProvideSupport => new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                BotLogicDecision.suppressionFire, \"Providing support\"),\r\n\r\n            EFollowerDecision.HealLeader => new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                BotLogicDecision.firstAid, \"Healing leader\"),\r\n\r\n            _ => new AICoreActionResultStruct<BotLogicDecision, GClass26>(\r\n                BotLogicDecision.holdPosition, \"Holding\")\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 5. Squad Coordination Patterns\r\n\r\n### SAIN Squad System\r\n\r\n**From**: `knowledge/AI/CoreComponents.md` Section 5\r\n\r\n```csharp\r\npublic class BotSquadContainer\r\n{\r\n    public SquadInfo SquadInfo { get; }\r\n    public bool BotInGroup { get; }\r\n}\r\n\r\npublic class SquadInfo\r\n{\r\n    public Dictionary<string, BotComponent> Members { get; }\r\n    public int MemberCount { get; }\r\n    public BotComponent Leader { get; }\r\n}\r\n```\r\n\r\n### FriendlyPMC Squad Integration\r\n\r\n**Leverage for Cluster Perception** (Phase 6):\r\n\r\n```csharp\r\npublic class FollowerClusterManager : MonoBehaviour\r\n{\r\n    // Adopt SAIN's squad tracking pattern\r\n    private Dictionary<string, FollowerCluster> _clusters =\r\n        new Dictionary<string, FollowerCluster>();\r\n\r\n    public class FollowerCluster\r\n    {\r\n        public string ClusterId { get; set; }\r\n        public Player Leader { get; set; }\r\n        public List<FollowerComponent> Members { get; set; }\r\n\r\n        // SAIN-inspired primary sensor pattern\r\n        public FollowerComponent PrimarySensor { get; set; }\r\n        public TargetSnapshot SharedTarget { get; set; }\r\n\r\n        // From DESIGN_INTENT.md Phase 6\r\n        public void Update()\r\n        {\r\n            // Re-score all members for sensor role (SAIN pattern)\r\n            FollowerComponent bestSensor = SelectPrimarySensor();\r\n\r\n            if (bestSensor != PrimarySensor)\r\n            {\r\n                PrimarySensor = bestSensor;\r\n            }\r\n\r\n            // Primary sensor does heavy work\r\n            if (PrimarySensor != null)\r\n            {\r\n                UpdateSharedPerception();\r\n            }\r\n        }\r\n\r\n        private FollowerComponent SelectPrimarySensor()\r\n        {\r\n            float bestScore = -1f;\r\n            FollowerComponent best = null;\r\n\r\n            foreach (var member in Members)\r\n            {\r\n                if (member.BotOwner.IsDead) continue;\r\n\r\n                float score = CalculateSensorScore(member);\r\n\r\n                if (score > bestScore)\r\n                {\r\n                    bestScore = score;\r\n                    best = member;\r\n                }\r\n            }\r\n\r\n            return best;\r\n        }\r\n\r\n        private float CalculateSensorScore(FollowerComponent bot)\r\n        {\r\n            // From DESIGN_INTENT.md Phase 6 sensor selection\r\n            float score = 0f;\r\n\r\n            if (SharedTarget != null)\r\n            {\r\n                Enemy enemy = bot.BotOwner.Memory.GoalEnemy;\r\n                if (enemy != null)\r\n                {\r\n                    // Has LOS to enemy\r\n                    if (enemy.IsVisible && enemy.InLineOfSight)\r\n                        score += 10f;\r\n\r\n                    // Facing enemy\r\n                    Vector3 toEnemy = (enemy.EnemyPosition - bot.transform.position).normalized;\r\n                    float dot = Vector3.Dot(bot.BotOwner.LookDirection, toEnemy);\r\n                    score += dot * 5f;  // 0-5 points for facing\r\n\r\n                    // Closer = better intel (inverse distance)\r\n                    float distance = Vector3.Distance(bot.transform.position, enemy.EnemyPosition);\r\n                    score += 10f / (1f + distance * 0.1f);\r\n\r\n                    // Height advantage\r\n                    float heightDiff = bot.transform.position.y - enemy.EnemyPosition.y;\r\n                    if (heightDiff > 0f)\r\n                        score += Mathf.Min(heightDiff * 0.5f, 3f);\r\n                }\r\n            }\r\n\r\n            return score;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Squad Decision Coordination\r\n\r\n**Adopt SAIN's Squad Decision Pattern**:\r\n\r\n```csharp\r\n// From knowledge/AI/AIDecisionSystem.md - Squad Decisions\r\npublic enum ESquadDecision\r\n{\r\n    None,\r\n    Surround,           // Flank from multiple sides\r\n    Suppress,           // Suppressive fire\r\n    Help,               // Assist squad member\r\n    Regroup             // Return to formation\r\n}\r\n\r\npublic class FollowerSquadCoordinator\r\n{\r\n    public ESquadDecision GetSquadDecision(FollowerCluster cluster)\r\n    {\r\n        // Check if leader needs help\r\n        if (LeaderInTrouble(cluster.Leader))\r\n            return ESquadDecision.Help;\r\n\r\n        // Check if should surround enemy\r\n        if (ShouldSurround(cluster))\r\n            return ESquadDecision.Surround;\r\n\r\n        // Check if support bot should suppress\r\n        if (ShouldSuppress(cluster))\r\n            return ESquadDecision.Suppress;\r\n\r\n        // Default: maintain formation\r\n        return ESquadDecision.Regroup;\r\n    }\r\n\r\n    private bool ShouldSurround(FollowerCluster cluster)\r\n    {\r\n        // From SAIN AIDecisionSystem.md - Surround Logic\r\n        if (cluster.Members.Count < 3) return false;\r\n\r\n        if (cluster.SharedTarget == null) return false;\r\n\r\n        // Check if squad is clustered\r\n        float angleSpread = CalculateAngleSpread(\r\n            cluster.Members.Select(m => m.transform.position).ToList(),\r\n            cluster.SharedTarget.Position\r\n        );\r\n\r\n        return angleSpread < 90f;  // Clustered = should spread\r\n    }\r\n\r\n    private float CalculateAngleSpread(List<Vector3> positions, Vector3 enemyPos)\r\n    {\r\n        // Calculate how spread out squad is around enemy\r\n        List<float> angles = new List<float>();\r\n\r\n        for (int i = 0; i < positions.Count; i++)\r\n        {\r\n            Vector3 toBot = (positions[i] - enemyPos).normalized;\r\n            float angle = Mathf.Atan2(toBot.z, toBot.x) * Mathf.Rad2Deg;\r\n            angles.Add(angle);\r\n        }\r\n\r\n        angles.Sort();\r\n\r\n        // Find largest gap between members\r\n        float maxGap = 0f;\r\n        for (int i = 0; i < angles.Count; i++)\r\n        {\r\n            int nextIndex = (i + 1) % angles.Count;\r\n            float gap = angles[nextIndex] - angles[i];\r\n            if (gap < 0) gap += 360f;\r\n            maxGap = Mathf.Max(maxGap, gap);\r\n        }\r\n\r\n        // Return coverage (360 - largest gap)\r\n        return 360f - maxGap;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 6. Event-Driven Updates\r\n\r\n### SAIN Event Pattern\r\n\r\n**From**: `knowledge/AI/Architecture.md` Section 8\r\n\r\n```csharp\r\npublic class EnemyEvents\r\n{\r\n    public EnemyToggleEventTimeTracked OnEnemyKnownChanged;\r\n    public EnemyToggleEventTimeTracked OnVisionChange;\r\n    public EnemyToggleEventTimeTracked OnEnemyLineOfSightChanged;\r\n}\r\n```\r\n\r\n### FriendlyPMC Cluster Events\r\n\r\n**Adopt for Cluster Perception**:\r\n\r\n```csharp\r\npublic class ClusterPerceptionInterface\r\n{\r\n    // Events for cluster members\r\n    public event Action<Enemy> OnClusterEnemyDetected;\r\n    public event Action<Vector3> OnClusterTakingFire;\r\n    public event Action<FollowerComponent> OnSensorChanged;\r\n\r\n    public void Init()\r\n    {\r\n        // Subscribe to BotMemory events (from 02-Bot-AI-Brain.md)\r\n        _bot.BotOwner.Memory.OnAddEnemy += OnEnemyAdded;\r\n        _bot.BotOwner.Memory.OnGoalEnemyChanged += OnGoalEnemyChanged;\r\n        _bot.Player.BeingHitAction += OnTakingDamage;\r\n    }\r\n\r\n    private void OnEnemyAdded(IPlayer enemy)\r\n    {\r\n        // Share with cluster (DESIGN_INTENT.md Phase 6)\r\n        var cluster = FollowerClusterManager.Instance.GetCluster(_bot);\r\n        if (cluster != null)\r\n        {\r\n            foreach (var member in cluster.Members)\r\n            {\r\n                if (member == _bot) continue;\r\n\r\n                // Add enemy to other cluster members\r\n                if (!member.BotOwner.EnemiesController.EnemyInfos.ContainsKey(enemy))\r\n                {\r\n                    member.BotOwner.Memory.AddEnemy(\r\n                        enemy,\r\n                        _bot.BotOwner.Settings,\r\n                        onActivation: false\r\n                    );\r\n                }\r\n            }\r\n\r\n            // Fire cluster event\r\n            OnClusterEnemyDetected?.Invoke(GetEnemyInfo(enemy));\r\n        }\r\n    }\r\n\r\n    private void OnTakingDamage(DamageInfoStruct damageInfo, EBodyPart bodyPart, float damage)\r\n    {\r\n        // Share damage with cluster\r\n        var cluster = FollowerClusterManager.Instance.GetCluster(_bot);\r\n        if (cluster != null && damageInfo.Player != null)\r\n        {\r\n            Vector3 attackDirection = damageInfo.MasterOrigin;\r\n            OnClusterTakingFire?.Invoke(attackDirection);\r\n\r\n            // Other members react to damage source\r\n            foreach (var member in cluster.Members)\r\n            {\r\n                if (member == _bot) continue;\r\n\r\n                // Add attacker as enemy if close\r\n                float distance = Vector3.Distance(\r\n                    member.transform.position,\r\n                    damageInfo.Player.Transform.position\r\n                );\r\n\r\n                if (distance < 50f)\r\n                {\r\n                    member.BotOwner.Memory.AddEnemy(\r\n                        damageInfo.Player.iPlayer,\r\n                        member.BotOwner.Settings,\r\n                        false\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        // Unsubscribe (SAIN pattern)\r\n        _bot.BotOwner.Memory.OnAddEnemy -= OnEnemyAdded;\r\n        _bot.BotOwner.Memory.OnGoalEnemyChanged -= OnGoalEnemyChanged;\r\n        _bot.Player.BeingHitAction -= OnTakingDamage;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7. Performance Optimization Patterns\r\n\r\n### SAIN's Tick Rate System\r\n\r\n**From**: `knowledge/AI/Architecture.md` Section 4\r\n\r\n```csharp\r\npublic enum ESAINTickState\r\n{\r\n    AlwaysUpdate,       // Every frame\r\n    OnlyBotActive,      // Bot active only\r\n    OnlyNoSleep,        // Not in standby\r\n    OnlyBotInCombat     // Combat only\r\n}\r\n```\r\n\r\n### FriendlyPMC Tick Optimization\r\n\r\n```csharp\r\npublic abstract class FollowerComponentBase\r\n{\r\n    protected float TickInterval { get; set; } = 0.1f;\r\n    protected float LastTickTime { get; set; }\r\n\r\n    public virtual bool ShallTick()\r\n    {\r\n        if (LastTickTime + TickInterval < Time.time)\r\n        {\r\n            LastTickTime = Time.time;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public abstract void Update();\r\n}\r\n\r\npublic class FollowerFormationManager : FollowerComponentBase\r\n{\r\n    public FollowerFormationManager()\r\n    {\r\n        TickInterval = 0.5f;  // Update formations every 0.5s\r\n    }\r\n\r\n    public override void Update()\r\n    {\r\n        if (!ShallTick()) return;\r\n\r\n        // Formation update logic\r\n        UpdateFormationPositions();\r\n    }\r\n}\r\n\r\npublic class ClusterPerceptionInterface : FollowerComponentBase\r\n{\r\n    public ClusterPerceptionInterface()\r\n    {\r\n        TickInterval = 0.1f;  // Check sensor rotation every 0.1s\r\n    }\r\n\r\n    public override void Update()\r\n    {\r\n        if (!ShallTick()) return;\r\n\r\n        // Sensor rotation logic\r\n        UpdatePrimarySensor();\r\n    }\r\n}\r\n```\r\n\r\n### Object Pooling (SAIN Pattern)\r\n\r\n```csharp\r\npublic class FollowerComponentPooling\r\n{\r\n    // Pre-allocated lists (avoid GC)\r\n    private static readonly List<Enemy> _preAllocEnemyList = new List<Enemy>(10);\r\n    private static readonly List<FollowerComponent> _preAllocFollowerList = new List<FollowerComponent>(5);\r\n\r\n    public static List<Enemy> GetNearbyEnemies(BotOwner bot, float radius)\r\n    {\r\n        _preAllocEnemyList.Clear();\r\n\r\n        foreach (var enemy in bot.EnemiesController.EnemyInfos.Values)\r\n        {\r\n            float distSqr = (enemy.CurrPosition - bot.Position).sqrMagnitude;\r\n            if (distSqr < radius * radius)\r\n            {\r\n                _preAllocEnemyList.Add(GetSAINEnemy(enemy));\r\n            }\r\n        }\r\n\r\n        return _preAllocEnemyList;  // Caller must not store reference\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 8. Optional SAIN Enhancement\r\n\r\n### Detection and Graceful Degradation\r\n\r\n```csharp\r\npublic class SAINIntegration\r\n{\r\n    private static bool? _sainPresent;\r\n\r\n    public static bool IsSAINPresent()\r\n    {\r\n        if (_sainPresent.HasValue)\r\n            return _sainPresent.Value;\r\n\r\n        _sainPresent = AppDomain.CurrentDomain.GetAssemblies()\r\n            .Any(a => a.GetName().Name.Equals(\"SAIN\", StringComparison.OrdinalIgnoreCase));\r\n\r\n        Logger.LogInfo($\"SAIN detection: {(_sainPresent.Value ? \"FOUND\" : \"NOT FOUND\")}\");\r\n\r\n        return _sainPresent.Value;\r\n    }\r\n\r\n    public static Type GetSAINType(string typeName)\r\n    {\r\n        if (!IsSAINPresent()) return null;\r\n\r\n        var sainAssembly = AppDomain.CurrentDomain.GetAssemblies()\r\n            .FirstOrDefault(a => a.GetName().Name.Equals(\"SAIN\", StringComparison.OrdinalIgnoreCase));\r\n\r\n        return sainAssembly?.GetType(typeName);\r\n    }\r\n}\r\n```\r\n\r\n### Enhanced Cover Finding with SAIN\r\n\r\n```csharp\r\npublic class EnhancedCoverFinder\r\n{\r\n    public CustomNavigationPoint FindCover(BotOwner bot, Vector3 searchCenter, float radius)\r\n    {\r\n        // Try SAIN first if available\r\n        if (SAINIntegration.IsSAINPresent())\r\n        {\r\n            var sainBot = bot.GetComponent<BotComponent>();\r\n            if (sainBot != null)\r\n            {\r\n                // Use SAIN's superior cover finding\r\n                var sainCover = sainBot.Cover.FindCover(searchCenter, radius);\r\n                if (sainCover != null)\r\n                {\r\n                    return ConvertSAINCoverToCustomNav(sainCover);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Fallback to vanilla/FriendlyPMC implementation\r\n        return Covers.GetClosestCoverPoint(bot, searchCenter, radius);\r\n    }\r\n\r\n    private CustomNavigationPoint ConvertSAINCoverToCustomNav(CoverPoint sainCover)\r\n    {\r\n        // Map SAIN CoverPoint to Tarkov CustomNavigationPoint\r\n        return new CustomNavigationPoint(sainCover.Position, ...);\r\n    }\r\n}\r\n```\r\n\r\n### Enhanced Movement with SAIN\r\n\r\n```csharp\r\npublic class EnhancedFollowerMovement\r\n{\r\n    public void MoveToPosition(BotOwner bot, Vector3 position, bool sprint)\r\n    {\r\n        if (SAINIntegration.IsSAINPresent())\r\n        {\r\n            var sainBot = bot.GetComponent<BotComponent>();\r\n            if (sainBot != null)\r\n            {\r\n                // Use SAIN's advanced pathfinding\r\n                if (sprint)\r\n                {\r\n                    sainBot.Mover.RunToPoint(\r\n                        position,\r\n                        urgency: ESprintUrgency.High\r\n                    );\r\n                }\r\n                else\r\n                {\r\n                    sainBot.Mover.WalkToPoint(position);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Fallback to vanilla movement\r\n        bot.Mover.GoToPoint(position);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 9. Implementation Roadmap\r\n\r\n### Phase 0-7: Baseline (No SAIN Integration)\r\n\r\n**Use vanilla Tarkov APIs** from our knowledge base:\r\n- `02-Bot-AI-Brain.md` - BigBrain layers\r\n- `01-Bot-Spawning.md` - Spawning\r\n- `03-Party-Friends-Messenger-System.md` - Social integration\r\n- `04-Voice-Gesture-Commands.md` - Commands\r\n\r\n**Result**: Functional mod without SAIN\r\n\r\n---\r\n\r\n### Phase 6+: Add SAIN Patterns\r\n\r\n**Adopt component architecture**:\r\n```\r\nWeek 1: Create FollowerComponent system\r\nWeek 2: Implement decision manager (simplified from SAIN)\r\nWeek 3: Add cluster perception with events\r\nWeek 4: Integrate formation manager\r\n```\r\n\r\n**Result**: Better architecture, easier to extend\r\n\r\n---\r\n\r\n### Phase 12+: Optional SAIN Enhancement\r\n\r\n**Add SAIN detection and enhanced behaviors**:\r\n\r\n```csharp\r\npublic class FollowerAIController\r\n{\r\n    public void Update()\r\n    {\r\n        if (SAINIntegration.IsSAINPresent())\r\n        {\r\n            UpdateWithSAIN();\r\n        }\r\n        else\r\n        {\r\n            UpdateVanilla();\r\n        }\r\n    }\r\n\r\n    private void UpdateWithSAIN()\r\n    {\r\n        var sainBot = BotOwner.GetComponent<BotComponent>();\r\n\r\n        // Use SAIN's decision system\r\n        ECombatDecision sainDecision = sainBot.Decision.CurrentCombatDecision;\r\n\r\n        // Translate to follower behavior\r\n        switch (sainDecision)\r\n        {\r\n            case ECombatDecision.SeekCover:\r\n                // SAIN already handling cover finding\r\n                break;\r\n\r\n            case ECombatDecision.StandAndShoot:\r\n                // Ensure follower maintains formation while shooting\r\n                EnforceFormationPosition();\r\n                break;\r\n\r\n            case ECombatDecision.Retreat:\r\n                // Coordinate retreat with leader\r\n                RetreatToLeader();\r\n                break;\r\n        }\r\n    }\r\n\r\n    private void UpdateVanilla()\r\n    {\r\n        // Standard follower AI from our docs\r\n        // Use 02-Bot-AI-Brain.md patterns\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 10. Integration Benefits Matrix\r\n\r\n| Feature | Vanilla | SAIN Pattern | SAIN Component | Benefit |\r\n|---------|---------|--------------|----------------|---------|\r\n| **Decision Making** | Single layer | 3-layer system | Full SAIN decision | More nuanced behavior |\r\n| **Cover Finding** | Basic | Score-based | Global pooling | Better positions |\r\n| **Movement** | Simple pathfinding | Advanced mover | SAINMoverClass | Smoother movement |\r\n| **Squad Coordination** | None | Squad decisions | SquadInfo | Tactical coordination |\r\n| **Performance** | No optimization | Tick rates | Full tick system | Better FPS |\r\n| **Medical** | Basic healing | Smart decisions | SAINMedicalClass | Tactical healing |\r\n| **Grenades** | Basic throw | Decision logic | GrenadeManager | Safer grenades |\r\n\r\n---\r\n\r\n## 11. Recommended Integration Approach\r\n\r\n### For FriendlyPMC Development\r\n\r\n**Phase 1 (Baseline)**: No SAIN integration\r\n- Use vanilla APIs from our knowledge base\r\n- Get mod working first\r\n- **Complexity**: Low\r\n- **Time**: 6-8 weeks\r\n\r\n**Phase 2 (Architecture)**: Adopt SAIN patterns\r\n- Create FollowerComponent system\r\n- Implement simplified decision manager\r\n- Use event-driven updates\r\n- **Complexity**: Medium\r\n- **Time**: 2-3 weeks\r\n\r\n**Phase 3 (Enhancement)**: Optional SAIN detection\r\n- Add SAIN presence detection\r\n- Use SAIN components if available\r\n- Fallback to standalone\r\n- **Complexity**: Medium\r\n- **Time**: 1-2 weeks\r\n\r\n**Phase 4 (Optimization)**: Performance tuning\r\n- Adopt tick rate system\r\n- Add object pooling\r\n- Optimize cluster perception\r\n- **Complexity**: Low\r\n- **Time**: 1 week\r\n\r\n---\r\n\r\n## Summary\r\n\r\n### SAIN Provides:\r\n\r\n‚úÖ **Proven Architecture** - 682 files, shipping mod\r\n‚úÖ **Component Patterns** - Modular, maintainable design\r\n‚úÖ **Decision Systems** - 3-layer decision architecture\r\n‚úÖ **Performance Patterns** - Tick rates, pooling, jobs\r\n‚úÖ **Event System** - Decoupled component communication\r\n‚úÖ **Squad Coordination** - Working squad decision logic\r\n\r\n### FriendlyPMC Should:\r\n\r\n1. **Adopt Patterns** - Component architecture, event system, tick rates\r\n2. **Reference Algorithms** - Decision logic, cover finding, movement\r\n3. **Optional Enhancement** - Detect and use SAIN if present\r\n4. **Stay Independent** - Work without SAIN as dependency\r\n\r\n### Integration Value:\r\n\r\n- üîπ **Pattern Adoption**: High value, medium effort\r\n- üîπ **Optional Enhancement**: Medium value, low effort\r\n- üîπ **Full Dependency**: Low value, high risk (mod conflicts)\r\n\r\n**Recommended**: **Pattern Adoption** with **Optional Enhancement**\r\n\r\n---\r\n\r\n## Quick Reference\r\n\r\n### Need SAIN Pattern For:\r\n- **Component architecture** ‚Üí `knowledge/AI/Architecture.md` Section 2.1\r\n- **Decision system** ‚Üí `knowledge/AI/AIDecisionSystem.md`\r\n- **Squad coordination** ‚Üí `knowledge/AI/AIDecisionSystem.md` Section on Squad Decisions\r\n- **Event system** ‚Üí `knowledge/AI/Architecture.md` Section 8\r\n- **Tick rates** ‚Üí `knowledge/AI/Architecture.md` Section 4.3\r\n\r\n### FriendlyPMC Implementation:\r\n- **Cluster perception** ‚Üí Use event pattern from SAIN\r\n- **Formation manager** ‚Üí Use component pattern from SAIN\r\n- **Decision system** ‚Üí Simplify SAIN's 3-layer to follower-specific\r\n- **Performance** ‚Üí Adopt tick rate optimization\r\n\r\n---\r\n\r\n**SAIN's architecture is production-proven. Adopt its patterns for FriendlyPMC success!** üéØ\r\n"},"16-SAIN-PATTERNS-FOR-FRIENDLYPMC":{"title":"SAIN Patterns for FriendlyPMC - Practical Integration Guide\r","category":"Core Systems","content":"# SAIN Patterns for FriendlyPMC - Practical Integration Guide\r\n\r\n**Purpose**: How to adopt SAIN v4.2.0 patterns for FriendlyPMC follower AI\r\n**Based On**: Authentic SAIN source code analysis\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nSAIN provides **production-proven patterns** for SPT AI modding. FriendlyPMC should adopt SAIN's **architectural patterns** while **simplifying** the complexity for follower-specific needs.\r\n\r\n**Adopt**: Component architecture, tick system, event-driven updates, BigBrain integration\r\n**Simplify**: 10 components (not 32), 7 decisions (not 34), vanilla vision (not multi-threaded)\r\n**Result**: SAIN-quality architecture at 30% complexity\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [Component Architecture](#1-component-architecture)\r\n2. [Decision System](#2-decision-system)\r\n3. [Enemy Tracking](#3-enemy-tracking)\r\n4. [Movement Integration](#4-movement-integration)\r\n5. [Cluster Perception](#5-cluster-perception-phase-6)\r\n6. [Voice Commands](#6-voice-commands-phase-7)\r\n7. [Complete Example](#7-complete-implementation-example)\r\n\r\n---\r\n\r\n## 1. Component Architecture\r\n\r\n### SAIN Pattern (32 Components)\r\n\r\n**From SAIN Architecture Doc**:\r\n```csharp\r\npublic class BotComponent : MonoBehaviour\r\n{\r\n    // 32 components total\r\n    public SAINBotInfoClass Info { get; }\r\n    public SAINDecisionClass Decision { get; }\r\n    public SAINEnemyController EnemyController { get; }\r\n    public SAINVisionClass Vision { get; }\r\n    // ... 28 more\r\n}\r\n```\r\n\r\n### FriendlyPMC Adaptation (10 Components)\r\n\r\n```csharp\r\npublic class FollowerComponent : MonoBehaviour\r\n{\r\n    // Core (4)\r\n    public FollowerInfo Info { get; private set; }\r\n    public FollowerActivation Activation { get; private set; }\r\n    public FollowerDecisionManager Decision { get; private set; }\r\n    public FollowerLeaderTracker LeaderTracker { get; private set; }\r\n\r\n    // Combat (3)\r\n    public FollowerEnemyTracker EnemyTracker { get; private set; }\r\n    public FollowerCombatController Combat { get; private set; }\r\n    public FollowerFriendlyFire FriendlyFire { get; private set; }\r\n\r\n    // Movement (2)\r\n    public FollowerMovementController Movement { get; private set; }\r\n    public FollowerFormationManager Formation { get; private set; }\r\n\r\n    // Support (1)\r\n    public FollowerClusterPerception ClusterPerception { get; private set; }\r\n\r\n    // References\r\n    public BotOwner BotOwner { get; private set; }\r\n    public Player Leader { get; private set; }\r\n\r\n    // Initialization\r\n    public void Initialize(BotOwner botOwner, Player leader)\r\n    {\r\n        BotOwner = botOwner;\r\n        Leader = leader;\r\n\r\n        // Create components (SAIN pattern)\r\n        Info = new FollowerInfo(this);\r\n        Activation = new FollowerActivation(this);\r\n        Decision = new FollowerDecisionManager(this);\r\n        LeaderTracker = new FollowerLeaderTracker(this, leader);\r\n        EnemyTracker = new FollowerEnemyTracker(this);\r\n        Combat = new FollowerCombatController(this);\r\n        FriendlyFire = new FollowerFriendlyFire(this);\r\n        Movement = new FollowerMovementController(this);\r\n        Formation = new FollowerFormationManager(this);\r\n        ClusterPerception = new FollowerClusterPerception(this);\r\n\r\n        // Init components (SAIN pattern)\r\n        Info.Init();\r\n        Activation.Init();\r\n        Decision.Init();\r\n        LeaderTracker.Init();\r\n        EnemyTracker.Init();\r\n        Combat.Init();\r\n        FriendlyFire.Init();\r\n        Movement.Init();\r\n        Formation.Init();\r\n        ClusterPerception.Init();\r\n    }\r\n}\r\n```\r\n\r\n**Complexity Reduction**: 32 ‚Üí 10 components (70% simpler)\r\n\r\n---\r\n\r\n## 2. Decision System\r\n\r\n### SAIN Pattern (34 Decision Types)\r\n\r\n**From SAIN Decision Doc**:\r\n- 17 ECombatDecision types\r\n- 12 ESquadDecision types\r\n- 5 ESelfActionType types\r\n\r\n### FriendlyPMC Simplification (7 Types)\r\n\r\n```csharp\r\npublic enum EFollowerDecision\r\n{\r\n    None,\r\n    FollowLeader,        // Default: Stay with leader\r\n    EngageEnemy,         // Combat: Fight from position\r\n    SeekCover,           // Combat: Move to cover\r\n    ExecuteCommand,      // Override: Voice command\r\n    HealLeader,          // Medic: Treat leader\r\n    ProvideSupport,      // Support: Suppressive fire\r\n    EvacuateCasualty    // Medic: Drag wounded (Phase 12B)\r\n}\r\n```\r\n\r\n### Decision Manager (SAIN Pattern)\r\n\r\n```csharp\r\npublic class FollowerDecisionManager : FollowerComponentBase\r\n{\r\n    // Current decisions\r\n    public EFollowerDecision CurrentDecision { get; private set; }\r\n    public EFollowerDecision PreviousDecision { get; private set; }\r\n\r\n    // Timing\r\n    public float TimeSinceDecisionChange { get; private set; }\r\n\r\n    // Events (SAIN pattern)\r\n    public event Action<EFollowerDecision, FollowerComponent> OnDecisionMade;\r\n\r\n    // Update frequency (SAIN: 10 Hz, FriendlyPMC: 5 Hz)\r\n    protected override float TickInterval => 0.2f;\r\n\r\n    public override void Update()\r\n    {\r\n        if (!ShallTick()) return;\r\n\r\n        EFollowerDecision newDecision = CalculateDecision();\r\n\r\n        if (newDecision != CurrentDecision)\r\n        {\r\n            PreviousDecision = CurrentDecision;\r\n            CurrentDecision = newDecision;\r\n            TimeSinceDecisionChange = 0f;\r\n\r\n            // Fire event (SAIN pattern)\r\n            OnDecisionMade?.Invoke(newDecision, Bot);\r\n        }\r\n    }\r\n\r\n    private EFollowerDecision CalculateDecision()\r\n    {\r\n        // Priority 1: Voice command override\r\n        if (Bot.CommandHandler.HasActiveCommand())\r\n            return EFollowerDecision.ExecuteCommand;\r\n\r\n        // Priority 2: Self-actions (from SAIN pattern)\r\n        if (ShouldHealLeader())\r\n            return EFollowerDecision.HealLeader;\r\n\r\n        // Priority 3: Combat decisions\r\n        if (BotOwner.Memory.HaveEnemy)\r\n        {\r\n            if (ShouldSeekCover())\r\n                return EFollowerDecision.SeekCover;\r\n\r\n            if (ShouldProvideSupport())\r\n                return EFollowerDecision.ProvideSupport;\r\n\r\n            return EFollowerDecision.EngageEnemy;\r\n        }\r\n\r\n        // Priority 4: Formation following\r\n        return EFollowerDecision.FollowLeader;\r\n    }\r\n\r\n    private bool ShouldSeekCover()\r\n    {\r\n        // Adapt SAIN's SeekCover logic (simplified)\r\n        if (BotOwner.Memory.IsInCover)\r\n            return false;\r\n\r\n        Enemy enemy = BotOwner.Memory.GoalEnemy;\r\n        if (enemy == null)\r\n            return false;\r\n\r\n        // Need cover if enemy can shoot and we're exposed\r\n        return enemy.CanShoot && enemy.IsVisible;\r\n    }\r\n\r\n    private bool ShouldProvideSupport()\r\n    {\r\n        // Support tactic + leader in combat\r\n        return Bot.Info.Tactic == \"Support\" &&\r\n               Bot.LeaderTracker.LeaderInCombat;\r\n    }\r\n\r\n    private bool ShouldHealLeader()\r\n    {\r\n        // Medic role + leader critical\r\n        return Bot.Info.Tactic == \"Medic\" &&\r\n               Bot.LeaderTracker.LeaderCriticalHealth();\r\n    }\r\n}\r\n```\r\n\r\n**Complexity Reduction**: 34 ‚Üí 7 decisions (80% simpler)\r\n\r\n---\r\n\r\n## 3. Enemy Tracking\r\n\r\n### SAIN Pattern (Per-Enemy LOD)\r\n\r\n**From SAIN Enemy Doc Section 1.1**:\r\n```csharp\r\n// SAIN uses adaptive update rates\r\nprivate float LookUpdateInterval(Enemy enemy)\r\n{\r\n    if (enemy.IsCurrentEnemy)\r\n        return enemy.IsAI ? 1f/15f : 1f/30f;  // 15-30 Hz\r\n\r\n    if (enemy.RealDistance > 200f)\r\n        return enemy.IsAI ? 1f/4f : 1f/12f;   // 4-12 Hz\r\n\r\n    // ... distance-based tiers\r\n}\r\n```\r\n\r\n### FriendlyPMC Adaptation\r\n\r\n```csharp\r\npublic class FollowerEnemyTracker : FollowerComponentBase\r\n{\r\n    // Per-enemy update timing (SAIN LOD pattern)\r\n    private Dictionary<string, float> _enemyUpdateTimes = new();\r\n\r\n    protected override float TickInterval => 0.1f;  // 10 Hz base\r\n\r\n    public override void Update()\r\n    {\r\n        if (!ShallTick()) return;\r\n\r\n        // Iterate all enemies (VALIDATED API)\r\n        foreach (var kvp in BotOwner.EnemiesController.EnemyInfos)\r\n        {\r\n            string enemyId = kvp.Key;\r\n            EnemyInfo enemy = kvp.Value;\r\n\r\n            // Check if time to update this enemy\r\n            if (_enemyUpdateTimes.TryGetValue(enemyId, out float nextUpdate))\r\n            {\r\n                if (Time.time < nextUpdate)\r\n                    continue;\r\n            }\r\n\r\n            // Process enemy\r\n            ProcessEnemy(enemy);\r\n\r\n            // Set next update (SAIN LOD pattern)\r\n            float interval = GetUpdateInterval(enemy);\r\n            _enemyUpdateTimes[enemyId] = Time.time + interval;\r\n        }\r\n\r\n        // Cleanup (every 300 frames ~5s)\r\n        if (Time.frameCount % 300 == 0)\r\n        {\r\n            CleanupStaleTimers();\r\n        }\r\n    }\r\n\r\n    private float GetUpdateInterval(EnemyInfo enemy)\r\n    {\r\n        // Goal enemy: 20 Hz (SAIN pattern)\r\n        if (BotOwner.Memory.GoalEnemy == enemy)\r\n            return 0.05f;\r\n\r\n        // Visible: 10 Hz\r\n        if (enemy.IsVisible)\r\n            return 0.1f;\r\n\r\n        // Known: 4 Hz\r\n        if (enemy.HaveSeen)\r\n            return 0.25f;\r\n\r\n        // Remembered: 1 Hz\r\n        return 1f;\r\n    }\r\n\r\n    private void CleanupStaleTimers()\r\n    {\r\n        _enemyUpdateTimes = _enemyUpdateTimes\r\n            .Where(kvp => BotOwner.EnemiesController.EnemyInfos.ContainsKey(kvp.Key))\r\n            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);\r\n    }\r\n\r\n    private void ProcessEnemy(EnemyInfo enemy)\r\n    {\r\n        // Enemy processing logic\r\n        // Share with cluster if primary sensor\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. Movement Integration\r\n\r\n### SAIN Pattern (Dual-Path Buffer)\r\n\r\n**From SAIN Movement Doc Section 3**:\r\n```csharp\r\n// Two paths for smooth transitions\r\nprivate BotPathDataManual _preparedPath1;\r\nprivate BotPathDataManual _preparedPath2;\r\n```\r\n\r\n### FriendlyPMC Simplified\r\n\r\n```csharp\r\npublic class FollowerMovementController : FollowerComponentBase\r\n{\r\n    protected override float TickInterval => 0.1f;  // 10 Hz\r\n\r\n    // Use SAIN's movement API directly\r\n    public void MoveToPosition(Vector3 position, bool sprint)\r\n    {\r\n        // From LTBRAIN/SAIN docs\r\n        if (sprint)\r\n        {\r\n            BotOwner.Mover.Sprint(position);\r\n        }\r\n        else\r\n        {\r\n            BotOwner.Mover.GoToPoint(position);\r\n        }\r\n    }\r\n\r\n    public void MoveToCover(CustomNavigationPoint cover)\r\n    {\r\n        // Set cover (vanilla AI paths automatically)\r\n        BotOwner.Memory.SetCoverPoints(cover);\r\n    }\r\n\r\n    public void SetStance(float pose)\r\n    {\r\n        // 0=prone, 0.5=crouch, 1=stand\r\n        BotOwner.Mover.SetTargetPose(pose);\r\n    }\r\n\r\n    public void Stop()\r\n    {\r\n        BotOwner.Mover.Stop();\r\n    }\r\n}\r\n```\r\n\r\n**Using Vanilla Systems**: Leverage Tarkov's pathfinding instead of reimplementing SAIN's complexity.\r\n\r\n---\r\n\r\n## 5. Cluster Perception (Phase 6)\r\n\r\n### SAIN Pattern (Individual Perception)\r\n\r\n**From SAIN Vision Doc**:\r\n- Each bot runs own vision raycasts (30 Hz)\r\n- Multi-threaded job system\r\n- Per-body-part checks\r\n\r\n### FriendlyPMC Adaptation (Cluster Sharing)\r\n\r\n**From DESIGN_INTENT.md Phase 6**:\r\n- One \"PrimarySensor\" per cluster\r\n- Rotates to bot with best LOS\r\n- Others read shared data\r\n\r\n```csharp\r\npublic class FollowerClusterPerception : FollowerComponentBase\r\n{\r\n    private FollowerCluster _cluster;\r\n\r\n    protected override float TickInterval => 0.1f;  // 10 Hz\r\n\r\n    public override void Init()\r\n    {\r\n        // Subscribe to memory events (from 02-Bot-AI-Brain.md)\r\n        BotOwner.Memory.OnAddEnemy += OnEnemyAdded;\r\n        BotOwner.Memory.OnGoalEnemyChanged += OnGoalEnemyChanged;\r\n        Bot.Player.BeingHitAction += OnTakingDamage;\r\n    }\r\n\r\n    public override void Update()\r\n    {\r\n        if (!ShallTick()) return;\r\n\r\n        // Am I the primary sensor?\r\n        if (_cluster != null && _cluster.PrimarySensor == Bot)\r\n        {\r\n            // I do heavy perception work\r\n            UpdatePrimarySensor();\r\n        }\r\n        else\r\n        {\r\n            // I read shared data (cheap)\r\n            ReadSharedPerception();\r\n        }\r\n\r\n        // Rotate sensor if needed (SAIN-inspired scoring)\r\n        _cluster?.UpdatePrimarySensor();\r\n    }\r\n\r\n    private void OnEnemyAdded(IPlayer enemy)\r\n    {\r\n        // Share with cluster (SAIN position sharing pattern)\r\n        _cluster?.ShareEnemyWithCluster(Bot, enemy);\r\n    }\r\n\r\n    private void OnTakingDamage(DamageInfoStruct info, EBodyPart part, float damage)\r\n    {\r\n        // Share damage source with cluster\r\n        _cluster?.ShareDamageSource(Bot, info);\r\n    }\r\n\r\n    private void UpdatePrimarySensor()\r\n    {\r\n        // Primary sensor: Full vision checks\r\n        // Use vanilla BotOwner vision (not SAIN's job system)\r\n        foreach (var enemy in BotOwner.EnemiesController.EnemyInfos.Values)\r\n        {\r\n            // Vanilla vision system already handles raycasts\r\n            // Just track and share results\r\n            if (enemy.IsVisible)\r\n            {\r\n                _cluster.UpdateSharedTarget(enemy);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void ReadSharedPerception()\r\n    {\r\n        // Read cluster's shared target (cheap)\r\n        if (_cluster.SharedTarget != null)\r\n        {\r\n            // Use shared enemy info instead of own checks\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**From SAIN**: Event-driven, position sharing, coordination\r\n**Simplified**: No multi-threaded raycasts, use vanilla vision\r\n\r\n**Performance**: Squad of 5 uses ~1 bot's perception cost (SAIN: ~1-2 bots)\r\n\r\n---\r\n\r\n## 6. Voice Commands (Phase 7)\r\n\r\n### SAIN Pattern (GroupTalk)\r\n\r\n**From SAIN Squad Doc Section 3.2**:\r\n```csharp\r\n// Leader commands\r\nprivate bool UpdateLeaderCommand()\r\n{\r\n    switch (leaderDecision)\r\n    {\r\n        case Regroup:\r\n            LeaderComponent.Say(EPhraseTrigger.Regroup);\r\n            LeaderComponent.Gesture(EInteraction.Come);\r\n            break;\r\n\r\n        case Suppress:\r\n            LeaderComponent.Say(EPhraseTrigger.Suppress);\r\n            LeaderComponent.Gesture(EInteraction.Point);\r\n            break;\r\n    }\r\n}\r\n\r\n// Member responses\r\nprivate void allMembersSay(EPhraseTrigger trigger)\r\n{\r\n    foreach (member in visibleMembers)\r\n    {\r\n        float delay = Random.Range(0.75f, 1.5f);\r\n        if (Random.value < 0.4f)  // 40% chance\r\n        {\r\n            Delay(delay, () => member.Say(trigger));\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### FriendlyPMC Adoption\r\n\r\n```csharp\r\npublic class FollowerCommandHandler : FollowerComponentBase\r\n{\r\n    public void OnCommandReceived(EPhraseTrigger command)\r\n    {\r\n        // Map command to decision (SAIN pattern)\r\n        EFollowerDecision decision = MapCommandToDecision(command);\r\n\r\n        // Set decision\r\n        Bot.Decision.SetCommandOverride(decision);\r\n\r\n        // Respond to command (SAIN GroupTalk pattern)\r\n        if (ShouldAcknowledge())\r\n        {\r\n            float delay = Random.Range(0.5f, 1.0f);\r\n            Utils.SetTimeout(() =>\r\n            {\r\n                BotOwner.BotTalk.TrySay(EPhraseTrigger.Roger);\r\n                BotOwner.Gesture.TryGestus(EInteraction.OkGesture, true);\r\n            }, (int)(delay * 1000));\r\n        }\r\n    }\r\n\r\n    private bool ShouldAcknowledge()\r\n    {\r\n        // From SAIN: proximity + chance\r\n        float distance = Vector3.Distance(BotOwner.Position, Bot.Leader.Position);\r\n\r\n        if (distance > 20f)\r\n            return false;  // Too far\r\n\r\n        return Random.value < 0.5f;  // 50% chance\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 7. Complete Implementation Example\r\n\r\n### FollowerComponent with SAIN Patterns\r\n\r\n**File**: `FollowerComponent.cs`\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing DrakiaXYZ.BigBrain.Brains;\r\nusing EFT;\r\nusing System;\r\nusing System.Collections.Generic;\r\n\r\npublic class FollowerComponent : MonoBehaviour\r\n{\r\n    // References\r\n    public BotOwner BotOwner { get; private set; }\r\n    public Player Leader { get; private set; }\r\n\r\n    // Components (SAIN pattern - simplified to 10)\r\n    public FollowerInfo Info { get; private set; }\r\n    public FollowerDecisionManager Decision { get; private set; }\r\n    public FollowerMovementController Movement { get; private set; }\r\n    public FollowerClusterPerception Cluster { get; private set; }\r\n\r\n    // Tick lists (SAIN pattern)\r\n    private List<IFollowerComponent> _alwaysUpdate = new();\r\n    private List<IFollowerComponent> _combatUpdate = new();\r\n\r\n    // State\r\n    public bool Active => !BotOwner.IsDead;\r\n\r\n    public void Initialize(BotOwner botOwner, Player leader)\r\n    {\r\n        BotOwner = botOwner;\r\n        Leader = leader;\r\n\r\n        // Create components\r\n        Info = new FollowerInfo(this);\r\n        Decision = new FollowerDecisionManager(this);\r\n        Movement = new FollowerMovementController(this);\r\n        Cluster = new FollowerClusterPerception(this);\r\n\r\n        // Organize by tick requirement (SAIN pattern)\r\n        _alwaysUpdate.Add(Info);\r\n        _alwaysUpdate.Add(Decision);\r\n\r\n        _combatUpdate.Add(Cluster);\r\n\r\n        // Init all\r\n        foreach (var component in _alwaysUpdate)\r\n        {\r\n            component.Init();\r\n        }\r\n\r\n        foreach (var component in _combatUpdate)\r\n        {\r\n            component.Init();\r\n        }\r\n    }\r\n\r\n    public void ManualUpdate()\r\n    {\r\n        if (!Active) return;\r\n\r\n        // Always update\r\n        TickGroup(_alwaysUpdate);\r\n\r\n        // Combat updates\r\n        if (BotOwner.Memory.HaveEnemy)\r\n        {\r\n            TickGroup(_combatUpdate);\r\n        }\r\n    }\r\n\r\n    private void TickGroup(List<IFollowerComponent> group)\r\n    {\r\n        foreach (var component in group)\r\n        {\r\n            if (component.ShallTick(Time.time))\r\n            {\r\n                component.Update();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        foreach (var component in _alwaysUpdate)\r\n        {\r\n            component.Dispose();\r\n        }\r\n\r\n        foreach (var component in _combatUpdate)\r\n        {\r\n            component.Dispose();\r\n        }\r\n\r\n        Destroy(this);\r\n    }\r\n}\r\n\r\n// Component interface (SAIN pattern)\r\npublic interface IFollowerComponent\r\n{\r\n    void Init();\r\n    void Update();\r\n    bool ShallTick(float currentTime);\r\n    void Dispose();\r\n}\r\n\r\n// Component base (SAIN pattern)\r\npublic abstract class FollowerComponentBase : IFollowerComponent\r\n{\r\n    protected FollowerComponent Bot { get; }\r\n    protected BotOwner BotOwner => Bot.BotOwner;\r\n\r\n    protected abstract float TickInterval { get; }\r\n    protected float LastTickTime { get; set; }\r\n\r\n    protected FollowerComponentBase(FollowerComponent bot)\r\n    {\r\n        Bot = bot;\r\n    }\r\n\r\n    public virtual void Init() { }\r\n\r\n    public abstract void Update();\r\n\r\n    public virtual bool ShallTick(float currentTime)\r\n    {\r\n        if (LastTickTime + TickInterval < currentTime)\r\n        {\r\n            LastTickTime = currentTime;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public virtual void Dispose() { }\r\n}\r\n```\r\n\r\n---\r\n\r\n### BigBrain Layer Integration\r\n\r\n**File**: `FollowerCombatLayer.cs`\r\n\r\n```csharp\r\nusing DrakiaXYZ.BigBrain.Brains;\r\nusing EFT;\r\n\r\npublic class FollowerCombatLayer : CustomLayer\r\n{\r\n    private FollowerComponent _follower;\r\n\r\n    public FollowerCombatLayer(BotOwner botOwner, int priority)\r\n        : base(botOwner, priority)\r\n    {\r\n        _follower = botOwner.GetComponent<FollowerComponent>();\r\n    }\r\n\r\n    public override string GetName() => \"FollowerCombat\";\r\n\r\n    public override bool IsActive()\r\n    {\r\n        return _follower != null &&\r\n               _follower.Active &&\r\n               BotOwner.Memory.HaveEnemy;\r\n    }\r\n\r\n    public override Action GetNextAction()\r\n    {\r\n        if (_follower == null)\r\n            return null;\r\n\r\n        // Use decision manager (SAIN pattern)\r\n        EFollowerDecision decision = _follower.Decision.CurrentDecision;\r\n\r\n        // Map to logic (SAIN pattern)\r\n        return decision switch\r\n        {\r\n            EFollowerDecision.FollowLeader => new Action(\r\n                typeof(FollowLeaderLogic), \"Following leader\"),\r\n\r\n            EFollowerDecision.EngageEnemy => new Action(\r\n                typeof(EngageEnemyLogic), \"Engaging enemy\"),\r\n\r\n            EFollowerDecision.SeekCover => new Action(\r\n                typeof(SeekCoverLogic), \"Seeking cover\"),\r\n\r\n            EFollowerDecision.ProvideSupport => new Action(\r\n                typeof(ProvideFireSupportLogic), \"Providing support fire\"),\r\n\r\n            _ => null\r\n        };\r\n    }\r\n\r\n    public override bool IsCurrentActionEnding()\r\n    {\r\n        // Decision changed? (SAIN pattern)\r\n        return _follower.Decision.CurrentDecision !=\r\n               _follower.Decision.PreviousDecision;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Logic Example\r\n\r\n**File**: `SeekCoverLogic.cs`\r\n\r\n```csharp\r\nusing DrakiaXYZ.BigBrain.Brains;\r\nusing EFT;\r\n\r\npublic class SeekCoverLogic : CustomLogic\r\n{\r\n    private CustomNavigationPoint _targetCover;\r\n\r\n    public SeekCoverLogic(BotOwner botOwner) : base(botOwner)\r\n    {\r\n    }\r\n\r\n    public override void Start()\r\n    {\r\n        // Find cover (simplified from SAIN)\r\n        _targetCover = FindNearestCover();\r\n\r\n        if (_targetCover != null)\r\n        {\r\n            // Set cover - vanilla AI paths (SAIN pattern)\r\n            BotOwner.Memory.SetCoverPoints(_targetCover);\r\n\r\n            Logger.LogInfo($\"[SeekCover] Moving to cover at {_targetCover.Position}\");\r\n        }\r\n    }\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        // Vanilla AI handles pathfinding\r\n        // Logic just monitors\r\n\r\n        if (_targetCover != null && BotOwner.Memory.IsInCover)\r\n        {\r\n            Logger.LogInfo(\"[SeekCover] Reached cover\");\r\n        }\r\n    }\r\n\r\n    private CustomNavigationPoint FindNearestCover()\r\n    {\r\n        // Use vanilla covers (not SAIN's dynamic system)\r\n        Vector3 botPos = BotOwner.Position;\r\n        var covers = BotOwner.Covers.GetClosePoints(botPos, 50f);\r\n\r\n        // SAIN validation pattern (simplified)\r\n        foreach (var cover in covers.OrderBy(c => (c.Position - botPos).sqrMagnitude))\r\n        {\r\n            if (!cover.IsFreeById(BotOwner.Id))\r\n                continue;\r\n\r\n            if (cover.CoverLevel == CoverLevel.Sit ||\r\n                cover.CoverLevel == CoverLevel.Stay)\r\n            {\r\n                return cover;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Summary: Pattern Adoption Matrix\r\n\r\n| SAIN System | Adopt | Simplify | Skip |\r\n|-------------|-------|----------|------|\r\n| **Architecture** | Component pattern, Tick system, Events | 10 components (not 32) | Job system, Multi-threading |\r\n| **Decisions** | Priority hierarchy, Stability | 7 types (not 34) | Complex scoring |\r\n| **Enemies** | LOD pattern, Event system | Simplified tracking | Multi-threaded vision |\r\n| **Movement** | API patterns, Urgency | Use vanilla paths | Dual-buffer, Advanced |\r\n| **Combat** | FF prevention | Target selection | Aim/recoil systems |\r\n| **Sensory** | Event-driven | Use vanilla | Job raycasts |\r\n| **Squad** | Position sharing, Communication | Cluster-based | Full coordination |\r\n\r\n**Result**: SAIN-quality architecture at 30% complexity, 100% functionality for followers.\r\n\r\n---\r\n\r\n**With SAIN patterns, FriendlyPMC gets production-proven architecture optimized for follower AI!** üéØ\r\n"},"13-BIGBRAIN-ARCHITECTURE":{"title":"BigBrain (LTBRAIN) - Complete Architecture Documentation\r","category":"BigBrain Foundation","content":"# BigBrain (LTBRAIN) - Complete Architecture Documentation\r\n\r\n**Source**: `E:\\AppDev\\LTsTarkovAI\\LTBRAIN` (DrakiaXYZ-BigBrain v1.4.0)\r\n**Purpose**: Foundational AI layer system for ALL SPT AI mods\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\n**BigBrain** is a BepInEx plugin that provides a **layer-based AI extension system** for Escape from Tarkov SPT. It allows mods to inject custom AI behavior by creating **layers** (decision-makers) and **logics** (executors) that override vanilla bot behavior based on priority.\r\n\r\n**Used By**:\r\n- SAIN (682 files built on BigBrain)\r\n- FriendlyPMC (follower AI)\r\n- Questing Bots\r\n- Other AI enhancement mods\r\n\r\n**Key Innovation**: Priority-based layer system that **doesn't replace** vanilla AI, but **augments** it.\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [System Overview](#1-system-overview)\r\n2. [Core Architecture](#2-core-architecture)\r\n3. [Layer System Design](#3-layer-system-design)\r\n4. [Logic System Design](#4-logic-system-design)\r\n5. [Integration with Tarkov AI](#5-integration-with-tarkov-ai)\r\n6. [Update Flow](#6-update-flow)\r\n7. [Priority and Layer Selection](#7-priority-and-layer-selection)\r\n8. [Lifecycle Management](#8-lifecycle-management)\r\n9. [Performance Considerations](#9-performance-considerations)\r\n10. [Design Rationale](#10-design-rationale)\r\n\r\n---\r\n\r\n## 1. System Overview\r\n\r\n### What BigBrain Does\r\n\r\nBigBrain sits **between Tarkov's vanilla AI** and **custom mod AI**, providing:\r\n\r\n```\r\nCustom Mod AI (SAIN, FriendlyPMC, etc.)\r\n        ‚Üì\r\n    BigBrain Layer System\r\n        ‚Üì\r\n  Vanilla Tarkov AI (BaseBrain, Nodes)\r\n        ‚Üì\r\n    Bot Behavior (Movement, Shooting)\r\n```\r\n\r\n**Without BigBrain**: Mods must patch vanilla AI directly (fragile, conflicts)\r\n**With BigBrain**: Mods register layers (clean, priority-based, compatible)\r\n\r\n---\r\n\r\n### Three-Tier Architecture\r\n\r\n**From**: `LTBRAIN/Brains/*.cs` and `LTBRAIN/Internal/*.cs`\r\n\r\n```\r\nTier 1: Custom Mod Code\r\n    ‚îú‚îÄ‚îÄ CustomLayer (extends CustomLayer base)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Decides WHAT to do\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Returns Action (logic type + reason)\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Checks when to activate/deactivate\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ CustomLogic (extends CustomLogic base)\r\n        ‚îú‚îÄ‚îÄ Executes HOW to do it\r\n        ‚îú‚îÄ‚îÄ Update() called every frame\r\n        ‚îî‚îÄ‚îÄ Interfaces with Tarkov AI\r\n\r\nTier 2: BigBrain Wrapper System\r\n    ‚îú‚îÄ‚îÄ CustomLayerWrapper (extends BaseLogicLayerSimpleAbstractClass)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Wraps CustomLayer\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Translates to Tarkov AI system\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Manages logic lifecycle\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ CustomLogicWrapper (extends BotNodeAbstractClass)\r\n        ‚îú‚îÄ‚îÄ Wraps CustomLogic\r\n        ‚îú‚îÄ‚îÄ Calls Update() each frame\r\n        ‚îî‚îÄ‚îÄ Integrates with vanilla nodes\r\n\r\nTier 3: Vanilla Tarkov AI\r\n    ‚îú‚îÄ‚îÄ BaseBrain (strategy)\r\n    ‚îú‚îÄ‚îÄ AICoreLayerClass (layers)\r\n    ‚îú‚îÄ‚îÄ BotNodeAbstractClass (nodes/logic)\r\n    ‚îî‚îÄ‚îÄ BotOwner (bot controller)\r\n```\r\n\r\n**Key Insight**: BigBrain provides **adapters** (wrappers) that make custom code compatible with Tarkov's AI system.\r\n\r\n---\r\n\r\n## 2. Core Architecture\r\n\r\n### Component Diagram\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ                    BotOwner (Tarkov)                     ‚îÇ\r\n‚îÇ                                                          ‚îÇ\r\n‚îÇ   Brain (BaseBrain)                                      ‚îÇ\r\n‚îÇ     ‚îú‚îÄ‚îÄ Layers (priority sorted)                        ‚îÇ\r\n‚îÇ     ‚îÇ   ‚îú‚îÄ‚îÄ Layer 9000 (CustomLayerWrapper)             ‚îÇ\r\n‚îÇ     ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ wraps ‚Üí FollowerLayer (YOUR CODE)       ‚îÇ\r\n‚îÇ     ‚îÇ   ‚îú‚îÄ‚îÄ Layer 600 (vanilla combat)                  ‚îÇ\r\n‚îÇ     ‚îÇ   ‚îú‚îÄ‚îÄ Layer 500 (vanilla patrol)                  ‚îÇ\r\n‚îÇ     ‚îÇ   ‚îî‚îÄ‚îÄ ...                                          ‚îÇ\r\n‚îÇ     ‚îÇ                                                     ‚îÇ\r\n‚îÇ     ‚îî‚îÄ‚îÄ Agent (executes active layer)                   ‚îÇ\r\n‚îÇ         ‚îî‚îÄ‚îÄ Nodes (Dictionary<BotLogicDecision, Node>)  ‚îÇ\r\n‚îÇ             ‚îú‚îÄ‚îÄ Node 9000 (CustomLogicWrapper)          ‚îÇ\r\n‚îÇ             ‚îÇ   ‚îî‚îÄ‚îÄ wraps ‚Üí FollowerLogic (YOUR CODE)   ‚îÇ\r\n‚îÇ             ‚îú‚îÄ‚îÄ Node runToCover (vanilla)               ‚îÇ\r\n‚îÇ             ‚îî‚îÄ‚îÄ ...                                      ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ              BrainManager (Singleton)                    ‚îÇ\r\n‚îÇ                                                          ‚îÇ\r\n‚îÇ  CustomLayers: Dictionary<int, LayerInfo>               ‚îÇ\r\n‚îÇ  CustomLogics: Dictionary<Type, int>                    ‚îÇ\r\n‚îÇ  ActivatedBots: Dictionary<IPlayer, BotOwner>           ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n```\r\n\r\n---\r\n\r\n### File Structure\r\n\r\n```\r\nLTBRAIN/\r\n‚îú‚îÄ‚îÄ BigBrainPlugin.cs          # BepInEx plugin entry point\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Brains/                     # Public API\r\n‚îÇ   ‚îú‚îÄ‚îÄ CustomLayer.cs          # Layer base class (YOU EXTEND THIS)\r\n‚îÇ   ‚îú‚îÄ‚îÄ CustomLogic.cs          # Logic base class (YOU EXTEND THIS)\r\n‚îÇ   ‚îú‚îÄ‚îÄ BrainManager.cs         # Registration system\r\n‚îÇ   ‚îî‚îÄ‚îÄ CustomBrain.cs          # (Future: custom brain support)\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Internal/                   # Internal wrappers\r\n‚îÇ   ‚îú‚îÄ‚îÄ CustomLayerWrapper.cs  # Wraps CustomLayer ‚Üí Tarkov layer\r\n‚îÇ   ‚îú‚îÄ‚îÄ CustomLogicWrapper.cs  # Wraps CustomLogic ‚Üí Tarkov node\r\n‚îÇ   ‚îú‚îÄ‚îÄ AbstractLayerInfo.cs   # Layer metadata\r\n‚îÇ   ‚îî‚îÄ‚îÄ ...\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Patches/                    # Harmony patches\r\n‚îÇ   ‚îú‚îÄ‚îÄ BotBaseBrainActivatePatch.cs     # Injects layers\r\n‚îÇ   ‚îú‚îÄ‚îÄ BotBrainCreateLogicNodePatch.cs  # Creates logic nodes\r\n‚îÇ   ‚îú‚îÄ‚îÄ BotAgentUpdatePatch.cs           # Triggers Start()\r\n‚îÇ   ‚îî‚îÄ‚îÄ ...\r\n‚îÇ\r\n‚îî‚îÄ‚îÄ Utils.cs                    # Helper utilities\r\n```\r\n\r\n---\r\n\r\n## 3. Layer System Design\r\n\r\n### CustomLayer Base Class\r\n\r\n**Source**: `LTBRAIN/Brains/CustomLayer.cs` Lines 7-48\r\n\r\n```csharp\r\npublic abstract class CustomLayer\r\n{\r\n    // References\r\n    public BotOwner BotOwner { get; private set; }\r\n    public int Priority { get; private set; }\r\n    public Action CurrentAction { get; set; } = null;\r\n\r\n    // Constructor\r\n    public CustomLayer(BotOwner botOwner, int priority)\r\n    {\r\n        BotOwner = botOwner;\r\n        Priority = priority;\r\n    }\r\n\r\n    // ===== REQUIRED METHODS (must implement) =====\r\n\r\n    // Layer name (for debugging)\r\n    public abstract string GetName();\r\n\r\n    // Check if layer should be active now\r\n    public abstract bool IsActive();\r\n\r\n    // Get next action to execute\r\n    public abstract Action GetNextAction();\r\n\r\n    // Check if current action should end\r\n    public abstract bool IsCurrentActionEnding();\r\n\r\n    // ===== OPTIONAL METHODS (can override) =====\r\n\r\n    // Called when layer becomes active\r\n    public virtual void Start() { }\r\n\r\n    // Called when layer becomes inactive\r\n    public virtual void Stop() { }\r\n\r\n    // Debug text for overlay\r\n    public virtual void BuildDebugText(StringBuilder stringBuilder) { }\r\n\r\n    // ===== NESTED CLASSES =====\r\n\r\n    public class Action\r\n    {\r\n        public Type Type { get; set; }          // CustomLogic type to execute\r\n        public string Reason { get; set; }      // Debug reason\r\n        public ActionData Data { get; set; }    // Optional data to pass\r\n\r\n        public Action(Type logicType, string reason, ActionData data = null)\r\n        {\r\n            Type = logicType;\r\n            Reason = reason;\r\n            Data = data;\r\n        }\r\n    }\r\n\r\n    public class ActionData : GClass26\r\n    {\r\n        // Inherit from Tarkov's GClass26\r\n        // Can add custom fields here\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Layer Lifecycle\r\n\r\n```\r\nBot Spawns\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ Tarkov creates BotOwner\r\n    ‚îú‚îÄ‚îÄ Tarkov creates BaseBrain\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ BaseBrain.Activate() called\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ[BotBaseBrainActivatePatch]\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ BrainManager injects registered CustomLayerWrappers\r\n    ‚îÇ           ‚îî‚îÄ‚îÄ CustomLayerWrapper wraps YOUR CustomLayer\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ Brain ready with layers\r\n\r\nEvery Frame\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ Brain evaluates all layers (priority order)\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ For each layer:\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ CustomLayerWrapper.ShallUseNow()\r\n    ‚îÇ           ‚îî‚îÄ‚îÄ Calls YOUR layer.IsActive()\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ Select highest priority active layer\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ If layer changed:\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ old_layer.Stop() called\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ new_layer.Start() called\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ Active layer.GetDecision()\r\n        ‚îî‚îÄ‚îÄ CustomLayerWrapper.GetDecision()\r\n            ‚îî‚îÄ‚îÄ Calls YOUR layer.GetNextAction()\r\n                ‚îî‚îÄ‚îÄ Returns Action(logicType, reason)\r\n\r\nBot Death/Dispose\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ Layer.Stop() called\r\n```\r\n\r\n---\r\n\r\n## 4. Logic System Design\r\n\r\n### CustomLogic Base Class\r\n\r\n**Source**: `LTBRAIN/Brains/CustomLogic.cs` Lines 6-22\r\n\r\n```csharp\r\npublic abstract class CustomLogic\r\n{\r\n    // Bot reference\r\n    public BotOwner BotOwner { get; private set; }\r\n\r\n    // Constructor\r\n    public CustomLogic(BotOwner botOwner)\r\n    {\r\n        BotOwner = botOwner;\r\n    }\r\n\r\n    // ===== OPTIONAL METHODS =====\r\n\r\n    // Called when logic becomes active\r\n    public virtual void Start() { }\r\n\r\n    // Called when logic becomes inactive\r\n    public virtual void Stop() { }\r\n\r\n    // ===== REQUIRED METHOD =====\r\n\r\n    // Called every frame while active\r\n    public abstract void Update(CustomLayer.ActionData data);\r\n\r\n    // ===== OPTIONAL =====\r\n\r\n    // Debug text\r\n    public virtual void BuildDebugText(StringBuilder stringBuilder) { }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Logic Lifecycle\r\n\r\n```\r\nLayer.GetNextAction() returns Action\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ Action.Type = typeof(YourLogic)\r\n\r\nBigBrain Agent Update\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ Check if logic exists in node dictionary\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ If NOT: Create logic instance\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ [BotBrainCreateLogicNodePatch]\r\n    ‚îÇ           ‚îî‚îÄ‚îÄ new CustomLogicWrapper(logicType, botOwner)\r\n    ‚îÇ               ‚îî‚îÄ‚îÄ Instantiates YOUR CustomLogic\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ If action changed: logic.Start() called\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ [BotAgentUpdatePatch]\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ CustomLogicWrapper.Start()\r\n    ‚îÇ           ‚îî‚îÄ‚îÄ YOUR logic.Start() called\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ logic.Update(data) called EVERY FRAME\r\n        ‚îî‚îÄ‚îÄ CustomLogicWrapper.UpdateNodeByBrain(data)\r\n            ‚îî‚îÄ‚îÄ YOUR logic.Update(data) called\r\n```\r\n\r\n**Key Insight**: Logics are **lazy-instantiated** - only created when action first requests them.\r\n\r\n---\r\n\r\n## 5. Integration with Tarkov AI\r\n\r\n### How BigBrain Hooks Into Tarkov\r\n\r\n**Source**: `LTBRAIN/Patches/*.cs`\r\n\r\n#### Patch 1: Layer Injection\r\n\r\n**File**: `BotBaseBrainActivatePatch.cs` Lines 12-62\r\n\r\n```csharp\r\n// Patches: BaseBrain.Activate()\r\n// When: Bot brain is activated (bot spawn)\r\n// Effect: Injects all registered CustomLayerWrappers\r\n\r\n[PatchPrefix]\r\npublic static void PatchPrefix(object __instance)\r\n{\r\n    BaseBrain botBrain = __instance as BaseBrain;\r\n    BotOwner botOwner = GetBotOwner(botBrain);\r\n\r\n    // For each registered custom layer\r\n    foreach (BrainManager.LayerInfo layerInfo in BrainManager.Instance.CustomLayers.Values)\r\n    {\r\n        // Check if layer applies to this bot\r\n        if (!layerInfo.AffectsBot(botOwner))\r\n            continue;\r\n\r\n        // Create wrapper around custom layer\r\n        CustomLayerWrapper wrapper = new CustomLayerWrapper(\r\n            layerInfo.customLayerType,\r\n            botOwner,\r\n            layerInfo.customLayerPriority\r\n        );\r\n\r\n        // Inject into brain's layer list\r\n        botBrain.AddLayer(layerInfo.customLayerId, wrapper, true);\r\n    }\r\n}\r\n```\r\n\r\n**Result**: Your CustomLayer is now in the brain's layer list with specified priority.\r\n\r\n---\r\n\r\n#### Patch 2: Logic Node Creation\r\n\r\n**File**: `BotBrainCreateLogicNodePatch.cs` Lines 12-64\r\n\r\n```csharp\r\n// Patches: StandartBotBrain.CreateLogicNode(BotLogicDecision)\r\n// When: Brain needs logic node for a decision ID\r\n// Effect: Creates CustomLogicWrapper for custom decision IDs\r\n\r\n[PatchPrefix]\r\npublic static bool PatchPrefix(BotLogicDecision decision, ref object __result)\r\n{\r\n    int logicIndex = (int)decision;\r\n\r\n    // Check if custom logic (ID >= 9000)\r\n    if (logicIndex >= BrainManager.START_LOGIC_ID)\r\n    {\r\n        // Calculate offset in custom logic list\r\n        logicIndex -= BrainManager.START_LOGIC_ID;\r\n\r\n        // Get logic type from registry\r\n        Type logicType = BrainManager.Instance.CustomLogicList[logicIndex];\r\n\r\n        // Create wrapper around custom logic\r\n        CustomLogicWrapper wrapper = new CustomLogicWrapper(logicType, botOwner);\r\n\r\n        __result = wrapper;\r\n        return false;  // Skip vanilla logic creation\r\n    }\r\n\r\n    return true;  // Use vanilla for non-custom IDs\r\n}\r\n```\r\n\r\n**Result**: When layer returns custom action, BigBrain creates your CustomLogic instance.\r\n\r\n---\r\n\r\n#### Patch 3: Logic Start Trigger\r\n\r\n**File**: `BotAgentUpdatePatch.cs` Lines 14-77\r\n\r\n```csharp\r\n// Patches: AICoreAgentClass.Update()\r\n// When: Every frame\r\n// Effect: Calls Start() when switching to new custom logic\r\n\r\n[PatchPrefix]\r\npublic static bool PatchPrefix(AICoreLogicAgentClass __instance)\r\n{\r\n    // Brain update (get current decision)\r\n    AILogicActionResultStruct? result = __instance.Brain.Update(...);\r\n\r\n    if (result != null)\r\n    {\r\n        BotLogicDecision action = result.Value.Action;\r\n\r\n        // Get or create node for this action\r\n        if (!__instance.Dictionary_0.TryGetValue(action, out var nodeInstance))\r\n        {\r\n            nodeInstance = CreateNode(action);  // Patch 2 handles custom nodes\r\n            __instance.Dictionary_0.Add(action, nodeInstance);\r\n        }\r\n\r\n        // If switching actions AND it's custom logic\r\n        if (__instance.PreviousAction != action &&\r\n            nodeInstance is CustomLogicWrapper customLogic)\r\n        {\r\n            customLogic.Start();  // ‚Üê Triggers YOUR logic.Start()\r\n        }\r\n\r\n        // Update the node\r\n        nodeInstance.UpdateNodeByMain(data);  // ‚Üê Triggers YOUR logic.Update()\r\n    }\r\n\r\n    return false;  // Skip vanilla update\r\n}\r\n```\r\n\r\n**Result**: Your CustomLogic.Start() called on action switch, Update() called every frame.\r\n\r\n---\r\n\r\n## 6. Update Flow\r\n\r\n### Complete Frame-by-Frame Flow\r\n\r\n```\r\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nFRAME START\r\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n\r\n1. Tarkov Update Loop\r\n   ‚îî‚îÄ‚îÄ BotOwner.Update()\r\n       ‚îî‚îÄ‚îÄ Brain.Agent.Update()  [PATCHED by BotAgentUpdatePatch]\r\n\r\n2. Brain Strategy Update\r\n   ‚îî‚îÄ‚îÄ BaseBrain.Update(previousDecision)\r\n       ‚îÇ\r\n       ‚îú‚îÄ‚îÄ For each layer (priority order):\r\n       ‚îÇ   ‚îÇ\r\n       ‚îÇ   ‚îú‚îÄ‚îÄ CustomLayerWrapper.ShallUseNow()  [BigBrain]\r\n       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ YOUR CustomLayer.IsActive()    [YOUR CODE]\r\n       ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ return true/false\r\n       ‚îÇ   ‚îÇ\r\n       ‚îÇ   ‚îî‚îÄ‚îÄ If true: CustomLayerWrapper.GetDecision()  [BigBrain]\r\n       ‚îÇ       ‚îî‚îÄ‚îÄ YOUR CustomLayer.GetNextAction()       [YOUR CODE]\r\n       ‚îÇ           ‚îî‚îÄ‚îÄ return new Action(typeof(YourLogic), \"reason\")\r\n       ‚îÇ\r\n       ‚îî‚îÄ‚îÄ Select highest priority layer with non-null action\r\n\r\n3. Check if Action Changed\r\n   ‚îÇ\r\n   ‚îú‚îÄ‚îÄ If changed:\r\n   ‚îÇ   ‚îÇ\r\n   ‚îÇ   ‚îú‚îÄ‚îÄ Call CustomLayerWrapper.ShallEndCurrentDecision()\r\n   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ YOUR CustomLayer.IsCurrentActionEnding()\r\n   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ return true (action should end)\r\n   ‚îÇ   ‚îÇ\r\n   ‚îÇ   ‚îú‚îÄ‚îÄ Stop old logic:\r\n   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CustomLogicWrapper.Stop()\r\n   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ YOUR CustomLogic.Stop()\r\n   ‚îÇ   ‚îÇ\r\n   ‚îÇ   ‚îî‚îÄ‚îÄ Get new action from layer.GetNextAction()\r\n   ‚îÇ\r\n   ‚îî‚îÄ‚îÄ If NOT changed: Continue current action\r\n\r\n4. Get/Create Logic Node\r\n   ‚îÇ\r\n   ‚îú‚îÄ‚îÄ Check if node exists for action ID\r\n   ‚îÇ   ‚îÇ\r\n   ‚îÇ   ‚îî‚îÄ‚îÄ If NOT: Create node [PATCHED by CreateLogicNodePatch]\r\n   ‚îÇ       ‚îî‚îÄ‚îÄ CustomLogicWrapper(logicType, botOwner)\r\n   ‚îÇ           ‚îî‚îÄ‚îÄ Instantiates YOUR CustomLogic\r\n   ‚îÇ\r\n   ‚îî‚îÄ‚îÄ If action just changed: Call Start()\r\n       ‚îî‚îÄ‚îÄ CustomLogicWrapper.Start()\r\n           ‚îî‚îÄ‚îÄ YOUR CustomLogic.Start()\r\n\r\n5. Update Logic Node\r\n   ‚îÇ\r\n   ‚îî‚îÄ‚îÄ node.UpdateNodeByMain(data)\r\n       ‚îî‚îÄ‚îÄ CustomLogicWrapper.UpdateNodeByBrain(data)\r\n           ‚îî‚îÄ‚îÄ YOUR CustomLogic.Update(data)  [YOUR CODE RUNS]\r\n\r\n6. Execute Bot Behavior\r\n   ‚îÇ\r\n   ‚îî‚îÄ‚îÄ Based on what YOUR logic did:\r\n       ‚îú‚îÄ‚îÄ Set movement targets ‚Üí Vanilla pathfinding moves bot\r\n       ‚îú‚îÄ‚îÄ Set cover points ‚Üí Vanilla cover system positions bot\r\n       ‚îú‚îÄ‚îÄ Set look direction ‚Üí Vanilla aiming system aims\r\n       ‚îî‚îÄ‚îÄ etc.\r\n\r\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nFRAME END\r\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n```\r\n\r\n---\r\n\r\n## 7. Priority and Layer Selection\r\n\r\n### Priority System\r\n\r\n**From**: `LTBRAIN/Brains/BrainManager.cs` Lines 16-17\r\n\r\n```csharp\r\npublic const int START_LAYER_ID = 9000;\r\npublic const int START_LOGIC_ID = 9000;\r\n```\r\n\r\n**Priority Ranges**:\r\n- **9000+**: Custom layers (BigBrain mods)\r\n- **600-900**: High-priority vanilla layers\r\n- **400-599**: Mid-priority vanilla layers\r\n- **200-399**: Low-priority vanilla layers\r\n- **< 200**: Fallback layers\r\n\r\n**Example Priority Assignment**:\r\n```csharp\r\nBrainManager.AddCustomLayer(\r\n    typeof(FollowerCombatLayer),\r\n    brains,\r\n    9100  // Very high priority - overrides almost everything\r\n);\r\n\r\nBrainManager.AddCustomLayer(\r\n    typeof(FollowerPatrolLayer),\r\n    brains,\r\n    9000  // High priority - but lower than combat\r\n);\r\n```\r\n\r\n---\r\n\r\n### Layer Selection Algorithm\r\n\r\n**Every frame**, brain evaluates layers in **descending priority order**:\r\n\r\n```\r\n1. Check Layer 9100 (FollowerCombat)\r\n   ‚îî‚îÄ‚îÄ IsActive()? Yes ‚Üí GetNextAction()? Returns action ‚Üí SELECT THIS\r\n\r\n2. Check Layer 9000 (FollowerPatrol)\r\n   ‚îî‚îÄ‚îÄ SKIP (lower priority layer already selected)\r\n\r\n3. Check Layer 600 (Vanilla Combat)\r\n   ‚îî‚îÄ‚îÄ SKIP (custom layer already selected)\r\n```\r\n\r\n**First active layer wins** - lower priority layers ignored.\r\n\r\n---\r\n\r\n### Layer Deactivation\r\n\r\nWhen layer's `IsActive()` returns false:\r\n```\r\n1. Brain skips this layer\r\n2. Checks next priority layer\r\n3. If new layer selected:\r\n   ‚îî‚îÄ‚îÄ old_layer.Stop() called\r\n   ‚îî‚îÄ‚îÄ new_layer.Start() called\r\n```\r\n\r\n**Example**:\r\n```csharp\r\npublic override bool IsActive()\r\n{\r\n    // Only active when following player\r\n    return HasPlayerToFollow && !BotOwner.IsDead;\r\n}\r\n\r\n// When player dies or bot assigned elsewhere:\r\n// IsActive() returns false ‚Üí Layer deactivates ‚Üí Stop() called\r\n```\r\n\r\n---\r\n\r\n## 8. Lifecycle Management\r\n\r\n### Layer Start/Stop\r\n\r\n**From**: `LTBRAIN/Internal/CustomLayerWrapper.cs` Lines 89-99\r\n\r\n```csharp\r\n// Called by Tarkov AI when layer activates\r\npublic void Start()\r\n{\r\n    customLayer.Start();  // Calls YOUR Start() method\r\n}\r\n\r\n// Called when layer deactivates\r\npublic void Stop()\r\n{\r\n    StopCurrentLogic();  // Stop any active logic first\r\n    customLayer.Stop();  // Then call YOUR Stop() method\r\n}\r\n```\r\n\r\n**Use Cases for Start()**:\r\n- Subscribe to events\r\n- Initialize state\r\n- Load configuration\r\n- Log activation\r\n\r\n**Use Cases for Stop()**:\r\n- Unsubscribe from events\r\n- Clear state\r\n- Cancel pending operations\r\n- Log deactivation\r\n\r\n---\r\n\r\n### Logic Start/Stop\r\n\r\n**From**: `LTBRAIN/Internal/CustomLogicWrapper.cs` Lines 23-31 and `BotAgentUpdatePatch.cs` Lines 52-56\r\n\r\n```csharp\r\n// Called when action changes TO this logic\r\npublic void Start()\r\n{\r\n    customLogic.Start();  // Calls YOUR Start() method\r\n}\r\n\r\n// Called when action changes AWAY from this logic\r\npublic void Stop()\r\n{\r\n    customLogic.Stop();  // Calls YOUR Stop() method\r\n}\r\n```\r\n\r\n**Use Cases for Logic.Start()**:\r\n- Set movement target (cover point, position)\r\n- Initialize action state\r\n- Configure bot for this action\r\n- Log action start\r\n\r\n**Use Cases for Logic.Stop()**:\r\n- Clear movement target\r\n- Reset bot state\r\n- Cancel timers\r\n- Log action complete\r\n\r\n---\r\n\r\n## 9. Performance Considerations\r\n\r\n### Lazy Logic Instantiation\r\n\r\n**From**: `BotBrainCreateLogicNodePatch.cs` and `BotAgentUpdatePatch.cs`\r\n\r\n**Pattern**:\r\n```\r\nLogic Created: Only when action first requested\r\nLogic Reused: Cached in node dictionary\r\nLogic Destroyed: When bot dies (dictionary cleared)\r\n```\r\n\r\n**Memory Efficiency**:\r\n- If layer never returns Action(typeof(RareLogic)), RareLogic is never instantiated\r\n- Common actions (movement, combat) instantiated once, reused\r\n- No wasted memory on unused actions\r\n\r\n**Example**:\r\n```csharp\r\n// Bot has 10 possible actions but only uses 3 during raid\r\n// Only 3 logic instances created (not 10)\r\n// Memory saved: 70%\r\n```\r\n\r\n---\r\n\r\n### Update Frequency Control\r\n\r\n**Layers** evaluated every frame (fast - just boolean checks)\r\n**Logics** updated every frame (but only ONE active logic runs)\r\n\r\n```csharp\r\n// Efficient: Only active logic runs\r\nif (currentAction.Type == typeof(SeekCoverLogic))\r\n{\r\n    seekCoverLogic.Update(data);  // Only this runs\r\n}\r\n\r\n// Idle logics do nothing (no CPU cost)\r\n```\r\n\r\n**Best Practice**: Keep layer.IsActive() and layer.IsCurrentActionEnding() **very fast**\r\n- Simple boolean checks\r\n- Cached values\r\n- No expensive calculations\r\n\r\n---\r\n\r\n## 10. Design Rationale\r\n\r\n### Why Layer/Logic Separation?\r\n\r\n**Layer (Decision Maker)**:\r\n- Lightweight\r\n- Evaluates quickly\r\n- Stateless decision logic\r\n- Can change frequently\r\n\r\n**Logic (Executor)**:\r\n- Heavier weight\r\n- Stateful execution\r\n- Initialized once\r\n- Runs until complete\r\n\r\n**Benefits**:\r\n1. **Performance**: Don't create/destroy executors every decision change\r\n2. **Clarity**: Decision separate from execution\r\n3. **Reusability**: Same logic used by multiple layers\r\n4. **Testing**: Can test decision logic separately from execution\r\n\r\n---\r\n\r\n### Why Priority System?\r\n\r\n**Allows mods to**:\r\n1. **Override vanilla AI** (higher priority)\r\n2. **Cooperate with other mods** (priority negotiation)\r\n3. **Fall back to vanilla** (when custom inactive)\r\n4. **Layer behavior** (combat > movement > idle)\r\n\r\n**Example**: SAIN Combat Layer\r\n```\r\nPriority 9000: SAIN Combat Layer (active during fights)\r\nPriority 600: Vanilla Combat Layer (SAIN overrides this)\r\nPriority 400: Vanilla Patrol Layer (only when no combat)\r\n```\r\n\r\n**Result**: SAIN enhances combat, but vanilla patrol still works when idle.\r\n\r\n---\r\n\r\n### Why Action System?\r\n\r\n**Actions are types** (not enums) because:\r\n1. **Type-safe**: Compiler checks logic types exist\r\n2. **Extensible**: Add new logic types without enum changes\r\n3. **Discoverable**: Can query registered logics\r\n4. **Flexible**: Can pass custom data per action\r\n\r\n**vs Enum-Based**:\r\n```csharp\r\n// ‚ùå Enum approach (inflexible)\r\nreturn BotLogicDecision.myCustomAction;  // Limited to predefined values\r\n\r\n// ‚úÖ Type approach (extensible)\r\nreturn new Action(typeof(MyNewLogic), \"reason\");  // Any logic type\r\n```\r\n\r\n---\r\n\r\n## Summary: BigBrain Architecture\r\n\r\n### Core Concepts\r\n\r\n1. **Layers decide**, **Logics execute**\r\n2. **Priority-based selection** (highest wins)\r\n3. **Wrappers translate** custom ‚Üí vanilla AI\r\n4. **Lazy instantiation** (performance)\r\n5. **Lifecycle hooks** (Start/Stop/Update)\r\n6. **Harmony patches** inject system\r\n\r\n### Data Flow\r\n\r\n```\r\nYour CustomLayer.GetNextAction()\r\n    ‚Üí Returns Action(typeof(YourLogic))\r\n        ‚Üí BigBrain maps to BotLogicDecision ID (9000+)\r\n            ‚Üí Tarkov brain selects decision\r\n                ‚Üí BigBrain creates CustomLogicWrapper\r\n                    ‚Üí Instantiates YOUR CustomLogic\r\n                        ‚Üí Calls Start(), then Update() each frame\r\n                            ‚Üí Your logic interfaces with Tarkov systems\r\n                                ‚Üí Bot behaves according to your code\r\n```\r\n\r\n### Integration Points\r\n\r\n- **Registration**: BrainManager.AddCustomLayer()\r\n- **Decision**: CustomLayer.GetNextAction()\r\n- **Execution**: CustomLogic.Update()\r\n- **Vanilla Access**: All via BotOwner reference\r\n\r\n**BigBrain is the bridge between your mod and Tarkov's AI engine.** üåâ\r\n\r\n---\r\n\r\n**Next**: See `14-BIGBRAIN-API-REFERENCE.md` for complete API documentation and `15-BIGBRAIN-IMPLEMENTATION-GUIDE.md` for practical examples.\r\n"},"14-BIGBRAIN-API-REFERENCE":{"title":"BigBrain - Complete API Reference\r","category":"BigBrain Foundation","content":"# BigBrain - Complete API Reference\r\n\r\n**Source**: `E:\\AppDev\\LTsTarkovAI\\LTBRAIN` (DrakiaXYZ-BigBrain v1.4.0)\r\n**Purpose**: Complete API documentation for BigBrain layer system\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [CustomLayer API](#1-customlayer-api)\r\n2. [CustomLogic API](#2-customlogic-api)\r\n3. [BrainManager API](#3-brainmanager-api)\r\n4. [Action and ActionData](#4-action-and-actiondata)\r\n5. [Helper Utilities](#5-helper-utilities)\r\n6. [Constants and Configuration](#6-constants-and-configuration)\r\n\r\n---\r\n\r\n## 1. CustomLayer API\r\n\r\n**Base Class**: `DrakiaXYZ.BigBrain.Brains.CustomLayer`\r\n**Source**: `LTBRAIN/Brains/CustomLayer.cs`\r\n**Purpose**: Decision-making layer that determines what bot should do\r\n\r\n### Constructor\r\n\r\n```csharp\r\npublic CustomLayer(BotOwner botOwner, int priority)\r\n```\r\n\r\n**Parameters**:\r\n- `botOwner`: The bot this layer controls\r\n- `priority`: Layer priority (higher = higher priority)\r\n\r\n**Called By**: BigBrain when bot spawns (via CustomLayerWrapper)\r\n\r\n**Example**:\r\n```csharp\r\npublic class MyCombatLayer : CustomLayer\r\n{\r\n    public MyCombatLayer(BotOwner botOwner, int priority)\r\n        : base(botOwner, priority)\r\n    {\r\n        // Your initialization here\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Properties\r\n\r\n#### BotOwner\r\n\r\n```csharp\r\npublic BotOwner BotOwner { get; private set; }\r\n```\r\n\r\n**Access bot's**:\r\n- `.Memory` - Memory system (enemies, cover, danger)\r\n- `.Mover` - Movement control\r\n- `.WeaponManager` - Weapon/shooting control\r\n- `.Position` - Current position\r\n- `.IsDead` - Alive status\r\n- All vanilla Tarkov AI systems\r\n\r\n**Example**:\r\n```csharp\r\nbool hasEnemy = BotOwner.Memory.HaveEnemy;\r\nVector3 position = BotOwner.Position;\r\n```\r\n\r\n#### Priority\r\n\r\n```csharp\r\npublic int Priority { get; private set; }\r\n```\r\n\r\n**Read-only** - Set in constructor\r\n\r\n**Higher priority** = selected first by brain\r\n\r\n#### CurrentAction\r\n\r\n```csharp\r\npublic Action CurrentAction { get; set; } = null;\r\n```\r\n\r\n**Managed by BigBrain** - stores currently executing action\r\n\r\n**Don't set manually** - BigBrain handles this\r\n\r\n---\r\n\r\n### Required Methods\r\n\r\n#### GetName()\r\n\r\n```csharp\r\npublic abstract string GetName();\r\n```\r\n\r\n**Purpose**: Return layer name for debugging/logging\r\n\r\n**Returns**: String identifier for this layer\r\n\r\n**Example**:\r\n```csharp\r\npublic override string GetName()\r\n{\r\n    return \"FollowerCombatLayer\";\r\n}\r\n```\r\n\r\n**Used By**:\r\n- BigBrain logging\r\n- Debug overlays\r\n- Layer identification\r\n\r\n---\r\n\r\n#### IsActive()\r\n\r\n```csharp\r\npublic abstract bool IsActive();\r\n```\r\n\r\n**Purpose**: Check if layer should be active RIGHT NOW\r\n\r\n**Returns**:\r\n- `true` - Layer is active, will be considered for selection\r\n- `false` - Layer is inactive, will be skipped\r\n\r\n**Called**: Every frame by BigBrain\r\n\r\n**Performance**: Keep this FAST! Simple boolean logic only.\r\n\r\n**Examples**:\r\n```csharp\r\n// Active when has enemy\r\npublic override bool IsActive()\r\n{\r\n    return BotOwner.Memory.HaveEnemy;\r\n}\r\n\r\n// Active when following player AND alive\r\npublic override bool IsActive()\r\n{\r\n    return hasPlayerToFollow && !BotOwner.IsDead;\r\n}\r\n\r\n// Active when specific role\r\npublic override bool IsActive()\r\n{\r\n    return botRole == BotRole.Medic && squadNeedsMedic;\r\n}\r\n```\r\n\r\n---\r\n\r\n#### GetNextAction()\r\n\r\n```csharp\r\npublic abstract Action GetNextAction();\r\n```\r\n\r\n**Purpose**: Decide what action bot should execute\r\n\r\n**Returns**:\r\n- `Action` object specifying logic type and reason\r\n- `null` if no action (layer inactive or no decision)\r\n\r\n**Called**: When layer is highest priority active layer\r\n\r\n**Example**:\r\n```csharp\r\npublic override Action GetNextAction()\r\n{\r\n    // No enemy = no action\r\n    if (!BotOwner.Memory.HaveEnemy)\r\n        return null;\r\n\r\n    Enemy enemy = BotOwner.Memory.GoalEnemy;\r\n\r\n    // Decision: Need cover?\r\n    if (!BotOwner.Memory.IsInCover && enemy.CanShoot)\r\n    {\r\n        return new Action(\r\n            typeof(SeekCoverLogic),\r\n            \"Enemy can shoot, seeking cover\"\r\n        );\r\n    }\r\n\r\n    // Decision: Can engage?\r\n    if (BotOwner.Memory.IsInCover && enemy.CanShoot)\r\n    {\r\n        return new Action(\r\n            typeof(EngageFromCoverLogic),\r\n            \"Engaging from cover\"\r\n        );\r\n    }\r\n\r\n    // Default\r\n    return new Action(\r\n        typeof(HoldPositionLogic),\r\n        \"Holding position\"\r\n    );\r\n}\r\n```\r\n\r\n---\r\n\r\n#### IsCurrentActionEnding()\r\n\r\n```csharp\r\npublic abstract bool IsCurrentActionEnding();\r\n```\r\n\r\n**Purpose**: Check if current action should end\r\n\r\n**Returns**:\r\n- `true` - Action complete, get new action\r\n- `false` - Continue current action\r\n\r\n**Called**: Every frame while action is active\r\n\r\n**Example**:\r\n```csharp\r\npublic override bool IsCurrentActionEnding()\r\n{\r\n    if (CurrentAction == null)\r\n        return false;\r\n\r\n    // Check specific action end conditions\r\n    if (CurrentAction.Type == typeof(SeekCoverLogic))\r\n    {\r\n        // End if reached cover\r\n        if (BotOwner.Memory.IsInCover)\r\n            return true;\r\n\r\n        // End if lost enemy\r\n        if (!BotOwner.Memory.HaveEnemy)\r\n            return true;\r\n    }\r\n\r\n    if (CurrentAction.Type == typeof(EngageFromCoverLogic))\r\n    {\r\n        // End if left cover\r\n        if (!BotOwner.Memory.IsInCover)\r\n            return true;\r\n\r\n        // End if enemy no longer shootable\r\n        if (!BotOwner.Memory.GoalEnemy.CanShoot)\r\n            return true;\r\n    }\r\n\r\n    return false;  // Continue action\r\n}\r\n```\r\n\r\n---\r\n\r\n### Optional Methods\r\n\r\n#### Start()\r\n\r\n```csharp\r\npublic virtual void Start() { }\r\n```\r\n\r\n**Purpose**: Called when layer becomes active\r\n\r\n**Use For**:\r\n- Event subscriptions\r\n- State initialization\r\n- Logging layer activation\r\n\r\n**Example**:\r\n```csharp\r\npublic override void Start()\r\n{\r\n    // Subscribe to events\r\n    BotOwner.Memory.OnGoalEnemyChanged += OnEnemyChanged;\r\n\r\n    // Log activation\r\n    Logger.LogInfo($\"FollowerCombatLayer activated for {BotOwner.name}\");\r\n}\r\n\r\nprivate void OnEnemyChanged(BotOwner bot)\r\n{\r\n    // React to enemy changes\r\n}\r\n```\r\n\r\n---\r\n\r\n#### Stop()\r\n\r\n```csharp\r\npublic virtual void Stop() { }\r\n```\r\n\r\n**Purpose**: Called when layer becomes inactive\r\n\r\n**Use For**:\r\n- Event unsubscriptions\r\n- State cleanup\r\n- Logging layer deactivation\r\n\r\n**Example**:\r\n```csharp\r\npublic override void Stop()\r\n{\r\n    // Unsubscribe from events\r\n    BotOwner.Memory.OnGoalEnemyChanged -= OnEnemyChanged;\r\n\r\n    // Clear state\r\n    currentTarget = null;\r\n\r\n    // Log deactivation\r\n    Logger.LogInfo($\"FollowerCombatLayer deactivated for {BotOwner.name}\");\r\n}\r\n```\r\n\r\n---\r\n\r\n#### BuildDebugText()\r\n\r\n```csharp\r\npublic virtual void BuildDebugText(StringBuilder stringBuilder) { }\r\n```\r\n\r\n**Purpose**: Add debug info to overlay (if debug build)\r\n\r\n**Example**:\r\n```csharp\r\npublic override void BuildDebugText(StringBuilder sb)\r\n{\r\n    sb.AppendLine($\"Layer: {GetName()}\");\r\n    sb.AppendLine($\"Priority: {Priority}\");\r\n    sb.AppendLine($\"Active: {IsActive()}\");\r\n\r\n    if (CurrentAction != null)\r\n    {\r\n        sb.AppendLine($\"Action: {CurrentAction.Type.Name}\");\r\n        sb.AppendLine($\"Reason: {CurrentAction.Reason}\");\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 2. CustomLogic API\r\n\r\n**Base Class**: `DrakiaXYZ.BigBrain.Brains.CustomLogic`\r\n**Source**: `LTBRAIN/Brains/CustomLogic.cs`\r\n**Purpose**: Action executor that interfaces with Tarkov AI systems\r\n\r\n### Constructor\r\n\r\n```csharp\r\npublic CustomLogic(BotOwner botOwner)\r\n```\r\n\r\n**Parameters**:\r\n- `botOwner`: The bot this logic controls\r\n\r\n**Called By**: BigBrain when action first requested\r\n\r\n**Example**:\r\n```csharp\r\npublic class SeekCoverLogic : CustomLogic\r\n{\r\n    private CustomNavigationPoint targetCover;\r\n\r\n    public SeekCoverLogic(BotOwner botOwner) : base(botOwner)\r\n    {\r\n        // Your initialization\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Properties\r\n\r\n#### BotOwner\r\n\r\n```csharp\r\npublic BotOwner BotOwner { get; private set; }\r\n```\r\n\r\n**Access**: All Tarkov AI systems via BotOwner\r\n\r\n**Same as layer BotOwner** - consistent reference\r\n\r\n---\r\n\r\n### Required Methods\r\n\r\n#### Update()\r\n\r\n```csharp\r\npublic abstract void Update(CustomLayer.ActionData data);\r\n```\r\n\r\n**Purpose**: Execute action logic every frame\r\n\r\n**Parameters**:\r\n- `data`: Optional action data from layer\r\n\r\n**Called**: Every frame while this logic is active\r\n\r\n**Example**:\r\n```csharp\r\npublic override void Update(CustomLayer.ActionData data)\r\n{\r\n    // Check if reached cover\r\n    if (BotOwner.Memory.IsInCover)\r\n    {\r\n        // Done - layer will detect via IsCurrentActionEnding()\r\n        return;\r\n    }\r\n\r\n    // Still moving - vanilla pathfinding handles movement\r\n    // Logic just monitors progress\r\n}\r\n```\r\n\r\n**Common Patterns**:\r\n```csharp\r\n// Pattern 1: Set target in Start(), monitor in Update()\r\npublic override void Start()\r\n{\r\n    targetCover = FindCover();\r\n    BotOwner.Memory.SetCoverPoints(targetCover);\r\n}\r\n\r\npublic override void Update(CustomLayer.ActionData data)\r\n{\r\n    // Vanilla pathfinding moves bot\r\n    // Just monitor completion\r\n}\r\n\r\n// Pattern 2: Continuous updates\r\npublic override void Update(CustomLayer.ActionData data)\r\n{\r\n    // Recalculate aim point each frame\r\n    Vector3 aimPoint = CalculateAimPoint();\r\n\r\n    // Look at aim point\r\n    BotOwner.Steering.LookToPoint(aimPoint);\r\n\r\n    // Vanilla shooting system fires when aimed\r\n}\r\n\r\n// Pattern 3: State machine\r\nprivate enum State { Moving, Acting, Complete }\r\nprivate State currentState = State.Moving;\r\n\r\npublic override void Update(CustomLayer.ActionData data)\r\n{\r\n    switch (currentState)\r\n    {\r\n        case State.Moving:\r\n            if (ReachedDestination())\r\n                currentState = State.Acting;\r\n            break;\r\n\r\n        case State.Acting:\r\n            if (ActionComplete())\r\n                currentState = State.Complete;\r\n            break;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Optional Methods\r\n\r\n#### Start()\r\n\r\n```csharp\r\npublic virtual void Start() { }\r\n```\r\n\r\n**Purpose**: Initialize when logic becomes active\r\n\r\n**Use For**:\r\n- Find and set targets (cover, position, enemy)\r\n- Initialize state machines\r\n- Set bot configuration for this action\r\n- Log action start\r\n\r\n**Example**:\r\n```csharp\r\npublic override void Start()\r\n{\r\n    // Find cover\r\n    targetCover = FindNearestCover(BotOwner.Position, 50f);\r\n\r\n    if (targetCover != null)\r\n    {\r\n        // Set cover in memory - vanilla AI will path to it\r\n        BotOwner.Memory.SetCoverPoints(targetCover);\r\n\r\n        Logger.LogInfo($\"SeekCoverLogic: Moving to cover at {targetCover.Position}\");\r\n    }\r\n    else\r\n    {\r\n        Logger.LogWarning(\"SeekCoverLogic: No cover found!\");\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n#### Stop()\r\n\r\n```csharp\r\npublic virtual void Stop() { }\r\n```\r\n\r\n**Purpose**: Cleanup when logic becomes inactive\r\n\r\n**Use For**:\r\n- Clear targets\r\n- Reset bot state\r\n- Cancel pending operations\r\n- Log action complete\r\n\r\n**Example**:\r\n```csharp\r\npublic override void Stop()\r\n{\r\n    // Clear cover target\r\n    targetCover = null;\r\n\r\n    // Reset bot stance\r\n    BotOwner.Mover.SetTargetPose(1f);  // Stand\r\n\r\n    Logger.LogInfo(\"SeekCoverLogic: Action complete\");\r\n}\r\n```\r\n\r\n---\r\n\r\n#### BuildDebugText()\r\n\r\n```csharp\r\npublic virtual void BuildDebugText(StringBuilder stringBuilder) { }\r\n```\r\n\r\n**Purpose**: Add debug info (same as layer)\r\n\r\n**Example**:\r\n```csharp\r\npublic override void BuildDebugText(StringBuilder sb)\r\n{\r\n    sb.AppendLine($\"Logic: SeekCoverLogic\");\r\n    sb.AppendLine($\"Target: {targetCover?.Position}\");\r\n    sb.AppendLine($\"Distance: {Vector3.Distance(BotOwner.Position, targetCover?.Position ?? Vector3.zero):F1}m\");\r\n    sb.AppendLine($\"In Cover: {BotOwner.Memory.IsInCover}\");\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. BrainManager API\r\n\r\n**Class**: `DrakiaXYZ.BigBrain.Brains.BrainManager`\r\n**Source**: `LTBRAIN/Brains/BrainManager.cs`\r\n**Type**: Singleton\r\n**Purpose**: Register and manage custom layers/logics\r\n\r\n### Registration Methods\r\n\r\n#### AddCustomLayer (Basic)\r\n\r\n```csharp\r\npublic static int AddCustomLayer(\r\n    Type customLayerType,\r\n    List<string> brainNames,\r\n    int customLayerPriority\r\n)\r\n```\r\n\r\n**Purpose**: Register custom layer for specific brain types\r\n\r\n**Parameters**:\r\n- `customLayerType`: Your layer class (must extend CustomLayer)\r\n- `brainNames`: Which brains to add to (e.g., [\"Assault\", \"PMC\"])\r\n- `customLayerPriority`: Priority (higher = higher priority)\r\n\r\n**Returns**: Layer ID (unique identifier)\r\n\r\n**Example**:\r\n```csharp\r\nint layerId = BrainManager.AddCustomLayer(\r\n    typeof(FollowerCombatLayer),\r\n    new List<string> { \"Assault\", \"PMC\" },\r\n    600\r\n);\r\n\r\nLogger.LogInfo($\"Registered FollowerCombatLayer with ID {layerId}\");\r\n```\r\n\r\n---\r\n\r\n#### AddCustomLayer (With Roles)\r\n\r\n```csharp\r\npublic static int AddCustomLayer(\r\n    Type customLayerType,\r\n    List<string> brainNames,\r\n    int customLayerPriority,\r\n    List<WildSpawnType> roles\r\n)\r\n```\r\n\r\n**Purpose**: Register layer for specific brain types AND bot roles\r\n\r\n**Parameters**:\r\n- Same as basic, plus:\r\n- `roles`: Which bot roles (pmcBEAR, pmcUSEC, assault, etc.)\r\n\r\n**Example**:\r\n```csharp\r\n// Only apply to PMC bots\r\nBrainManager.AddCustomLayer(\r\n    typeof(FollowerCombatLayer),\r\n    new List<string> { \"Assault\" },\r\n    600,\r\n    new List<WildSpawnType> { WildSpawnType.pmcBEAR, WildSpawnType.pmcUSEC }\r\n);\r\n```\r\n\r\n---\r\n\r\n#### AddCustomLayers (Bulk)\r\n\r\n```csharp\r\npublic static void AddCustomLayers(\r\n    List<Type> customLayerTypes,\r\n    List<string> brainNames,\r\n    int customLayerPriority\r\n)\r\n```\r\n\r\n**Purpose**: Register multiple layers at once (same priority/brains)\r\n\r\n**Example**:\r\n```csharp\r\nBrainManager.AddCustomLayers(\r\n    new List<Type>\r\n    {\r\n        typeof(FollowerCombatLayer),\r\n        typeof(FollowerPatrolLayer),\r\n        typeof(FollowerMedicLayer)\r\n    },\r\n    new List<string> { \"Assault\" },\r\n    600\r\n);\r\n```\r\n\r\n---\r\n\r\n### Layer Management Methods\r\n\r\n#### RemoveLayer\r\n\r\n```csharp\r\npublic static void RemoveLayer(\r\n    string layerName,\r\n    List<string> brainNames\r\n)\r\n```\r\n\r\n**Purpose**: Disable a layer for specific brains\r\n\r\n**Parameters**:\r\n- `layerName`: Name returned by layer.GetName()\r\n- `brainNames`: Which brains to remove from\r\n\r\n**Example**:\r\n```csharp\r\n// Disable vanilla combat layer for followers\r\nBrainManager.RemoveLayer(\r\n    \"BotLogicCombat\",  // Vanilla layer name\r\n    new List<string> { \"Assault\" }\r\n);\r\n```\r\n\r\n**Effect**:\r\n- Layer removed from all matching bots\r\n- Applies to future spawns too\r\n\r\n---\r\n\r\n#### RestoreLayer\r\n\r\n```csharp\r\npublic static void RestoreLayer(\r\n    string layerName,\r\n    List<string> brainNames\r\n)\r\n```\r\n\r\n**Purpose**: Re-enable previously removed layer\r\n\r\n**Example**:\r\n```csharp\r\n// Re-enable vanilla combat\r\nBrainManager.RestoreLayer(\r\n    \"BotLogicCombat\",\r\n    new List<string> { \"Assault\" }\r\n);\r\n```\r\n\r\n---\r\n\r\n### Query Methods\r\n\r\n#### IsCustomLayerActive\r\n\r\n```csharp\r\npublic static bool IsCustomLayerActive(BotOwner botOwner)\r\n```\r\n\r\n**Purpose**: Check if bot is currently running a custom layer\r\n\r\n**Returns**: `true` if active layer is CustomLayer (not vanilla)\r\n\r\n**Example**:\r\n```csharp\r\nif (BrainManager.IsCustomLayerActive(botOwner))\r\n{\r\n    // Bot is using custom AI\r\n}\r\n```\r\n\r\n---\r\n\r\n#### GetActiveLayerName\r\n\r\n```csharp\r\npublic static string GetActiveLayerName(BotOwner botOwner)\r\n```\r\n\r\n**Purpose**: Get name of currently active layer\r\n\r\n**Returns**: Layer name string\r\n\r\n**Example**:\r\n```csharp\r\nstring layerName = BrainManager.GetActiveLayerName(botOwner);\r\nLogger.LogInfo($\"Bot {botOwner.name} using layer: {layerName}\");\r\n```\r\n\r\n---\r\n\r\n#### GetActiveLayer\r\n\r\n```csharp\r\npublic static object GetActiveLayer(BotOwner botOwner)\r\n```\r\n\r\n**Purpose**: Get current active layer instance\r\n\r\n**Returns**:\r\n- `CustomLayer` if custom layer active\r\n- `AICoreLayerClass` if vanilla layer active\r\n- `null` if error\r\n\r\n**Example**:\r\n```csharp\r\nobject activeLayer = BrainManager.GetActiveLayer(botOwner);\r\n\r\nif (activeLayer is CustomLayer customLayer)\r\n{\r\n    // Custom layer is active\r\n    string name = customLayer.GetName();\r\n}\r\nelse if (activeLayer is AICoreLayerClass vanillaLayer)\r\n{\r\n    // Vanilla layer is active\r\n    string name = vanillaLayer.Name();\r\n}\r\n```\r\n\r\n---\r\n\r\n### Read-Only Collections\r\n\r\n#### CustomLayersReadOnly\r\n\r\n```csharp\r\npublic static IReadOnlyDictionary<int, LayerInfo> CustomLayersReadOnly\r\n```\r\n\r\n**Purpose**: Get all registered custom layers\r\n\r\n**Example**:\r\n```csharp\r\nvar layers = BrainManager.CustomLayersReadOnly;\r\nLogger.LogInfo($\"Total custom layers: {layers.Count}\");\r\n\r\nforeach (var kvp in layers)\r\n{\r\n    int layerId = kvp.Key;\r\n    var layerInfo = kvp.Value;\r\n\r\n    Logger.LogInfo($\"  Layer {layerId}: {layerInfo.customLayerType.Name} (priority {layerInfo.customLayerPriority})\");\r\n}\r\n```\r\n\r\n---\r\n\r\n#### CustomLogicsReadOnly\r\n\r\n```csharp\r\npublic static IReadOnlyDictionary<Type, int> CustomLogicsReadOnly\r\n```\r\n\r\n**Purpose**: Get all registered custom logics\r\n\r\n**Returns**: Dictionary mapping logic type ‚Üí logic ID\r\n\r\n---\r\n\r\n## 4. Action and ActionData\r\n\r\n### Action Class\r\n\r\n**Source**: `LTBRAIN/Brains/CustomLayer.cs` Lines 29-41\r\n\r\n```csharp\r\npublic class Action\r\n{\r\n    public Type Type { get; set; }          // CustomLogic type\r\n    public string Reason { get; set; }      // Debug reason\r\n    public ActionData Data { get; set; }    // Optional data\r\n\r\n    public Action(Type logicType, string reason, ActionData data = null)\r\n    {\r\n        Type = logicType;\r\n        Reason = reason;\r\n        Data = data;\r\n    }\r\n}\r\n```\r\n\r\n**Usage**:\r\n```csharp\r\n// Simple action\r\nreturn new Action(typeof(SeekCoverLogic), \"Need cover\");\r\n\r\n// Action with data\r\nvar actionData = new CustomLayer.ActionData();\r\n// ... populate data\r\nreturn new Action(typeof(ComplexLogic), \"Complex action\", actionData);\r\n```\r\n\r\n---\r\n\r\n### ActionData Class\r\n\r\n**Source**: `LTBRAIN/Brains/CustomLayer.cs` Lines 43-46\r\n\r\n```csharp\r\npublic class ActionData : GClass26\r\n{\r\n    // Inherit from Tarkov's GClass26 (brain data)\r\n    // Add custom fields here\r\n}\r\n```\r\n\r\n**Purpose**: Pass custom data from layer to logic\r\n\r\n**Example**:\r\n```csharp\r\npublic class MyActionData : CustomLayer.ActionData\r\n{\r\n    public Vector3 TargetPosition { get; set; }\r\n    public float Speed { get; set; }\r\n    public bool UsesCover { get; set; }\r\n}\r\n\r\n// In layer:\r\nvar data = new MyActionData\r\n{\r\n    TargetPosition = coverPoint.Position,\r\n    Speed = 1.5f,\r\n    UsesCover = true\r\n};\r\n\r\nreturn new Action(typeof(MoveToPointLogic), \"Moving to point\", data);\r\n\r\n// In logic:\r\npublic override void Update(CustomLayer.ActionData baseData)\r\n{\r\n    MyActionData data = baseData as MyActionData;\r\n    if (data != null)\r\n    {\r\n        Vector3 target = data.TargetPosition;\r\n        // Use data...\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 5. Helper Utilities\r\n\r\n### LayerInfo Class\r\n\r\n**Source**: `LTBRAIN/Brains/BrainManager.cs` Lines 69-93\r\n\r\n```csharp\r\npublic class LayerInfo\r\n{\r\n    public Type customLayerType { get; private set; }\r\n    public int customLayerPriority { get; private set; }\r\n    public int customLayerId { get; private set; }\r\n\r\n    public IReadOnlyList<string> CustomLayerBrains { get; }\r\n    public IReadOnlyList<WildSpawnType> CustomLayerRoles { get; }\r\n}\r\n```\r\n\r\n**Purpose**: Metadata about registered layer\r\n\r\n**Contains**:\r\n- Layer type\r\n- Priority\r\n- Unique ID\r\n- Which brains/roles it applies to\r\n\r\n---\r\n\r\n## 6. Constants and Configuration\r\n\r\n### Layer/Logic ID Ranges\r\n\r\n**Source**: `LTBRAIN/Brains/BrainManager.cs` Lines 16-17\r\n\r\n```csharp\r\npublic const int START_LAYER_ID = 9000;\r\npublic const int START_LOGIC_ID = 9000;\r\n```\r\n\r\n**Custom IDs**: 9000 and above\r\n**Vanilla IDs**: Below 9000\r\n\r\n**Why 9000?**:\r\n- Ensures no conflict with vanilla IDs\r\n- Custom layers automatically have high priority\r\n- Easy to identify custom vs vanilla in logs\r\n\r\n---\r\n\r\n### Brain Names\r\n\r\n**Common Brain Types** (from Tarkov):\r\n- `\"Assault\"` - Regular AI (scavs, PMCs)\r\n- `\"PMC\"` - PMC-specific brain\r\n- `\"Boss\"` - Boss AI (Killa, Gluhar, etc.)\r\n- `\"Follower\"` - Boss follower AI (guards, minions)\r\n- `\"Sectant\"` - Cultist AI\r\n- `\"Zombie\"` - Zombie/infected AI\r\n\r\n**Get all brain names**:\r\n```csharp\r\n// From your bot\r\nstring brainName = botOwner.Brain.BaseBrain.ShortName();\r\n```\r\n\r\n---\r\n\r\n### WildSpawnType Enum\r\n\r\n**Common Bot Roles**:\r\n- `WildSpawnType.pmcBEAR` - BEAR PMC\r\n- `WildSpawnType.pmcUSEC` - USEC PMC\r\n- `WildSpawnType.assault` - Scav\r\n- `WildSpawnType.bossKilla` - Killa\r\n- `WildSpawnType.followerBigPipe` - BigPipe (boss follower)\r\n- etc.\r\n\r\n**All types**:\r\n```csharp\r\nvar allTypes = BrainManager.AllWildSpawnTypes;  // Read-only list\r\n```\r\n\r\n---\r\n\r\n## Summary: API Quick Reference\r\n\r\n### CustomLayer\r\n\r\n| Method | Purpose | Required |\r\n|--------|---------|----------|\r\n| `GetName()` | Return layer name | ‚úÖ Yes |\r\n| `IsActive()` | Check if active | ‚úÖ Yes |\r\n| `GetNextAction()` | Decide action | ‚úÖ Yes |\r\n| `IsCurrentActionEnding()` | Check if done | ‚úÖ Yes |\r\n| `Start()` | Layer activated | Optional |\r\n| `Stop()` | Layer deactivated | Optional |\r\n\r\n### CustomLogic\r\n\r\n| Method | Purpose | Required |\r\n|--------|---------|----------|\r\n| `Update(data)` | Execute each frame | ‚úÖ Yes |\r\n| `Start()` | Logic activated | Optional |\r\n| `Stop()` | Logic deactivated | Optional |\r\n\r\n### BrainManager\r\n\r\n| Method | Purpose |\r\n|--------|---------|\r\n| `AddCustomLayer(type, brains, priority)` | Register layer |\r\n| `RemoveLayer(name, brains)` | Disable layer |\r\n| `RestoreLayer(name, brains)` | Re-enable layer |\r\n| `IsCustomLayerActive(bot)` | Check if custom active |\r\n| `GetActiveLayerName(bot)` | Get current layer name |\r\n\r\n---\r\n\r\n**Next**: See `14-BIGBRAIN-API-REFERENCE.md` for complete method signatures and `15-BIGBRAIN-IMPLEMENTATION-GUIDE.md` for practical examples.\r\n"},"15-BIGBRAIN-IMPLEMENTATION-GUIDE":{"title":"BigBrain - Implementation Guide for FriendlyPMC\r","category":"BigBrain Foundation","content":"# BigBrain - Implementation Guide for FriendlyPMC\r\n\r\n**Source**: Validated LTBRAIN patterns + SAIN AI examples\r\n**Purpose**: Practical guide for implementing BigBrain layers in FriendlyPMC\r\n**Last Updated**: 2025-11-21\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [Hello World Example](#1-hello-world-example)\r\n2. [Follower Combat Layer](#2-follower-combat-layer-complete-example)\r\n3. [Movement Patterns](#3-movement-patterns)\r\n4. [Combat Patterns](#4-combat-patterns)\r\n5. [Coordination Patterns](#5-coordination-patterns)\r\n6. [Testing and Debugging](#6-testing-and-debugging)\r\n7. [Common Patterns from SAIN](#7-common-patterns-from-sain)\r\n8. [Performance Optimization](#8-performance-optimization)\r\n\r\n---\r\n\r\n## 1. Hello World Example\r\n\r\n### Minimal Working Layer\r\n\r\n**File**: `FollowerHelloLayer.cs`\r\n\r\n```csharp\r\nusing DrakiaXYZ.BigBrain.Brains;\r\nusing EFT;\r\nusing UnityEngine;\r\n\r\npublic class FollowerHelloLayer : CustomLayer\r\n{\r\n    public FollowerHelloLayer(BotOwner botOwner, int priority)\r\n        : base(botOwner, priority)\r\n    {\r\n    }\r\n\r\n    public override string GetName()\r\n    {\r\n        return \"FollowerHello\";\r\n    }\r\n\r\n    public override bool IsActive()\r\n    {\r\n        // Always active (for testing)\r\n        return !BotOwner.IsDead;\r\n    }\r\n\r\n    public override Action GetNextAction()\r\n    {\r\n        // Always return same action\r\n        return new Action(\r\n            typeof(SayHelloLogic),\r\n            \"Saying hello\"\r\n        );\r\n    }\r\n\r\n    public override bool IsCurrentActionEnding()\r\n    {\r\n        // Never end (for testing)\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n**File**: `SayHelloLogic.cs`\r\n\r\n```csharp\r\nusing DrakiaXYZ.BigBrain.Brains;\r\nusing EFT;\r\nusing UnityEngine;\r\n\r\npublic class SayHelloLogic : CustomLogic\r\n{\r\n    private float lastHelloTime;\r\n\r\n    public SayHelloLogic(BotOwner botOwner) : base(botOwner)\r\n    {\r\n    }\r\n\r\n    public override void Start()\r\n    {\r\n        BotOwner.BotTalk.TrySay(EPhraseTrigger.OnFight);\r\n        Debug.Log($\"[BigBrain] Hello from {BotOwner.name}!\");\r\n        lastHelloTime = Time.time;\r\n    }\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        // Say hello every 30 seconds\r\n        if (Time.time - lastHelloTime > 30f)\r\n        {\r\n            BotOwner.BotTalk.TrySay(EPhraseTrigger.OnFight);\r\n            Debug.Log($\"[BigBrain] Hello again from {BotOwner.name}!\");\r\n            lastHelloTime = Time.time;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**File**: `YourPlugin.cs`\r\n\r\n```csharp\r\nusing BepInEx;\r\nusing DrakiaXYZ.BigBrain.Brains;\r\n\r\n[BepInPlugin(\"com.yourname.friendlypmc\", \"FriendlyPMC\", \"1.0.0\")]\r\n[BepInDependency(\"xyz.drakia.bigbrain\", \"1.4.0\")]\r\npublic class FriendlyPMCPlugin : BaseUnityPlugin\r\n{\r\n    private void Awake()\r\n    {\r\n        Logger.LogInfo(\"Loading FriendlyPMC...\");\r\n\r\n        // Register layer with BigBrain\r\n        BrainManager.AddCustomLayer(\r\n            typeof(FollowerHelloLayer),\r\n            new List<string> { \"Assault\" },  // All bots\r\n            600                               // High priority\r\n        );\r\n\r\n        Logger.LogInfo(\"FriendlyPMC loaded!\");\r\n    }\r\n}\r\n```\r\n\r\n**Test**:\r\n1. Load game with BigBrain + your mod\r\n2. Start raid\r\n3. Watch logs: Should see \"Hello from Bot_Name!\"\r\n4. Every 30s: \"Hello again from Bot_Name!\"\r\n\r\n---\r\n\r\n## 2. Follower Combat Layer (Complete Example)\r\n\r\n### Layer: Decision Maker\r\n\r\n**File**: `FollowerCombatLayer.cs`\r\n\r\n```csharp\r\nusing DrakiaXYZ.BigBrain.Brains;\r\nusing EFT;\r\nusing UnityEngine;\r\n\r\npublic class FollowerCombatLayer : CustomLayer\r\n{\r\n    private Player _leader;\r\n\r\n    public FollowerCombatLayer(BotOwner botOwner, int priority)\r\n        : base(botOwner, priority)\r\n    {\r\n        // Get leader from follower registry\r\n        _leader = GetLeaderForFollower(botOwner);\r\n    }\r\n\r\n    public override string GetName()\r\n    {\r\n        return \"FollowerCombat\";\r\n    }\r\n\r\n    public override bool IsActive()\r\n    {\r\n        // Active if:\r\n        // 1. Bot is alive\r\n        // 2. Has leader assigned\r\n        // 3. Has enemy OR recently had enemy\r\n        return !BotOwner.IsDead &&\r\n               _leader != null &&\r\n               (BotOwner.Memory.HaveEnemy || RecentlyHadEnemy());\r\n    }\r\n\r\n    public override Action GetNextAction()\r\n    {\r\n        if (!BotOwner.Memory.HaveEnemy)\r\n            return null;\r\n\r\n        EnemyInfo enemy = BotOwner.Memory.GoalEnemy;\r\n\r\n        // Priority 1: Heavy damage - retreat to cover\r\n        if (IsCriticallyWounded())\r\n        {\r\n            return new Action(\r\n                typeof(RetreatToCoverLogic),\r\n                \"Critically wounded, retreating\"\r\n            );\r\n        }\r\n\r\n        // Priority 2: Not in cover and enemy can shoot\r\n        if (!BotOwner.Memory.IsInCover && enemy.CanShoot)\r\n        {\r\n            return new Action(\r\n                typeof(SeekCoverLogic),\r\n                \"Enemy can shoot, need cover\"\r\n            );\r\n        }\r\n\r\n        // Priority 3: In cover, engage enemy\r\n        if (BotOwner.Memory.IsInCover)\r\n        {\r\n            return new Action(\r\n                typeof(EngageFromCoverLogic),\r\n                \"Engaging from cover\"\r\n            );\r\n        }\r\n\r\n        // Priority 4: Move to better position\r\n        if (ShouldReposit ion())\r\n        {\r\n            return new Action(\r\n                typeof(RepositionLogic),\r\n                \"Repositioning for better angle\"\r\n            );\r\n        }\r\n\r\n        // Default: Hold and shoot\r\n        return new Action(\r\n            typeof(HoldAndShootLogic),\r\n            \"Holding position\"\r\n        );\r\n    }\r\n\r\n    public override bool IsCurrentActionEnding()\r\n    {\r\n        if (CurrentAction == null)\r\n            return false;\r\n\r\n        // Check action-specific end conditions\r\n        if (CurrentAction.Type == typeof(SeekCoverLogic))\r\n        {\r\n            // End if reached cover\r\n            if (BotOwner.Memory.IsInCover)\r\n                return true;\r\n\r\n            // End if lost enemy\r\n            if (!BotOwner.Memory.HaveEnemy)\r\n                return true;\r\n        }\r\n\r\n        if (CurrentAction.Type == typeof(EngageFromCoverLogic))\r\n        {\r\n            // End if left cover (compromised)\r\n            if (!BotOwner.Memory.IsInCover)\r\n                return true;\r\n\r\n            // End if can't shoot anymore\r\n            if (BotOwner.Memory.GoalEnemy != null &&\r\n                !BotOwner.Memory.GoalEnemy.CanShoot)\r\n                return true;\r\n        }\r\n\r\n        if (CurrentAction.Type == typeof(RetreatToCoverLogic))\r\n        {\r\n            // End if reached safe cover\r\n            if (BotOwner.Memory.IsInCover && !IsUnderFire())\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override void Start()\r\n    {\r\n        Logger.LogInfo($\"[FollowerCombat] Layer activated for {BotOwner.name}\");\r\n    }\r\n\r\n    public override void Stop()\r\n    {\r\n        Logger.LogInfo($\"[FollowerCombat] Layer deactivated for {BotOwner.name}\");\r\n    }\r\n\r\n    // Helper methods\r\n    private bool IsCriticallyWounded()\r\n    {\r\n        var health = BotOwner.HealthController.GetBodyPartHealth(EBodyPart.Common, false);\r\n        return health.Normalized < 0.3f;  // < 30% health\r\n    }\r\n\r\n    private bool RecentlyHadEnemy()\r\n    {\r\n        // Consider recently in combat if lost enemy < 5s ago\r\n        return Time.time - BotOwner.Memory.LastEnemyTimeSeen < 5f;\r\n    }\r\n\r\n    private bool ShouldReposition()\r\n    {\r\n        if (BotOwner.Memory.GoalEnemy == null)\r\n            return false;\r\n\r\n        // Can't shoot from current position\r\n        return !BotOwner.Memory.GoalEnemy.CanShoot &&\r\n               BotOwner.Memory.GoalEnemy.IsVisible;\r\n    }\r\n\r\n    private bool IsUnderFire()\r\n    {\r\n        return BotOwner.Memory.IsUnderFire ||\r\n               Time.time - BotOwner.Memory.LastTimeHit < 3f;\r\n    }\r\n\r\n    private Player GetLeaderForFollower(BotOwner bot)\r\n    {\r\n        // Get from your follower registry\r\n        return null;  // Implement based on your system\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Logic: Seek Cover Executor\r\n\r\n**File**: `SeekCoverLogic.cs`\r\n\r\n```csharp\r\nusing DrakiaXYZ.BigBrain.Brains;\r\nusing EFT;\r\nusing UnityEngine;\r\n\r\npublic class SeekCoverLogic : CustomLogic\r\n{\r\n    private CustomNavigationPoint _targetCover;\r\n\r\n    public SeekCoverLogic(BotOwner botOwner) : base(botOwner)\r\n    {\r\n    }\r\n\r\n    public override void Start()\r\n    {\r\n        // Find nearest cover\r\n        _targetCover = FindNearestCover();\r\n\r\n        if (_targetCover != null)\r\n        {\r\n            // Set cover point - vanilla AI will path there\r\n            BotOwner.Memory.SetCoverPoints(_targetCover);\r\n\r\n            Logger.LogInfo($\"[SeekCover] Moving to cover at {_targetCover.Position}\");\r\n        }\r\n        else\r\n        {\r\n            Logger.LogWarning($\"[SeekCover] No cover found for {BotOwner.name}!\");\r\n        }\r\n    }\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        // Vanilla pathfinding handles movement\r\n        // Just monitor progress\r\n\r\n        if (_targetCover == null)\r\n            return;\r\n\r\n        float distanceToCover = Vector3.Distance(\r\n            BotOwner.Position,\r\n            _targetCover.Position\r\n        );\r\n\r\n        // Debug logging\r\n        if (Time.frameCount % 60 == 0)  // Every second at 60 FPS\r\n        {\r\n            Logger.LogInfo($\"[SeekCover] Distance to cover: {distanceToCover:F1}m\");\r\n        }\r\n\r\n        // Vanilla AI handles:\r\n        // - Pathfinding to cover\r\n        // - Obstacle avoidance\r\n        // - Speed control\r\n        // - Pose adjustment\r\n    }\r\n\r\n    public override void Stop()\r\n    {\r\n        Logger.LogInfo($\"[SeekCover] Reached cover or action canceled\");\r\n        _targetCover = null;\r\n    }\r\n\r\n    private CustomNavigationPoint FindNearestCover()\r\n    {\r\n        Vector3 botPos = BotOwner.Position;\r\n\r\n        // Get nearby covers from vanilla system\r\n        var covers = BotOwner.Covers.GetClosePoints(botPos, 50f);\r\n\r\n        // Filter and select\r\n        foreach (var cover in covers.OrderBy(c => (c.Position - botPos).sqrMagnitude))\r\n        {\r\n            // Must be free\r\n            if (!cover.IsFreeById(BotOwner.Id))\r\n                continue;\r\n\r\n            // Must be quality cover\r\n            if (cover.CoverLevel == CoverLevel.Sit ||\r\n                cover.CoverLevel == CoverLevel.Stay)\r\n            {\r\n                return cover;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Logic: Engage From Cover\r\n\r\n**File**: `EngageFromCoverLogic.cs`\r\n\r\n```csharp\r\nusing DrakiaXYZ.BigBrain.Brains;\r\nusing EFT;\r\n\r\npublic class EngageFromCoverLogic : CustomLogic\r\n{\r\n    public EngageFromCoverLogic(BotOwner botOwner) : base(botOwner)\r\n    {\r\n    }\r\n\r\n    public override void Start()\r\n    {\r\n        // Set tactic to attack\r\n        BotOwner.Tactic.SetTactic(BotsGroup.BotCurrentTactic.Attack);\r\n\r\n        Logger.LogInfo($\"[EngageFromCover] Starting engagement from cover\");\r\n    }\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        if (BotOwner.Memory.GoalEnemy == null)\r\n            return;\r\n\r\n        // Vanilla systems handle:\r\n        // - Aiming at enemy (BotOwner.AimingData)\r\n        // - Shooting when aimed (BotOwner.WeaponManager.Shoot)\r\n        // - Peeking from cover (BotOwner.Cover system)\r\n        // - Recoil control (BotOwner.WeaponManager)\r\n\r\n        // Logic just ensures bot stays in cover\r\n        if (!BotOwner.Memory.IsInCover)\r\n        {\r\n            // Somehow left cover - will end via IsCurrentActionEnding()\r\n            Logger.LogWarning(\"[EngageFromCover] Left cover during engagement!\");\r\n        }\r\n    }\r\n\r\n    public override void Stop()\r\n    {\r\n        Logger.LogInfo(\"[EngageFromCover] Engagement complete\");\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. Movement Patterns\r\n\r\n### Pattern 1: Move to Position\r\n\r\n```csharp\r\npublic class MoveToPositionLogic : CustomLogic\r\n{\r\n    private Vector3 _targetPosition;\r\n    private bool _shouldSprint;\r\n\r\n    public override void Start()\r\n    {\r\n        // Set target in Start()\r\n        _targetPosition = GetTargetPosition();\r\n        _shouldSprint = ShouldSprint(_targetPosition);\r\n\r\n        // Method 1: Via GoToSomePointData (recommended)\r\n        BotOwner.GoToSomePointData.Point = _targetPosition;\r\n        BotOwner.GoToSomePointData.UpdateToGo(_shouldSprint);\r\n\r\n        Logger.LogInfo($\"[MoveToPosition] Moving to {_targetPosition} (sprint={_shouldSprint})\");\r\n    }\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        // Check if reached\r\n        float distance = Vector3.Distance(BotOwner.Position, _targetPosition);\r\n\r\n        if (distance < 2f)\r\n        {\r\n            // Reached - layer will detect via IsCurrentActionEnding()\r\n            Logger.LogInfo(\"[MoveToPosition] Reached destination\");\r\n        }\r\n\r\n        // Vanilla pathfinding handles:\r\n        // - Nav mesh pathing\r\n        // - Obstacle avoidance\r\n        // - Speed control\r\n        // - Vaulting/jumping\r\n    }\r\n\r\n    private Vector3 GetTargetPosition()\r\n    {\r\n        // Your logic to determine target\r\n        return Vector3.zero;\r\n    }\r\n\r\n    private bool ShouldSprint(Vector3 target)\r\n    {\r\n        float distance = Vector3.Distance(BotOwner.Position, target);\r\n        return distance > 15f;  // Sprint if far\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Pattern 2: Move to Cover\r\n\r\n```csharp\r\npublic class MoveToCoverLogic : CustomLogic\r\n{\r\n    private CustomNavigationPoint _targetCover;\r\n\r\n    public override void Start()\r\n    {\r\n        // Find cover\r\n        _targetCover = FindCoverNearPosition(GetSearchCenter(), 50f);\r\n\r\n        if (_targetCover != null)\r\n        {\r\n            // Set cover - vanilla AI handles pathing\r\n            BotOwner.Memory.SetCoverPoints(_targetCover);\r\n\r\n            Logger.LogInfo($\"[MoveToCover] Pathing to cover at {_targetCover.Position}\");\r\n        }\r\n    }\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        // Vanilla cover system handles:\r\n        // - Pathfinding to cover\r\n        // - Approaching cover\r\n        // - Entering cover pose\r\n        // - Setting IsInCover flag\r\n\r\n        // Monitor progress\r\n        if (_targetCover != null && BotOwner.Memory.IsInCover)\r\n        {\r\n            Logger.LogInfo(\"[MoveToCover] Reached cover successfully\");\r\n        }\r\n    }\r\n\r\n    private CustomNavigationPoint FindCoverNearPosition(Vector3 center, float radius)\r\n    {\r\n        var covers = BotOwner.Covers.GetClosePoints(center, radius);\r\n\r\n        return covers\r\n            .Where(c => c.IsFreeById(BotOwner.Id))\r\n            .Where(c => c.CoverLevel == CoverLevel.Sit || c.CoverLevel == CoverLevel.Stay)\r\n            .OrderBy(c => (c.Position - center).sqrMagnitude)\r\n            .FirstOrDefault();\r\n    }\r\n\r\n    private Vector3 GetSearchCenter()\r\n    {\r\n        // Your logic\r\n        return BotOwner.Position;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Pattern 3: Follow Leader\r\n\r\n```csharp\r\npublic class FollowLeaderLogic : CustomLogic\r\n{\r\n    private Player _leader;\r\n    private float _followDistance = 10f;\r\n    private Vector3 _lastTargetPosition;\r\n\r\n    public override void Start()\r\n    {\r\n        _leader = GetLeader();\r\n\r\n        if (_leader != null)\r\n        {\r\n            UpdateFollowPosition();\r\n            Logger.LogInfo($\"[FollowLeader] Following {_leader.Profile.Nickname}\");\r\n        }\r\n    }\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        if (_leader == null || _leader.HealthController == null || !_leader.HealthController.IsAlive)\r\n        {\r\n            // Leader dead/missing - action will end\r\n            return;\r\n        }\r\n\r\n        // Update follow position every 0.5s\r\n        if (Time.frameCount % 30 == 0)  // 0.5s at 60 FPS\r\n        {\r\n            UpdateFollowPosition();\r\n        }\r\n\r\n        // Vanilla pathfinding handles movement to point\r\n    }\r\n\r\n    public override void Stop()\r\n    {\r\n        Logger.LogInfo(\"[FollowLeader] Stopped following\");\r\n    }\r\n\r\n    private void UpdateFollowPosition()\r\n    {\r\n        Vector3 leaderPos = _leader.Position;\r\n        float distance = Vector3.Distance(BotOwner.Position, leaderPos);\r\n\r\n        // Only update if leader moved significantly or bot far away\r\n        if (distance > _followDistance * 1.5f ||\r\n            Vector3.Distance(leaderPos, _lastTargetPosition) > 5f)\r\n        {\r\n            // Calculate follow position (behind leader)\r\n            Vector3 followOffset = -_leader.LookDirection * _followDistance;\r\n            Vector3 targetPos = leaderPos + followOffset;\r\n\r\n            // Set target\r\n            BotOwner.GoToSomePointData.Point = targetPos;\r\n            BotOwner.GoToSomePointData.UpdateToGo(distance > 20f);  // Sprint if far\r\n\r\n            _lastTargetPosition = targetPos;\r\n        }\r\n    }\r\n\r\n    private Player GetLeader()\r\n    {\r\n        // Get from your follower system\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4. Combat Patterns\r\n\r\n### Pattern 1: Engage Enemy\r\n\r\n```csharp\r\npublic class EngageEnemyLogic : CustomLogic\r\n{\r\n    public override void Start()\r\n    {\r\n        // Set aggressive tactic\r\n        BotOwner.Tactic.SetTactic(BotsGroup.BotCurrentTactic.Attack);\r\n\r\n        Logger.LogInfo(\"[EngageEnemy] Starting engagement\");\r\n    }\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        if (BotOwner.Memory.GoalEnemy == null)\r\n            return;\r\n\r\n        // Vanilla systems handle:\r\n        // - Aiming (BotOwner.AimingData)\r\n        // - Shooting (BotOwner.WeaponManager)\r\n        // - Recoil control\r\n        // - Reload management\r\n        // - Cover peeking\r\n\r\n        // Logic just ensures proper stance\r\n        if (BotOwner.Memory.IsInCover)\r\n        {\r\n            // In cover - let vanilla handle peek/shoot\r\n        }\r\n        else\r\n        {\r\n            // Standing - ensure upright for better aim\r\n            BotOwner.Mover.SetTargetPose(1f);  // Stand\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Pattern 2: Suppress Enemy Area\r\n\r\n```csharp\r\npublic class SuppressAreaLogic : CustomLogic\r\n{\r\n    private Vector3 _suppressionTarget;\r\n    private float _suppressionEndTime;\r\n\r\n    public override void Start()\r\n    {\r\n        _suppressionTarget = BotOwner.Memory.GoalEnemy?.CurrPosition ?? Vector3.zero;\r\n        _suppressionEndTime = Time.time + 3f;  // 3 second burst\r\n\r\n        Logger.LogInfo($\"[Suppress] Suppressing area around {_suppressionTarget}\");\r\n    }\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        if (Time.time > _suppressionEndTime)\r\n        {\r\n            // Burst complete - action will end\r\n            return;\r\n        }\r\n\r\n        // Set look direction toward suppression area\r\n        Vector3 aimPoint = _suppressionTarget + Vector3.up * 1.5f;  // Head height\r\n        Vector3 lookDir = (aimPoint - BotOwner.LookSensor.HeadPoint).normalized;\r\n\r\n        // Vanilla aiming system takes over\r\n        // Vanilla shooting system fires\r\n\r\n        // Logic just maintains aim direction toward area\r\n    }\r\n\r\n    public override void Stop()\r\n    {\r\n        Logger.LogInfo(\"[Suppress] Suppression complete\");\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 5. Coordination Patterns\r\n\r\n### Pattern 1: Multi-Enemy Awareness\r\n\r\n```csharp\r\npublic class MultiEnemyAwarenessLayer : CustomLayer\r\n{\r\n    public override Action GetNextAction()\r\n    {\r\n        // Access ALL enemies (from BLOCKER 2 solution)\r\n        var allEnemies = BotOwner.EnemiesController.EnemyInfos;\r\n\r\n        int visibleCount = allEnemies.Values.Count(e => e.IsVisible);\r\n\r\n        // Surrounded - defensive action\r\n        if (visibleCount >= 3)\r\n        {\r\n            return new Action(\r\n                typeof(DefensiveFormationLogic),\r\n                $\"Surrounded by {visibleCount} enemies\"\r\n            );\r\n        }\r\n\r\n        // Multiple threats - prioritize\r\n        if (visibleCount >= 2)\r\n        {\r\n            return new Action(\r\n                typeof(PrioritizeThreatsLogic),\r\n                \"Multiple visible enemies\"\r\n            );\r\n        }\r\n\r\n        // Single enemy - standard combat\r\n        return new Action(\r\n            typeof(StandardCombatLogic),\r\n            \"Single enemy engagement\"\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Pattern 2: Cluster Perception Integration\r\n\r\n```csharp\r\npublic class ClusterAwareLogic : CustomLogic\r\n{\r\n    public override void Start()\r\n    {\r\n        // Subscribe to cluster events (from DESIGN_INTENT Phase 6)\r\n        var cluster = GetClusterForBot(BotOwner);\r\n\r\n        if (cluster != null)\r\n        {\r\n            // Read shared perception\r\n            if (cluster.SharedTarget != null)\r\n            {\r\n                // Use cluster's enemy info instead of local detection\r\n                Logger.LogInfo($\"[ClusterAware] Using shared target from cluster\");\r\n            }\r\n        }\r\n    }\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        // Check if I'm the primary sensor\r\n        var cluster = GetClusterForBot(BotOwner);\r\n\r\n        if (cluster != null && cluster.PrimarySensor == this)\r\n        {\r\n            // I do heavy perception work\r\n            UpdateSharedPerception();\r\n        }\r\n        else\r\n        {\r\n            // I read shared data (cheap)\r\n            ReadSharedPerception();\r\n        }\r\n    }\r\n\r\n    private void UpdateSharedPerception()\r\n    {\r\n        // Primary sensor: expensive LOS checks\r\n        // From 02-Bot-AI-Brain.md Section 8.2\r\n    }\r\n\r\n    private void ReadSharedPerception()\r\n    {\r\n        // Non-sensor: just read cluster data\r\n        // From DESIGN_INTENT.md Phase 6\r\n    }\r\n\r\n    private object GetClusterForBot(BotOwner bot)\r\n    {\r\n        // Get from your cluster manager\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 6. Testing and Debugging\r\n\r\n### Enable Debug Logging\r\n\r\n```csharp\r\npublic override void BuildDebugText(StringBuilder sb)\r\n{\r\n    sb.AppendLine($\"=== {GetName()} ===\");\r\n    sb.AppendLine($\"Active: {IsActive()}\");\r\n    sb.AppendLine($\"Priority: {Priority}\");\r\n\r\n    if (CurrentAction != null)\r\n    {\r\n        sb.AppendLine($\"Action: {CurrentAction.Type.Name}\");\r\n        sb.AppendLine($\"Reason: {CurrentAction.Reason}\");\r\n    }\r\n\r\n    sb.AppendLine($\"Bot: {BotOwner.name}\");\r\n    sb.AppendLine($\"Has Enemy: {BotOwner.Memory.HaveEnemy}\");\r\n    sb.AppendLine($\"In Cover: {BotOwner.Memory.IsInCover}\");\r\n}\r\n```\r\n\r\n---\r\n\r\n### Console Logging Pattern\r\n\r\n```csharp\r\n// In Layer\r\npublic override void Start()\r\n{\r\n    Logger.LogInfo($\"‚òÖ [{GetName()}] ACTIVATED for {BotOwner.name}\");\r\n}\r\n\r\npublic override void Stop()\r\n{\r\n    Logger.LogInfo($\"‚òÖ [{GetName()}] DEACTIVATED for {BotOwner.name}\");\r\n}\r\n\r\npublic override Action GetNextAction()\r\n{\r\n    var action = // ... decision logic\r\n    Logger.LogInfo($\"  [{GetName()}] Action: {action?.Type.Name ?? \"null\"} - {action?.Reason ?? \"no action\"}\");\r\n    return action;\r\n}\r\n\r\n// In Logic\r\npublic override void Start()\r\n{\r\n    Logger.LogInfo($\"  ‚Üí [{GetType().Name}] START\");\r\n}\r\n\r\npublic override void Stop()\r\n{\r\n    Logger.LogInfo($\"  ‚Üí [{GetType().Name}] STOP\");\r\n}\r\n\r\npublic override void Update(CustomLayer.ActionData data)\r\n{\r\n    if (Time.frameCount % 300 == 0)  // Every 5 seconds\r\n    {\r\n        Logger.LogInfo($\"  ‚Üí [{GetType().Name}] Still running...\");\r\n    }\r\n}\r\n```\r\n\r\n**Expected Log Output**:\r\n```\r\n[Info] ‚òÖ [FollowerCombat] ACTIVATED for Bot_0\r\n[Info]   [FollowerCombat] Action: SeekCoverLogic - Enemy can shoot, need cover\r\n[Info]   ‚Üí [SeekCoverLogic] START\r\n[Info]   ‚Üí [SeekCoverLogic] Still running...\r\n[Info]   ‚Üí [SeekCoverLogic] STOP\r\n[Info]   [FollowerCombat] Action: EngageFromCoverLogic - Engaging from cover\r\n[Info]   ‚Üí [EngageFromCoverLogic] START\r\n```\r\n\r\n---\r\n\r\n### Testing Checklist\r\n\r\n#### Layer Registration\r\n- [ ] BrainManager.AddCustomLayer() called in plugin Awake()\r\n- [ ] No exceptions during registration\r\n- [ ] Logs confirm layer ID assigned\r\n\r\n#### Layer Activation\r\n- [ ] Bot spawns ‚Üí IsActive() called\r\n- [ ] IsActive() returns true when expected\r\n- [ ] GetNextAction() called when active\r\n- [ ] Start() called when layer activates\r\n\r\n#### Logic Execution\r\n- [ ] Logic.Start() called when action begins\r\n- [ ] Logic.Update() called every frame\r\n- [ ] Bot behaves as expected (moves, shoots, etc.)\r\n- [ ] Logic.Stop() called when action ends\r\n\r\n#### Layer Deactivation\r\n- [ ] IsActive() returns false when expected\r\n- [ ] Stop() called when layer deactivates\r\n- [ ] Bot falls back to vanilla AI correctly\r\n\r\n---\r\n\r\n## 7. Common Patterns from SAIN\r\n\r\n### SAIN Combat Layer Pattern\r\n\r\n**From**: `knowledge/AI/Architecture.md` and SAIN analysis\r\n\r\n```csharp\r\n// SAIN uses multiple sub-decisions in one layer\r\npublic class SAINCombatLayer : CustomLayer\r\n{\r\n    public override Action GetNextAction()\r\n    {\r\n        // Get decision from decision system\r\n        ECombatDecision decision = GetCombatDecision();\r\n\r\n        // Map to logic\r\n        return decision switch\r\n        {\r\n            ECombatDecision.Retreat => new Action(typeof(RetreatLogic), \"Retreating\"),\r\n            ECombatDecision.SeekCover => new Action(typeof(SeekCoverLogic), \"Seeking cover\"),\r\n            ECombatDecision.StandAndShoot => new Action(typeof(StandShootLogic), \"Standing and shooting\"),\r\n            ECombatDecision.RushEnemy => new Action(typeof(RushLogic), \"Rushing enemy\"),\r\n            ECombatDecision.ThrowGrenade => new Action(typeof(GrenadeLogic), \"Throwing grenade\"),\r\n            _ => null\r\n        };\r\n    }\r\n\r\n    private ECombatDecision GetCombatDecision()\r\n    {\r\n        // Complex decision tree\r\n        // From knowledge/AI/AIDecisionSystem.md\r\n        return ECombatDecision.None;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### SAIN Enemy Selection Pattern\r\n\r\n**From**: `knowledge/AI/CoreComponents.md` Lines 274-300\r\n\r\n```csharp\r\npublic Enemy SelectBestEnemy()\r\n{\r\n    var allEnemies = BotOwner.EnemiesController.EnemyInfos;\r\n\r\n    // Priority 1: Visible enemies\r\n    var visibleEnemies = allEnemies.Values\r\n        .Where(e => e.IsVisible && e.Person.HealthController.IsAlive)\r\n        .ToList();\r\n\r\n    if (visibleEnemies.Count > 0)\r\n    {\r\n        // Select closest visible\r\n        return visibleEnemies.OrderBy(e => e.Distance).First();\r\n    }\r\n\r\n    // Priority 2: Recently seen\r\n    var recentlySeen = allEnemies.Values\r\n        .Where(e => e.HaveSeen && e.Person.HealthController.IsAlive)\r\n        .Where(e => Time.time - e.PersonalLastSeenTime < 10f)\r\n        .ToList();\r\n\r\n    if (recentlySeen.Count > 0)\r\n    {\r\n        return recentlySeen.OrderBy(e => Time.time - e.PersonalLastSeenTime).First();\r\n    }\r\n\r\n    return null;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 8. Performance Optimization\r\n\r\n### Cache Expensive Checks\r\n\r\n```csharp\r\npublic class OptimizedLayer : CustomLayer\r\n{\r\n    private float _nextCoverSearchTime;\r\n    private CustomNavigationPoint _cachedCover;\r\n\r\n    public override Action GetNextAction()\r\n    {\r\n        // Cache cover search (expensive)\r\n        if (Time.time > _nextCoverSearchTime)\r\n        {\r\n            _cachedCover = FindCover();\r\n            _nextCoverSearchTime = Time.time + 1f;  // Recheck every 1s\r\n        }\r\n\r\n        if (_cachedCover != null)\r\n        {\r\n            return new Action(typeof(UseCachedCoverLogic), \"Using cached cover\");\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Limit Update Frequency\r\n\r\n```csharp\r\npublic class ThrottledLogic : CustomLogic\r\n{\r\n    private float _lastUpdateTime;\r\n    private const float UPDATE_INTERVAL = 0.1f;  // 10 Hz instead of 60 Hz\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        // Throttle updates\r\n        if (Time.time - _lastUpdateTime < UPDATE_INTERVAL)\r\n            return;\r\n\r\n        _lastUpdateTime = Time.time;\r\n\r\n        // Actual work here (10 times per second instead of 60)\r\n        DoExpensiveWork();\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Per-Enemy LOD (From SAIN)\r\n\r\n```csharp\r\npublic class LODEnemyTracking : CustomLogic\r\n{\r\n    private Dictionary<string, float> _enemyUpdateTimes = new Dictionary<string, float>();\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        foreach (var kvp in BotOwner.EnemiesController.EnemyInfos)\r\n        {\r\n            string enemyId = kvp.Key;\r\n            EnemyInfo enemy = kvp.Value;\r\n\r\n            // Check if time to update this enemy\r\n            if (_enemyUpdateTimes.TryGetValue(enemyId, out float nextUpdate))\r\n            {\r\n                if (Time.time < nextUpdate)\r\n                    continue;\r\n            }\r\n\r\n            // Update this enemy\r\n            ProcessEnemy(enemy);\r\n\r\n            // Set next update based on priority\r\n            float interval = GetUpdateInterval(enemy);\r\n            _enemyUpdateTimes[enemyId] = Time.time + interval;\r\n        }\r\n\r\n        // Cleanup every 300 frames (~5s)\r\n        if (Time.frameCount % 300 == 0)\r\n        {\r\n            CleanupStaleEnemies();\r\n        }\r\n    }\r\n\r\n    private float GetUpdateInterval(EnemyInfo enemy)\r\n    {\r\n        // Goal enemy: 20 Hz\r\n        if (BotOwner.Memory.GoalEnemy == enemy)\r\n            return 0.05f;\r\n\r\n        // Visible: 10 Hz\r\n        if (enemy.IsVisible)\r\n            return 0.1f;\r\n\r\n        // Known: 4 Hz\r\n        if (enemy.HaveSeen)\r\n            return 0.25f;\r\n\r\n        // Remembered: 1 Hz\r\n        return 1f;\r\n    }\r\n\r\n    private void CleanupStaleEnemies()\r\n    {\r\n        _enemyUpdateTimes = _enemyUpdateTimes\r\n            .Where(kvp => BotOwner.EnemiesController.EnemyInfos.ContainsKey(kvp.Key))\r\n            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Summary: Quick Reference Card\r\n\r\n### Creating Layer\r\n\r\n```csharp\r\npublic class MyLayer : CustomLayer\r\n{\r\n    public MyLayer(BotOwner bot, int priority) : base(bot, priority) { }\r\n    public override string GetName() => \"MyLayer\";\r\n    public override bool IsActive() => condition;\r\n    public override Action GetNextAction() => new Action(typeof(MyLogic), \"reason\");\r\n    public override bool IsCurrentActionEnding() => endCondition;\r\n}\r\n```\r\n\r\n### Creating Logic\r\n\r\n```csharp\r\npublic class MyLogic : CustomLogic\r\n{\r\n    public MyLogic(BotOwner bot) : base(bot) { }\r\n\r\n    public override void Start()\r\n    {\r\n        // Set targets here\r\n        BotOwner.Memory.SetCoverPoints(cover);\r\n    }\r\n\r\n    public override void Update(CustomLayer.ActionData data)\r\n    {\r\n        // Monitor/adjust here\r\n        // Vanilla AI executes movement/combat\r\n    }\r\n}\r\n```\r\n\r\n### Registering\r\n\r\n```csharp\r\nBrainManager.AddCustomLayer(\r\n    typeof(MyLayer),\r\n    new List<string> { \"Assault\" },\r\n    600\r\n);\r\n```\r\n\r\n### Movement\r\n\r\n```csharp\r\n// Set position\r\nBotOwner.GoToSomePointData.Point = pos;\r\nBotOwner.GoToSomePointData.UpdateToGo(sprint: true);\r\n\r\n// Set cover\r\nBotOwner.Memory.SetCoverPoints(cover);\r\n\r\n// Set stance\r\nBotOwner.Mover.SetTargetPose(0.5f);  // 0=prone, 0.5=crouch, 1=stand\r\n```\r\n\r\n### Enemy Iteration\r\n\r\n```csharp\r\nforeach (var kvp in BotOwner.EnemiesController.EnemyInfos)\r\n{\r\n    EnemyInfo enemy = kvp.Value;\r\n    // Process enemy\r\n}\r\n```\r\n\r\n---\r\n\r\n**With BigBrain, you control bot AI through layers and logics. Vanilla systems handle the execution details!** üß†‚ú®\r\n"},"AIDecisionSystem":{"title":"SAIN AI Decision System Documentation\r","category":"SAIN AI Reference","content":"# SAIN AI Decision System Documentation\r\n\r\n## Overview\r\n\r\nThe SAIN decision system is a multi-layered AI architecture that combines three decision types:\r\n1. **Combat Decisions** (ECombatDecision) - Individual combat tactics\r\n2. **Squad Decisions** (ESquadDecision) - Group coordination\r\n3. **Self Actions** (ESelfActionType) - Self-preservation actions\r\n\r\n## Decision Architecture\r\n\r\n```\r\nSAINDecisionClass (Master Controller)\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ BotDecisionManager (Combines decisions)\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Fires OnDecisionMade events\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ EnemyDecisionClass (Combat logic)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Calculates ECombatDecision\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Evaluates tactical situation\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ SquadDecisionClass (Squad coordination)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Calculates ESquadDecision\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Coordinates with squad members\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ SelfActionDecisionClass (Self-preservation)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Calculates ESelfActionType\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Medical/reload/repair decisions\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ DogFightDecisionClass (Close combat)\r\n        ‚îú‚îÄ‚îÄ Handles <15m engagements\r\n        ‚îî‚îÄ‚îÄ Aggressive close-range tactics\r\n```\r\n\r\n## Combat Decisions (ECombatDecision)\r\n\r\n### Decision Types\r\n\r\n```csharp\r\npublic enum ECombatDecision\r\n{\r\n    None,                // No combat decision\r\n    Retreat,             // Fall back from enemy\r\n    Search,              // Search for lost enemy\r\n    RunAway,             // Flee at high speed\r\n    DogFight,            // Close-quarters aggressive fight\r\n    SeekCover,           // Find and move to cover\r\n    StandAndShoot,       // Hold position and engage\r\n    ThrowGrenade,        // Throw grenade at enemy\r\n    ShiftCover,          // Move to different cover\r\n    RushEnemy,           // Charge toward enemy\r\n    MoveToEngage,        // Reposition for better shot\r\n    ShootDistantEnemy,   // Engage at long range\r\n    AvoidGrenade,        // Evade incoming grenade\r\n    Freeze,              // Stand still (ambush/stealth)\r\n    CreepOnEnemy,        // Slow approach\r\n    MeleeAttack,         // Melee range attack\r\n    FightZombies,        // Special zombie combat\r\n    DebugNoDecision      // Debug/error state\r\n}\r\n```\r\n\r\n### EnemyDecisionClass Logic\r\n\r\n**Decision Flow:**\r\n```csharp\r\npublic ECombatDecision GetDecision()\r\n{\r\n    // No enemy = no combat decision\r\n    if (!Bot.HasEnemy) return ECombatDecision.None;\r\n\r\n    Enemy enemy = Bot.GoalEnemy;\r\n\r\n    // Emergency: Grenade avoidance\r\n    if (ShouldAvoidGrenade())\r\n        return ECombatDecision.AvoidGrenade;\r\n\r\n    // Priority 1: Health/tactical retreat\r\n    if (ShouldRetreat(enemy))\r\n        return ECombatDecision.Retreat;\r\n\r\n    // Priority 2: Lost enemy - search\r\n    if (ShouldSearch(enemy))\r\n        return ECombatDecision.Search;\r\n\r\n    // Priority 3: Close combat\r\n    if (ShouldDogFight(enemy))\r\n        return ECombatDecision.DogFight;\r\n\r\n    // Priority 4: Aggressive rush\r\n    if (ShouldRush(enemy))\r\n        return ECombatDecision.RushEnemy;\r\n\r\n    // Priority 5: Cover-based combat\r\n    if (NeedsCover(enemy))\r\n    {\r\n        if (InCover && ShouldShiftCover())\r\n            return ECombatDecision.ShiftCover;\r\n        else\r\n            return ECombatDecision.SeekCover;\r\n    }\r\n\r\n    // Priority 6: Grenades\r\n    if (ShouldThrowGrenade(enemy))\r\n        return ECombatDecision.ThrowGrenade;\r\n\r\n    // Priority 7: Repositioning\r\n    if (ShouldMoveToEngage(enemy))\r\n        return ECombatDecision.MoveToEngage;\r\n\r\n    // Default: Shoot from current position\r\n    return ECombatDecision.StandAndShoot;\r\n}\r\n```\r\n\r\n### Decision Algorithms\r\n\r\n**Retreat Decision:**\r\n```csharp\r\nprivate bool ShouldRetreat(Enemy enemy)\r\n{\r\n    PersonalitySettings personality = Bot.Info.PersonalitySettings;\r\n\r\n    // Health threshold\r\n    float healthPercent = Bot.Player.HealthController.GetBodyPartHealth(EBodyPart.Common).Current /\r\n                         Bot.Player.HealthController.GetBodyPartHealth(EBodyPart.Common).Maximum;\r\n\r\n    if (healthPercent < personality.RETREAT_HEALTH_THRESHOLD)\r\n        return true;\r\n\r\n    // Suppression threshold\r\n    if (Bot.Suppression.IsSuppressed &&\r\n        Bot.Suppression.SuppressionLevel > personality.RETREAT_SUPPRESSION_THRESHOLD)\r\n        return true;\r\n\r\n    // Outnumbered check\r\n    int visibleEnemies = Bot.EnemyController.VisibleEnemies.Count;\r\n    int squadMembers = Bot.Squad.SquadInfo.MemberCount;\r\n\r\n    if (visibleEnemies > squadMembers * personality.RETREAT_OUTNUMBER_RATIO)\r\n        return true;\r\n\r\n    // Out of ammo\r\n    if (Bot.Shoot.FirearmController.CurrentMagazine.Count == 0 &&\r\n        !Bot.Shoot.HasReloadAvailable)\r\n        return true;\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n**Search Decision:**\r\n```csharp\r\nprivate bool ShouldSearch(Enemy enemy)\r\n{\r\n    // Must have lost enemy\r\n    if (enemy.IsVisible) return false;\r\n    if (!enemy.EnemyKnown) return false;\r\n\r\n    // Time since last known\r\n    float timeSinceLastKnown = enemy.TimeSinceLastKnownUpdated;\r\n\r\n    PersonalitySettings personality = Bot.Info.PersonalitySettings;\r\n\r\n    // Immediate search if recently lost\r\n    if (timeSinceLastKnown < personality.SEARCH_TIME_MIN)\r\n        return true;\r\n\r\n    // Personality-based search duration\r\n    if (timeSinceLastKnown < personality.SEARCH_TIME_MAX)\r\n    {\r\n        // More aggressive personalities search longer\r\n        float searchChance = Mathf.Lerp(1f, 0f,\r\n            timeSinceLastKnown / personality.SEARCH_TIME_MAX);\r\n\r\n        return Random.value < searchChance * personality.SEARCH_AGGRESSION;\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n**Rush Decision:**\r\n```csharp\r\nprivate bool ShouldRush(Enemy enemy)\r\n{\r\n    PersonalitySettings personality = Bot.Info.PersonalitySettings;\r\n\r\n    // Personality must allow rushing\r\n    if (personality.RUSH_ENABLED == false) return false;\r\n\r\n    // Distance check\r\n    float distance = enemy.RealDistance;\r\n    if (distance < personality.RUSH_DISTANCE_MIN || distance > personality.RUSH_DISTANCE_MAX)\r\n        return false;\r\n\r\n    // Enemy must not be looking\r\n    if (enemy.Status.EnemyLookAtMe) return false;\r\n\r\n    // Have advantage (health/position)\r\n    if (Bot.Player.HealthController.GetBodyPartHealth(EBodyPart.Common).Current >\r\n        personality.RUSH_HEALTH_MIN)\r\n    {\r\n        // Enemy suppressed or reloading\r\n        if (enemy.Status.EnemyReloading || enemy.Status.EnemySuppressed)\r\n            return true;\r\n\r\n        // Random rush chance based on personality\r\n        if (Random.value < personality.RUSH_CHANCE)\r\n            return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n**Cover Decision:**\r\n```csharp\r\nprivate bool NeedsCover(Enemy enemy)\r\n{\r\n    // Already in good cover\r\n    if (Bot.Cover.CoverInUse != null &&\r\n        Bot.Cover.CoverInUse.Spotted.CoverValue > 0.7f)\r\n        return false;\r\n\r\n    // Visible and under fire\r\n    if (enemy.IsVisible && enemy.Status.ShotAtMeRecently)\r\n        return true;\r\n\r\n    // Suppressed\r\n    if (Bot.Suppression.IsSuppressed)\r\n        return true;\r\n\r\n    // Low health\r\n    float healthPercent = Bot.Player.HealthController.GetBodyPartHealth(EBodyPart.Common).Current /\r\n                         Bot.Player.HealthController.GetBodyPartHealth(EBodyPart.Common).Maximum;\r\n    if (healthPercent < 0.5f)\r\n        return true;\r\n\r\n    // Outnumbered\r\n    if (Bot.EnemyController.VisibleEnemies.Count > 1)\r\n        return true;\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n**DogFight Decision:**\r\n```csharp\r\npublic bool CheckShallDogFight(EnemyList enemies, out Enemy result)\r\n{\r\n    PersonalitySettings personality = Bot.Info.PersonalitySettings;\r\n\r\n    // Find closest visible enemy\r\n    Enemy closestEnemy = enemies.FilterByPredicate(x => x.IsVisible)\r\n                                .OrderBy(x => x.RealDistance)\r\n                                .FirstOrDefault();\r\n\r\n    if (closestEnemy != null)\r\n    {\r\n        float distance = closestEnemy.RealDistance;\r\n\r\n        // Within dogfight range\r\n        if (distance < personality.DOGFIGHT_DISTANCE)\r\n        {\r\n            // High aggression or low health (desperate)\r\n            float healthPercent = Bot.Player.HealthController.GetBodyPartHealth(EBodyPart.Common).Current /\r\n                                 Bot.Player.HealthController.GetBodyPartHealth(EBodyPart.Common).Maximum;\r\n\r\n            if (personality.DOGFIGHT_AGGRESSION > 0.7f || healthPercent < 0.3f)\r\n            {\r\n                result = closestEnemy;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    result = null;\r\n    return false;\r\n}\r\n```\r\n\r\n## Squad Decisions (ESquadDecision)\r\n\r\n### Decision Types\r\n\r\n```csharp\r\npublic enum ESquadDecision\r\n{\r\n    None,               // No squad decision\r\n    Surround,           // Flank from multiple sides\r\n    Retreat,            // Squad falls back together\r\n    Suppress,           // Suppressive fire\r\n    PushSuppressedEnemy,// Advance on suppressed enemy\r\n    BoundingRetreat,    // Leapfrog retreat\r\n    Regroup,            // Return to squad\r\n    SpreadOut,          // Increase spacing\r\n    HoldPositions,      // Stay in place\r\n    Help,               // Assist squad member\r\n    Search,             // Coordinate search\r\n    GroupSearch         // Group search pattern\r\n}\r\n```\r\n\r\n### SquadDecisionClass Logic\r\n\r\n```csharp\r\npublic ESquadDecision GetDecision()\r\n{\r\n    // Must be in squad\r\n    if (!Bot.Squad.BotInGroup) return ESquadDecision.None;\r\n\r\n    SquadInfo squad = Bot.Squad.SquadInfo;\r\n\r\n    // Check if squad member needs help\r\n    if (ShouldHelp(squad))\r\n        return ESquadDecision.Help;\r\n\r\n    // Squad retreat if multiple members retreating\r\n    if (ShouldSquadRetreat(squad))\r\n        return ESquadDecision.Retreat;\r\n\r\n    // No shared enemy = no squad tactics\r\n    Enemy sharedEnemy = GetSharedEnemy(squad);\r\n    if (sharedEnemy == null) return ESquadDecision.None;\r\n\r\n    // Coordinate search for lost enemy\r\n    if (ShouldGroupSearch(squad, sharedEnemy))\r\n        return ESquadDecision.GroupSearch;\r\n\r\n    // Surround enemy if have numbers\r\n    if (ShouldSurround(squad, sharedEnemy))\r\n        return ESquadDecision.Surround;\r\n\r\n    // Suppress and push tactics\r\n    if (ShouldSuppress(squad, sharedEnemy))\r\n        return ESquadDecision.Suppress;\r\n\r\n    if (ShouldPushSuppressed(squad, sharedEnemy))\r\n        return ESquadDecision.PushSuppressedEnemy;\r\n\r\n    // Hold defensive positions\r\n    return ESquadDecision.HoldPositions;\r\n}\r\n```\r\n\r\n**Surround Logic:**\r\n```csharp\r\nprivate bool ShouldSurround(SquadInfo squad, Enemy enemy)\r\n{\r\n    // Need minimum squad size\r\n    if (squad.MemberCount < 3) return false;\r\n\r\n    // Enemy must be stationary/in cover\r\n    if (enemy.Path.PathDistance < 5f) return false;\r\n\r\n    // Calculate squad positions relative to enemy\r\n    List<Vector3> memberPositions = squad.Members.Select(x => x.Position).ToList();\r\n    Vector3 enemyPos = enemy.EnemyPosition;\r\n\r\n    // Check if squad is already spread out around enemy\r\n    float angleSpread = CalculateAngleSpread(memberPositions, enemyPos);\r\n\r\n    // If clustered, initiate surround\r\n    if (angleSpread < 90f) // Squad is clustered\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n**Help Decision:**\r\n```csharp\r\nprivate bool ShouldHelp(SquadInfo squad)\r\n{\r\n    foreach (BotComponent member in squad.Members)\r\n    {\r\n        if (member == Bot) continue;\r\n\r\n        // Member is low health\r\n        float memberHealth = member.Player.HealthController.GetBodyPartHealth(EBodyPart.Common).Current /\r\n                            member.Player.HealthController.GetBodyPartHealth(EBodyPart.Common).Maximum;\r\n\r\n        if (memberHealth < 0.3f)\r\n        {\r\n            // Close enough to help\r\n            float distance = Bot.PlayerComponent.GetDistanceToPlayer(member.ProfileId);\r\n            if (distance < 50f)\r\n            {\r\n                // Not in worse situation ourselves\r\n                if (Bot.Player.HealthController.GetBodyPartHealth(EBodyPart.Common).Current >\r\n                    member.Player.HealthController.GetBodyPartHealth(EBodyPart.Common).Current)\r\n                {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n## Self Action Decisions (ESelfActionType)\r\n\r\n### Decision Types\r\n\r\n```csharp\r\npublic enum ESelfActionType\r\n{\r\n    None,       // No self action needed\r\n    FirstAid,   // Use healing item\r\n    Surgery,    // Perform surgery\r\n    Reload,     // Reload weapon\r\n    FixWeapon,  // Fix weapon malfunction\r\n    DropBackpack, // Drop backpack for mobility\r\n    Stimulant   // Use combat stimulant\r\n}\r\n```\r\n\r\n### SelfActionDecisionClass Logic\r\n\r\n```csharp\r\npublic ESelfActionType GetDecision()\r\n{\r\n    // Weapon malfunction - immediate priority\r\n    if (Bot.Shoot.WeaponMalfunctioned)\r\n        return ESelfActionType.FixWeapon;\r\n\r\n    // Need reload\r\n    if (NeedsReload())\r\n        return ESelfActionType.Reload;\r\n\r\n    // Health critical\r\n    if (NeedsHealing())\r\n    {\r\n        if (NeedsSurgery())\r\n            return ESelfActionType.Surgery;\r\n        else\r\n            return ESelfActionType.FirstAid;\r\n    }\r\n\r\n    // Tactical stimulant use\r\n    if (ShouldUseStim())\r\n        return ESelfActionType.Stimulant;\r\n\r\n    // Drop backpack for combat mobility\r\n    if (ShouldDropBackpack())\r\n        return ESelfActionType.DropBackpack;\r\n\r\n    return ESelfActionType.None;\r\n}\r\n```\r\n\r\n**Healing Decision:**\r\n```csharp\r\nprivate bool NeedsHealing()\r\n{\r\n    IHealthController health = Bot.Player.HealthController;\r\n\r\n    // Check body parts\r\n    foreach (EBodyPart part in Enum.GetValues(typeof(EBodyPart)))\r\n    {\r\n        if (part == EBodyPart.Common) continue;\r\n\r\n        BodyPartHealth partHealth = health.GetBodyPartHealth(part);\r\n\r\n        // Critical damage\r\n        if (partHealth.Current < partHealth.Maximum * 0.3f)\r\n            return true;\r\n\r\n        // Bleeding\r\n        if (health.IsBodyPartBleeding(part))\r\n            return true;\r\n\r\n        // Fracture (if have splint)\r\n        if (health.IsBodyPartBroken(part) && Bot.Medical.HasSplint)\r\n            return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n**Reload Decision:**\r\n```csharp\r\nprivate bool NeedsReload()\r\n{\r\n    if (Bot.Shoot.FirearmController == null) return false;\r\n\r\n    MagazineClass currentMag = Bot.Shoot.FirearmController.CurrentMagazine;\r\n    int ammoInMag = currentMag.Count;\r\n    int magCapacity = currentMag.MaxCount;\r\n\r\n    // Empty mag\r\n    if (ammoInMag == 0) return true;\r\n\r\n    // Low ammo and not in combat\r\n    if (ammoInMag < magCapacity * 0.3f && !Bot.IsInCombat)\r\n        return true;\r\n\r\n    // Low ammo and in cover\r\n    if (ammoInMag < magCapacity * 0.5f &&\r\n        Bot.Cover.CoverInUse != null)\r\n        return true;\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n## Decision Manager Integration\r\n\r\n### BotDecisionManager\r\n**Purpose**: Combines all decision types and manages transitions\r\n\r\n```csharp\r\npublic class BotDecisionManager\r\n{\r\n    // Current decisions\r\n    public ECombatDecision CurrentCombatDecision { get; private set; }\r\n    public ESquadDecision CurrentSquadDecision { get; private set; }\r\n    public ESelfActionType CurrentSelfDecision { get; private set; }\r\n\r\n    // Previous decisions (for transition logic)\r\n    public ECombatDecision PreviousCombatDecision { get; private set; }\r\n    public ESquadDecision PreviousSquadDecision { get; private set; }\r\n    public ESelfActionType PreviousSelfDecision { get; private set; }\r\n\r\n    // Decision timing\r\n    public float ChangeDecisionTime { get; private set; }\r\n    public float TimeSinceChangeDecision => Time.time - ChangeDecisionTime;\r\n\r\n    // Events\r\n    public event Action<ECombatDecision, ESquadDecision, ESelfActionType, Enemy, BotComponent> OnDecisionMade;\r\n}\r\n```\r\n\r\n**Decision Update:**\r\n```csharp\r\npublic void ManualUpdate()\r\n{\r\n    // Calculate new decisions\r\n    ECombatDecision newCombat = Bot.Decision.EnemyDecisions.GetDecision();\r\n    ESquadDecision newSquad = Bot.Decision.SquadDecisions.GetDecision();\r\n    ESelfActionType newSelf = Bot.Decision.SelfActionDecisions.GetDecision();\r\n\r\n    // Check if decisions changed\r\n    bool decisionsChanged = newCombat != CurrentCombatDecision ||\r\n                           newSquad != CurrentSquadDecision ||\r\n                           newSelf != CurrentSelfDecision;\r\n\r\n    if (decisionsChanged)\r\n    {\r\n        // Store previous\r\n        PreviousCombatDecision = CurrentCombatDecision;\r\n        PreviousSquadDecision = CurrentSquadDecision;\r\n        PreviousSelfDecision = CurrentSelfDecision;\r\n\r\n        // Update current\r\n        CurrentCombatDecision = newCombat;\r\n        CurrentSquadDecision = newSquad;\r\n        CurrentSelfDecision = newSelf;\r\n\r\n        // Update timing\r\n        ChangeDecisionTime = Time.time;\r\n\r\n        // Fire event\r\n        OnDecisionMade?.Invoke(newCombat, newSquad, newSelf, Bot.GoalEnemy, Bot);\r\n    }\r\n}\r\n```\r\n\r\n**Decision Priority:**\r\n```\r\n1. Self Actions (highest) - Survival takes precedence\r\n   ‚îî‚îÄ‚îÄ FirstAid, Surgery, Reload, FixWeapon\r\n\r\n2. Squad Decisions - Coordinate with team\r\n   ‚îî‚îÄ‚îÄ Help, Retreat, Surround, Suppress\r\n\r\n3. Combat Decisions - Individual tactics\r\n   ‚îî‚îÄ‚îÄ AvoidGrenade, Retreat, DogFight, SeekCover, etc.\r\n```\r\n\r\n## Decision Transitions\r\n\r\n**Example: Search ‚Üí Engage Flow**\r\n```\r\nLost Enemy (Search)\r\n    ‚îú‚îÄ‚îÄ Bot searches last known position\r\n    ‚îú‚îÄ‚îÄ Hears gunshot or sees enemy\r\n    ‚îú‚îÄ‚îÄ Enemy detected\r\n    ‚îî‚îÄ‚îÄ Decision changes to engagement\r\n\r\nDecision Change Process:\r\n    ‚îú‚îÄ‚îÄ OnDecisionMade event fired\r\n    ‚îú‚îÄ‚îÄ BigBrain layer detects change\r\n    ‚îú‚îÄ‚îÄ IsCurrentActionEnding() returns true\r\n    ‚îú‚îÄ‚îÄ Old action (SearchAction) ends\r\n    ‚îî‚îÄ‚îÄ New action (StandAndShootAction) starts\r\n```\r\n\r\n**Decision Stability:**\r\n```csharp\r\n// Prevent rapid decision switching\r\npublic bool ShouldAllowDecisionChange()\r\n{\r\n    // Must wait minimum time between changes\r\n    if (TimeSinceChangeDecision < MinDecisionTime)\r\n        return false;\r\n\r\n    // Unless emergency (grenade, critical health)\r\n    if (IsEmergency())\r\n        return true;\r\n\r\n    return true;\r\n}\r\n```\r\n\r\n## Summary\r\n\r\nThe SAIN decision system combines three decision layers:\r\n1. **Combat** - Tactical engagement decisions\r\n2. **Squad** - Team coordination decisions\r\n3. **Self** - Survival and maintenance decisions\r\n\r\nDecisions are calculated each update based on:\r\n- Current enemy state (visible, distance, threat)\r\n- Bot state (health, ammo, suppression)\r\n- Squad state (members, positions, status)\r\n- Personality settings (aggression, caution, tactics)\r\n- Environmental factors (cover, positions, map)\r\n\r\nThe system uses weighted scoring and threshold checks to select appropriate behaviors, with smooth transitions managed by the BigBrain layer system.\r\n"},"Architecture":{"title":"SAIN AI System - Architecture Documentation\r","category":"SAIN AI Reference","content":"# SAIN AI System - Architecture Documentation\r\n\r\n## Table of Contents\r\n1. [System Overview](#system-overview)\r\n2. [Core Design Patterns](#core-design-patterns)\r\n3. [Component Hierarchy](#component-hierarchy)\r\n4. [Update Loop Architecture](#update-loop-architecture)\r\n5. [Memory Management](#memory-management)\r\n6. [Initialization Flow](#initialization-flow)\r\n7. [Layer System Integration](#layer-system-integration)\r\n8. [Event System](#event-system)\r\n9. [Job System](#job-system)\r\n10. [Configuration Architecture](#configuration-architecture)\r\n\r\n---\r\n\r\n## System Overview\r\n\r\n### High-Level Architecture\r\n\r\nSAIN uses a hierarchical component-based architecture with three main tiers:\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ                    Unity Game Engine                        ‚îÇ\r\n‚îÇ                    (Escape from Tarkov)                     ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚îÇ\r\n                            ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n                            ‚îÇ                     ‚îÇ\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ      SPT-AKI Framework            ‚îÇ  ‚îÇ   BigBrain Mod      ‚îÇ\r\n‚îÇ  (Server + Client Modding)        ‚îÇ  ‚îÇ   (Layer System)    ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚îÇ\r\n                            ‚îÇ\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ         SAIN Plugin (BepInEx)         ‚îÇ\r\n        ‚îÇ        - Harmony Patches              ‚îÇ\r\n        ‚îÇ        - Component Injection          ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚îÇ\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ                                       ‚îÇ\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  Global Layer   ‚îÇ                  ‚îÇ   Bot Layer      ‚îÇ\r\n‚îÇ                 ‚îÇ                  ‚îÇ                  ‚îÇ\r\n‚îÇ GameWorld       ‚îÇ                  ‚îÇ BotComponent     ‚îÇ\r\n‚îÇ BotManager      ‚îÇ                  ‚îÇ (per bot)        ‚îÇ\r\n‚îÇ BotSpawnCtrl    ‚îÇ                  ‚îÇ  - Decision      ‚îÇ\r\n‚îÇ CoverManager    ‚îÇ                  ‚îÇ  - Vision        ‚îÇ\r\n‚îÇ JobManager      ‚îÇ                  ‚îÇ  - Enemies       ‚îÇ\r\n‚îÇ                 ‚îÇ                  ‚îÇ  - Movement      ‚îÇ\r\n‚îÇ                 ‚îÇ                  ‚îÇ  - Combat        ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n```\r\n\r\n### Architectural Principles\r\n\r\n1. **Component-Based Design**: Each bot is composed of specialized components for different AI subsystems\r\n2. **Singleton Managers**: Global systems use singleton pattern for centralized control\r\n3. **Event-Driven Updates**: Components subscribe to events to reduce polling\r\n4. **Lazy Initialization**: Components initialize only when needed\r\n5. **Tick-Rate Optimization**: Different update frequencies based on importance\r\n6. **Job System Integration**: Expensive operations run on worker threads\r\n7. **Layer Injection**: BigBrain layer system allows overriding base game AI\r\n\r\n---\r\n\r\n## Core Design Patterns\r\n\r\n### 1. Component Pattern\r\n\r\nEvery bot has a `BotComponent` that aggregates 25+ specialized subsystems:\r\n\r\n```csharp\r\npublic class BotComponent : BotComponentBase, ISPlayer\r\n{\r\n    // Decision Systems\r\n    public SAINDecisionClass Decision { get; private set; }\r\n\r\n    // Sensory Systems\r\n    public SAINVisionClass Vision { get; private set; }\r\n    public SAINHearingSensorClass Hearing { get; private set; }\r\n\r\n    // Combat Systems\r\n    public SAINShootData Shoot { get; private set; }\r\n    public BotGrenadeManager Grenade { get; private set; }\r\n\r\n    // Movement Systems\r\n    public SAINMoverClass Mover { get; private set; }\r\n    public SAINCoverClass Cover { get; private set; }\r\n\r\n    // Enemy Management\r\n    public SAINEnemyController EnemyController { get; private set; }\r\n\r\n    // ... 15+ more components\r\n}\r\n```\r\n\r\n**Benefits:**\r\n- Clear separation of concerns\r\n- Easy to add/remove features\r\n- Testable in isolation\r\n- Reusable across bot types\r\n\r\n### 2. Singleton Pattern\r\n\r\nGlobal managers use thread-safe lazy singletons:\r\n\r\n```csharp\r\npublic class BotManagerComponent : MonoBehaviour\r\n{\r\n    private static BotManagerComponent _instance;\r\n\r\n    public static BotManagerComponent Instance\r\n    {\r\n        get\r\n        {\r\n            if (_instance == null)\r\n            {\r\n                _instance = FindObjectOfType<BotManagerComponent>();\r\n            }\r\n            return _instance;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Singletons in SAIN:**\r\n- `GameWorldComponent` - Game world state\r\n- `BotManagerComponent` - Bot coordination\r\n- `BotSpawnController` - Bot spawning\r\n- `CoverManagerClass` - Cover point pooling\r\n- `JobManager` - Raycast job scheduling\r\n\r\n### 3. Strategy Pattern\r\n\r\nDecision-making uses strategy pattern for different decision types:\r\n\r\n```csharp\r\npublic class SAINDecisionClass\r\n{\r\n    public EnemyDecisionClass EnemyDecisions { get; }\r\n    public SquadDecisionClass SquadDecisions { get; }\r\n    public SelfActionDecisionClass SelfActionDecisions { get; }\r\n\r\n    // Each strategy calculates its own decision\r\n    public void ManualUpdate()\r\n    {\r\n        EnemyDecisions.ManualUpdate();\r\n        SquadDecisions.ManualUpdate();\r\n        SelfActionDecisions.ManualUpdate();\r\n        DecisionManager.MakeDecision(); // Combines strategies\r\n    }\r\n}\r\n```\r\n\r\n### 4. Observer Pattern\r\n\r\nEvent system for component communication:\r\n\r\n```csharp\r\npublic class Enemy\r\n{\r\n    public EnemyEvents Events { get; }\r\n\r\n    public event Action OnEnemyDisposed;\r\n}\r\n\r\npublic class EnemyEvents\r\n{\r\n    public EnemyToggleEventTimeTracked OnEnemyKnownChanged;\r\n    public EnemyToggleEventTimeTracked OnVisionChange;\r\n    public EnemyToggleEventTimeTracked OnEnemyLineOfSightChanged;\r\n}\r\n```\r\n\r\nComponents subscribe to events to react to state changes without tight coupling.\r\n\r\n### 5. Object Pool Pattern\r\n\r\nFrequently created objects use pooling:\r\n\r\n```csharp\r\n// Enemy lists are pre-allocated\r\nprivate readonly List<Enemy> _preAllocList = new List<Enemy>();\r\n\r\n// Reused instead of creating new lists\r\nKnownEnemies.FilterByPredicateNonAlloc(_preAllocList, predicate);\r\n```\r\n\r\n### 6. State Machine Pattern\r\n\r\nBot activation uses state tracking:\r\n\r\n```csharp\r\npublic enum ESAINTickState\r\n{\r\n    AlwaysUpdate,       // Every frame\r\n    OnlyBotActive,      // Bot spawned and active\r\n    OnlyNoSleep,        // Not in standby mode\r\n    OnlyBotInCombat     // Actively fighting\r\n}\r\n```\r\n\r\nEach component declares its tick requirement, and the system only updates it when appropriate.\r\n\r\n---\r\n\r\n## Component Hierarchy\r\n\r\n### Tier 1: Global Managers (Singletons)\r\n\r\n```\r\nGameWorldComponent\r\n‚îú‚îÄ‚îÄ Manages game world state\r\n‚îú‚îÄ‚îÄ Tracks all players\r\n‚îî‚îÄ‚îÄ Coordinates global events\r\n\r\nBotManagerComponent\r\n‚îú‚îÄ‚îÄ Manages all SAIN bots\r\n‚îú‚îÄ‚îÄ Processes raycast jobs\r\n‚îú‚îÄ‚îÄ Updates cover manager\r\n‚îî‚îÄ‚îÄ Coordinates bot updates\r\n\r\nBotSpawnController\r\n‚îú‚îÄ‚îÄ Detects bot spawns\r\n‚îú‚îÄ‚îÄ Attaches BotComponent\r\n‚îî‚îÄ‚îÄ Initializes SAIN systems\r\n\r\nCoverManagerClass\r\n‚îú‚îÄ‚îÄ Pools cover points globally\r\n‚îú‚îÄ‚îÄ Manages cover point lifecycle\r\n‚îî‚îÄ‚îÄ Coordinates cover searches\r\n\r\nJobManager\r\n‚îú‚îÄ‚îÄ Schedules Unity jobs\r\n‚îú‚îÄ‚îÄ Manages job completion\r\n‚îî‚îÄ‚îÄ Handles job results\r\n```\r\n\r\n### Tier 2: Per-Bot Components (BotComponent)\r\n\r\n```\r\nBotComponent (one per bot)\r\n‚îú‚îÄ‚îÄ BotComponentBase (inheritance)\r\n‚îÇ   ‚îú‚îÄ‚îÄ Player reference\r\n‚îÇ   ‚îú‚îÄ‚îÄ BotOwner reference\r\n‚îÇ   ‚îî‚îÄ‚îÄ Transform data\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Core Systems\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINBotInfoClass (bot metadata)\r\n‚îÇ   ‚îú‚îÄ‚îÄ BotActivationClass (activation state)\r\n‚îÇ   ‚îî‚îÄ‚îÄ SAINAILimit (performance limiting)\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Decision Systems\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINDecisionClass (master decision)\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BotDecisionManager (combines decisions)\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EnemyDecisionClass (combat decisions)\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SquadDecisionClass (squad coordination)\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SelfActionDecisionClass (self actions)\r\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DogFightDecisionClass (close combat)\r\n‚îÇ   ‚îÇ\r\n‚îÇ   ‚îî‚îÄ‚îÄ SAINSelfActionClass (executes self actions)\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Enemy Management\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINEnemyController (tracks all enemies)\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dictionary<string, Enemy>\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ KnownEnemies (EnemyList)\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VisibleEnemies (EnemyList)\r\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ EnemiesInLineOfSight (EnemyList)\r\n‚îÇ   ‚îÇ\r\n‚îÇ   ‚îî‚îÄ‚îÄ Enemy (per enemy) - see Tier 3\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Sensory Systems\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINVisionClass (vision processing)\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINHearingSensorClass (sound detection)\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINNoBushESP (foliage penetration)\r\n‚îÇ   ‚îî‚îÄ‚îÄ FlashLightDazzleClass (flashlight effects)\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Combat Systems\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINShootData (shooting mechanics)\r\n‚îÇ   ‚îú‚îÄ‚îÄ BotGrenadeManager (grenades)\r\n‚îÇ   ‚îú‚îÄ‚îÄ AimClass (aiming calculations)\r\n‚îÇ   ‚îú‚îÄ‚îÄ ManualShootClass (fire control)\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINFriendlyFireClass (FF prevention)\r\n‚îÇ   ‚îî‚îÄ‚îÄ SAINBotSuppressClass (suppression)\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Movement Systems\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINMoverClass (movement controller)\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINSteeringClass (look direction)\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINCoverClass (cover system)\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINVaultClass (vaulting)\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINBotUnstuckClass (unstuck logic)\r\n‚îÇ   ‚îî‚îÄ‚îÄ DoorOpener (door interaction)\r\n‚îÇ\r\n‚îî‚îÄ‚îÄ Support Systems\r\n    ‚îú‚îÄ‚îÄ SAINMemoryClass (memory)\r\n    ‚îú‚îÄ‚îÄ SAINSearchClass (search behavior)\r\n    ‚îú‚îÄ‚îÄ SAINBotTalkClass (voice lines)\r\n    ‚îú‚îÄ‚îÄ SAINBotMedicalClass (medical)\r\n    ‚îú‚îÄ‚îÄ BotSquadContainer (squad)\r\n    ‚îú‚îÄ‚îÄ BotLightController (lights)\r\n    ‚îú‚îÄ‚îÄ BotBackpackDropClass (backpack)\r\n    ‚îú‚îÄ‚îÄ CurrentTargetClass (targeting)\r\n    ‚îú‚îÄ‚îÄ BotWeightManagement (weight)\r\n    ‚îî‚îÄ‚îÄ SAINBotSpaceAwareness (spatial)\r\n```\r\n\r\n### Tier 3: Enemy Objects\r\n\r\n```\r\nEnemy (per enemy per bot)\r\n‚îú‚îÄ‚îÄ Enemy identity\r\n‚îÇ   ‚îú‚îÄ‚îÄ EnemyPlayer (Player reference)\r\n‚îÇ   ‚îú‚îÄ‚îÄ EnemyPlayerComponent (PlayerComponent)\r\n‚îÇ   ‚îú‚îÄ‚îÄ EnemyTransform (position/rotation)\r\n‚îÇ   ‚îî‚îÄ‚îÄ EnemyProfileId (unique ID)\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Enemy Vision\r\n‚îÇ   ‚îú‚îÄ‚îÄ EnemyVisionClass (visibility state)\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IsVisible (can bot see enemy)\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ InLineOfSight (clear LoS)\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CanShoot (can shoot at enemy)\r\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TimeSinceSeen (time tracking)\r\n‚îÇ   ‚îÇ\r\n‚îÇ   ‚îî‚îÄ‚îÄ EnemyAim (aiming at enemy)\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Enemy Audio\r\n‚îÇ   ‚îî‚îÄ‚îÄ EnemyHearing (heard state)\r\n‚îÇ       ‚îú‚îÄ‚îÄ Heard (bot heard enemy)\r\n‚îÇ       ‚îî‚îÄ‚îÄ TimeSinceHeard\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Enemy Knowledge\r\n‚îÇ   ‚îú‚îÄ‚îÄ EnemyKnownPlaces (position tracking)\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LastKnownPosition\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LastSeenPosition\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LastHeardPosition\r\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TimeSinceLastKnownUpdated\r\n‚îÇ   ‚îÇ\r\n‚îÇ   ‚îú‚îÄ‚îÄ EnemyKnownChecker (knowledge state)\r\n‚îÇ   ‚îî‚îÄ‚îÄ EnemyInfo (base game enemy info)\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Enemy Status\r\n‚îÇ   ‚îú‚îÄ‚îÄ SAINEnemyStatus (behavior tracking)\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EnemyLookAtMe\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ShotAtMe\r\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ShotAtMeRecently\r\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ various timers\r\n‚îÇ   ‚îÇ\r\n‚îÇ   ‚îî‚îÄ‚îÄ PositionSmoother (smooth position)\r\n‚îÇ\r\n‚îú‚îÄ‚îÄ Enemy Path\r\n‚îÇ   ‚îî‚îÄ‚îÄ SAINEnemyPath (pathfinding)\r\n‚îÇ       ‚îú‚îÄ‚îÄ PathCorners (NavMesh path)\r\n‚îÇ       ‚îú‚îÄ‚îÄ PathDistance\r\n‚îÇ       ‚îî‚îÄ‚îÄ EPathDistance (enum)\r\n‚îÇ\r\n‚îî‚îÄ‚îÄ Enemy Events\r\n    ‚îî‚îÄ‚îÄ EnemyEvents (event dispatching)\r\n        ‚îú‚îÄ‚îÄ OnEnemyKnownChanged\r\n        ‚îú‚îÄ‚îÄ OnVisionChange\r\n        ‚îú‚îÄ‚îÄ OnEnemyLineOfSightChanged\r\n        ‚îî‚îÄ‚îÄ OnSearch\r\n```\r\n\r\n---\r\n\r\n## Update Loop Architecture\r\n\r\n### Master Update Flow\r\n\r\n```\r\nUnity Update Loop\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ GameWorldComponent.Update()\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Tracks players, updates global state\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ BotManagerComponent.Update()\r\n        ‚îÇ\r\n        ‚îú‚îÄ‚îÄ Update all BotComponents\r\n        ‚îÇ   ‚îî‚îÄ‚îÄ For each BotComponent:\r\n        ‚îÇ       ‚îî‚îÄ‚îÄ BotComponent.ManualUpdate(currentTime, deltaTime)\r\n        ‚îÇ\r\n        ‚îú‚îÄ‚îÄ JobManager.UpdateJobs()\r\n        ‚îÇ   ‚îú‚îÄ‚îÄ Check completed raycast jobs\r\n        ‚îÇ   ‚îî‚îÄ‚îÄ Process job results\r\n        ‚îÇ\r\n        ‚îî‚îÄ‚îÄ CoverManagerClass.Update()\r\n            ‚îî‚îÄ‚îÄ Update cover point states\r\n```\r\n\r\n### BotComponent Update Cycle\r\n\r\n```csharp\r\npublic void ManualUpdate(float currentTime, float deltaTime)\r\n{\r\n    // Phase 1: Always Update (every frame)\r\n    TickClassGroup(_alwaysTickClasses, currentTime);\r\n    // Components: BotActivation, Info, GlobalEvents, etc.\r\n\r\n    bool botActive = BotActive;\r\n    if (botActive)\r\n    {\r\n        // Phase 2: Bot Active (bot spawned and running)\r\n        TickClassGroup(_tickWhenActiveClasses, currentTime);\r\n        // Components: Decision, EnemyController, Vision, Hearing\r\n    }\r\n\r\n    bool botInStandBy = BotInStandBy;\r\n    if (!botInStandBy)\r\n    {\r\n        // Phase 3: Not Sleeping (not in standby mode)\r\n        TickClassGroup(_tickWhenNoSleepClasses, currentTime);\r\n        // Components: Mover, Steering, Cover, Vault, Search\r\n\r\n        HandleDumbShit(); // Easter egg cheater code\r\n    }\r\n\r\n    bool inCombat = botActive && !botInStandBy &&\r\n                    SAINLayersActive && GoalEnemy != null;\r\n    if (inCombat)\r\n    {\r\n        // Phase 4: Combat (actively fighting)\r\n        TickClassGroup(_tickWhenCombatClasses, currentTime);\r\n        // Components: Shoot, Grenade, Suppression, Aim, FriendlyFire\r\n    }\r\n}\r\n```\r\n\r\n### Tick Rate System\r\n\r\nEach component defines its update requirements:\r\n\r\n```csharp\r\npublic abstract class BotBase : IBotClass\r\n{\r\n    public ESAINTickState TickRequirement { get; protected set; }\r\n    public float TickInterval { get; protected set; }\r\n    public float LastTickTime { get; protected set; }\r\n\r\n    public virtual bool ShallTick(float CurrentTime)\r\n    {\r\n        if (CanEverTick && LastTickTime + TickInterval < CurrentTime)\r\n        {\r\n            LastTickTime = Time.time;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n**Example Tick Rates:**\r\n- Vision system: 15-30 Hz depending on enemy priority\r\n- Hearing system: 10 Hz\r\n- Decision system: 5-10 Hz\r\n- Cover finding: 1-2 Hz\r\n- Medical checks: 0.5 Hz\r\n\r\n---\r\n\r\n## Memory Management\r\n\r\n### Component Lifecycle\r\n\r\n```\r\nBot Spawn\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ EFT spawns bot ‚Üí BotOwner created\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ BotSpawnController detects spawn\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Creates PlayerComponent (Unity component)\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ Attached to bot GameObject\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ BotSpawnController.GetOrCreateSAIN()\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Creates BotComponent (Unity component)\r\n    ‚îÇ       ‚îú‚îÄ‚îÄ Attached to bot GameObject\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ References PlayerComponent\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ BotComponent.Activate(botOwner)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ InitializeBot()\r\n    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateClasses() - 25+ components\r\n    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AddToSquad()\r\n    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ InitClasses() - calls Init() on each\r\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FinishInit()\r\n    ‚îÇ   ‚îÇ\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ OnBotActivated event fired\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ Bot starts updating\r\n        ‚îî‚îÄ‚îÄ ManualUpdate() called each frame\r\n\r\nBot Death/Disposal\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ BotComponent.Dispose()\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ StopAllCoroutines()\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Dispose all components (25+)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Destroy NoBushESP component\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Destroy self (Unity)\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ Garbage collection\r\n```\r\n\r\n### Memory Optimization Strategies\r\n\r\n1. **Pre-allocated Collections**\r\n```csharp\r\nprivate readonly List<Enemy> _preAllocList = new List<Enemy>();\r\n// Reused instead of allocating new lists\r\n```\r\n\r\n2. **Object Pooling**\r\n```csharp\r\n// Cover points pooled globally\r\npublic class CoverManagerClass\r\n{\r\n    private Dictionary<Vector3, CoverPoint> _coverPoints;\r\n    // Reused across all bots\r\n}\r\n```\r\n\r\n3. **Lazy Loading**\r\n```csharp\r\npublic Enemy GetEnemy(string profileID, bool mustBeActive)\r\n{\r\n    // Only creates enemy when actually needed\r\n    if (!Enemies.TryGetValue(profileID, out var enemy))\r\n    {\r\n        enemy = CheckAddEnemy(player);\r\n    }\r\n    return enemy;\r\n}\r\n```\r\n\r\n4. **Conditional Tick System**\r\n```csharp\r\n// Only update what's necessary based on bot state\r\npublic override void ManualUpdate()\r\n{\r\n    if (!ShallTick(Time.time)) return;\r\n    // ... actual work\r\n}\r\n```\r\n\r\n---\r\n\r\n## Initialization Flow\r\n\r\n### Plugin Initialization\r\n\r\n```\r\nGame Startup\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ BepInEx loads SAIN.dll\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ SAINPlugin.Load() called (if exists)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Initialize configuration\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Apply Harmony patches\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Register with BigBrain\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Set up mod detection\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ Game starts\r\n\r\nRaid Start\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ GameWorld created\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ GameWorldComponent attached (Harmony patch)\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ GameWorldComponent.Init()\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ BotManagerComponent created\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ BotManagerComponent.Init()\r\n    ‚îÇ       ‚îú‚îÄ‚îÄ Initialize job manager\r\n    ‚îÇ       ‚îú‚îÄ‚îÄ Initialize cover manager\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ Subscribe to events\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ Wait for bots to spawn\r\n\r\nBot Spawn (per bot)\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ EFT spawns BotOwner\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ PlayerComponent attached (Harmony patch)\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ PlayerComponent.Init()\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ BotSpawnController.OnBotSpawn()\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Create/Get BotComponent\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ BotComponent.Activate()\r\n    ‚îÇ           (see Component Lifecycle above)\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ Bot ready for SAIN control\r\n```\r\n\r\n### Component Initialization Order\r\n\r\nWithin `BotComponent.InitializeBot()`:\r\n\r\n```\r\n1. CreateClasses() - Construct all 25+ components\r\n   ‚îÇ\r\n   ‚îú‚îÄ‚îÄ Info (must be first - provides bot metadata)\r\n   ‚îú‚îÄ‚îÄ NoBushESP (Unity component)\r\n   ‚îú‚îÄ‚îÄ Squad container\r\n   ‚îú‚îÄ‚îÄ BusyHandsDetector\r\n   ‚îú‚îÄ‚îÄ GlobalEvents\r\n   ‚îú‚îÄ‚îÄ Shoot data\r\n   ‚îú‚îÄ‚îÄ ... all other components\r\n   ‚îî‚îÄ‚îÄ BotActivation (last - controls activation state)\r\n\r\n2. AddToSquad() - Register with squad system\r\n   ‚îÇ\r\n   ‚îî‚îÄ‚îÄ Squad.SquadInfo.AddMember(this)\r\n\r\n3. InitClasses() - Call Init() on each component\r\n   ‚îÇ\r\n   ‚îú‚îÄ‚îÄ NoBushESP.Init()\r\n   ‚îî‚îÄ‚îÄ For each component:\r\n       ‚îî‚îÄ‚îÄ component.Init()\r\n           ‚îú‚îÄ‚îÄ Subscribe to events\r\n           ‚îú‚îÄ‚îÄ Load configuration\r\n           ‚îî‚îÄ‚îÄ Initialize sub-systems\r\n\r\n4. FinishInit() - Final setup\r\n   ‚îÇ\r\n   ‚îú‚îÄ‚îÄ VerifyBrain() - Ensure valid BigBrain brain\r\n   ‚îú‚îÄ‚îÄ Set MaxShootDist to float.MaxValue\r\n   ‚îú‚îÄ‚îÄ Set IsNoOffsetShooting = false\r\n   ‚îî‚îÄ‚îÄ Initialize joke/easter egg features\r\n```\r\n\r\n---\r\n\r\n## Layer System Integration\r\n\r\n### BigBrain Layer Architecture\r\n\r\nSAIN injects custom AI behavior using BigBrain's layer system:\r\n\r\n```\r\nBigBrain BotOwner.Brain\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ Custom Layers (priority-based)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ SAINAvoidThreatLayer (priority: high)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ ExtractLayer\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ CombatSoloLayer\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ CombatSquadLayer\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ RunToCoverLayer\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ Base Game Layers (fallback)\r\n        ‚îî‚îÄ‚îÄ Only used if SAIN layers inactive\r\n```\r\n\r\n### Layer Base Class\r\n\r\n```csharp\r\npublic abstract class SAINLayer : CustomLayer\r\n{\r\n    public BotComponent Bot { get; private set; }\r\n    public ESAINLayer ELayer { get; private set; }\r\n\r\n    protected SAINLayer(BotOwner botOwner, int priority,\r\n                       string layerName, ESAINLayer eSAINLayer)\r\n    {\r\n        // Initialize with priority\r\n        base._002Ector(botOwner, priority);\r\n    }\r\n\r\n    // BigBrain calls this to check if layer should activate\r\n    public abstract override CustomLayerDelgateResult GetLayerResult();\r\n\r\n    // Called each frame when layer is active\r\n    public abstract override void Update();\r\n\r\n    // BigBrain calls this to check if current action should end\r\n    public override bool IsCurrentActionEnding()\r\n    {\r\n        if (_actionReset) // Decision changed\r\n        {\r\n            _actionReset = false;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n### Layer Activation Flow\r\n\r\n```\r\n1. BigBrain Update Cycle\r\n   ‚îÇ\r\n   ‚îú‚îÄ‚îÄ For each layer (priority order):\r\n   ‚îÇ   ‚îî‚îÄ‚îÄ layer.GetLayerResult()\r\n   ‚îÇ       ‚îú‚îÄ‚îÄ Check if conditions met\r\n   ‚îÇ       ‚îî‚îÄ‚îÄ Return action or null\r\n   ‚îÇ\r\n   ‚îú‚îÄ‚îÄ Select highest priority layer with valid action\r\n   ‚îÇ\r\n   ‚îî‚îÄ‚îÄ If layer changed:\r\n       ‚îú‚îÄ‚îÄ Call previous layer.OnLayerDeactivated()\r\n       ‚îî‚îÄ‚îÄ Call new layer.OnLayerActivated()\r\n\r\n2. Layer Update\r\n   ‚îÇ\r\n   ‚îî‚îÄ‚îÄ active_layer.Update()\r\n       ‚îú‚îÄ‚îÄ current_action.Update()\r\n       ‚îÇ   ‚îú‚îÄ‚îÄ Execute bot behavior\r\n       ‚îÇ   ‚îî‚îÄ‚îÄ Check if action complete\r\n       ‚îÇ\r\n       ‚îî‚îÄ‚îÄ If action complete:\r\n           ‚îî‚îÄ‚îÄ GetLayerResult() for new action\r\n```\r\n\r\n### Example: CombatSoloLayer\r\n\r\n```csharp\r\npublic class CombatSoloLayer : SAINLayer\r\n{\r\n    public override CustomLayerDelgateResult GetLayerResult()\r\n    {\r\n        // Check if bot should use solo combat layer\r\n        if (!Bot.BotActive) return null;\r\n        if (Bot.GoalEnemy == null) return null;\r\n\r\n        // Get current decision\r\n        ECombatDecision decision = Bot.Decision.CurrentCombatDecision;\r\n\r\n        // Select action based on decision\r\n        return decision switch\r\n        {\r\n            ECombatDecision.RushEnemy => RushEnemyAction,\r\n            ECombatDecision.StandAndShoot => StandAndShootAction,\r\n            ECombatDecision.SeekCover => SeekCoverAction,\r\n            ECombatDecision.Search => SearchAction,\r\n            ECombatDecision.ThrowGrenade => ThrowGrenadeAction,\r\n            // ... etc\r\n            _ => null\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Event System\r\n\r\n### Event Architecture\r\n\r\nSAIN uses strongly-typed events for component communication:\r\n\r\n```csharp\r\n// Event container class\r\npublic class EnemyEvents\r\n{\r\n    // Toggle events track boolean states with time tracking\r\n    public EnemyToggleEventTimeTracked OnEnemyKnownChanged;\r\n    public EnemyToggleEventTimeTracked OnVisionChange;\r\n    public EnemyToggleEventTimeTracked OnEnemyLineOfSightChanged;\r\n    public EnemyToggleEventTimeTracked OnSearch;\r\n\r\n    // Delegates for subscribers\r\n    public EnemyToggleEventTimeTracked.OnToggle += OnToggle;\r\n}\r\n\r\n// Event implementation\r\npublic class EnemyToggleEventTimeTracked\r\n{\r\n    public delegate void OnToggle(bool value, Enemy enemy);\r\n    public OnToggle OnToggleDelegate;\r\n\r\n    public bool Value { get; private set; }\r\n    public float TimeSinceTrue { get; private set; }\r\n    public float TimeSinceFalse { get; private set; }\r\n\r\n    public void SetValue(bool newValue, float currentTime)\r\n    {\r\n        if (newValue != Value)\r\n        {\r\n            Value = newValue;\r\n            OnToggleDelegate?.Invoke(newValue, enemy);\r\n\r\n            if (newValue)\r\n                TimeSinceTrue = 0;\r\n            else\r\n                TimeSinceFalse = 0;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Event Subscription Pattern\r\n\r\n```csharp\r\n// Component subscribes to enemy events\r\nprivate void EnemyAdded(Enemy enemy)\r\n{\r\n    EnemyEvents events = enemy.Events;\r\n\r\n    // Subscribe to know when enemy becomes known\r\n    KnownEnemies.Subscribe(ref events.OnEnemyKnownChanged.OnToggle);\r\n\r\n    // Subscribe to vision changes\r\n    EnemiesInLineOfSight.Subscribe(ref events.OnVisionChange.OnToggle);\r\n    VisibleEnemies.Subscribe(ref events.OnEnemyLineOfSightChanged.OnToggle);\r\n}\r\n\r\n// Component unsubscribes when enemy removed\r\nprivate void EnemyRemoved(string profileID, Enemy enemy)\r\n{\r\n    EnemyEvents events = enemy.Events;\r\n\r\n    KnownEnemies.Unsubscribe(ref events.OnEnemyKnownChanged.OnToggle, enemy);\r\n    EnemiesInLineOfSight.Unsubscribe(ref events.OnVisionChange.OnToggle, enemy);\r\n    VisibleEnemies.Unsubscribe(ref events.OnEnemyLineOfSightChanged.OnToggle, enemy);\r\n}\r\n```\r\n\r\n### Common Events\r\n\r\n1. **Bot Events**\r\n   - `OnBotActivated` - Bot fully initialized\r\n   - `OnBotStateChange` - Bot state changed (spawned, dead, etc.)\r\n\r\n2. **Enemy Events**\r\n   - `OnEnemyKnownChanged` - Enemy known/forgotten\r\n   - `OnVisionChange` - Visibility changed\r\n   - `OnEnemyLineOfSightChanged` - Line of sight changed\r\n   - `OnSearch` - Search state changed\r\n\r\n3. **Decision Events**\r\n   - `OnDecisionMade` - New decision calculated\r\n   - Passes: combat decision, squad decision, self action, target enemy, bot\r\n\r\n4. **Controller Events**\r\n   - `OnEnemyAdded` - New enemy tracked\r\n   - `OnEnemyRemoved` - Enemy no longer tracked\r\n   - `OnPeaceChanged` - Combat state changed\r\n\r\n---\r\n\r\n## Job System\r\n\r\n### Unity Job System Integration\r\n\r\nSAIN uses Unity's Job System for expensive raycasts:\r\n\r\n```csharp\r\npublic class JobManager\r\n{\r\n    // Schedules job on worker thread\r\n    public JobHandle ScheduleJob<T>(T job) where T : struct, IJob\r\n    {\r\n        return job.Schedule();\r\n    }\r\n\r\n    // Checks if job completed\r\n    public bool IsJobComplete(JobHandle handle)\r\n    {\r\n        return handle.IsCompleted;\r\n    }\r\n\r\n    // Forces job to complete\r\n    public void CompleteJob(JobHandle handle)\r\n    {\r\n        handle.Complete();\r\n    }\r\n}\r\n```\r\n\r\n### Raycast Job Types\r\n\r\n1. **Vision Line of Sight**\r\n```csharp\r\npublic struct RaycastJob : IRaycastJob\r\n{\r\n    public Vector3 Start;\r\n    public Vector3 End;\r\n    public LayerMask Mask;\r\n\r\n    public RaycastHit Result;\r\n    public bool Hit;\r\n\r\n    public void Execute()\r\n    {\r\n        Hit = Physics.Raycast(Start, (End - Start).normalized,\r\n                             out Result, Vector3.Distance(Start, End), Mask);\r\n    }\r\n}\r\n```\r\n\r\n2. **Cover Analysis**\r\n```csharp\r\npublic struct CalcDistanceAndNormalJob : IJob\r\n{\r\n    public Vector3 Point;\r\n    public Vector3 Target;\r\n\r\n    public float Distance;\r\n    public Vector3 Normal;\r\n\r\n    public void Execute()\r\n    {\r\n        Vector3 diff = Target - Point;\r\n        Distance = diff.magnitude;\r\n        Normal = diff / Distance; // normalize\r\n    }\r\n}\r\n```\r\n\r\n3. **Enemy Place Calculation**\r\n```csharp\r\npublic struct CalcEnemyPlaceJob : IJob\r\n{\r\n    public Vector3 EnemyPosition;\r\n    public Vector3 BotPosition;\r\n    // ... other params\r\n\r\n    public void Execute()\r\n    {\r\n        // Calculate enemy position quality\r\n        // Raycasts for cover evaluation\r\n        // Pathfinding distance\r\n    }\r\n}\r\n```\r\n\r\n### Job Lifecycle\r\n\r\n```\r\n1. Create Job Struct\r\n   ‚îú‚îÄ‚îÄ Populate input fields\r\n   ‚îî‚îÄ‚îÄ Allocate output fields (NativeArray)\r\n\r\n2. Schedule Job\r\n   ‚îú‚îÄ‚îÄ JobHandle handle = job.Schedule()\r\n   ‚îî‚îÄ‚îÄ Job queued on worker thread\r\n\r\n3. Continue Main Thread\r\n   ‚îî‚îÄ‚îÄ Bot continues other work\r\n\r\n4. Check Completion (later frame)\r\n   ‚îú‚îÄ‚îÄ if (handle.IsCompleted)\r\n   ‚îî‚îÄ‚îÄ Process results\r\n\r\n5. Dispose Native Collections\r\n   ‚îî‚îÄ‚îÄ NativeArray.Dispose()\r\n```\r\n\r\n---\r\n\r\n## Configuration Architecture\r\n\r\n### Preset System\r\n\r\nConfiguration is hierarchical:\r\n\r\n```\r\nSAINPresetClass (root)\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ GlobalSettings (all bots)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Mind settings\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Hearing settings\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Vision settings\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Steering settings\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Look settings\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Aiming settings\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ General settings\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ BotSettings (per bot type)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Assault\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ PMC\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Scav\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Boss\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ ... etc\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ SAINSettings (per bot)\r\n    ‚îÇ           ‚îú‚îÄ‚îÄ Mind\r\n    ‚îÇ           ‚îú‚îÄ‚îÄ Shoot\r\n    ‚îÇ           ‚îú‚îÄ‚îÄ Aiming\r\n    ‚îÇ           ‚îú‚îÄ‚îÄ Cover\r\n    ‚îÇ           ‚îú‚îÄ‚îÄ Grenade\r\n    ‚îÇ           ‚îî‚îÄ‚îÄ ... etc\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ PersonalitySettings (per personality)\r\n        ‚îú‚îÄ‚îÄ Normal\r\n        ‚îú‚îÄ‚îÄ GigaChad\r\n        ‚îú‚îÄ‚îÄ Rat\r\n        ‚îú‚îÄ‚îÄ Chad\r\n        ‚îú‚îÄ‚îÄ Coward\r\n        ‚îî‚îÄ‚îÄ ... etc\r\n            ‚îú‚îÄ‚îÄ General\r\n            ‚îú‚îÄ‚îÄ Search\r\n            ‚îú‚îÄ‚îÄ Rush\r\n            ‚îú‚îÄ‚îÄ Cover\r\n            ‚îî‚îÄ‚îÄ Talk\r\n```\r\n\r\n### Configuration Loading\r\n\r\n```\r\n1. Plugin Initialization\r\n   ‚îî‚îÄ‚îÄ PresetHandler.Init()\r\n       ‚îú‚îÄ‚îÄ Load default preset\r\n       ‚îú‚îÄ‚îÄ Load custom presets (if any)\r\n       ‚îî‚îÄ‚îÄ Fire OnPresetUpdated event\r\n\r\n2. Components Subscribe\r\n   ‚îî‚îÄ‚îÄ component.Init()\r\n       ‚îî‚îÄ‚îÄ PresetHandler.OnPresetUpdated += UpdatePresetSettings\r\n\r\n3. Runtime Updates\r\n   ‚îú‚îÄ‚îÄ User edits preset in-game (SAINEditor)\r\n   ‚îú‚îÄ‚îÄ PresetHandler.SavePreset()\r\n   ‚îî‚îÄ‚îÄ OnPresetUpdated event fired\r\n       ‚îî‚îÄ‚îÄ All components refresh their cached settings\r\n```\r\n\r\n### Settings Attributes\r\n\r\nConfiguration properties use custom attributes for UI generation:\r\n\r\n```csharp\r\n[Name(\"Vision Speed\")]\r\n[Description(\"How fast bots detect visible enemies\")]\r\n[MinMax(0.1f, 10f)]\r\n[Default(1.0f)]\r\npublic float VisionSpeed = 1.0f;\r\n\r\n[Percentage]\r\n[Default(0.75f)]\r\npublic float CoverMinimumHeight = 0.75f;\r\n\r\n[Advanced]\r\n[Hidden] // Hide from basic UI\r\npublic float DebugValue = 0.0f;\r\n```\r\n\r\nThe editor reads these attributes to build the runtime configuration GUI.\r\n\r\n---\r\n\r\n## Summary\r\n\r\nSAIN's architecture is built on these key principles:\r\n\r\n1. **Modular Component Design** - Easy to extend and maintain\r\n2. **Performance Optimization** - Tick rates, job system, pooling\r\n3. **Event-Driven Updates** - Reduces coupling between systems\r\n4. **Layered AI Control** - BigBrain integration for behavior injection\r\n5. **Hierarchical Configuration** - Global ‚Üí Bot Type ‚Üí Personality\r\n6. **Singleton Coordination** - Centralized management for global state\r\n7. **Lazy Initialization** - Only create what's needed when needed\r\n\r\nThis architecture allows SAIN to provide sophisticated AI behavior while maintaining good performance and mod compatibility with SPT-AKI.\r\n"},"CombatSystems":{"title":"SAIN Combat Systems Documentation\r","category":"SAIN AI Reference","content":"# SAIN Combat Systems Documentation\r\n\r\n## Overview\r\nSAIN's combat system includes shooting mechanics, aiming, grenades, suppression, cover usage, and friendly fire prevention.\r\n\r\n## Core Combat Components\r\n\r\n### SAINShootData - Shooting Mechanics\r\n**Namespace**: `SAIN.SAINComponent.Classes.WeaponFunction`\r\n**Purpose**: Control firing, recoil, and shooting behavior\r\n\r\n**Key Properties:**\r\n```csharp\r\npublic FirearmController FirearmController { get; } // EFT weapon controller\r\npublic bool WeaponReady { get; } // Can shoot now\r\npublic bool WeaponMalfunctioned { get; } // Weapon jammed\r\npublic float TimeSinceShot { get; } // Last shot fired\r\npublic float CurrentRecoil { get; } // Accumulated recoil\r\n\r\n// Rate of fire control\r\npublic float BaseFireRate { get; } // Weapon's base fire rate\r\npublic float ModifiedFireRate { get; } // With SAIN modifications\r\npublic bool BurstFiring { get; } // Currently in burst\r\npublic int BurstLength { get; } // Rounds per burst\r\n```\r\n\r\n**Shooting Algorithm:**\r\n```csharp\r\npublic void Shoot(Vector3 target, bool shouldAim)\r\n{\r\n    if (!CanShoot()) return;\r\n\r\n    // Aim down sights if needed\r\n    if (shouldAim && !IsAiming)\r\n    {\r\n        StartAiming();\r\n    }\r\n\r\n    // Calculate shot\r\n    Vector3 aimPoint = CalculateAimPoint(target);\r\n\r\n    // Apply scatter based on conditions\r\n    aimPoint += CalculateScatter();\r\n\r\n    // Fire weapon\r\n    FirearmController.Shoot(aimPoint);\r\n\r\n    // Track recoil\r\n    CurrentRecoil += WeaponRecoil;\r\n\r\n    // Update timing\r\n    TimeSinceShot = 0f;\r\n    NextShotTime = Time.time + FireDelay;\r\n}\r\n\r\nprivate bool CanShoot()\r\n{\r\n    if (!WeaponReady) return false;\r\n    if (WeaponMalfunctioned) return false;\r\n    if (CurrentRecoil > MaxRecoil) return false;\r\n    if (Time.time < NextShotTime) return false;\r\n    if (!HasAmmo) return false;\r\n    if (Bot.FriendlyFire.FriendInLineOfFire) return false;\r\n\r\n    return true;\r\n}\r\n```\r\n\r\n**Recoil Management:**\r\n```csharp\r\npublic void UpdateRecoil()\r\n{\r\n    // Recoil decay when not firing\r\n    if (TimeSinceShot > RecoilDecayDelay)\r\n    {\r\n        float decayRate = PersonalitySettings.RECOIL_DECAY_RATE;\r\n        CurrentRecoil = Mathf.Max(0f, CurrentRecoil - decayRate * Time.deltaTime);\r\n    }\r\n\r\n    // Stop shooting if recoil too high\r\n    if (CurrentRecoil > MaxRecoil)\r\n    {\r\n        StopShooting();\r\n        WaitForRecoilReset();\r\n    }\r\n}\r\n```\r\n\r\n**Burst Fire Control:**\r\n```csharp\r\npublic void StartBurst()\r\n{\r\n    BurstFiring = true;\r\n    BurstRoundsLeft = CalculateBurstLength();\r\n}\r\n\r\nprivate int CalculateBurstLength()\r\n{\r\n    PersonalitySettings personality = Bot.Info.PersonalitySettings;\r\n\r\n    // Base burst size\r\n    int baseBurst = personality.BASE_BURST_LENGTH;\r\n\r\n    // Modify by distance\r\n    float distance = Bot.GoalEnemy.RealDistance;\r\n    if (distance > 50f)\r\n    {\r\n        baseBurst = Mathf.RoundToInt(baseBurst * 0.5f); // Shorter bursts at range\r\n    }\r\n\r\n    // Modify by weapon class\r\n    switch (Bot.Info.WeaponClass)\r\n    {\r\n        case EWeaponClass.SMG:\r\n            baseBurst *= 2; // Longer SMG bursts\r\n            break;\r\n        case EWeaponClass.AssaultRifle:\r\n            // Default\r\n            break;\r\n        case EWeaponClass.DMR:\r\n        case EWeaponClass.Sniper:\r\n            return 1; // Single shots\r\n    }\r\n\r\n    return Mathf.Clamp(baseBurst, 1, 15);\r\n}\r\n```\r\n\r\n---\r\n\r\n### AimClass - Aiming Calculations\r\n**Namespace**: `SAIN.SAINComponent.Classes.WeaponFunction`\r\n**Purpose**: Calculate aim points and scatter\r\n\r\n**Aim Point Selection:**\r\n```csharp\r\npublic Vector3 GetAimPoint(Enemy enemy)\r\n{\r\n    Vector3 baseAimPoint;\r\n\r\n    // Prioritize visible enemy\r\n    if (enemy.IsVisible)\r\n    {\r\n        baseAimPoint = SelectBodyPart(enemy);\r\n    }\r\n    // Or last known position\r\n    else if (enemy.LastKnownPosition.HasValue)\r\n    {\r\n        baseAimPoint = enemy.LastKnownPosition.Value + Vector3.up * 1.5f; // Head height\r\n    }\r\n    else\r\n    {\r\n        return Vector3.zero;\r\n    }\r\n\r\n    // Apply prediction for moving targets\r\n    if (enemy.IsVisible && IsMoving(enemy))\r\n    {\r\n        baseAimPoint = PredictMovement(enemy, baseAimPoint);\r\n    }\r\n\r\n    // Apply scatter\r\n    baseAimPoint += CalculateScatter(enemy);\r\n\r\n    return baseAimPoint;\r\n}\r\n\r\nprivate Vector3 SelectBodyPart(Enemy enemy)\r\n{\r\n    float distance = enemy.RealDistance;\r\n    PersonalitySettings personality = Bot.Info.PersonalitySettings;\r\n\r\n    // Close range - center mass\r\n    if (distance < 25f)\r\n    {\r\n        return enemy.CenterMass;\r\n    }\r\n\r\n    // Medium range - torso\r\n    if (distance < 75f)\r\n    {\r\n        return enemy.EnemyPlayer.MainParts[BodyPartType.Chest].Position;\r\n    }\r\n\r\n    // Long range - center of visible area\r\n    return enemy.CenterMass;\r\n}\r\n```\r\n\r\n**Scatter Calculation:**\r\n```csharp\r\nprivate Vector3 CalculateScatter(Enemy enemy)\r\n{\r\n    float scatterAmount = 0f;\r\n\r\n    PersonalitySettings personality = Bot.Info.PersonalitySettings;\r\n    BotDifficulty difficulty = Bot.Info.Profile.Difficulty;\r\n\r\n    // Base scatter by difficulty\r\n    scatterAmount = difficulty switch\r\n    {\r\n        BotDifficulty.Easy => 0.5f,\r\n        BotDifficulty.Normal => 0.3f,\r\n        BotDifficulty.Hard => 0.15f,\r\n        BotDifficulty.Impossible => 0.05f,\r\n        _ => 0.3f\r\n    };\r\n\r\n    // Modify by distance\r\n    float distance = enemy.RealDistance;\r\n    scatterAmount *= Mathf.Clamp(distance / 100f, 0.5f, 3f);\r\n\r\n    // Increase scatter if suppressed\r\n    if (Bot.Suppression.IsSuppressed)\r\n    {\r\n        scatterAmount *= 1.5f + Bot.Suppression.SuppressionLevel;\r\n    }\r\n\r\n    // Increase scatter if moving\r\n    if (Bot.Mover.IsMoving)\r\n    {\r\n        scatterAmount *= personality.SCATTER_MULT_MOVING;\r\n    }\r\n\r\n    // Increase scatter if not aimed\r\n    if (!Bot.Shoot.IsAiming)\r\n    {\r\n        scatterAmount *= personality.SCATTER_MULT_NOT_AIMED;\r\n    }\r\n\r\n    // Reduce scatter if in cover and stationary\r\n    if (Bot.Cover.CoverInUse != null && !Bot.Mover.IsMoving)\r\n    {\r\n        scatterAmount *= 0.5f;\r\n    }\r\n\r\n    // Generate random scatter within cone\r\n    Vector3 scatter = Random.insideUnitSphere * scatterAmount;\r\n    scatter.z = 0f; // Only horizontal/vertical scatter\r\n\r\n    return scatter;\r\n}\r\n```\r\n\r\n---\r\n\r\n### BotGrenadeManager - Grenade System\r\n**Namespace**: `SAIN.SAINComponent.Classes.WeaponFunction`\r\n**Purpose**: Grenade throwing logic\r\n\r\n**Throw Decision:**\r\n```csharp\r\npublic bool ShouldThrowGrenade(Enemy enemy)\r\n{\r\n    if (!HasGrenades) return false;\r\n    if (TimeSinceLastThrow < CooldownTime) return false;\r\n\r\n    PersonalitySettings personality = Bot.Info.PersonalitySettings;\r\n    if (!personality.GRENADE_ENABLED) return false;\r\n\r\n    // Check conditions\r\n    bool enemyStationary = enemy.Path.PathDistance < 3f;\r\n    bool inCover = enemy.Status.EnemyInCover;\r\n    bool goodDistance = enemy.RealDistance > 15f && enemy.RealDistance < 40f;\r\n    bool hasSquad = Bot.Squad.BotInGroup;\r\n\r\n    // Higher chance if enemy in cover\r\n    if (inCover && goodDistance && enemyStationary)\r\n    {\r\n        return Random.value < personality.GRENADE_CHANCE_COVER;\r\n    }\r\n\r\n    // Or if multiple enemies\r\n    if (Bot.EnemyController.VisibleEnemies.Count > 1 && goodDistance)\r\n    {\r\n        return Random.value < personality.GRENADE_CHANCE_MULTIPLE;\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n**Throw Calculation:**\r\n```csharp\r\npublic GrenadeThrow CalculateThrow(Enemy enemy)\r\n{\r\n    Vector3 targetPos = PredictEnemyPosition(enemy, FlightTime);\r\n\r\n    // Check if can throw over obstacles\r\n    Vector3 throwOrigin = Bot.Transform.EyePosition;\r\n    bool directPath = CheckDirectPath(throwOrigin, targetPos);\r\n\r\n    GrenadeThrowType throwType;\r\n    if (directPath)\r\n    {\r\n        throwType = GrenadeThrowType.Direct;\r\n    }\r\n    else\r\n    {\r\n        // Try high arc\r\n        if (CanThrowHighArc(throwOrigin, targetPos))\r\n        {\r\n            throwType = GrenadeThrowType.HighArc;\r\n        }\r\n        else\r\n        {\r\n            return null; // Cannot throw\r\n        }\r\n    }\r\n\r\n    // Calculate throw direction and power\r\n    GrenadeThrowDirection direction = CalculateThrowDirection(throwOrigin, targetPos, throwType);\r\n    float throwPower = CalculateThrowPower(Vector3.Distance(throwOrigin, targetPos));\r\n\r\n    return new GrenadeThrow(targetPos, direction, throwPower, throwType);\r\n}\r\n```\r\n\r\n---\r\n\r\n### SAINFriendlyFireClass - FF Prevention\r\n**Namespace**: `SAIN.SAINComponent.Classes.WeaponFunction`\r\n**Purpose**: Prevent shooting team members\r\n\r\n**Check System:**\r\n```csharp\r\npublic bool FriendInLineOfFire { get; private set; }\r\n\r\npublic void CheckFriendlyFire()\r\n{\r\n    if (Bot.GoalEnemy == null)\r\n    {\r\n        FriendInLineOfFire = false;\r\n        return;\r\n    }\r\n\r\n    Vector3 shootDirection = (Bot.GoalEnemy.EnemyPosition - Bot.Transform.EyePosition).normalized;\r\n    Vector3 shootOrigin = Bot.Transform.EyePosition;\r\n\r\n    // Check each squad member\r\n    foreach (BotComponent squadMember in Bot.Squad.SquadInfo.Members)\r\n    {\r\n        if (squadMember == Bot) continue;\r\n\r\n        // Check if in line of fire\r\n        if (IsInLineOfFire(shootOrigin, shootDirection, squadMember))\r\n        {\r\n            FriendInLineOfFire = true;\r\n            return;\r\n        }\r\n    }\r\n\r\n    FriendInLineOfFire = false;\r\n}\r\n\r\nprivate bool IsInLineOfFire(Vector3 origin, Vector3 direction, BotComponent friend)\r\n{\r\n    Vector3 toFriend = friend.Position - origin;\r\n\r\n    // Angle check\r\n    float angle = Vector3.Angle(direction, toFriend);\r\n    if (angle > FFAngleThreshold) return false; // Not in cone\r\n\r\n    // Distance check - closer friends = larger safety margin\r\n    float friendDistance = toFriend.magnitude;\r\n    float safetyMargin = Mathf.Lerp(2f, 0.5f, friendDistance / 50f);\r\n\r\n    // Point-to-line distance\r\n    float distanceToLine = Vector3.Cross(direction, toFriend).magnitude;\r\n\r\n    return distanceToLine < safetyMargin;\r\n}\r\n```\r\n\r\n---\r\n\r\n### SAINBotSuppressClass - Suppression System\r\n**Namespace**: `SAIN.SAINComponent.Classes`\r\n**Purpose**: Track and apply suppression effects\r\n\r\n**Suppression State:**\r\n```csharp\r\npublic bool IsSuppressed => SuppressionLevel > SuppressionThreshold;\r\npublic float SuppressionLevel { get; private set; } // 0-1 scale\r\npublic float TimeSinceSuppressed { get; private set; }\r\n\r\npublic void AddSuppression(float amount, Vector3 source)\r\n{\r\n    SuppressionLevel = Mathf.Clamp01(SuppressionLevel + amount);\r\n\r\n    if (IsSuppressed)\r\n    {\r\n        TimeSinceSuppressed = 0f;\r\n\r\n        // React to suppression\r\n        OnSuppressed(source);\r\n    }\r\n}\r\n\r\npublic void UpdateSuppression()\r\n{\r\n    // Decay over time\r\n    if (SuppressionLevel > 0f)\r\n    {\r\n        float decayRate = PersonalitySettings.SUPPRESSION_DECAY_RATE;\r\n\r\n        // Faster decay in cover\r\n        if (Bot.Cover.CoverInUse != null)\r\n        {\r\n            decayRate *= 2f;\r\n        }\r\n\r\n        SuppressionLevel = Mathf.Max(0f, SuppressionLevel - decayRate * Time.deltaTime);\r\n    }\r\n\r\n    TimeSinceSuppressed += Time.deltaTime;\r\n}\r\n```\r\n\r\n**Suppression Effects:**\r\n```csharp\r\nprivate void OnSuppressed(Vector3 source)\r\n{\r\n    // Modify aim scatter\r\n    Bot.Aim.ScatterMultiplier *= 2f;\r\n\r\n    // Reduce peek frequency\r\n    Bot.Cover.PeekDelay *= 1.5f;\r\n\r\n    // May force seek cover\r\n    if (SuppressionLevel > 0.7f && Bot.Cover.CoverInUse == null)\r\n    {\r\n        Bot.Decision.ForceDecision(ECombatDecision.SeekCover);\r\n    }\r\n\r\n    // Voice line\r\n    Bot.Talk.TalkAfterDelay(EPhraseTrigger.OnBeingHurt, ETagStatus.Combat, 0.5f);\r\n}\r\n```\r\n\r\n---\r\n\r\n## Cover System Integration\r\n\r\n### SAINCoverClass - Cover Usage\r\n**Namespace**: `SAIN.SAINComponent.Classes`\r\n**Purpose**: Find and use cover\r\n\r\n**Cover Point Selection:**\r\n```csharp\r\npublic CoverPoint FindCover(Enemy enemy)\r\n{\r\n    Vector3 enemyPos = enemy.EnemyPosition;\r\n    Vector3 botPos = Bot.Position;\r\n\r\n    // Search parameters\r\n    CoverSearchParams searchParams = new CoverSearchParams\r\n    {\r\n        SearchOrigin = botPos,\r\n        ThreatOrigin = enemyPos,\r\n        SearchRadius = 30f,\r\n        MinCoverValue = 0.5f\r\n    };\r\n\r\n    // Get cover points from manager\r\n    List<CoverPoint> candidates = CoverManager.FindCoverPoints(searchParams);\r\n\r\n    // Score each point\r\n    CoverPoint bestCover = null;\r\n    float bestScore = float.MinValue;\r\n\r\n    foreach (CoverPoint point in candidates)\r\n    {\r\n        float score = ScoreCoverPoint(point, enemy);\r\n        if (score > bestScore)\r\n        {\r\n            bestScore = score;\r\n            bestCover = point;\r\n        }\r\n    }\r\n\r\n    return bestCover;\r\n}\r\n\r\nprivate float ScoreCoverPoint(CoverPoint point, Enemy enemy)\r\n{\r\n    float score = 0f;\r\n\r\n    // Factor 1: Protection from enemy (most important)\r\n    score += point.Spotted.CoverValue * 100f;\r\n\r\n    // Factor 2: Distance to bot (prefer closer)\r\n    float distToBot = Vector3.Distance(point.Position, Bot.Position);\r\n    score += Mathf.Clamp(50f - distToBot, 0f, 50f);\r\n\r\n    // Factor 3: Path distance (prefer accessible)\r\n    float pathDist = point.PathData.PathDistance;\r\n    if (pathDist > 100f) score -= 50f; // Too far\r\n\r\n    // Factor 4: Position relative to enemy\r\n    Vector3 toEnemy = enemy.EnemyPosition - point.Position;\r\n    float angleToEnemy = Vector3.Angle(point.Normal, toEnemy);\r\n    if (angleToEnemy > 90f) score += 20f; // Cover facing away from enemy\r\n\r\n    // Factor 5: Tactical position\r\n    if (point.Position.y > Bot.Position.y)\r\n        score += 10f; // Height advantage\r\n\r\n    return score;\r\n}\r\n```\r\n\r\n**Cover Actions:**\r\n```csharp\r\npublic void EnterCover(CoverPoint cover)\r\n{\r\n    CoverInUse = cover;\r\n    cover.Reserved = true;\r\n    cover.ReservedBy = Bot.ProfileId;\r\n\r\n    // Adjust stance\r\n    if (cover.CoverHeight < 1.5f)\r\n    {\r\n        Bot.Mover.SetPose(PoseLevel.Crouch);\r\n    }\r\n\r\n    // Face cover direction\r\n    Bot.Steering.LookToDirection(cover.Normal);\r\n}\r\n\r\npublic void PeekFromCover()\r\n{\r\n    if (CoverInUse == null) return;\r\n\r\n    // Lean if possible\r\n    if (CanLean())\r\n    {\r\n        Bot.Mover.Lean(LeanDirection.Right); // Or Left based on cover\r\n    }\r\n    else\r\n    {\r\n        // Stand to peek over low cover\r\n        Bot.Mover.SetPose(PoseLevel.Stand);\r\n    }\r\n\r\n    // Look at enemy\r\n    if (Bot.GoalEnemy != null)\r\n    {\r\n        Bot.Steering.LookToPoint(Bot.GoalEnemy.EnemyPosition);\r\n    }\r\n\r\n    InPeekState = true;\r\n}\r\n\r\npublic void DuckToCover()\r\n{\r\n    if (InPeekState)\r\n    {\r\n        Bot.Mover.SetPose(PoseLevel.Crouch);\r\n        Bot.Mover.StopLeaning();\r\n        InPeekState = false;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Combat Behavior Patterns\r\n\r\n### Engagement Distances\r\n```csharp\r\npublic enum EngagementRange\r\n{\r\n    Melee,      // 0-5m\r\n    Close,      // 5-25m\r\n    Medium,     // 25-75m\r\n    Long,       // 75-150m\r\n    VeryLong    // 150m+\r\n}\r\n\r\npublic EngagementRange GetEngagementRange(Enemy enemy)\r\n{\r\n    float distance = enemy.RealDistance;\r\n\r\n    if (distance < 5f) return EngagementRange.Melee;\r\n    if (distance < 25f) return EngagementRange.Close;\r\n    if (distance < 75f) return EngagementRange.Medium;\r\n    if (distance < 150f) return EngagementRange.Long;\r\n    return EngagementRange.VeryLong;\r\n}\r\n```\r\n\r\n### Tactics by Range\r\n```csharp\r\nprivate void ExecuteRangeTactics(Enemy enemy)\r\n{\r\n    EngagementRange range = GetEngagementRange(enemy);\r\n\r\n    switch (range)\r\n    {\r\n        case EngagementRange.Melee:\r\n            // Aggressive, no cover, full auto\r\n            Bot.Mover.SprintToward(enemy.EnemyPosition);\r\n            Bot.Shoot.SetFireMode(FireMode.FullAuto);\r\n            break;\r\n\r\n        case EngagementRange.Close:\r\n            // Mobile, use cover, burst fire\r\n            if (NeedsCover(enemy))\r\n                Bot.Cover.FindAndMoveToCover(enemy);\r\n            Bot.Shoot.SetFireMode(FireMode.Burst);\r\n            break;\r\n\r\n        case EngagementRange.Medium:\r\n            // Cover-based, controlled bursts\r\n            UseOptimalCover(enemy);\r\n            Bot.Shoot.SetFireMode(FireMode.Burst);\r\n            Bot.Mover.SetPose(PoseLevel.Crouch);\r\n            break;\r\n\r\n        case EngagementRange.Long:\r\n            // Static, single shots, prone if possible\r\n            UseOptimalCover(enemy);\r\n            Bot.Shoot.SetFireMode(FireMode.Single);\r\n            Bot.Mover.SetPose(PoseLevel.Prone);\r\n            break;\r\n\r\n        case EngagementRange.VeryLong:\r\n            // Move closer or disengage\r\n            if (Bot.Info.WeaponClass == EWeaponClass.Sniper)\r\n            {\r\n                // Sniper - engage\r\n                Bot.Shoot.SetFireMode(FireMode.Single);\r\n            }\r\n            else\r\n            {\r\n                // Move to medium range\r\n                Bot.Decision.ForceDecision(ECombatDecision.MoveToEngage);\r\n            }\r\n            break;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\nSAIN combat systems provide:\r\n1. **Realistic Shooting** - Recoil, burst control, scatter based on conditions\r\n2. **Smart Aiming** - Body part selection, movement prediction, scatter calculation\r\n3. **Tactical Grenades** - Situation-aware grenade throws with trajectory calculation\r\n4. **FF Prevention** - Checks allies before shooting\r\n5. **Suppression** - Tracks and reacts to incoming fire\r\n6. **Cover Usage** - Finds, scores, and uses cover effectively\r\n7. **Range Tactics** - Adjusts behavior based on engagement distance\r\n\r\nAll systems integrate with personality settings to create varied, believable combat behavior.\r\n"},"CoreComponents":{"title":"SAIN AI System - Core Components Documentation\r","category":"SAIN AI Reference","content":"# SAIN AI System - Core Components Documentation\r\n\r\nThis document details the main components and their responsibilities in the SAIN AI system.\r\n\r\n## Table of Contents\r\n1. [Global Managers](#global-managers)\r\n2. [BotComponent - Master Controller](#botcomponent---master-controller)\r\n3. [Enemy Management](#enemy-management)\r\n4. [Information Systems](#information-systems)\r\n5. [Squad System](#squad-system)\r\n6. [Activation and Limiting](#activation-and-limiting)\r\n7. [Component Interaction Patterns](#component-interaction-patterns)\r\n\r\n---\r\n\r\n## Global Managers\r\n\r\n### GameWorldComponent\r\n**Namespace**: `SAIN.Components`\r\n**Type**: Singleton MonoBehaviour\r\n**Purpose**: Game world state manager\r\n\r\n**Key Responsibilities:**\r\n- Track all players in raid\r\n- Manage global game state\r\n- Coordinate world-level events\r\n- Interface with EFT GameWorld\r\n\r\n**Properties:**\r\n```csharp\r\npublic static GameWorldComponent Instance { get; }\r\npublic GameWorld GameWorld { get; }\r\npublic Dictionary<string, PlayerComponent> AllPlayers { get; }\r\n```\r\n\r\n---\r\n\r\n### BotManagerComponent\r\n**Namespace**: `SAIN.Components`\r\n**Type**: Singleton MonoBehaviour\r\n**Purpose**: Central bot coordination\r\n\r\n**Key Responsibilities:**\r\n- Manage all SAIN-enabled bots\r\n- Process raycast job queue\r\n- Update global cover manager\r\n- Coordinate bot updates\r\n- Handle bot lifecycle\r\n\r\n**Properties:**\r\n```csharp\r\npublic static BotManagerComponent Instance { get; }\r\npublic Dictionary<string, BotComponent> Bots { get; }\r\npublic JobManager JobManager { get; }\r\npublic CoverManagerClass CoverManager { get; }\r\n```\r\n\r\n**Update Flow:**\r\n```csharp\r\nvoid Update()\r\n{\r\n    // Update all bots\r\n    foreach (var bot in Bots.Values)\r\n    {\r\n        if (bot.BotOwner.BotState == EBotState.Active)\r\n        {\r\n            bot.ManualUpdate(Time.time, Time.deltaTime);\r\n        }\r\n    }\r\n\r\n    // Process async jobs\r\n    JobManager.UpdateJobs();\r\n\r\n    // Update cover system\r\n    CoverManager.Update();\r\n}\r\n```\r\n\r\n---\r\n\r\n### BotSpawnController\r\n**Namespace**: `SAIN.Components`\r\n**Type**: Singleton\r\n**Purpose**: Bot spawn detection and SAIN attachment\r\n\r\n**Key Responsibilities:**\r\n- Detect when bots spawn\r\n- Create/attach BotComponent\r\n- Create/attach PlayerComponent\r\n- Initialize SAIN systems\r\n\r\n**Methods:**\r\n```csharp\r\npublic BotComponent GetOrCreateSAIN(BotOwner botOwner)\r\n{\r\n    // Check if already has SAIN\r\n    if (botOwner.GetComponent<BotComponent>() == null)\r\n    {\r\n        // Create PlayerComponent first\r\n        PlayerComponent playerComp = GetOrCreatePlayerComponent(botOwner);\r\n\r\n        // Create BotComponent\r\n        BotComponent sain = botOwner.gameObject.AddComponent<BotComponent>();\r\n\r\n        // Activate bot\r\n        sain.ActivateIfBotActive(botOwner);\r\n\r\n        return sain;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### CoverManagerClass\r\n**Namespace**: `SAIN.Components`\r\n**Type**: Singleton\r\n**Purpose**: Global cover point pooling\r\n\r\n**Key Responsibilities:**\r\n- Pool cover points globally\r\n- Prevent duplicate cover searches\r\n- Manage cover point lifecycle\r\n- Track cover point usage\r\n\r\n**Data Structures:**\r\n```csharp\r\n// Cover points by position\r\nDictionary<Vector3, CoverPoint> CoverPoints;\r\n\r\n// Active searches to prevent duplicates\r\nDictionary<string, CoverSearchRequest> ActiveSearches;\r\n```\r\n\r\n---\r\n\r\n## BotComponent - Master Controller\r\n\r\n**Namespace**: `SAIN.Components`\r\n**Type**: MonoBehaviour (per bot)\r\n**Inherits**: BotComponentBase, ISPlayer\r\n\r\n### Overview\r\n\r\nBotComponent is the master controller for each SAIN bot, aggregating 25+ specialized subsystems.\r\n\r\n### Component Creation\r\n\r\n```csharp\r\nprivate bool CreateClasses()\r\n{\r\n    // Core Information\r\n    Info = new SAINBotInfoClass(this);\r\n    Squad = new BotSquadContainer(this);\r\n    BotActivation = new SAINActivationClass(this);\r\n    AILimit = new SAINAILimit(this);\r\n\r\n    // Enemy Management\r\n    EnemyController = new SAINEnemyController(this);\r\n    Memory = new SAINMemoryClass(this);\r\n\r\n    // Decision Systems\r\n    Decision = new SAINDecisionClass(this);\r\n    SelfActions = new SAINSelfActionClass(this);\r\n\r\n    // Sensory Systems\r\n    Vision = new SAINVisionClass(this);\r\n    Hearing = new SAINHearingSensorClass(this);\r\n    NoBushESP = gameObject.AddComponent<SAINNoBushESP>();\r\n\r\n    // Combat Systems\r\n    Shoot = new SAINShootData(this);\r\n    Grenade = new BotGrenadeManager(this);\r\n    Aim = new AimClass(this);\r\n    ManualShoot = new ManualShootClass(this);\r\n    FriendlyFire = new SAINFriendlyFireClass(this);\r\n    Suppression = new SAINBotSuppressClass(this);\r\n\r\n    // Movement Systems\r\n    Mover = new SAINMoverClass(this);\r\n    Steering = new SAINSteeringClass(this);\r\n    Cover = new SAINCoverClass(this);\r\n    Vault = new SAINVaultClass(this);\r\n    BotStuck = new SAINBotUnstuckClass(this);\r\n\r\n    // Support Systems\r\n    Search = new SAINSearchClass(this);\r\n    Talk = new SAINBotTalkClass(this);\r\n    Medical = new SAINBotMedicalClass(this);\r\n    SpaceAwareness = new SAINBotSpaceAwareness(this);\r\n    DoorOpener = new DoorOpener(this);\r\n    BotLight = new BotLightController(this);\r\n    BackpackDropper = new BotBackpackDropClass(this);\r\n    CurrentTarget = new CurrentTargetClass(this);\r\n    WeightManagement = new BotWeightManagement(this);\r\n    BusyHandsDetector = new BotBusyHandsDetector(this);\r\n    GlobalEvents = new BotGlobalEventsClass(this);\r\n    AimDownSightsController = new AimDownSightsController(this);\r\n\r\n    return true;\r\n}\r\n```\r\n\r\n### Key Properties\r\n\r\n```csharp\r\n// References\r\npublic BotOwner BotOwner { get; }\r\npublic Player Player { get; }\r\npublic PlayerComponent PlayerComponent { get; }\r\n\r\n// State\r\npublic bool BotActive => BotActivation.BotActive;\r\npublic bool IsInCombat => BotActivation.BotInCombat;\r\npublic bool SAINLayersActive => BotActivation.SAINLayersActive;\r\npublic ESAINLayer ActiveLayer { get; set; }\r\n\r\n// Current Enemy\r\npublic bool HasEnemy => Enemy.IsEnemyActive(EnemyController.GoalEnemy);\r\npublic Enemy GoalEnemy { get; }\r\n\r\n// Decision State\r\npublic IBotAction CurrentAction => BotActivation.CurrentAction;\r\npublic AILimitSetting CurrentAILimit => AILimit.CurrentAILimit;\r\n```\r\n\r\n### Update Tick Lists\r\n\r\nComponents are organized by tick requirement:\r\n\r\n```csharp\r\n// Always update (every frame)\r\nprivate readonly List<IBotClass> _alwaysTickClasses;\r\n// Contains: BotActivation, Info, GlobalEvents, AILimit\r\n\r\n// Bot active only\r\nprivate readonly List<IBotClass> _tickWhenActiveClasses;\r\n// Contains: Decision, EnemyController, Vision, Hearing, Memory\r\n\r\n// Not in standby\r\nprivate readonly List<IBotClass> _tickWhenNoSleepClasses;\r\n// Contains: Mover, Steering, Cover, Search, Vault, BotStuck, Talk\r\n\r\n// Combat only\r\nprivate readonly List<IBotClass> _tickWhenCombatClasses;\r\n// Contains: Shoot, Grenade, Suppression, Aim, FriendlyFire, ManualShoot\r\n```\r\n\r\n---\r\n\r\n## Enemy Management\r\n\r\n### SAINEnemyController\r\n**Namespace**: `SAIN.SAINComponent.Classes.EnemyClasses`\r\n**Purpose**: Track and manage all enemies for a bot\r\n\r\n**Key Collections:**\r\n```csharp\r\n// All enemies by profile ID\r\npublic Dictionary<string, Enemy> Enemies { get; }\r\n\r\n// Active enemy lists\r\npublic EnemyList KnownEnemies { get; }      // Enemies bot knows about\r\npublic EnemyList VisibleEnemies { get; }    // Currently visible\r\npublic EnemyList EnemiesInLineOfSight { get; }  // Has clear LoS\r\n\r\n// Current target\r\npublic Enemy GoalEnemy { get; private set; }\r\npublic Enemy LastGoalEnemy { get; private set; }\r\n```\r\n\r\n**Enemy Selection Algorithm:**\r\n```csharp\r\npublic Enemy ChooseEnemy()\r\n{\r\n    if (KnownEnemies.Count == 0)\r\n        return null;\r\n\r\n    // Priority 1: DogFight decision (close combat)\r\n    if (DogFightDecision.CheckShallDogFight(KnownEnemies, out var result))\r\n        return result;\r\n\r\n    // Priority 2: Visible enemies\r\n    if (VisibleEnemies.Count > 0)\r\n        return SelectVisibleEnemy();\r\n\r\n    // Priority 3: Enemy who recently shot bot\r\n    if (Medical.TimeSinceShot < 2f)\r\n    {\r\n        Enemy shooter = Medical.HitByEnemy.EnemyWhoLastShotMe;\r\n        if (shooter != null && shooter.LastKnownPosition.HasValue)\r\n            return shooter;\r\n    }\r\n\r\n    // Priority 4: Recently seen enemies (with shooter priority)\r\n    List<Enemy> seenEnemies = KnownEnemies.Filter(x => x.Seen);\r\n    if (seenEnemies.Count > 0)\r\n    {\r\n        // Prefer shooters who shot at/hit bot\r\n        foreach (Enemy enemy in seenEnemies)\r\n        {\r\n            if (enemy.IsShooter() &&\r\n                (enemy.Status.ShotAtMe || enemy.Status.ShotMe))\r\n                return enemy;\r\n        }\r\n        return seenEnemies.OrderBy(x => x.TimeSinceSeen).First();\r\n    }\r\n\r\n    // Priority 5: Closest last known position\r\n    return KnownEnemies.OrderBy(x => x.KnownPlaces.BotDistanceFromLastKnown).First();\r\n}\r\n```\r\n\r\n**Enemy Lifecycle:**\r\n```csharp\r\n// Add enemy\r\npublic Enemy CheckAddEnemy(IPlayer iPlayer)\r\n{\r\n    // Validate player\r\n    if (IsPlayerFriendly(iPlayer)) return null;\r\n    if (iPlayer.ProfileId == Bot.ProfileId) return null;\r\n\r\n    // Get or create enemy\r\n    if (!Enemies.TryGetValue(iPlayer.ProfileId, out Enemy enemy))\r\n    {\r\n        PlayerComponent enemyComp = GetPlayerComponent(iPlayer);\r\n        EnemyInfo enemyInfo = CreateEnemyInfo(iPlayer);\r\n\r\n        enemy = new Enemy(Bot, enemyComp, enemyInfo);\r\n        enemy.Init();\r\n\r\n        Enemies.Add(iPlayer.ProfileId, enemy);\r\n        Events.OnEnemyAdded?.Invoke(enemy);\r\n    }\r\n\r\n    return enemy;\r\n}\r\n\r\n// Remove enemy\r\npublic void RemoveEnemy(string profileID)\r\n{\r\n    if (Enemies.TryGetValue(profileID, out Enemy enemy))\r\n    {\r\n        Events.OnEnemyRemoved?.Invoke(profileID, enemy);\r\n        enemy.Dispose();\r\n        Enemies.Remove(profileID);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Enemy Class\r\n**Namespace**: `SAIN.SAINComponent.Classes.EnemyClasses`\r\n**Purpose**: Represents one enemy from the bot's perspective\r\n\r\n**Structure:**\r\n```csharp\r\npublic class Enemy : BotBase, ISPlayer\r\n{\r\n    // Identity\r\n    public string EnemyProfileId { get; }\r\n    public string EnemyName { get; }\r\n    public Player EnemyPlayer { get; }\r\n    public PlayerComponent EnemyPlayerComponent { get; }\r\n    public PlayerTransformClass EnemyTransform { get; }\r\n\r\n    // Subsystems\r\n    public EnemyEvents Events { get; }\r\n    public EnemyVisionClass Vision { get; }\r\n    public EnemyHearing Hearing { get; }\r\n    public EnemyKnownPlaces KnownPlaces { get; }\r\n    public SAINEnemyStatus Status { get; }\r\n    public SAINEnemyPath Path { get; }\r\n    public EnemyAim Aim { get; }\r\n    public EnemyInfo EnemyInfo { get; }\r\n\r\n    // State Properties\r\n    public bool IsVisible => Vision.IsVisible;\r\n    public bool InLineOfSight => Vision.InLineOfSight;\r\n    public bool CanShoot => Vision.CanShoot;\r\n    public bool Seen => Vision.Seen;\r\n    public bool Heard => Hearing.Heard;\r\n    public bool EnemyKnown => Events.OnEnemyKnownChanged.Value;\r\n    public bool IsCurrentEnemy => Bot.EnemyController.GoalEnemy == this;\r\n\r\n    // Timing\r\n    public float TimeSinceSeen => Vision.TimeSinceSeen;\r\n    public float TimeSinceHeard => Hearing.TimeSinceHeard;\r\n    public float TimeSinceLastKnownUpdated => KnownPlaces.TimeSinceLastKnownUpdated;\r\n\r\n    // Positions\r\n    public Vector3 EnemyPosition => EnemyTransform.Position;\r\n    public Vector3? LastKnownPosition => KnownPlaces.LastKnownPosition;\r\n    public Vector3 CenterMass => FindCenterMass(EnemyPlayerComponent);\r\n\r\n    // Distance/Direction\r\n    public float RealDistance { get; private set; }\r\n    public Vector3 EnemyDirection { get; private set; }\r\n    public Vector3 EnemyDirectionNormal { get; private set; }\r\n}\r\n```\r\n\r\n**Enemy Update:**\r\n```csharp\r\npublic void TickEnemy(float currentTime, float forgetEnemyTime, bool botSearching)\r\n{\r\n    // Update basic data\r\n    UpdateDistAndDirection();\r\n\r\n    // Check if sniper (distance-based)\r\n    if (IsSniper)\r\n    {\r\n        IsSniper = RealDistance < Bot.Info.PersonalitySettings.General.ENEMYSNIPER_DISTANCE_END;\r\n    }\r\n\r\n    // Update subsystems\r\n    KnownChecker.TickEnemy(currentTime, forgetEnemyTime, botSearching);\r\n    Vision.TickEnemy(currentTime);\r\n    Hearing.TickEnemy(currentTime);\r\n    KnownPlaces.TickEnemy(currentTime);\r\n    Status.TickEnemy(currentTime);\r\n}\r\n```\r\n\r\n**Known Places System:**\r\n```csharp\r\npublic class EnemyKnownPlaces\r\n{\r\n    public Vector3? LastKnownPosition { get; private set; }\r\n    public Vector3? LastSeenPosition { get; private set; }\r\n    public Vector3? LastHeardPosition { get; private set; }\r\n\r\n    public float TimeSinceLastKnownUpdated { get; private set; }\r\n    public float BotDistanceFromLastKnown { get; private set; }\r\n    public float EnemyDistanceFromLastKnown { get; private set; }\r\n\r\n    // Update when enemy seen\r\n    public EnemyPlace UpdateSeenPlace(Vector3 position, float currentTime)\r\n    {\r\n        LastSeenPosition = position;\r\n        return UpdateLastKnown(position, currentTime, true);\r\n    }\r\n\r\n    // Update when enemy heard\r\n    public EnemyPlace UpdateHeardPlace(Vector3 position, float currentTime)\r\n    {\r\n        LastHeardPosition = position;\r\n        if (TimeSinceSeen > 2f) // Only update if haven't seen recently\r\n        {\r\n            return UpdateLastKnown(position, currentTime, false);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private EnemyPlace UpdateLastKnown(Vector3 position, float currentTime, bool seen)\r\n    {\r\n        LastKnownPosition = position;\r\n        TimeSinceLastKnownUpdated = 0f;\r\n\r\n        // Update distances\r\n        BotDistanceFromLastKnown = Vector3.Distance(Bot.Position, position);\r\n        EnemyDistanceFromLastKnown = Vector3.Distance(EnemyPosition, position);\r\n\r\n        return new EnemyPlace(position, currentTime, seen);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Information Systems\r\n\r\n### SAINBotInfoClass\r\n**Namespace**: `SAIN.SAINComponent.Classes.Info`\r\n**Purpose**: Provides bot metadata and profile information\r\n\r\n**Properties:**\r\n```csharp\r\n// Profile Data\r\npublic ProfileInfo Profile { get; }\r\n    ‚îú‚îÄ‚îÄ IsPMC\r\n    ‚îú‚îÄ‚îÄ IsScav\r\n    ‚îú‚îÄ‚îÄ IsPlayerScav\r\n    ‚îú‚îÄ‚îÄ IsBoss\r\n    ‚îú‚îÄ‚îÄ BotType\r\n    ‚îú‚îÄ‚îÄ BotDifficulty\r\n    ‚îî‚îÄ‚îÄ PowerLevel\r\n\r\n// Personality\r\npublic EPersonality Personality { get; }\r\npublic PersonalitySettingsClass PersonalitySettings { get; }\r\n\r\n// Configuration\r\npublic float ForgetEnemyTime { get; } // Time before forgetting enemy\r\npublic float VisibleMoveSpeed { get; } // How fast bot moves when visible\r\npublic float HiddenMoveSpeed { get; } // How fast bot moves when not seen\r\n\r\n// Weapon Info\r\npublic EWeaponClass WeaponClass { get; } // SMG, Rifle, Sniper, etc.\r\npublic ECaliber Caliber { get; } // Weapon caliber\r\n```\r\n\r\n**Profile Detection:**\r\n```csharp\r\npublic class ProfileInfo\r\n{\r\n    public bool IsPMC => IsUSEC || IsBEAR;\r\n    public bool IsUSEC => WildSpawnType == WildSpawnType.pmcUSEC;\r\n    public bool IsBEAR => WildSpawnType == WildSpawnType.pmcBEAR;\r\n    public bool IsScav => WildSpawnType == WildSpawnType.assault;\r\n    public bool IsPlayerScav => WildSpawnType == WildSpawnType.assault &&\r\n                                Role == BotRole.PlayerScav;\r\n    public bool IsBoss => BotType == BotType.Boss ||\r\n                          BotType == BotType.BossFollower;\r\n\r\n    public WildSpawnType WildSpawnType { get; }\r\n    public BotRole Role { get; }\r\n    public BotDifficulty Difficulty { get; }\r\n    public int PowerLevel { get; } // 0-100 based on gear/skills\r\n}\r\n```\r\n\r\n---\r\n\r\n### SAINMemoryClass\r\n**Namespace**: `SAIN.SAINComponent.Classes.Memory`\r\n**Purpose**: Enemy memory and position history\r\n\r\n**Data Structures:**\r\n```csharp\r\n// Historical enemy positions\r\nDictionary<string, List<EnemyPlace>> EnemyPlaceHistory;\r\n\r\n// Enemy investigation status\r\nDictionary<string, InvestigationStatus> Investigations;\r\n\r\npublic class EnemyPlace\r\n{\r\n    public Vector3 Position { get; }\r\n    public float TimeCreated { get; }\r\n    public bool Seen { get; } // true if seen, false if heard\r\n}\r\n```\r\n\r\n**Memory Operations:**\r\n```csharp\r\n// Add position to history\r\npublic void AddEnemyPlace(Enemy enemy, Vector3 position, bool seen)\r\n{\r\n    if (!EnemyPlaceHistory.TryGetValue(enemy.EnemyProfileId, out var list))\r\n    {\r\n        list = new List<EnemyPlace>();\r\n        EnemyPlaceHistory[enemy.EnemyProfileId] = list;\r\n    }\r\n\r\n    list.Add(new EnemyPlace(position, Time.time, seen));\r\n\r\n    // Limit history size\r\n    if (list.Count > MaxHistorySize)\r\n    {\r\n        list.RemoveAt(0);\r\n    }\r\n}\r\n\r\n// Get recent positions for search\r\npublic List<Vector3> GetRecentPositions(string profileId, float maxAge)\r\n{\r\n    if (EnemyPlaceHistory.TryGetValue(profileId, out var list))\r\n    {\r\n        float cutoffTime = Time.time - maxAge;\r\n        return list.Where(x => x.TimeCreated > cutoffTime)\r\n                   .Select(x => x.Position)\r\n                   .ToList();\r\n    }\r\n    return new List<Vector3>();\r\n}\r\n```\r\n\r\n---\r\n\r\n## Squad System\r\n\r\n### BotSquadContainer\r\n**Namespace**: `SAIN.SAINComponent.Classes`\r\n**Purpose**: Squad membership and communication\r\n\r\n**Properties:**\r\n```csharp\r\npublic SquadInfo SquadInfo { get; } // Squad information\r\npublic bool BotInGroup => SquadInfo.IsInGroup;\r\npublic int MemberCount => SquadInfo.MemberCount;\r\npublic bool IsSquadLead => SquadInfo.IsSquadLeader;\r\n```\r\n\r\n**Squad Information:**\r\n```csharp\r\npublic class SquadInfo\r\n{\r\n    public List<BotComponent> Members { get; }\r\n    public BotComponent SquadLeader { get; private set; }\r\n    public bool IsInGroup => Members.Count > 1;\r\n    public int MemberCount => Members.Count;\r\n\r\n    public void AddMember(BotComponent bot)\r\n    {\r\n        if (!Members.Contains(bot))\r\n        {\r\n            Members.Add(bot);\r\n\r\n            // Update squad leader (highest power level)\r\n            UpdateSquadLeader();\r\n        }\r\n    }\r\n\r\n    public void RemoveMember(BotComponent bot)\r\n    {\r\n        Members.Remove(bot);\r\n        if (SquadLeader == bot)\r\n        {\r\n            UpdateSquadLeader();\r\n        }\r\n    }\r\n\r\n    private void UpdateSquadLeader()\r\n    {\r\n        SquadLeader = Members.OrderByDescending(x => x.Info.Profile.PowerLevel)\r\n                             .FirstOrDefault();\r\n    }\r\n}\r\n```\r\n\r\n**Squad Communication:**\r\n```csharp\r\n// Report enemy position to squad\r\npublic void ReportEnemyPosition(Enemy enemy, EnemyPlace place, bool seen, float currentTime)\r\n{\r\n    foreach (BotComponent member in SquadInfo.Members)\r\n    {\r\n        if (member == Bot) continue; // Don't report to self\r\n\r\n        // Check if member is close enough to receive report\r\n        if (member.PlayerComponent.GetDistanceToPlayer(Bot.ProfileId) < 100f)\r\n        {\r\n            // Update member's enemy knowledge\r\n            Enemy memberEnemy = member.EnemyController.GetEnemy(enemy.EnemyProfileId, false);\r\n            if (memberEnemy != null)\r\n            {\r\n                memberEnemy.EnemyPositionReported(place, seen, currentTime);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Activation and Limiting\r\n\r\n### SAINActivationClass\r\n**Namespace**: `SAIN.SAINComponent.Classes`\r\n**Purpose**: Control bot activation and layer state\r\n\r\n**States:**\r\n```csharp\r\npublic bool BotActive { get; private set; }\r\npublic bool BotInStandBy { get; private set; }\r\npublic bool BotInCombat { get; private set; }\r\npublic bool SAINLayersActive { get; private set; }\r\npublic bool GameEnding { get; private set; }\r\n\r\npublic ESAINLayer ActiveLayer { get; private set; }\r\npublic IBotAction CurrentAction { get; private set; }\r\n```\r\n\r\n**Activation Logic:**\r\n```csharp\r\npublic void SetActive(bool botActive)\r\n{\r\n    if (BotActive != botActive)\r\n    {\r\n        BotActive = botActive;\r\n\r\n        if (botActive)\r\n        {\r\n            OnBotActivated();\r\n        }\r\n        else\r\n        {\r\n            OnBotDeactivated();\r\n        }\r\n    }\r\n}\r\n\r\nprivate void OnBotActivated()\r\n{\r\n    // Enable SAIN layers\r\n    SAINLayersActive = true;\r\n\r\n    // Reset decision state\r\n    Bot.Decision.ResetDecisions(true);\r\n}\r\n\r\nprivate void OnBotDeactivated()\r\n{\r\n    // Disable SAIN layers\r\n    SAINLayersActive = false;\r\n\r\n    // Clear current enemy\r\n    Bot.EnemyController.ClearEnemy();\r\n}\r\n```\r\n\r\n### SAINAILimit\r\n**Namespace**: `SAIN.SAINComponent.Classes`\r\n**Purpose**: Limit AI processing based on distance/performance\r\n\r\n**Limit Levels:**\r\n```csharp\r\npublic enum AILimitSetting\r\n{\r\n    None,         // No limiting (player close or in combat)\r\n    Low,          // Slight reduction\r\n    Medium,       // Moderate reduction\r\n    High,         // Heavy reduction\r\n    VeryHigh,     // Minimal processing\r\n    Hibernation   // Almost no processing\r\n}\r\n```\r\n\r\n**Calculation:**\r\n```csharp\r\npublic AILimitSetting CalculateLimit()\r\n{\r\n    // Never limit if in combat\r\n    if (Bot.IsInCombat)\r\n        return AILimitSetting.None;\r\n\r\n    // Distance to closest player\r\n    float distToPlayer = Bot.PlayerComponent.GetDistanceToClosestPlayer();\r\n\r\n    // Apply distance-based limiting\r\n    if (distToPlayer < 50f)\r\n        return AILimitSetting.None;\r\n    if (distToPlayer < 100f)\r\n        return AILimitSetting.Low;\r\n    if (distToPlayer < 200f)\r\n        return AILimitSetting.Medium;\r\n    if (distToPlayer < 300f)\r\n        return AILimitSetting.High;\r\n\r\n    return AILimitSetting.VeryHigh;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Component Interaction Patterns\r\n\r\n### 1. Decision ‚Üí Action Flow\r\n\r\n```\r\nDecision System\r\n    ‚îú‚îÄ‚îÄ Calculates ECombatDecision\r\n    ‚îú‚îÄ‚îÄ Fires OnDecisionMade event\r\n    ‚îî‚îÄ‚îÄ BotDecisionManager updates\r\n\r\nLayer System (BigBrain)\r\n    ‚îú‚îÄ‚îÄ Receives decision\r\n    ‚îú‚îÄ‚îÄ Selects appropriate layer\r\n    ‚îî‚îÄ‚îÄ Activates action\r\n\r\nAction (e.g., RushEnemyAction)\r\n    ‚îú‚îÄ‚îÄ Uses Mover for movement\r\n    ‚îú‚îÄ‚îÄ Uses Steering for look direction\r\n    ‚îú‚îÄ‚îÄ Uses Shoot for firing\r\n    ‚îî‚îÄ‚îÄ Completes when goal reached\r\n```\r\n\r\n### 2. Vision ‚Üí Enemy Flow\r\n\r\n```\r\nVision System\r\n    ‚îú‚îÄ‚îÄ Raycasts to potential enemies\r\n    ‚îú‚îÄ‚îÄ Determines visibility\r\n    ‚îî‚îÄ‚îÄ Fires OnEnemyVisible event\r\n\r\nEnemyController\r\n    ‚îú‚îÄ‚îÄ Receives visibility event\r\n    ‚îú‚îÄ‚îÄ CheckAddEnemy(player)\r\n    ‚îî‚îÄ‚îÄ Creates/updates Enemy object\r\n\r\nEnemy\r\n    ‚îú‚îÄ‚îÄ Updates Vision.IsVisible\r\n    ‚îú‚îÄ‚îÄ Updates KnownPlaces\r\n    ‚îî‚îÄ‚îÄ Fires Events.OnVisionChange\r\n\r\nDecision System\r\n    ‚îú‚îÄ‚îÄ Receives OnVisionChange\r\n    ‚îú‚îÄ‚îÄ Recalculates decisions\r\n    ‚îî‚îÄ‚îÄ May change combat behavior\r\n```\r\n\r\n### 3. Squad Coordination Flow\r\n\r\n```\r\nBot A sees enemy\r\n    ‚îú‚îÄ‚îÄ Enemy.UpdateCurrentEnemyPos()\r\n    ‚îî‚îÄ‚îÄ Squad.SquadInfo.ReportEnemyPosition()\r\n\r\nSquad Members (Bot B, C, D)\r\n    ‚îú‚îÄ‚îÄ Receive enemy report\r\n    ‚îú‚îÄ‚îÄ Update their Enemy.KnownPlaces\r\n    ‚îî‚îÄ‚îÄ Can make decisions based on squad intel\r\n\r\nSquad Decision System\r\n    ‚îú‚îÄ‚îÄ Analyzes squad member states\r\n    ‚îú‚îÄ‚îÄ Determines squad decision (Suppress, Surround, etc.)\r\n    ‚îî‚îÄ‚îÄ Coordinates squad behavior\r\n```\r\n\r\n### 4. Cover System Flow\r\n\r\n```\r\nDecision: SeekCover\r\n    ‚îú‚îÄ‚îÄ Action: SeekCoverAction starts\r\n    ‚îî‚îÄ‚îÄ Requests cover from Cover.CoverClass\r\n\r\nCoverClass\r\n    ‚îú‚îÄ‚îÄ CoverFinder.FindCover()\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Check CoverManager for existing points\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Or search for new cover points\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ Evaluate cover points\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Distance to bot\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Protection from enemy\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Path distance\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ Score each point\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ Select best cover point\r\n\r\nMover\r\n    ‚îú‚îÄ‚îÄ Path to cover point\r\n    ‚îú‚îÄ‚îÄ Sprint if exposed\r\n    ‚îî‚îÄ‚îÄ Arrive at cover\r\n\r\nAction completes\r\n    ‚îú‚îÄ‚îÄ Decision changes to HoldInCover\r\n    ‚îî‚îÄ‚îÄ New action starts\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\nCore components in SAIN follow these principles:\r\n\r\n1. **Single Responsibility**: Each component handles one aspect of AI\r\n2. **Composition**: BotComponent composes 25+ specialized components\r\n3. **Event Communication**: Components communicate via events to reduce coupling\r\n4. **Hierarchical Management**: Global managers coordinate bot-level components\r\n5. **Lazy Evaluation**: Systems only process when needed (tick rate system)\r\n6. **State Tracking**: Each component maintains its own state independently\r\n\r\nThis modular design allows easy extension, testing, and maintenance of the AI system.\r\n"},"DataModels":{"title":"SAIN Data Models and Structures\r","category":"SAIN AI Reference","content":"# SAIN Data Models and Structures\r\n\r\n## Overview\r\nThis document catalogs the key data structures, enums, and classes used throughout the SAIN system.\r\n\r\n## Core Enumerations\r\n\r\n### Combat and Decision Enums\r\n\r\n**ECombatDecision** - Combat tactical decisions\r\n```csharp\r\npublic enum ECombatDecision\r\n{\r\n    None,                // No combat decision\r\n    Retreat,             // Fall back from enemy\r\n    Search,              // Search for lost enemy\r\n    RunAway,             // Flee at high speed\r\n    DogFight,            // Close-quarters aggressive fight (<15m)\r\n    SeekCover,           // Find and move to cover\r\n    StandAndShoot,       // Hold position and engage\r\n    ThrowGrenade,        // Throw grenade at enemy\r\n    ShiftCover,          // Move to different cover\r\n    RushEnemy,           // Charge toward enemy\r\n    MoveToEngage,        // Reposition for better shot\r\n    ShootDistantEnemy,   // Engage at long range\r\n    AvoidGrenade,        // Evade incoming grenade\r\n    Freeze,              // Stand still (ambush/stealth)\r\n    CreepOnEnemy,        // Slow approach\r\n    MeleeAttack,         // Melee range attack\r\n    FightZombies,        // Special zombie combat mode\r\n    DebugNoDecision      // Debug/error state\r\n}\r\n```\r\n\r\n**ESquadDecision** - Squad coordination decisions\r\n```csharp\r\npublic enum ESquadDecision\r\n{\r\n    None,               // No squad decision\r\n    Surround,           // Flank from multiple sides\r\n    Retreat,            // Squad falls back together\r\n    Suppress,           // Suppressive fire\r\n    PushSuppressedEnemy,// Advance on suppressed enemy\r\n    BoundingRetreat,    // Leapfrog retreat (alternating cover)\r\n    Regroup,            // Return to squad formation\r\n    SpreadOut,          // Increase spacing between members\r\n    HoldPositions,      // Stay in place, defensive\r\n    Help,               // Assist squad member in trouble\r\n    Search,             // Coordinate search of area\r\n    GroupSearch         // Group search pattern (sweep)\r\n}\r\n```\r\n\r\n**ESelfActionType** - Self-preservation actions\r\n```csharp\r\npublic enum ESelfActionType\r\n{\r\n    None,           // No self action needed\r\n    FirstAid,       // Use healing item\r\n    Surgery,        // Perform surgery (broken limb/heavy bleed)\r\n    Reload,         // Reload weapon\r\n    FixWeapon,      // Fix weapon malfunction\r\n    DropBackpack,   // Drop backpack for mobility\r\n    Stimulant       // Use combat stimulant\r\n}\r\n```\r\n\r\n**EPersonality** - Bot personality types\r\n```csharp\r\npublic enum EPersonality\r\n{\r\n    Normal,          // Balanced, standard behavior\r\n    GigaChad,        // Ultra-aggressive, fearless\r\n    Chad,            // Aggressive, confident\r\n    Rat,             // Passive, cautious, ambush-focused\r\n    Coward,          // Extremely passive, retreats often\r\n    Timmy,           // Inexperienced, poor aim/decisions\r\n    SnappingTurtle,  // Defensive, aggressive when approached\r\n    Wreckless,       // Aggressive without tactics\r\n    Necromancer      // Zombie/undead behavior\r\n}\r\n```\r\n\r\n### Layer and State Enums\r\n\r\n**ESAINLayer** - BigBrain layer types\r\n```csharp\r\npublic enum ESAINLayer\r\n{\r\n    None,           // No active SAIN layer\r\n    AvoidThreat,    // Grenade avoidance layer\r\n    Extract,        // Extraction layer\r\n    CombatSolo,     // Solo combat layer\r\n    CombatSquad,    // Squad combat layer\r\n    RunToCover      // Cover movement layer\r\n}\r\n```\r\n\r\n**ESAINTickState** - Component update requirements\r\n```csharp\r\npublic enum ESAINTickState\r\n{\r\n    AlwaysUpdate,       // Every frame (activation, info)\r\n    OnlyBotActive,      // Bot spawned and active (decision, enemies)\r\n    OnlyNoSleep,        // Not in standby mode (movement, cover)\r\n    OnlyBotInCombat     // Actively fighting (shooting, grenades)\r\n}\r\n```\r\n\r\n**AILimitSetting** - AI processing limits\r\n```csharp\r\npublic enum AILimitSetting\r\n{\r\n    None,         // No limiting (player nearby or in combat)\r\n    Low,          // Slight reduction (50-100m from player)\r\n    Medium,       // Moderate reduction (100-200m)\r\n    High,         // Heavy reduction (200-300m)\r\n    VeryHigh,     // Minimal processing (300m+)\r\n    Hibernation   // Almost no processing (very far)\r\n}\r\n```\r\n\r\n### Combat Support Enums\r\n\r\n**CoverStatus** - Cover state\r\n```csharp\r\npublic enum CoverStatus\r\n{\r\n    None,           // Not using cover\r\n    InCover,        // Behind cover\r\n    MovingToCover,  // Traveling to cover\r\n    Peeking,        // Peeking from cover to shoot\r\n    Shifting        // Moving between covers\r\n}\r\n```\r\n\r\n**FriendlyFireStatus** - FF prevention state\r\n```csharp\r\npublic enum FriendlyFireStatus\r\n{\r\n    Clear,          // No friendlies in line of fire\r\n    FriendInLine,   // Friend blocking shot\r\n    CloseToFriend,  // Friend near line of fire\r\n    Dangerous       // High FF risk\r\n}\r\n```\r\n\r\n**LeanSetting** - Leaning direction\r\n```csharp\r\npublic enum LeanSetting\r\n{\r\n    None,       // Not leaning\r\n    Left,       // Leaning left\r\n    Right       // Leaning right\r\n}\r\n```\r\n\r\n**SideStepSetting** - Side-stepping direction\r\n```csharp\r\npublic enum SideStepSetting\r\n{\r\n    None,       // Not side-stepping\r\n    Left,       // Side-step left\r\n    Right       // Side-step right\r\n}\r\n```\r\n\r\n### Weapon and Equipment Enums\r\n\r\n**EWeaponClass** - Weapon categories\r\n```csharp\r\npublic enum EWeaponClass\r\n{\r\n    None,           // No weapon / Melee\r\n    Pistol,         // Handgun\r\n    SMG,            // Submachine gun\r\n    AssaultRifle,   // Assault rifle\r\n    AssaultCarbine, // Carbine variant\r\n    DMR,            // Designated marksman rifle\r\n    Sniper,         // Sniper rifle\r\n    Shotgun,        // Shotgun\r\n    LMG,            // Light machine gun\r\n    GrenadeLauncher // Grenade launcher\r\n}\r\n```\r\n\r\n**ECaliber** - Ammo calibers\r\n```csharp\r\npublic enum ECaliber\r\n{\r\n    None,\r\n    Caliber9x18PM,\r\n    Caliber9x19,\r\n    Caliber45ACP,\r\n    Caliber762x25,\r\n    Caliber57x28,\r\n    Caliber762x39,\r\n    Caliber545x39,\r\n    Caliber556x45,\r\n    Caliber762x51,\r\n    Caliber762x54R,\r\n    Caliber366TKM,\r\n    Caliber12gauge,\r\n    Caliber20gauge,\r\n    Caliber23x75,\r\n    Caliber40mmgrenade,\r\n    // ... more calibers\r\n}\r\n```\r\n\r\n**EEquipmentType** - Equipment categories for stealth\r\n```csharp\r\npublic enum EEquipmentType\r\n{\r\n    Headwear,       // Helmets, hats\r\n    Eyewear,        // Glasses, goggles\r\n    FaceCover,      // Masks, balaclavas\r\n    ArmorVest,      // Body armor\r\n    Backpack,       // Backpacks\r\n    TacticalRig,    // Chest rigs\r\n    Holster,        // Pistol holster\r\n    SecuredContainer // Safe container\r\n}\r\n```\r\n\r\n### Audio and Perception Enums\r\n\r\n**SAINSoundType** - Sound categories\r\n```csharp\r\npublic enum SAINSoundType\r\n{\r\n    None,           // No sound\r\n    GunShot,        // Weapon fire (300m base)\r\n    Footstep,       // Movement sound (15m base)\r\n    Reload,         // Reloading weapon (5m base)\r\n    Healing,        // Medical use (3m base)\r\n    Grenade,        // Grenade pin/throw (50m base)\r\n    Door,           // Door open/close (20m base)\r\n    Jump,           // Jump/land sound (10m base)\r\n    Loot,           // Looting container (5m base)\r\n    Inspect,        // Item inspect (3m base)\r\n    Mumble,         // Voice/mumble (10m base)\r\n    Pain,           // Damage grunt (15m base)\r\n    Falling,        // Falling sound (20m base)\r\n    Bush,           // Bush rustle (8m base)\r\n    WeaponSwitch    // Changing weapons (5m base)\r\n}\r\n```\r\n\r\n**ESoundCleanupReason** - Why sound was removed\r\n```csharp\r\npublic enum ESoundCleanupReason\r\n{\r\n    Timeout,        // Sound expired\r\n    Investigated,   // Bot checked sound location\r\n    NewPriority,    // Higher priority sound occurred\r\n    SourceDead,     // Sound source died\r\n    TooFar          // Sound source moved too far\r\n}\r\n```\r\n\r\n### Path and Distance Enums\r\n\r\n**EPathDistance** - Path distance categories\r\n```csharp\r\npublic enum EPathDistance\r\n{\r\n    VeryClose,  // < 10m path distance\r\n    Close,      // 10-30m\r\n    Mid,        // 30-75m\r\n    Far,        // 75-150m\r\n    VeryFar     // > 150m path distance\r\n}\r\n```\r\n\r\n**ELocation** - Map locations (for settings per map)\r\n```csharp\r\npublic enum ELocation\r\n{\r\n    None,\r\n    Factory,\r\n    Customs,\r\n    Woods,\r\n    Shoreline,\r\n    Interchange,\r\n    Reserve,\r\n    Lighthouse,\r\n    Streets,\r\n    Labs,\r\n    GroundZero\r\n    // ... more locations\r\n}\r\n```\r\n\r\n## Data Structures\r\n\r\n### Enemy Data Structures\r\n\r\n**EnemyPlace** - Historical enemy position\r\n```csharp\r\npublic class EnemyPlace\r\n{\r\n    public Vector3 Position { get; set; }\r\n    public float TimeCreated { get; set; }\r\n    public bool Seen { get; set; }        // true if seen, false if heard\r\n    public float TimeLastUpdated { get; set; }\r\n    public Vector3 Direction { get; set; }  // Direction from bot when created\r\n    public float Distance { get; set; }     // Distance from bot when created\r\n}\r\n```\r\n\r\n**EnemyInfo** - Base game enemy information (EFT class)\r\n```csharp\r\npublic class EnemyInfo\r\n{\r\n    public IPlayer Person { get; set; }\r\n    public string ProfileId { get; set; }\r\n    public Vector3 Position { get; set; }\r\n    public Vector3 Direction { get; set; }\r\n    public float Distance { get; set; }\r\n    public bool IsVisible { get; set; }\r\n    public bool IsHeared { get; set; }\r\n    public float LastSeenTime { get; set; }\r\n    public float LastHeardTime { get; set; }\r\n}\r\n```\r\n\r\n**EnemyData** - SAIN enemy data wrapper\r\n```csharp\r\npublic struct EnemyData\r\n{\r\n    public Enemy Enemy { get; }\r\n    public BotComponent Bot { get; }\r\n    public Player EnemyPlayer { get; }\r\n    public BotOwner BotOwner { get; }\r\n    public EnemyInfo EnemyInfo { get; }\r\n\r\n    public EnemyData(Enemy enemy)\r\n    {\r\n        Enemy = enemy;\r\n        Bot = enemy.Bot;\r\n        EnemyPlayer = enemy.EnemyPlayer;\r\n        BotOwner = enemy.Bot.BotOwner;\r\n        EnemyInfo = enemy.EnemyInfo;\r\n    }\r\n}\r\n```\r\n\r\n### Cover Structures\r\n\r\n**CoverPoint** - Cover location data\r\n```csharp\r\npublic class CoverPoint\r\n{\r\n    public Vector3 Position { get; set; }\r\n    public Vector3 Normal { get; set; }        // Surface normal\r\n    public float CoverHeight { get; set; }     // Height of cover\r\n    public float CoverValue { get; set; }      // Quality score (0-1)\r\n    public Collider Collider { get; set; }     // Cover object\r\n    public bool Reserved { get; set; }         // Is cover in use\r\n    public string ReservedBy { get; set; }     // Bot using this cover\r\n    public float TimeReserved { get; set; }\r\n\r\n    // Calculated data\r\n    public SpottedCoverPoint Spotted { get; set; }  // Visibility analysis\r\n    public PathData PathData { get; set; }          // Path info\r\n    public TargetData TargetData { get; set; }      // Target relation\r\n}\r\n```\r\n\r\n**CoverAnalysis** - Cover quality analysis result\r\n```csharp\r\npublic struct CoverAnalysis\r\n{\r\n    public float CoverValue { get; set; }      // Overall quality (0-1)\r\n    public Vector3 CoverNormal { get; set; }   // Surface normal\r\n    public float Height { get; set; }          // Cover height\r\n    public Vector3 HitPoint { get; set; }      // Raycast hit point\r\n    public bool BlocksLineOfSight { get; set; }\r\n    public MaterialType Material { get; set; }\r\n}\r\n```\r\n\r\n**SpottedCoverPoint** - Cover visibility data\r\n```csharp\r\npublic class SpottedCoverPoint\r\n{\r\n    public float CoverValue { get; set; }          // Protection value\r\n    public bool EnemyCanSeePoint { get; set; }     // Enemy LoS\r\n    public bool BotCanSeeEnemy { get; set; }       // Bot LoS from cover\r\n    public float AngleToEnemy { get; set; }        // Angle from cover normal\r\n    public Vector3 PeekDirection { get; set; }     // Direction to peek\r\n}\r\n```\r\n\r\n**PathData** - Pathfinding data to cover\r\n```csharp\r\npublic class PathData\r\n{\r\n    public NavMeshPath Path { get; set; }\r\n    public float PathDistance { get; set; }\r\n    public Vector3[] Corners { get; set; }\r\n    public bool PathValid { get; set; }\r\n    public float PathCalculationTime { get; set; }\r\n}\r\n```\r\n\r\n### Transform and Movement Structures\r\n\r\n**PlayerTransformClass** - Player transform data\r\n```csharp\r\npublic class PlayerTransformClass\r\n{\r\n    public Vector3 Position { get; set; }\r\n    public Vector3 EyePosition { get; set; }\r\n    public Vector3 BodyPosition { get; set; }\r\n    public Vector3 Forward { get; set; }\r\n    public Vector3 Up { get; set; }\r\n    public Vector3 Right { get; set; }\r\n    public Quaternion Rotation { get; set; }\r\n\r\n    public NavData NavData { get; set; }  // NavMesh data\r\n\r\n    public void Update(Player player)\r\n    {\r\n        Position = player.Position;\r\n        EyePosition = player.MainParts[BodyPartType.Head].Position;\r\n        BodyPosition = player.MainParts[BodyPartType.Chest].Position;\r\n        Forward = player.Transform.forward;\r\n        Up = player.Transform.up;\r\n        Right = player.Transform.right;\r\n        Rotation = player.Transform.rotation;\r\n\r\n        NavData.Update(Position);\r\n    }\r\n}\r\n```\r\n\r\n**NavData** - NavMesh related data\r\n```csharp\r\npublic struct NavData\r\n{\r\n    public Vector3 Position { get; set; }      // NavMesh projected position\r\n    public bool OnNavMesh { get; set; }        // Is on NavMesh\r\n    public float DistanceToNavMesh { get; set; }  // If off-mesh\r\n\r\n    public void Update(Vector3 worldPosition)\r\n    {\r\n        if (NavMesh.SamplePosition(worldPosition, out NavMeshHit hit, 2f, NavMesh.AllAreas))\r\n        {\r\n            Position = hit.position;\r\n            OnNavMesh = true;\r\n            DistanceToNavMesh = Vector3.Distance(worldPosition, hit.position);\r\n        }\r\n        else\r\n        {\r\n            Position = worldPosition;\r\n            OnNavMesh = false;\r\n            DistanceToNavMesh = float.MaxValue;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Decision Structures\r\n\r\n**BotDecisionPackage** - Complete decision state\r\n```csharp\r\npublic struct BotDecisionPackage\r\n{\r\n    public ECombatDecision CombatDecision { get; set; }\r\n    public ESquadDecision SquadDecision { get; set; }\r\n    public ESelfActionType SelfAction { get; set; }\r\n    public Enemy TargetEnemy { get; set; }\r\n    public float DecisionTime { get; set; }\r\n    public float DecisionConfidence { get; set; }  // 0-1 how confident\r\n\r\n    public bool IsValid => CombatDecision != ECombatDecision.None ||\r\n                           SquadDecision != ESquadDecision.None ||\r\n                           SelfAction != ESelfActionType.None;\r\n}\r\n```\r\n\r\n**DecisionScore** - Decision scoring for selection\r\n```csharp\r\npublic struct DecisionScore\r\n{\r\n    public float Score { get; set; }\r\n    public string Reasoning { get; set; }  // Debug info\r\n    public Dictionary<string, float> Factors { get; set; }  // Score breakdown\r\n}\r\n```\r\n\r\n### Event Structures\r\n\r\n**EnemyToggleEventTimeTracked** - Boolean event with time tracking\r\n```csharp\r\npublic class EnemyToggleEventTimeTracked\r\n{\r\n    public delegate void OnToggle(bool value, Enemy enemy);\r\n\r\n    public OnToggle OnToggleDelegate;\r\n\r\n    public bool Value { get; private set; }\r\n    public float TimeSinceTrue { get; private set; }\r\n    public float TimeSinceFalse { get; private set; }\r\n    public float TimeOfLastTrue { get; private set; }\r\n    public float TimeOfLastFalse { get; private set; }\r\n\r\n    public void SetValue(bool newValue, float currentTime, Enemy enemy)\r\n    {\r\n        if (newValue != Value)\r\n        {\r\n            Value = newValue;\r\n            OnToggleDelegate?.Invoke(newValue, enemy);\r\n\r\n            if (newValue)\r\n            {\r\n                TimeOfLastTrue = currentTime;\r\n                TimeSinceTrue = 0f;\r\n            }\r\n            else\r\n            {\r\n                TimeOfLastFalse = currentTime;\r\n                TimeSinceFalse = 0f;\r\n            }\r\n        }\r\n    }\r\n\r\n    public void Update(float currentTime)\r\n    {\r\n        if (Value)\r\n            TimeSinceTrue = currentTime - TimeOfLastTrue;\r\n        else\r\n            TimeSinceFalse = currentTime - TimeOfLastFalse;\r\n    }\r\n}\r\n```\r\n\r\n**SoundEvent** - Sound occurrence data\r\n```csharp\r\npublic struct SoundEvent\r\n{\r\n    public SAINSoundType Type { get; set; }\r\n    public Vector3 Position { get; set; }\r\n    public float Volume { get; set; }\r\n    public float Distance { get; set; }      // Distance to listener\r\n    public Player Source { get; set; }       // Who made the sound\r\n    public float TimeHeard { get; set; }\r\n    public bool Investigated { get; set; }\r\n\r\n    public float TimeSinceHeard(float currentTime)\r\n    {\r\n        return currentTime - TimeHeard;\r\n    }\r\n}\r\n```\r\n\r\n### Grenade Structures\r\n\r\n**GrenadeThrow** - Grenade throw calculation\r\n```csharp\r\npublic class GrenadeThrow\r\n{\r\n    public Vector3 TargetPosition { get; set; }\r\n    public GrenadeThrowDirection Direction { get; set; }\r\n    public float ThrowPower { get; set; }        // 0-1 throw strength\r\n    public GrenadeThrowType ThrowType { get; set; }\r\n    public float FlightTime { get; set; }        // Estimated flight time\r\n    public Vector3[] TrajectoryPoints { get; set; }  // Predicted arc\r\n\r\n    public GrenadeThrow(Vector3 target, GrenadeThrowDirection dir,\r\n                       float power, GrenadeThrowType type)\r\n    {\r\n        TargetPosition = target;\r\n        Direction = dir;\r\n        ThrowPower = power;\r\n        ThrowType = type;\r\n    }\r\n}\r\n```\r\n\r\n**GrenadeThrowDirection** - Throw direction type\r\n```csharp\r\npublic enum GrenadeThrowDirection\r\n{\r\n    Forward,    // Straight throw\r\n    Up,         // High arc\r\n    Down        // Low throw\r\n}\r\n```\r\n\r\n**GrenadeThrowType** - Throw method\r\n```csharp\r\npublic enum GrenadeThrowType\r\n{\r\n    Direct,     // Direct path to target\r\n    HighArc,    // Over obstacles\r\n    Bounce      // Bounce off wall\r\n}\r\n```\r\n\r\n### Job System Structures\r\n\r\n**RaycastJobResult** - Raycast job output\r\n```csharp\r\npublic struct RaycastJobResult\r\n{\r\n    public bool Hit { get; set; }\r\n    public Vector3 HitPoint { get; set; }\r\n    public Vector3 HitNormal { get; set; }\r\n    public float Distance { get; set; }\r\n    public Collider HitCollider { get; set; }\r\n    public GameObject HitObject { get; set; }\r\n}\r\n```\r\n\r\n**CoverSearchParams** - Cover search parameters\r\n```csharp\r\npublic struct CoverSearchParams\r\n{\r\n    public Vector3 SearchOrigin { get; set; }\r\n    public Vector3 ThreatOrigin { get; set; }\r\n    public float SearchRadius { get; set; }\r\n    public float MinCoverValue { get; set; }\r\n    public int MaxResults { get; set; }\r\n    public LayerMask CoverLayerMask { get; set; }\r\n}\r\n```\r\n\r\n## Interface Definitions\r\n\r\n**IBotClass** - Base interface for bot components\r\n```csharp\r\npublic interface IBotClass\r\n{\r\n    BotComponent Bot { get; }\r\n    ESAINTickState TickRequirement { get; }\r\n    bool CanEverTick { get; }\r\n    float TickInterval { get; }\r\n    float LastTickTime { get; }\r\n\r\n    void Init();\r\n    void ManualUpdate();\r\n    bool ShallTick(float currentTime);\r\n    void Dispose();\r\n}\r\n```\r\n\r\n**ISPlayer** - Shared player interface\r\n```csharp\r\npublic interface ISPlayer\r\n{\r\n    Vector3 NavMeshPosition { get; }\r\n    float GetDistanceToPlayer(string profileId);\r\n    bool IsPlayerInRange(string profileId, float maxDistance, out float distance);\r\n}\r\n```\r\n\r\n**IBotAction** - Action interface\r\n```csharp\r\npublic interface IBotAction\r\n{\r\n    string ActionName { get; }\r\n    bool IsActive { get; }\r\n    bool IsComplete { get; }\r\n    float ActionStartTime { get; }\r\n\r\n    void Start();\r\n    void Update();\r\n    void Stop();\r\n}\r\n```\r\n\r\n## Summary\r\n\r\nKey data structures in SAIN:\r\n\r\n1. **Enumerations** - Type-safe decision/state tracking\r\n2. **Enemy Data** - Multi-layered enemy representation\r\n3. **Cover Structures** - Cover finding and quality analysis\r\n4. **Transform Data** - Position and orientation tracking\r\n5. **Event Structures** - Time-tracked state changes\r\n6. **Decision Packages** - Complete decision state\r\n7. **Job Structures** - Async operation results\r\n8. **Interfaces** - Common component contracts\r\n\r\nThese structures provide the foundation for SAIN's sophisticated AI behavior while maintaining clean, type-safe code.\r\n"},"INDEX":{"title":"SAIN AI System - Complete Technical Documentation Index\r","category":"SAIN AI Reference","content":"# SAIN AI System - Complete Technical Documentation Index\r\n\r\n## Document Overview\r\n\r\nThis documentation provides a comprehensive technical breakdown of the SAIN (SolarintAI Improvements) mod for Escape from Tarkov SPT. The SAIN codebase contains **682 C# files** implementing a sophisticated AI enhancement system.\r\n\r\n## Quick Navigation\r\n\r\n| Document | Description | Key Topics |\r\n|----------|-------------|------------|\r\n| [Architecture.md](./Architecture.md) | System architecture and design patterns | Core design, component relationships, update loops |\r\n| [CoreComponents.md](./CoreComponents.md) | Main system components | BotComponent, PlayerComponent, managers |\r\n| [AIDecisionSystem.md](./AIDecisionSystem.md) | AI decision-making logic | Decision trees, combat/squad/self decisions |\r\n| [CombatSystems.md](./CombatSystems.md) | Combat mechanics | Shooting, grenades, cover, tactics |\r\n| [SensorySystem.md](./SensorySystem.md) | Perception systems | Vision, hearing, enemy detection |\r\n| [MovementSystem.md](./MovementSystem.md) | Movement and pathfinding | Navigation, cover finding, positioning |\r\n| [PersonalityConfig.md](./PersonalityConfig.md) | Bot personalities | Personality types, behavior settings |\r\n| [PatchesIntegration.md](./PatchesIntegration.md) | SPT integration | Harmony patches, game hooks |\r\n| [DataModels.md](./DataModels.md) | Data structures | Enums, classes, structs |\r\n\r\n## System Overview\r\n\r\n### What is SAIN?\r\n\r\nSAIN is a comprehensive AI overhaul mod that replaces and enhances Escape from Tarkov's bot AI system with:\r\n\r\n- **Advanced Decision-Making**: Multi-layered decision system with combat, squad, and self-action logic\r\n- **Realistic Sensory Systems**: Vision, hearing, and perception mechanics with line-of-sight calculations\r\n- **Tactical Combat**: Cover usage, suppression, flanking, squad coordination\r\n- **Dynamic Movement**: Pathfinding, tactical positioning, vaulting, unstuck mechanics\r\n- **Personality System**: Multiple bot personalities affecting behavior patterns\r\n- **Integration Framework**: Hooks into SPT-AKI using Harmony patches and BigBrain layer system\r\n\r\n### Core Architecture\r\n\r\n```\r\nGameWorldComponent (Singleton)\r\n    ‚îî‚îÄ‚îÄ BotManagerComponent (Singleton)\r\n            ‚îî‚îÄ‚îÄ BotSpawnController\r\n                    ‚îî‚îÄ‚îÄ BotComponent (per bot)\r\n                            ‚îú‚îÄ‚îÄ SAINDecisionClass\r\n                            ‚îú‚îÄ‚îÄ SAINEnemyController\r\n                            ‚îú‚îÄ‚îÄ SAINVisionClass\r\n                            ‚îú‚îÄ‚îÄ SAINHearingSensorClass\r\n                            ‚îú‚îÄ‚îÄ SAINMoverClass\r\n                            ‚îú‚îÄ‚îÄ SAINCoverClass\r\n                            ‚îú‚îÄ‚îÄ SAINShootData\r\n                            ‚îú‚îÄ‚îÄ BotGrenadeManager\r\n                            ‚îî‚îÄ‚îÄ [25+ other subsystems]\r\n```\r\n\r\n## Component Hierarchy\r\n\r\n### Top-Level Managers\r\n- `GameWorldComponent` - Game world singleton, manages global state\r\n- `BotManagerComponent` - Manages all SAIN bots, raycast jobs, cover points\r\n- `BotSpawnController` - Handles bot spawning and SAIN component attachment\r\n\r\n### Per-Bot Components (BotComponent)\r\nEach bot has a `BotComponent` that contains:\r\n\r\n#### Decision Systems\r\n- `SAINDecisionClass` - Master decision controller\r\n- `EnemyDecisionClass` - Enemy-focused combat decisions\r\n- `SquadDecisionClass` - Squad coordination decisions\r\n- `SelfActionDecisionClass` - Self-preservation actions\r\n\r\n#### Sensory Systems\r\n- `SAINVisionClass` - Vision processing\r\n- `SAINHearingSensorClass` - Sound detection\r\n- `SAINNoBushESP` - Foliage penetration system\r\n- `FlashLightDazzleClass` - Flashlight effects\r\n\r\n#### Enemy Management\r\n- `SAINEnemyController` - Tracks all enemies\r\n- `Enemy` - Individual enemy representation with:\r\n  - `EnemyVisionClass` - Enemy-specific vision state\r\n  - `EnemyKnownPlaces` - Last known positions\r\n  - `SAINEnemyPath` - Pathfinding to enemy\r\n  - `SAINEnemyStatus` - Enemy status tracking\r\n\r\n#### Combat Systems\r\n- `SAINShootData` - Shooting mechanics\r\n- `BotGrenadeManager` - Grenade throwing logic\r\n- `SAINFriendlyFireClass` - Friendly fire prevention\r\n- `SAINBotSuppressClass` - Suppression effects\r\n- `AimClass` - Aiming calculations\r\n- `ManualShootClass` - Manual fire control\r\n\r\n#### Movement Systems\r\n- `SAINMoverClass` - Movement controller\r\n- `SAINSteeringClass` - Look direction steering\r\n- `SAINCoverClass` - Cover system\r\n- `SAINVaultClass` - Vaulting mechanics\r\n- `SAINBotUnstuckClass` - Unstuck logic\r\n- `DoorOpener` - Door interaction\r\n\r\n#### Support Systems\r\n- `SAINMemoryClass` - Enemy memory\r\n- `SAINSearchClass` - Search behavior\r\n- `SAINBotTalkClass` - Voice lines\r\n- `SAINBotInfoClass` - Bot information\r\n- `SAINBotMedicalClass` - Medical actions\r\n- `SAINSelfActionClass` - Self actions\r\n- `BotSquadContainer` - Squad membership\r\n\r\n## Layer System (BigBrain Integration)\r\n\r\nSAIN uses the BigBrain mod's layer system to inject custom AI behavior:\r\n\r\n### Layer Types\r\n1. **Combat Layers**\r\n   - `CombatSoloLayer` - Individual combat actions\r\n   - `CombatSquadLayer` - Squad combat coordination\r\n\r\n2. **Movement Layers**\r\n   - `RunToCoverLayer` - Running to cover\r\n\r\n3. **Utility Layers**\r\n   - `ExtractLayer` - Extraction behavior\r\n   - `SAINAvoidThreatLayer` - Grenade avoidance\r\n\r\n### Layer Actions\r\nEach layer contains multiple actions corresponding to decisions:\r\n- `RushEnemyAction`\r\n- `SeekCoverAction`\r\n- `StandAndShootAction`\r\n- `SearchAction`\r\n- `ThrowGrenadeAction`\r\n- `SurroundAction`\r\n- `SuppressAction`\r\n- etc.\r\n\r\n## Key Enumerations\r\n\r\n### Combat Decisions (ECombatDecision)\r\n```csharp\r\nNone, Retreat, Search, RunAway, DogFight, SeekCover,\r\nStandAndShoot, ThrowGrenade, ShiftCover, RushEnemy,\r\nMoveToEngage, ShootDistantEnemy, AvoidGrenade, Freeze,\r\nCreepOnEnemy, MeleeAttack, FightZombies\r\n```\r\n\r\n### Squad Decisions (ESquadDecision)\r\n```csharp\r\nNone, Surround, Retreat, Suppress, PushSuppressedEnemy,\r\nBoundingRetreat, Regroup, SpreadOut, HoldPositions,\r\nHelp, Search, GroupSearch\r\n```\r\n\r\n### Self Actions (ESelfActionType)\r\n```csharp\r\nNone, FirstAid, Surgery, Reload, FixWeapon, DropBackpack, Stimulant\r\n```\r\n\r\n### Bot Personalities (EPersonality)\r\n```csharp\r\nNormal, GigaChad, Rat, Chad, Coward, Timmy, SnappingTurtle,\r\nWreckless, Necromancer\r\n```\r\n\r\n## Search Keywords\r\n\r\n### By Topic\r\n- **Architecture**: GameWorldComponent, BotManagerComponent, BotComponent, singleton pattern\r\n- **Decisions**: ECombatDecision, ESquadDecision, ESelfActionType, decision tree, BotDecisionManager\r\n- **Combat**: shooting, aiming, scatter, recoil, rate of fire, grenade, cover, suppression\r\n- **Vision**: line of sight, LoS, raycast, visible, seen, NoBushESP, flashlight\r\n- **Hearing**: sound detection, gunshot, footstep, SAINSoundType, audio sensor\r\n- **Movement**: pathfinding, NavMesh, cover finder, vault, mover, steering\r\n- **Enemies**: Enemy class, EnemyController, known enemies, last known position\r\n- **Squad**: squad coordination, group behavior, ally communication\r\n- **Personality**: personality settings, behavior modifiers, bot types\r\n- **Patches**: Harmony, prefix, postfix, transpiler, game integration\r\n- **Configuration**: preset system, global settings, bot settings, personality settings\r\n\r\n### By Namespace\r\n- `SAIN.Components` - Core component classes\r\n- `SAIN.SAINComponent` - Bot component classes\r\n- `SAIN.SAINComponent.Classes.Decision` - Decision system\r\n- `SAIN.SAINComponent.Classes.EnemyClasses` - Enemy management\r\n- `SAIN.SAINComponent.Classes.Sense` - Sensory systems\r\n- `SAIN.SAINComponent.Classes.Mover` - Movement classes\r\n- `SAIN.SAINComponent.Classes.WeaponFunction` - Weapon/shooting\r\n- `SAIN.SAINComponent.SubComponents.CoverFinder` - Cover finding\r\n- `SAIN.Layers` - BigBrain layer implementations\r\n- `SAIN.Layers.Combat.Solo` - Solo combat actions\r\n- `SAIN.Layers.Combat.Squad` - Squad actions\r\n- `SAIN.Patches.*` - Harmony patches\r\n- `SAIN.Preset` - Configuration/preset system\r\n- `SAIN.Preset.Personalities` - Personality definitions\r\n- `SAIN.Models.Enums` - Enumeration types\r\n\r\n## Data Flow Overview\r\n\r\n### Bot Update Cycle\r\n```\r\n1. BotManagerComponent.Update()\r\n   ‚îú‚îÄ‚îÄ Update all BotComponents\r\n   ‚îú‚îÄ‚îÄ Process raycast jobs\r\n   ‚îî‚îÄ‚îÄ Update cover manager\r\n\r\n2. BotComponent.ManualUpdate()\r\n   ‚îú‚îÄ‚îÄ Tick always-update classes (activation, info, etc.)\r\n   ‚îú‚îÄ‚îÄ If bot active:\r\n   ‚îÇ   ‚îú‚îÄ‚îÄ Tick active classes (enemies, decision, vision, hearing)\r\n   ‚îÇ   ‚îî‚îÄ‚îÄ If not in standby:\r\n   ‚îÇ       ‚îú‚îÄ‚îÄ Tick no-sleep classes (mover, steering, cover)\r\n   ‚îÇ       ‚îî‚îÄ‚îÄ If in combat:\r\n   ‚îÇ           ‚îî‚îÄ‚îÄ Tick combat classes (shoot, grenades, suppression)\r\n\r\n3. Enemy Detection\r\n   ‚îú‚îÄ‚îÄ Vision system raycasts\r\n   ‚îú‚îÄ‚îÄ Hearing system sound detection\r\n   ‚îî‚îÄ‚îÄ EnemyController.CheckAddEnemy()\r\n\r\n4. Decision Making\r\n   ‚îú‚îÄ‚îÄ EnemyDecisions.GetDecision()\r\n   ‚îú‚îÄ‚îÄ SquadDecisions.GetDecision()\r\n   ‚îú‚îÄ‚îÄ SelfActionDecisions.GetDecision()\r\n   ‚îî‚îÄ‚îÄ BotDecisionManager.MakeDecision()\r\n\r\n5. Action Execution\r\n   ‚îú‚îÄ‚îÄ BigBrain layer selection\r\n   ‚îú‚îÄ‚îÄ Action.Update()\r\n   ‚îî‚îÄ‚îÄ Bot behavior output (movement, shooting, etc.)\r\n```\r\n\r\n### Enemy Tracking Flow\r\n```\r\n1. Player/Bot enters vision ‚Üí Vision.CheckLineOfSight()\r\n2. Raycast determines LoS ‚Üí Vision.OnEnemyVisible()\r\n3. EnemyController.CheckAddEnemy() ‚Üí Create Enemy object\r\n4. Enemy.TickEnemy() updates:\r\n   ‚îú‚îÄ‚îÄ Vision state (visible, LoS, can shoot)\r\n   ‚îú‚îÄ‚îÄ Hearing state (heard, time since heard)\r\n   ‚îú‚îÄ‚îÄ Known state (known, forgotten)\r\n   ‚îú‚îÄ‚îÄ Last known positions\r\n   ‚îî‚îÄ‚îÄ Path to enemy\r\n5. EnemyController.ChooseEnemy() ‚Üí Select goal enemy\r\n6. Decision system uses goal enemy ‚Üí Make decisions\r\n7. Combat actions target goal enemy ‚Üí Execute behavior\r\n```\r\n\r\n## File Organization\r\n\r\n### Configuration Files\r\nAll preset and configuration data stored in:\r\n- `SAIN.Preset.GlobalSettings` - Global AI settings\r\n- `SAIN.Preset.BotSettings` - Per-bot-type settings\r\n- `SAIN.Preset.Personalities` - Personality definitions\r\n- `SAIN.Preset.GearStealthValues` - Equipment stealth values\r\n\r\n### Patch Files\r\nHarmony patches organized by category:\r\n- `SAIN.Patches.Generic` - General patches\r\n- `SAIN.Patches.Vision` - Vision system patches\r\n- `SAIN.Patches.Hearing` - Hearing system patches\r\n- `SAIN.Patches.Shoot.*` - Shooting mechanic patches\r\n- `SAIN.Patches.Movement` - Movement patches\r\n- `SAIN.Patches.Talk` - Voice line patches\r\n- `SAIN.Patches.Components` - Component lifecycle patches\r\n\r\n## Integration Points\r\n\r\n### SPT-AKI Integration\r\n- Uses BepInEx plugin framework\r\n- Harmony patching for game method interception\r\n- BigBrain mod for layer-based AI behavior\r\n- Dependency on SPT version (tracked via `SAINDifficulty` class)\r\n\r\n### Mod Compatibility Detection\r\n- Checks for Realism Mod\r\n- Checks for Questing Bots\r\n- Checks for Project FIKA (multiplayer)\r\n- Checks for FIKA Headless\r\n- Adjusts behavior based on detected mods\r\n\r\n## Performance Considerations\r\n\r\n### Update Tick System\r\nBots and their subsystems have different tick rates:\r\n- `ESAINTickState.AlwaysUpdate` - Every frame\r\n- `ESAINTickState.OnlyBotActive` - Only when bot activated\r\n- `ESAINTickState.OnlyNoSleep` - Only when not in standby\r\n- `ESAINTickState.OnlyBotInCombat` - Only during combat\r\n\r\n### Raycast Job System\r\nUses Unity Job System for expensive raycasts:\r\n- Vision line-of-sight checks\r\n- Cover point evaluation\r\n- Path visibility checks\r\n- Enemy place calculations\r\n\r\n### AI Limiting\r\n`AILimitSetting` system reduces AI activity based on:\r\n- Distance from player\r\n- Current combat state\r\n- System performance needs\r\n\r\n## Editor and Debug Features\r\n\r\n### In-Game Editor\r\n`SAINEditor` class provides runtime configuration editing:\r\n- Bot personality tweaking\r\n- Global settings adjustment\r\n- Bot-specific settings\r\n- Visual debug overlay\r\n\r\n### Debug Visualization\r\n`DebugOverlay` class draws:\r\n- Decision states\r\n- Enemy positions\r\n- Cover points\r\n- Path visualization\r\n- Line-of-sight rays\r\n\r\n## Usage Notes for Recreation\r\n\r\n### Critical Dependencies\r\n1. **BigBrain** - Required for layer system\r\n2. **Unity NavMesh** - For pathfinding\r\n3. **Unity Job System** - For performance optimization\r\n4. **SPT-AKI types** - Game class references\r\n\r\n### Key Algorithms\r\n1. **Cover Finding**: Sphere-cast around bot, raycast to evaluate cover quality\r\n2. **Enemy Selection**: Priority scoring based on threat, distance, visibility\r\n3. **Decision Making**: Weighted scoring of multiple factors per decision type\r\n4. **Vision System**: Raycast from eye to target with bush penetration checks\r\n5. **Hearing System**: Sound event propagation with distance/occlusion factors\r\n\r\n### Design Patterns\r\n- **Component-based architecture**: Each bot has modular components\r\n- **Event-driven updates**: Components subscribe to enemy/event changes\r\n- **State machines**: Decision states, enemy states, layer states\r\n- **Singleton managers**: GameWorld and BotManager are singletons\r\n- **Object pooling**: Raycast jobs, enemy lists pre-allocated\r\n\r\n---\r\n\r\n## Document Version\r\n- **SAIN Version**: Decompiled from latest version (4.2.0+)\r\n- **Documentation Date**: 2025-11-21\r\n- **Total Files Analyzed**: 682 C# files\r\n- **Source Location**: `E:\\AppDev\\LTsTarkovAI\\SAIN_DECOMPILED`\r\n\r\n## Next Steps\r\n\r\nFor detailed information on any specific system, refer to the individual documentation files listed in the Quick Navigation table above. Each document provides:\r\n- Detailed class and method descriptions\r\n- Code flow explanations\r\n- Implementation notes\r\n- Integration points\r\n- Recreation guidelines\r\n"},"MovementSystem":{"title":"SAIN Movement System Documentation\r","category":"SAIN AI Reference","content":"# SAIN Movement System Documentation\r\n\r\n## Overview\r\nSAIN's movement system includes pathfinding, cover finding, tactical positioning, vaulting, and unstuck mechanics using Unity's NavMesh system.\r\n\r\n## Core Movement Components\r\n\r\n### SAINMoverClass\r\n**Namespace**: `SAIN.SAINComponent.Classes.Mover`\r\n**Purpose**: Control bot movement and pathfinding\r\n\r\n**Movement API:**\r\n```csharp\r\npublic class SAINMoverClass\r\n{\r\n    public bool IsMoving { get; private set; }\r\n    public bool IsSprinting { get; private set; }\r\n    public float CurrentSpeed { get; private set; }\r\n    public Vector3 Destination { get; private set; }\r\n    public NavMeshPath CurrentPath { get; private set; }\r\n\r\n    // Movement commands\r\n    public void MoveTo(Vector3 destination, bool sprint = false)\r\n    {\r\n        Destination = destination;\r\n        IsSprinting = sprint;\r\n\r\n        // Calculate path\r\n        NavMeshPath path = new NavMeshPath();\r\n        if (NavMesh.CalculatePath(Bot.Position, destination, NavMesh.AllAreas, path))\r\n        {\r\n            CurrentPath = path;\r\n            BotOwner.Mover.GoToPoint(destination, sprint);\r\n            IsMoving = true;\r\n        }\r\n    }\r\n\r\n    public void Stop()\r\n    {\r\n        IsMoving = false;\r\n        IsSprinting = false;\r\n        BotOwner.Mover.Stop();\r\n    }\r\n\r\n    public void SetPose(PoseLevel pose)\r\n    {\r\n        BotOwner.SetPose(pose);\r\n    }\r\n\r\n    public void Lean(LeanDirection direction)\r\n    {\r\n        BotOwner.MovementContext.SetTilt(direction);\r\n    }\r\n}\r\n```\r\n\r\n**Speed Control:**\r\n```csharp\r\npublic void SetMoveSpeed(float speed)\r\n{\r\n    // Clamp speed\r\n    speed = Mathf.Clamp(speed, MinSpeed, MaxSpeed);\r\n\r\n    // Apply modifiers\r\n    if (Bot.Suppression.IsSuppressed)\r\n    {\r\n        speed *= 0.7f; // Slower when suppressed\r\n    }\r\n\r\n    if (Bot.Player.Physical.Overweight)\r\n    {\r\n        speed *= 0.8f; // Slower when overweight\r\n    }\r\n\r\n    if (Bot.Cover.InCover && Bot.GoalEnemy != null && Bot.GoalEnemy.IsVisible)\r\n    {\r\n        speed *= 0.6f; // Careful movement in cover under fire\r\n    }\r\n\r\n    BotOwner.SetTargetMoveSpeed(speed);\r\n    CurrentSpeed = speed;\r\n}\r\n```\r\n\r\n---\r\n\r\n### SAINSteeringClass\r\n**Namespace**: `SAIN.SAINComponent.Classes`\r\n**Purpose**: Control look direction and aiming\r\n\r\n**Steering API:**\r\n```csharp\r\npublic void LookToPoint(Vector3 point)\r\n{\r\n    Vector3 direction = (point - Bot.Transform.EyePosition).normalized;\r\n    LookToDirection(direction);\r\n}\r\n\r\npublic void LookToDirection(Vector3 direction)\r\n{\r\n    // Calculate rotation\r\n    Quaternion targetRotation = Quaternion.LookRotation(direction);\r\n\r\n    // Apply smoothing\r\n    float smoothSpeed = CalculateSmoothSpeed();\r\n    Quaternion smoothedRotation = Quaternion.Slerp(\r\n        BotOwner.LookDirection,\r\n        targetRotation,\r\n        smoothSpeed * Time.deltaTime\r\n    );\r\n\r\n    // Set look direction\r\n    BotOwner.Steering.LookToDirection(smoothedRotation * Vector3.forward);\r\n}\r\n\r\nprivate float CalculateSmoothSpeed()\r\n{\r\n    float baseSpeed = GlobalSettings.Look.BASE_LOOK_SPEED;\r\n\r\n    // Faster when tracking visible enemy\r\n    if (Bot.GoalEnemy != null && Bot.GoalEnemy.IsVisible)\r\n    {\r\n        baseSpeed *= 2f;\r\n    }\r\n\r\n    // Slower when suppressed\r\n    if (Bot.Suppression.IsSuppressed)\r\n    {\r\n        baseSpeed *= 0.5f;\r\n    }\r\n\r\n    return baseSpeed;\r\n}\r\n```\r\n\r\n**Predictive Look Smoothing:**\r\n```csharp\r\npublic class PredictiveLookSmoothing\r\n{\r\n    public Vector3 GetSmoothedLookTarget(Enemy enemy)\r\n    {\r\n        Vector3 enemyPos = enemy.EnemyPosition;\r\n        Vector3 enemyVelocity = enemy.EnemyPlayerData.Velocity;\r\n\r\n        // Predict future position\r\n        float predictionTime = CalculatePredictionTime(enemy.RealDistance);\r\n        Vector3 predictedPos = enemyPos + (enemyVelocity * predictionTime);\r\n\r\n        // Smooth toward predicted position\r\n        return Vector3.Lerp(CurrentLookTarget, predictedPos, SmoothFactor * Time.deltaTime);\r\n    }\r\n\r\n    private float CalculatePredictionTime(float distance)\r\n    {\r\n        // Further enemies need more prediction\r\n        return Mathf.Clamp(distance / 100f, 0.1f, 0.5f);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Cover System\r\n\r\n### Cover Finding (CoverFinder)\r\n**Namespace**: `SAIN.SAINComponent.SubComponents.CoverFinder`\r\n**Purpose**: Find tactically sound cover positions\r\n\r\n**Cover Search:**\r\n```csharp\r\npublic List<CoverPoint> FindCoverPoints(Vector3 searchOrigin, Vector3 threatOrigin, float searchRadius)\r\n{\r\n    List<CoverPoint> coverPoints = new List<CoverPoint>();\r\n\r\n    // Use global cover manager pool if available\r\n    CoverPoint[] existingPoints = CoverManager.GetNearbyPoints(searchOrigin, searchRadius);\r\n    if (existingPoints.Length > 0)\r\n    {\r\n        return existingPoints.ToList();\r\n    }\r\n\r\n    // Otherwise search for new cover\r\n    return SearchForNewCover(searchOrigin, threatOrigin, searchRadius);\r\n}\r\n\r\nprivate List<CoverPoint> SearchForNewCover(Vector3 origin, Vector3 threat, float radius)\r\n{\r\n    List<CoverPoint> points = new List<CoverPoint>();\r\n\r\n    // Sphere cast around origin to find obstacles\r\n    Collider[] colliders = Physics.OverlapSphere(origin, radius, CoverLayerMask);\r\n\r\n    foreach (Collider collider in colliders)\r\n    {\r\n        // Evaluate collider as potential cover\r\n        CoverPoint[] pointsFromCollider = AnalyzeColliderForCover(collider, origin, threat);\r\n        points.AddRange(pointsFromCollider);\r\n    }\r\n\r\n    return points;\r\n}\r\n```\r\n\r\n**Cover Analysis:**\r\n```csharp\r\nprivate CoverPoint[] AnalyzeColliderForCover(Collider collider, Vector3 botPos, Vector3 threatPos)\r\n{\r\n    List<CoverPoint> points = new List<CoverPoint>();\r\n\r\n    // Get collider bounds\r\n    Bounds bounds = collider.bounds;\r\n\r\n    // Test sample points around collider\r\n    int sampleCount = 8; // Points around perimeter\r\n    for (int i = 0; i < sampleCount; i++)\r\n    {\r\n        float angle = (360f / sampleCount) * i;\r\n        Vector3 samplePoint = CalculateSamplePoint(bounds, angle);\r\n\r\n        // Check if point provides cover\r\n        CoverAnalysis analysis = AnalyzeCoverAtPoint(samplePoint, threatPos);\r\n\r\n        if (analysis.CoverValue > MinCoverValue)\r\n        {\r\n            CoverPoint point = new CoverPoint\r\n            {\r\n                Position = samplePoint,\r\n                Normal = analysis.CoverNormal,\r\n                CoverHeight = analysis.Height,\r\n                CoverValue = analysis.CoverValue,\r\n                Collider = collider\r\n            };\r\n\r\n            points.Add(point);\r\n        }\r\n    }\r\n\r\n    return points.ToArray();\r\n}\r\n```\r\n\r\n**Cover Quality:**\r\n```csharp\r\nprivate CoverAnalysis AnalyzeCoverAtPoint(Vector3 point, Vector3 threat)\r\n{\r\n    Vector3 toThreat = (threat - point).normalized;\r\n\r\n    // Raycast from threat to point\r\n    bool blocked = Physics.Raycast(threat, -toThreat,\r\n                                   out RaycastHit hit,\r\n                                   Vector3.Distance(threat, point),\r\n                                   CoverLayerMask);\r\n\r\n    if (!blocked)\r\n    {\r\n        return new CoverAnalysis { CoverValue = 0f }; // No cover\r\n    }\r\n\r\n    // Calculate cover quality\r\n    float coverHeight = hit.point.y - point.y;\r\n    float coverValue = CalculateCoverValue(hit, coverHeight);\r\n\r\n    return new CoverAnalysis\r\n    {\r\n        CoverValue = coverValue,\r\n        CoverNormal = hit.normal,\r\n        Height = coverHeight,\r\n        HitPoint = hit.point\r\n    };\r\n}\r\n\r\nprivate float CalculateCoverValue(RaycastHit hit, float height)\r\n{\r\n    float value = 0f;\r\n\r\n    // Height-based value\r\n    if (height > 2f)\r\n        value = 1f; // Full cover\r\n    else if (height > 1.5f)\r\n        value = 0.8f; // High cover\r\n    else if (height > 1f)\r\n        value = 0.6f; // Medium cover\r\n    else if (height > 0.5f)\r\n        value = 0.4f; // Low cover\r\n    else\r\n        value = 0.2f; // Minimal cover\r\n\r\n    // Bonus for solid materials\r\n    if (IsSolidMaterial(hit.collider))\r\n    {\r\n        value *= 1.2f;\r\n    }\r\n\r\n    return Mathf.Clamp01(value);\r\n}\r\n```\r\n\r\n---\r\n\r\n### SAINCoverClass\r\n**Namespace**: `SAIN.SAINComponent.Classes`\r\n**Purpose**: Manage bot's cover usage\r\n\r\n**Cover State:**\r\n```csharp\r\npublic CoverPoint CoverInUse { get; private set; }\r\npublic bool InCover => CoverInUse != null;\r\npublic bool SprintingToCover { get; private set; }\r\npublic float TimeSinceEnteredCover { get; private set; }\r\n\r\npublic void SeekCover(Enemy enemy)\r\n{\r\n    // Find cover\r\n    CoverPoint cover = FindBestCover(enemy);\r\n    if (cover == null) return;\r\n\r\n    // Move to cover\r\n    bool sprint = ShouldSprintToCover(enemy, cover);\r\n    MoveToCover(cover, sprint);\r\n}\r\n\r\nprivate bool ShouldSprintToCover(Enemy enemy, CoverPoint cover)\r\n{\r\n    // Sprint if enemy can see bot\r\n    if (enemy.IsVisible) return true;\r\n\r\n    // Sprint if under fire\r\n    if (Bot.Medical.TimeSinceShot < 2f) return true;\r\n\r\n    // Sprint if cover is far\r\n    float distance = Vector3.Distance(Bot.Position, cover.Position);\r\n    if (distance > 20f) return true;\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n**Cover Behavior:**\r\n```csharp\r\npublic void UpdateCoverBehavior()\r\n{\r\n    if (!InCover) return;\r\n\r\n    TimeSinceEnteredCover += Time.deltaTime;\r\n\r\n    Enemy enemy = Bot.GoalEnemy;\r\n    if (enemy == null) return;\r\n\r\n    // Peek-shoot pattern\r\n    if (_peekTimer <= 0f)\r\n    {\r\n        if (_inPeek)\r\n        {\r\n            // Duck back to cover\r\n            DuckToCover();\r\n            _peekTimer = Random.Range(PeekCooldownMin, PeekCooldownMax);\r\n            _inPeek = false;\r\n        }\r\n        else\r\n        {\r\n            // Peek from cover\r\n            PeekFromCover();\r\n            _peekTimer = Random.Range(PeekDurationMin, PeekDurationMax);\r\n            _inPeek = true;\r\n        }\r\n    }\r\n\r\n    _peekTimer -= Time.deltaTime;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Tactical Positioning\r\n\r\n### Positioning Logic\r\n```csharp\r\npublic Vector3 FindTacticalPosition(Enemy enemy)\r\n{\r\n    Vector3 enemyPos = enemy.EnemyPosition;\r\n    Vector3 botPos = Bot.Position;\r\n\r\n    ECombatDecision decision = Bot.Decision.CurrentCombatDecision;\r\n\r\n    return decision switch\r\n    {\r\n        ECombatDecision.RushEnemy => FindRushPosition(enemyPos),\r\n        ECombatDecision.Retreat => FindRetreatPosition(enemyPos),\r\n        ECombatDecision.MoveToEngage => FindEngagePosition(enemyPos),\r\n        ECombatDecision.ShiftCover => FindShiftCoverPosition(enemyPos),\r\n        _ => botPos\r\n    };\r\n}\r\n\r\nprivate Vector3 FindRushPosition(Vector3 enemyPos)\r\n{\r\n    Vector3 toEnemy = (enemyPos - Bot.Position).normalized;\r\n\r\n    // Position slightly to side for flanking\r\n    Vector3 flankOffset = Vector3.Cross(toEnemy, Vector3.up) * Random.Range(-5f, 5f);\r\n\r\n    // Move most of the way to enemy\r\n    Vector3 targetPos = enemyPos - (toEnemy * 10f) + flankOffset;\r\n\r\n    // Ensure valid NavMesh position\r\n    if (NavMesh.SamplePosition(targetPos, out NavMeshHit hit, 5f, NavMesh.AllAreas))\r\n    {\r\n        return hit.position;\r\n    }\r\n\r\n    return Bot.Position;\r\n}\r\n\r\nprivate Vector3 FindRetreatPosition(Vector3 enemyPos)\r\n{\r\n    Vector3 awayFromEnemy = (Bot.Position - enemyPos).normalized;\r\n\r\n    // Find position away from enemy\r\n    Vector3 targetPos = Bot.Position + (awayFromEnemy * 30f);\r\n\r\n    // Add lateral offset for unpredictability\r\n    Vector3 lateralOffset = Vector3.Cross(awayFromEnemy, Vector3.up) * Random.Range(-10f, 10f);\r\n    targetPos += lateralOffset;\r\n\r\n    // Find cover at retreat position\r\n    CoverPoint retreatCover = FindCoverNear(targetPos, enemyPos);\r\n    if (retreatCover != null)\r\n    {\r\n        return retreatCover.Position;\r\n    }\r\n\r\n    // Or just valid NavMesh position\r\n    if (NavMesh.SamplePosition(targetPos, out NavMeshHit hit, 10f, NavMesh.AllAreas))\r\n    {\r\n        return hit.position;\r\n    }\r\n\r\n    return Bot.Position;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Vaulting and Obstacles\r\n\r\n### SAINVaultClass\r\n**Namespace**: `SAIN.SAINComponent.Classes`\r\n**Purpose**: Handle vaulting over obstacles\r\n\r\n**Vault Detection:**\r\n```csharp\r\npublic bool CheckForVaultableObstacle(out Vector3 vaultPoint)\r\n{\r\n    // Raycast forward to detect obstacle\r\n    Vector3 origin = Bot.Position + Vector3.up * 0.5f;\r\n    Vector3 forward = Bot.Transform.Forward;\r\n\r\n    if (Physics.Raycast(origin, forward, out RaycastHit hit, VaultCheckDistance))\r\n    {\r\n        // Check if obstacle is vaultable height\r\n        float obstacleHeight = hit.point.y - Bot.Position.y;\r\n\r\n        if (obstacleHeight > MinVaultHeight && obstacleHeight < MaxVaultHeight)\r\n        {\r\n            // Check if there's space to land\r\n            if (CheckLandingSpace(hit.point, forward, out Vector3 landingPoint))\r\n            {\r\n                vaultPoint = landingPoint;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    vaultPoint = Vector3.zero;\r\n    return false;\r\n}\r\n\r\nprivate bool CheckLandingSpace(Vector3 obstacleTop, Vector3 direction, out Vector3 landing)\r\n{\r\n    // Raycast from obstacle top to find landing\r\n    Vector3 checkStart = obstacleTop + Vector3.up * 0.5f + direction * 0.5f;\r\n\r\n    if (Physics.Raycast(checkStart, Vector3.down, out RaycastHit hit, 5f))\r\n    {\r\n        landing = hit.point;\r\n        return true;\r\n    }\r\n\r\n    landing = Vector3.zero;\r\n    return false;\r\n}\r\n```\r\n\r\n**Vault Execution:**\r\n```csharp\r\npublic void ExecuteVault(Vector3 vaultPoint)\r\n{\r\n    // Trigger vault animation\r\n    BotOwner.MovementContext.TryVault();\r\n\r\n    // Queue movement to vault point\r\n    Bot.Mover.MoveTo(vaultPoint);\r\n\r\n    IsVaulting = true;\r\n    VaultStartTime = Time.time;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Unstuck System\r\n\r\n### SAINBotUnstuckClass\r\n**Namespace**: `SAIN.SAINComponent.Classes`\r\n**Purpose**: Detect and resolve stuck situations\r\n\r\n**Stuck Detection:**\r\n```csharp\r\npublic void CheckIfStuck()\r\n{\r\n    if (!Bot.Mover.IsMoving) return;\r\n\r\n    // Track position over time\r\n    float distanceMoved = Vector3.Distance(Bot.Position, _lastCheckPosition);\r\n\r\n    if (distanceMoved < StuckDistanceThreshold)\r\n    {\r\n        _stuckTime += Time.deltaTime;\r\n\r\n        if (_stuckTime > StuckTimeThreshold)\r\n        {\r\n            OnBotStuck();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        _stuckTime = 0f;\r\n    }\r\n\r\n    _lastCheckPosition = Bot.Position;\r\n}\r\n\r\nprivate void OnBotStuck()\r\n{\r\n    Logger.LogWarning($\"Bot {Bot.Player.Profile.Nickname} is stuck!\");\r\n\r\n    // Attempt unstuck\r\n    AttemptUnstuck();\r\n}\r\n```\r\n\r\n**Unstuck Methods:**\r\n```csharp\r\nprivate void AttemptUnstuck()\r\n{\r\n    UnstuckMethod method = SelectUnstuckMethod();\r\n\r\n    switch (method)\r\n    {\r\n        case UnstuckMethod.Recalculate:\r\n            RecalculatePath();\r\n            break;\r\n\r\n        case UnstuckMethod.FindAlternate:\r\n            FindAlternatePath();\r\n            break;\r\n\r\n        case UnstuckMethod.Jump:\r\n            TryJump();\r\n            break;\r\n\r\n        case UnstuckMethod.Teleport:\r\n            TeleportToValidPosition();\r\n            break;\r\n    }\r\n}\r\n\r\nprivate void RecalculatePath()\r\n{\r\n    // Recalculate path to current destination\r\n    Bot.Mover.Stop();\r\n    Bot.Mover.MoveTo(Bot.Mover.Destination);\r\n}\r\n\r\nprivate void FindAlternatePath()\r\n{\r\n    // Find alternate point near destination\r\n    Vector3 alternate = FindNearbyValidPosition(Bot.Mover.Destination, 10f);\r\n    Bot.Mover.MoveTo(alternate);\r\n}\r\n\r\nprivate void TryJump()\r\n{\r\n    // Jump to clear small obstacle\r\n    BotOwner.MovementContext.TryJump();\r\n}\r\n\r\nprivate void TeleportToValidPosition()\r\n{\r\n    // Last resort - teleport to valid NavMesh\r\n    if (NavMesh.SamplePosition(Bot.Position, out NavMeshHit hit, 5f, NavMesh.AllAreas))\r\n    {\r\n        Bot.Player.Teleport(hit.position);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Path Management\r\n\r\n### Path Distance Tracking\r\n```csharp\r\npublic enum EPathDistance\r\n{\r\n    VeryClose,  // < 10m\r\n    Close,      // 10-30m\r\n    Mid,        // 30-75m\r\n    Far,        // 75-150m\r\n    VeryFar     // > 150m\r\n}\r\n\r\npublic class SAINEnemyPath\r\n{\r\n    public NavMeshPath PathToEnemy { get; private set; }\r\n    public float PathDistance { get; private set; }\r\n    public EPathDistance EPathDistance { get; private set; }\r\n    public Vector3[] PathCorners { get; private set; }\r\n\r\n    public void UpdatePath(Enemy enemy)\r\n    {\r\n        // Calculate NavMesh path to enemy\r\n        NavMeshPath path = new NavMeshPath();\r\n        if (NavMesh.CalculatePath(Bot.Position, enemy.EnemyPosition, NavMesh.AllAreas, path))\r\n        {\r\n            PathToEnemy = path;\r\n            PathCorners = path.corners;\r\n            PathDistance = CalculatePathLength(path);\r\n            EPathDistance = CategorizePath Distance(PathDistance);\r\n        }\r\n    }\r\n\r\n    private float CalculatePathLength(NavMeshPath path)\r\n    {\r\n        float length = 0f;\r\n        for (int i = 0; i < path.corners.Length - 1; i++)\r\n        {\r\n            length += Vector3.Distance(path.corners[i], path.corners[i + 1]);\r\n        }\r\n        return length;\r\n    }\r\n\r\n    private EPathDistance CategorizePathDistance(float distance)\r\n    {\r\n        if (distance < 10f) return EPathDistance.VeryClose;\r\n        if (distance < 30f) return EPathDistance.Close;\r\n        if (distance < 75f) return EPathDistance.Mid;\r\n        if (distance < 150f) return EPathDistance.Far;\r\n        return EPathDistance.VeryFar;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\nSAIN's movement system provides:\r\n\r\n1. **NavMesh Pathfinding** - Reliable navigation using Unity NavMesh\r\n2. **Tactical Positioning** - Context-aware position selection\r\n3. **Cover System** - Find, evaluate, and use cover effectively\r\n4. **Smooth Steering** - Natural look direction changes\r\n5. **Vaulting** - Obstacle traversal\r\n6. **Unstuck Logic** - Automatic recovery from stuck states\r\n7. **Speed Control** - Situation-appropriate movement speeds\r\n\r\nAll systems work together to create realistic, tactical bot movement and positioning.\r\n"},"PatchesIntegration":{"title":"SAIN Patches and SPT Integration\r","category":"SAIN AI Reference","content":"# SAIN Patches and SPT Integration\r\n\r\n## Overview\r\nSAIN uses Harmony patching to integrate with Escape from Tarkov and SPT-AKI. Patches intercept game methods to inject SAIN behavior while maintaining compatibility with the base game and other mods.\r\n\r\n## Patch Categories\r\n\r\n### 1. Component Patches\r\n**Location**: `SAIN.Patches.Components`\r\n**Purpose**: Inject SAIN components into game objects\r\n\r\n**BotOwner Component Injection:**\r\n```csharp\r\n[HarmonyPatch(typeof(BotOwner), \"Activate\")]\r\npublic class BotOwnerActivatePatch\r\n{\r\n    [HarmonyPostfix]\r\n    public static void PatchPostfix(BotOwner __instance)\r\n    {\r\n        // Attach SAIN components when bot activates\r\n        BotComponent sain = BotSpawnController.Instance.GetOrCreateSAIN(__instance);\r\n\r\n        if (sain != null)\r\n        {\r\n            sain.ActivateIfBotActive(__instance);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**PlayerComponent Injection:**\r\n```csharp\r\n[HarmonyPatch(typeof(Player), \"Init\")]\r\npublic class PlayerInitPatch\r\n{\r\n    [HarmonyPostfix]\r\n    public static void PatchPostfix(Player __instance)\r\n    {\r\n        // Attach PlayerComponent to all players\r\n        if (__instance.gameObject.GetComponent<PlayerComponent>() == null)\r\n        {\r\n            PlayerComponent playerComp = __instance.gameObject.AddComponent<PlayerComponent>();\r\n            playerComp.Init(__instance);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 2. Vision Patches\r\n**Location**: `SAIN.Patches.Vision`\r\n**Purpose**: Modify vision and detection mechanics\r\n\r\n**Vision Distance Patch:**\r\n```csharp\r\n[HarmonyPatch(typeof(BotOwner), \"CalcGoalEnemy\")]\r\npublic class CalcGoalEnemyPatch\r\n{\r\n    [HarmonyPrefix]\r\n    public static bool PatchPrefix(BotOwner __instance)\r\n    {\r\n        // Let SAIN handle enemy selection\r\n        BotComponent sain = BotSpawnController.Instance.GetSAIN(__instance);\r\n\r\n        if (sain != null && sain.BotActive)\r\n        {\r\n            // SAIN controls enemy selection\r\n            sain.EnemyController.ChooseEnemy();\r\n            return false; // Skip original method\r\n        }\r\n\r\n        return true; // Use original if SAIN not active\r\n    }\r\n}\r\n```\r\n\r\n**Line of Sight Patch:**\r\n```csharp\r\n[HarmonyPatch(typeof(BotsGroup), \"HasVisionContact\")]\r\npublic class HasVisionContactPatch\r\n{\r\n    [HarmonyPostfix]\r\n    public static void PatchPostfix(ref bool __result, BotsGroup __instance, IPlayer player)\r\n    {\r\n        // Add SAIN vision logic\r\n        if (__result) return; // Already has contact\r\n\r\n        BotOwner botOwner = __instance.BotOwner;\r\n        BotComponent sain = BotSpawnController.Instance.GetSAIN(botOwner);\r\n\r\n        if (sain != null)\r\n        {\r\n            // Check SAIN vision system\r\n            Enemy enemy = sain.EnemyController.GetEnemy(player.ProfileId, false);\r\n            if (enemy != null && enemy.IsVisible)\r\n            {\r\n                __result = true;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3. Hearing Patches\r\n**Location**: `SAIN.Patches.Hearing`\r\n**Purpose**: Intercept sound events for custom hearing system\r\n\r\n**Sound Play Patch:**\r\n```csharp\r\n[HarmonyPatch(typeof(Player), \"OnMakingShot\")]\r\npublic class OnMakingShotPatch\r\n{\r\n    [HarmonyPostfix]\r\n    public static void PatchPostfix(Player __instance)\r\n    {\r\n        // Notify SAIN hearing system of gunshot\r\n        Vector3 position = __instance.Position;\r\n        float volume = 1.0f;\r\n\r\n        BroadcastSound(SAINSoundType.GunShot, position, volume, __instance);\r\n    }\r\n\r\n    private static void BroadcastSound(SAINSoundType type, Vector3 pos, float volume, Player source)\r\n    {\r\n        // Notify all SAIN bots\r\n        foreach (BotComponent bot in BotManagerComponent.Instance.Bots.Values)\r\n        {\r\n            if (bot.BotActive)\r\n            {\r\n                bot.Hearing.OnSoundPlayed(type, pos, volume, source);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Footstep Patch:**\r\n```csharp\r\n[HarmonyPatch(typeof(Player), \"OnStepSound\")]\r\npublic class OnStepSoundPatch\r\n{\r\n    [HarmonyPostfix]\r\n    public static void PatchPostfix(Player __instance, float volume)\r\n    {\r\n        BroadcastSound(SAINSoundType.Footstep, __instance.Position, volume * 0.5f, __instance);\r\n    }\r\n}\r\n```\r\n\r\n### 4. Shooting Patches\r\n**Location**: `SAIN.Patches.Shoot.*`\r\n\r\n**Aim Patch:**\r\n```csharp\r\n[HarmonyPatch(typeof(BotOwner), \"method_CalculateAimOffset\")]\r\npublic class AimOffsetPatch\r\n{\r\n    [HarmonyPrefix]\r\n    public static bool PatchPrefix(BotOwner __instance, ref Vector3 __result)\r\n    {\r\n        BotComponent sain = BotSpawnController.Instance.GetSAIN(__instance);\r\n\r\n        if (sain != null && sain.BotActive && sain.GoalEnemy != null)\r\n        {\r\n            // Use SAIN aim calculation\r\n            __result = sain.Aim.GetAimOffset(sain.GoalEnemy);\r\n            return false; // Skip original\r\n        }\r\n\r\n        return true; // Use original\r\n    }\r\n}\r\n```\r\n\r\n**Rate of Fire Patch:**\r\n```csharp\r\n[HarmonyPatch(typeof(BotOwner), \"method_FireRateControl\")]\r\npublic class FireRateControlPatch\r\n{\r\n    [HarmonyPostfix]\r\n    public static void PatchPostfix(BotOwner __instance, ref float __result)\r\n    {\r\n        BotComponent sain = BotSpawnController.Instance.GetSAIN(__instance);\r\n\r\n        if (sain != null && sain.BotActive)\r\n        {\r\n            // Apply SAIN fire rate modifications\r\n            PersonalitySettings personality = sain.Info.PersonalitySettings;\r\n\r\n            __result *= personality.Shoot.FIRE_RATE_MULT;\r\n\r\n            // Additional modifiers\r\n            if (sain.Suppression.IsSuppressed)\r\n            {\r\n                __result *= 0.7f; // Slower when suppressed\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Grenade Patch:**\r\n```csharp\r\n[HarmonyPatch(typeof(BotOwner), \"method_ThrowGrenade\")]\r\npublic class ThrowGrenadePatch\r\n{\r\n    [HarmonyPrefix]\r\n    public static bool PatchPrefix(BotOwner __instance)\r\n    {\r\n        BotComponent sain = BotSpawnController.Instance.GetSAIN(__instance);\r\n\r\n        if (sain != null && sain.BotActive)\r\n        {\r\n            // Use SAIN grenade system\r\n            if (sain.Decision.CurrentCombatDecision == ECombatDecision.ThrowGrenade)\r\n            {\r\n                sain.Grenade.ExecuteThrow();\r\n            }\r\n            return false; // Skip original\r\n        }\r\n\r\n        return true; // Use original\r\n    }\r\n}\r\n```\r\n\r\n### 5. Movement Patches\r\n**Location**: `SAIN.Patches.Movement`\r\n\r\n**Sprint Patch:**\r\n```csharp\r\n[HarmonyPatch(typeof(BotMover), \"Sprint\")]\r\npublic class SprintPatch\r\n{\r\n    [HarmonyPrefix]\r\n    public static bool PatchPrefix(BotMover __instance, bool sprint)\r\n    {\r\n        BotOwner botOwner = __instance.BotOwner;\r\n        BotComponent sain = BotSpawnController.Instance.GetSAIN(botOwner);\r\n\r\n        if (sain != null && sain.BotActive)\r\n        {\r\n            // SAIN controls sprinting\r\n            return false; // Skip original\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n**Pose Patch:**\r\n```csharp\r\n[HarmonyPatch(typeof(BotOwner), \"SetPose\")]\r\npublic class SetPosePatch\r\n{\r\n    [HarmonyPostfix]\r\n    public static void PatchPostfix(BotOwner __instance, float pose)\r\n    {\r\n        BotComponent sain = BotSpawnController.Instance.GetSAIN(__instance);\r\n\r\n        if (sain != null && sain.BotActive)\r\n        {\r\n            // Track pose changes\r\n            PoseLevel poseLevel = ConvertPose(pose);\r\n            sain.Info.CurrentPose = poseLevel;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 6. Talk Patches\r\n**Location**: `SAIN.Patches.Talk`\r\n\r\n**Phrase Trigger Patch:**\r\n```csharp\r\n[HarmonyPatch(typeof(BotTalk), \"Say\")]\r\npublic class BotTalkSayPatch\r\n{\r\n    [HarmonyPrefix]\r\n    public static bool PatchPrefix(BotTalk __instance, EPhraseTrigger trigger)\r\n    {\r\n        BotOwner botOwner = __instance.BotOwner;\r\n        BotComponent sain = BotSpawnController.Instance.GetSAIN(botOwner);\r\n\r\n        if (sain != null && sain.BotActive)\r\n        {\r\n            // Let SAIN manage voice lines\r\n            return sain.Talk.ShouldAllowVoiceLine(trigger);\r\n        }\r\n\r\n        return true; // Allow by default\r\n    }\r\n}\r\n```\r\n\r\n### 7. Generic Fixes\r\n**Location**: `SAIN.Patches.Generic.Fixes`\r\n\r\n**Brain Verification Patch:**\r\n```csharp\r\n[HarmonyPatch(typeof(BotOwner), \"InitBrain\")]\r\npublic class InitBrainPatch\r\n{\r\n    [HarmonyPostfix]\r\n    public static void PatchPostfix(BotOwner __instance)\r\n    {\r\n        // Ensure BigBrain layers are added\r\n        BotComponent sain = BotSpawnController.Instance.GetSAIN(__instance);\r\n\r\n        if (sain != null)\r\n        {\r\n            AddBigBrainLayers(__instance);\r\n        }\r\n    }\r\n\r\n    private static void AddBigBrainLayers(BotOwner botOwner)\r\n    {\r\n        BaseBrain brain = botOwner.Brain.BaseBrain;\r\n\r\n        // Add SAIN layers in priority order\r\n        brain.AddLayer(new SAINAvoidThreatLayer(botOwner, 100));\r\n        brain.AddLayer(new ExtractLayer(botOwner, 90));\r\n        brain.AddLayer(new CombatSoloLayer(botOwner, 80));\r\n        brain.AddLayer(new CombatSquadLayer(botOwner, 70));\r\n        brain.AddLayer(new RunToCoverLayer(botOwner, 60));\r\n    }\r\n}\r\n```\r\n\r\n## BigBrain Integration\r\n\r\n### Layer System\r\n\r\nSAIN uses BigBrain's custom layer system to inject AI behavior:\r\n\r\n```csharp\r\n// BigBrain provides CustomLayer base class\r\npublic abstract class SAINLayer : CustomLayer\r\n{\r\n    protected SAINLayer(BotOwner botOwner, int priority, string layerName)\r\n    {\r\n        // BigBrain constructor\r\n        base._002Ector(botOwner, priority);\r\n    }\r\n\r\n    // BigBrain calls this to check layer activation\r\n    public abstract override CustomLayerDelgateResult GetLayerResult();\r\n\r\n    // BigBrain calls this each frame when active\r\n    public abstract override void Update();\r\n}\r\n```\r\n\r\n**Layer Registration:**\r\n```csharp\r\npublic class BigBrainIntegration\r\n{\r\n    public static void RegisterLayers()\r\n    {\r\n        // Register with BigBrain\r\n        BigBrainManager.RegisterLayerFactory(CreateSAINLayers);\r\n    }\r\n\r\n    private static IEnumerable<CustomLayer> CreateSAINLayers(BotOwner botOwner)\r\n    {\r\n        // Return SAIN layers for this bot\r\n        yield return new SAINAvoidThreatLayer(botOwner, 100);\r\n        yield return new ExtractLayer(botOwner, 90);\r\n        yield return new CombatSoloLayer(botOwner, 80);\r\n        yield return new CombatSquadLayer(botOwner, 70);\r\n        yield return new RunToCoverLayer(botOwner, 60);\r\n    }\r\n}\r\n```\r\n\r\n## SPT-AKI Compatibility\r\n\r\n### Version Checking\r\n\r\n```csharp\r\npublic class SAINDifficulty\r\n{\r\n    private static string SPT_VERSION;\r\n\r\n    public static void CheckSPTVersion()\r\n    {\r\n        // Get SPT version\r\n        Assembly sptAssembly = Assembly.GetAssembly(typeof(BotOwner));\r\n        Version version = sptAssembly.GetName().Version;\r\n\r\n        SPT_VERSION = $\"{version.Major}.{version.Minor}.{version.Build}\";\r\n\r\n        Logger.LogInfo($\"SPT Version Detected: {SPT_VERSION}\");\r\n\r\n        // Check compatibility\r\n        if (!IsCompatible(version))\r\n        {\r\n            Logger.LogError($\"SAIN may not be compatible with SPT {SPT_VERSION}!\");\r\n        }\r\n    }\r\n\r\n    private static bool IsCompatible(Version version)\r\n    {\r\n        // SAIN compatible SPT versions\r\n        if (version.Major == 3 && version.Minor >= 9) return true; // 3.9.x\r\n        if (version.Major == 4 && version.Minor <= 5) return true; // 4.0-4.5\r\n\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n### Dependency Management\r\n\r\n```csharp\r\npublic class DependencyChecker\r\n{\r\n    public static void CheckDependencies()\r\n    {\r\n        // Required: BigBrain\r\n        if (!IsBigBrainLoaded())\r\n        {\r\n            Logger.LogError(\"BigBrain is required for SAIN! Please install BigBrain.\");\r\n            return;\r\n        }\r\n\r\n        // Optional: Realism Mod\r\n        if (ModDetection.RealismLoaded)\r\n        {\r\n            Logger.LogInfo(\"Realism Mod detected - applying compatibility patches.\");\r\n            ApplyRealismCompatibility();\r\n        }\r\n\r\n        // Optional: Questing Bots\r\n        if (ModDetection.QuestingBotsLoaded)\r\n        {\r\n            Logger.LogInfo(\"Questing Bots detected - integrating SAIN quest awareness.\");\r\n            IntegrateQuestingBots();\r\n        }\r\n\r\n        // Optional: FIKA\r\n        if (ModDetection.ProjectFikaLoaded)\r\n        {\r\n            Logger.LogInfo(\"FIKA detected - enabling multiplayer compatibility.\");\r\n            EnableFIKACompatibility();\r\n        }\r\n    }\r\n\r\n    private static bool IsBigBrainLoaded()\r\n    {\r\n        return Chainloader.PluginInfos.ContainsKey(\"DrakiaXYZ.BigBrain\");\r\n    }\r\n}\r\n```\r\n\r\n## Mod Compatibility\r\n\r\n### Detected Mods\r\n\r\n```csharp\r\npublic static class ModDetection\r\n{\r\n    public static bool RealismLoaded { get; private set; }\r\n    public static bool QuestingBotsLoaded { get; private set; }\r\n    public static bool ProjectFikaLoaded { get; private set; }\r\n    public static bool ProjectFikaHeadlessLoaded { get; private set; }\r\n\r\n    public static void CheckPlugins()\r\n    {\r\n        if (Chainloader.PluginInfos.ContainsKey(\"com.fika.core\"))\r\n        {\r\n            ProjectFikaLoaded = true;\r\n            Logger.LogInfo(\"SAIN: Project Fika Detected.\");\r\n        }\r\n\r\n        if (Chainloader.PluginInfos.ContainsKey(\"com.DanW.QuestingBots\"))\r\n        {\r\n            QuestingBotsLoaded = true;\r\n            Logger.LogInfo(\"SAIN: Questing Bots Detected.\");\r\n        }\r\n\r\n        if (Chainloader.PluginInfos.ContainsKey(\"RealismMod\"))\r\n        {\r\n            RealismLoaded = true;\r\n            Logger.LogInfo(\"SAIN: Realism Detected.\");\r\n            UpdateArmorClassCoef(); // Adjust for Realism's armor changes\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### FIKA Compatibility\r\n\r\n```csharp\r\npublic class FIKAIntegration\r\n{\r\n    public static void EnableMultiplayerSupport()\r\n    {\r\n        // Disable certain SAIN features for multiplayer\r\n        GlobalSettings.AI_LIMIT_ENABLED = false; // Don't limit AI in multiplayer\r\n\r\n        // Sync enemy information across clients\r\n        EnableEnemySyncing();\r\n\r\n        // Adjust bot behavior for multiplayer\r\n        GlobalSettings.Mind.DETECTION_SPEED *= 1.2f; // Slightly faster for fairness\r\n    }\r\n\r\n    private static void EnableEnemySyncing()\r\n    {\r\n        // FIKA handles enemy syncing - SAIN observes\r\n        Logger.LogInfo(\"SAIN: Enemy syncing delegated to FIKA.\");\r\n    }\r\n}\r\n```\r\n\r\n## Plugin Lifecycle\r\n\r\n### Initialization\r\n\r\n```csharp\r\n[BepInPlugin(\"me.sol.sain\", \"SAIN\", \"4.2.0\")]\r\n[BepInDependency(\"DrakiaXYZ.BigBrain\", \"1.0.0\")]\r\npublic class SAINPlugin : BaseUnityPlugin\r\n{\r\n    private void Awake()\r\n    {\r\n        Logger = base.Logger;\r\n\r\n        // Check dependencies\r\n        DependencyChecker.CheckDependencies();\r\n\r\n        // Check SPT version\r\n        SAINDifficulty.CheckSPTVersion();\r\n\r\n        // Detect other mods\r\n        ModDetection.CheckPlugins();\r\n\r\n        // Apply Harmony patches\r\n        Harmony harmony = new Harmony(\"me.sol.sain\");\r\n        harmony.PatchAll();\r\n\r\n        // Register BigBrain layers\r\n        BigBrainIntegration.RegisterLayers();\r\n\r\n        // Load configuration\r\n        PresetHandler.LoadDefaultPreset();\r\n\r\n        Logger.LogInfo(\"SAIN Plugin Loaded!\");\r\n    }\r\n}\r\n```\r\n\r\n## Patch Best Practices\r\n\r\n### 1. Prefix vs Postfix\r\n\r\n**Use Prefix when:**\r\n- Need to skip original method\r\n- Need to modify input parameters\r\n- Need to prevent method execution\r\n\r\n**Use Postfix when:**\r\n- Need to modify return value\r\n- Need to add behavior after original\r\n- Need to read original method results\r\n\r\n### 2. Transpiler Usage\r\n\r\nSAIN avoids transpilers due to complexity and SPT version compatibility issues. Prefer prefix/postfix when possible.\r\n\r\n### 3. Error Handling\r\n\r\n```csharp\r\n[HarmonyPatch(typeof(SomeClass), \"SomeMethod\")]\r\npublic class SomePatch\r\n{\r\n    [HarmonyPrefix]\r\n    public static bool PatchPrefix(SomeClass __instance)\r\n    {\r\n        try\r\n        {\r\n            // Patch logic\r\n            return DoSAINLogic(__instance);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Logger.LogError($\"Error in SomePatch: {ex}\");\r\n            return true; // Fallback to original\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Summary\r\n\r\nSAIN integrates with SPT-AKI through:\r\n\r\n1. **Harmony Patches** - Intercept game methods for custom behavior\r\n2. **BigBrain Layers** - Inject AI decision layers\r\n3. **Component Injection** - Attach SAIN components to game objects\r\n4. **Event Interception** - Capture sounds, vision, damage events\r\n5. **Mod Detection** - Adapt to other installed mods\r\n6. **Version Checking** - Ensure SPT compatibility\r\n7. **Error Handling** - Graceful degradation if issues occur\r\n\r\nThis integration approach maintains compatibility with the base game and other mods while providing comprehensive AI enhancement.\r\n"},"PersonalityConfig":{"title":"SAIN Personality and Configuration System\r","category":"SAIN AI Reference","content":"# SAIN Personality and Configuration System\r\n\r\n## Overview\r\nSAIN uses a hierarchical configuration system with personalities that modify bot behavior. Configuration flows from Global Settings ‚Üí Bot Type Settings ‚Üí Personality Settings.\r\n\r\n## Personality Types\r\n\r\n```csharp\r\npublic enum EPersonality\r\n{\r\n    Normal,          // Balanced gameplay\r\n    GigaChad,        // Ultra-aggressive, fearless\r\n    Chad,            // Aggressive, confident\r\n    Rat,             // Passive, cautious, ambush-focused\r\n    Coward,          // Extremely passive, retreats often\r\n    Timmy,           // Inexperienced, poor decisions\r\n    SnappingTurtle,  // Defensive, aggressive when close\r\n    Wreckless,       // Aggressive without tactics\r\n    Necromancer      // Zombie/undead behavior\r\n}\r\n```\r\n\r\n### Personality Characteristics\r\n\r\n**GigaChad:**\r\n```csharp\r\n- RUSH_ENABLED: true\r\n- RUSH_CHANCE: 0.8f (80% chance)\r\n- RUSH_DISTANCE_MAX: 100f\r\n- RETREAT_HEALTH_THRESHOLD: 0.1f (fights to near-death)\r\n- DOGFIGHT_AGGRESSION: 1.0f\r\n- SEARCH_AGGRESSION: 1.0f\r\n- GRENADE_CHANCE_COVER: 0.7f\r\n```\r\n\r\n**Rat:**\r\n```csharp\r\n- RUSH_ENABLED: false\r\n- RETREAT_HEALTH_THRESHOLD: 0.7f (retreats early)\r\n- COVER_MIN_VALUE: 0.8f (only uses excellent cover)\r\n- SEARCH_TIME_MAX: 5f (gives up searching quickly)\r\n- AMBUSH_ENABLED: true\r\n- HOLD_POSITION_CHANCE: 0.8f\r\n```\r\n\r\n**Timmy:**\r\n```csharp\r\n- AIM_SCATTER_MULT: 2.5f (poor aim)\r\n- RECOIL_CONTROL: 0.3f (bad recoil management)\r\n- DECISION_DELAY: 2f (slow reactions)\r\n- GRENADE_ENABLED: false\r\n- RETREAT_PANIC_THRESHOLD: 0.6f\r\n```\r\n\r\n## Configuration Architecture\r\n\r\n### Hierarchy\r\n\r\n```\r\nSAINPresetClass\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ GlobalSettings (affects all bots)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Mind\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Hearing\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Vision\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Steering\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Look\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Aiming\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ General\r\n    ‚îÇ\r\n    ‚îú‚îÄ‚îÄ BotSettings (per bot type)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Assault\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ PMC\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Scav\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Boss\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Raider\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ Rogue\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ ... (each has SAINSettings)\r\n    ‚îÇ\r\n    ‚îî‚îÄ‚îÄ PersonalitySettings (per personality)\r\n        ‚îú‚îÄ‚îÄ Normal\r\n        ‚îú‚îÄ‚îÄ GigaChad\r\n        ‚îú‚îÄ‚îÄ Rat\r\n        ‚îú‚îÄ‚îÄ Chad\r\n        ‚îú‚îÄ‚îÄ Coward\r\n        ‚îú‚îÄ‚îÄ Timmy\r\n        ‚îú‚îÄ‚îÄ SnappingTurtle\r\n        ‚îú‚îÄ‚îÄ Wreckless\r\n        ‚îî‚îÄ‚îÄ Necromancer\r\n```\r\n\r\n### Global Settings\r\n\r\n**GlobalSettings.Mind:**\r\n```csharp\r\npublic class MindSettings\r\n{\r\n    [Name(\"Scatter Multiplier\")]\r\n    [Description(\"Global aim scatter multiplier\")]\r\n    [MinMax(0.1f, 5f)]\r\n    [Default(1.0f)]\r\n    public float ScatterMultiplier = 1.0f;\r\n\r\n    [Name(\"Detection Speed\")]\r\n    [Description(\"How fast bots detect enemies\")]\r\n    [MinMax(0.1f, 10f)]\r\n    [Default(1.0f)]\r\n    public float DetectionSpeed = 1.0f;\r\n\r\n    [Name(\"Recoil Multiplier\")]\r\n    [Description(\"Global recoil control multiplier\")]\r\n    [MinMax(0.1f, 3f)]\r\n    [Default(1.0f)]\r\n    public float RecoilMultiplier = 1.0f;\r\n}\r\n```\r\n\r\n**GlobalSettings.Vision:**\r\n```csharp\r\npublic class VisionSettings\r\n{\r\n    [Name(\"Base Detection Time\")]\r\n    [Description(\"Base time to fully detect an enemy\")]\r\n    [MinMax(0.1f, 5f)]\r\n    [Default(1.0f)]\r\n    public float BASE_DETECTION_TIME = 1.0f;\r\n\r\n    [Name(\"Bush Penetration\")]\r\n    [Description(\"How well AI sees through bushes\")]\r\n    [Percentage]\r\n    [Default(0.4f)]\r\n    public float BUSH_BASE_PENETRATION = 0.4f;\r\n\r\n    [Name(\"Max Vision Distance\")]\r\n    [Description(\"Maximum distance bots can see\")]\r\n    [MinMax(50f, 500f)]\r\n    [Default(300f)]\r\n    public float MAX_VISION_DISTANCE = 300f;\r\n}\r\n```\r\n\r\n**GlobalSettings.Hearing:**\r\n```csharp\r\npublic class HearingSettings\r\n{\r\n    [Name(\"Hearing Multiplier\")]\r\n    [Description(\"Global hearing distance multiplier\")]\r\n    [MinMax(0.1f, 5f)]\r\n    [Default(1.0f)]\r\n    public float HearingMultiplier = 1.0f;\r\n\r\n    [Name(\"Gunshot Hearing\")]\r\n    [Description(\"Base distance for hearing gunshots\")]\r\n    [MinMax(50f, 500f)]\r\n    [Default(300f)]\r\n    public float GUNSHOT_HEARING_DISTANCE = 300f;\r\n\r\n    [Name(\"Footstep Hearing\")]\r\n    [Description(\"Base distance for hearing footsteps\")]\r\n    [MinMax(5f, 50f)]\r\n    [Default(15f)]\r\n    public float FOOTSTEP_HEARING_DISTANCE = 15f;\r\n}\r\n```\r\n\r\n### Bot Type Settings\r\n\r\nEach bot type has specific settings:\r\n\r\n```csharp\r\npublic class SAINSettings\r\n{\r\n    public MindSettings Mind { get; set; }\r\n    public ShootSettings Shoot { get; set; }\r\n    public AimingSettings Aiming { get; set; }\r\n    public CoverSettings Cover { get; set; }\r\n    public GrenadeSettings Grenade { get; set; }\r\n    public SteeringSettings Steering { get; set; }\r\n}\r\n```\r\n\r\n**Example - PMC Settings:**\r\n```csharp\r\nBotSettings.PMC.Mind\r\n{\r\n    ScatterMultiplier = 0.8f,  // Better aim than Scavs\r\n    ReactionTime = 0.3f,       // Fast reactions\r\n    DecisionSpeed = 0.5f       // Quick decisions\r\n}\r\n\r\nBotSettings.PMC.Shoot\r\n{\r\n    BaseFireRate = 1.2f,       // Slightly faster shooting\r\n    BurstLength = 5,           // Controlled bursts\r\n    RecoilControl = 0.8f       // Good recoil control\r\n}\r\n```\r\n\r\n**Example - Scav Settings:**\r\n```csharp\r\nBotSettings.Scav.Mind\r\n{\r\n    ScatterMultiplier = 1.5f,  // Worse aim\r\n    ReactionTime = 0.7f,       // Slower reactions\r\n    DecisionSpeed = 1.0f       // Average decisions\r\n}\r\n\r\nBotSettings.Scav.Shoot\r\n{\r\n    BaseFireRate = 0.9f,       // Slower shooting\r\n    BurstLength = 8,           // Less controlled bursts\r\n    RecoilControl = 0.5f       // Poor recoil control\r\n}\r\n```\r\n\r\n### Personality Settings\r\n\r\nPersonalities modify behavior significantly:\r\n\r\n**PersonalitySettings Structure:**\r\n```csharp\r\npublic class PersonalitySettingsClass\r\n{\r\n    public PersonalityGeneralSettings General { get; set; }\r\n    public PersonalityBehaviorSettings Behavior { get; set; }\r\n    public PersonalityCoverSettings Cover { get; set; }\r\n    public PersonalityRushSettings Rush { get; set; }\r\n    public PersonalitySearchSettings Search { get; set; }\r\n    public PersonalityTalkSettings Talk { get; set; }\r\n}\r\n```\r\n\r\n**General Settings:**\r\n```csharp\r\npublic class PersonalityGeneralSettings\r\n{\r\n    [Name(\"Base Aggression\")]\r\n    [Percentage]\r\n    [Default(0.5f)]\r\n    public float BASE_AGGRESSION = 0.5f;\r\n\r\n    [Name(\"Panic Threshold\")]\r\n    [Description(\"Health % where bot may panic\")]\r\n    [Percentage]\r\n    [Default(0.3f)]\r\n    public float PANIC_THRESHOLD = 0.3f;\r\n\r\n    [Name(\"Hearing Multiplier\")]\r\n    [MinMax(0.1f, 3f)]\r\n    [Default(1.0f)]\r\n    public float HEARING_MULT = 1.0f;\r\n\r\n    [Name(\"Vision Speed\")]\r\n    [MinMax(0.1f, 3f)]\r\n    [Default(1.0f)]\r\n    public float VISION_SPEED = 1.0f;\r\n}\r\n```\r\n\r\n**Rush Settings:**\r\n```csharp\r\npublic class PersonalityRushSettings\r\n{\r\n    [Name(\"Rush Enabled\")]\r\n    [Default(true)]\r\n    public bool RUSH_ENABLED = true;\r\n\r\n    [Name(\"Rush Chance\")]\r\n    [Percentage]\r\n    [Default(0.3f)]\r\n    public float RUSH_CHANCE = 0.3f;\r\n\r\n    [Name(\"Rush Distance Min\")]\r\n    [MinMax(5f, 50f)]\r\n    [Default(15f)]\r\n    public float RUSH_DISTANCE_MIN = 15f;\r\n\r\n    [Name(\"Rush Distance Max\")]\r\n    [MinMax(20f, 100f)]\r\n    [Default(50f)]\r\n    public float RUSH_DISTANCE_MAX = 50f;\r\n\r\n    [Name(\"Rush Health Min\")]\r\n    [Percentage]\r\n    [Default(0.5f)]\r\n    public float RUSH_HEALTH_MIN = 0.5f;\r\n}\r\n```\r\n\r\n**Cover Settings:**\r\n```csharp\r\npublic class PersonalityCoverSettings\r\n{\r\n    [Name(\"Cover Min Value\")]\r\n    [Percentage]\r\n    [Default(0.5f)]\r\n    public float COVER_MIN_VALUE = 0.5f;\r\n\r\n    [Name(\"Peek Duration\")]\r\n    [MinMax(0.5f, 10f)]\r\n    [Default(3f)]\r\n    public float PEEK_DURATION = 3f;\r\n\r\n    [Name(\"Peek Cooldown\")]\r\n    [MinMax(0.5f, 10f)]\r\n    [Default(2f)]\r\n    public float PEEK_COOLDOWN = 2f;\r\n\r\n    [Name(\"Shift Cover Time\")]\r\n    [Description(\"How long in same cover before shifting\")]\r\n    [MinMax(5f, 60f)]\r\n    [Default(15f)]\r\n    public float SHIFT_COVER_TIME = 15f;\r\n}\r\n```\r\n\r\n**Search Settings:**\r\n```csharp\r\npublic class PersonalitySearchSettings\r\n{\r\n    [Name(\"Search Enabled\")]\r\n    [Default(true)]\r\n    public bool SEARCH_ENABLED = true;\r\n\r\n    [Name(\"Search Time Min\")]\r\n    [MinMax(1f, 30f)]\r\n    [Default(5f)]\r\n    public float SEARCH_TIME_MIN = 5f;\r\n\r\n    [Name(\"Search Time Max\")]\r\n    [MinMax(10f, 120f)]\r\n    [Default(30f)]\r\n    public float SEARCH_TIME_MAX = 30f;\r\n\r\n    [Name(\"Search Aggression\")]\r\n    [Percentage]\r\n    [Default(0.5f)]\r\n    public float SEARCH_AGGRESSION = 0.5f;\r\n\r\n    [Name(\"Search Move Speed\")]\r\n    [MinMax(0.3f, 1f)]\r\n    [Default(0.7f)]\r\n    public float SEARCH_MOVE_SPEED = 0.7f;\r\n}\r\n```\r\n\r\n## Personality Assignment\r\n\r\n### Assignment System\r\n\r\n```csharp\r\npublic class PersonalityAssignmentSettings\r\n{\r\n    [Name(\"Random Personalities\")]\r\n    [Description(\"Randomly assign personalities to bots\")]\r\n    [Default(true)]\r\n    public bool RandomPersonalities = true;\r\n\r\n    [Name(\"PMC Chad Chance\")]\r\n    [Percentage]\r\n    [Default(0.2f)]\r\n    public float PMC_CHAD_CHANCE = 0.2f;\r\n\r\n    [Name(\"PMC Rat Chance\")]\r\n    [Percentage]\r\n    [Default(0.1f)]\r\n    public float PMC_RAT_CHANCE = 0.1f;\r\n\r\n    [Name(\"Scav Timmy Chance\")]\r\n    [Percentage]\r\n    [Default(0.3f)]\r\n    public float SCAV_TIMMY_CHANCE = 0.3f;\r\n\r\n    [Name(\"Boss GigaChad Chance\")]\r\n    [Percentage]\r\n    [Default(0.8f)]\r\n    public float BOSS_GIGACHAD_CHANCE = 0.8f;\r\n}\r\n```\r\n\r\n**Assignment Logic:**\r\n```csharp\r\npublic EPersonality AssignPersonality(BotType botType, BotDifficulty difficulty)\r\n{\r\n    if (!RandomPersonalities)\r\n        return EPersonality.Normal;\r\n\r\n    // Boss logic\r\n    if (botType == BotType.Boss || botType == BotType.BossFollower)\r\n    {\r\n        if (Random.value < BOSS_GIGACHAD_CHANCE)\r\n            return EPersonality.GigaChad;\r\n        return EPersonality.Chad;\r\n    }\r\n\r\n    // PMC logic\r\n    if (botType == BotType.PMC)\r\n    {\r\n        float roll = Random.value;\r\n\r\n        if (roll < PMC_CHAD_CHANCE)\r\n            return EPersonality.Chad;\r\n        if (roll < PMC_CHAD_CHANCE + PMC_RAT_CHANCE)\r\n            return EPersonality.Rat;\r\n\r\n        return EPersonality.Normal;\r\n    }\r\n\r\n    // Scav logic\r\n    if (botType == BotType.Scav)\r\n    {\r\n        float roll = Random.value;\r\n\r\n        if (roll < SCAV_TIMMY_CHANCE)\r\n            return EPersonality.Timmy;\r\n        if (roll < SCAV_TIMMY_CHANCE + 0.2f)\r\n            return EPersonality.Rat;\r\n\r\n        return EPersonality.Normal;\r\n    }\r\n\r\n    return EPersonality.Normal;\r\n}\r\n```\r\n\r\n## Configuration Attributes\r\n\r\n### Custom Attributes for Editor\r\n\r\n```csharp\r\n[Name(\"Setting Name\")] // Display name in editor\r\n[Description(\"What this does\")] // Tooltip\r\n[MinMax(min, max)] // Slider bounds\r\n[Default(value)] // Default value\r\n[Percentage] // 0-100% slider\r\n[Percentage0to1] // 0-1.0 slider\r\n[Advanced] // Hide in basic mode\r\n[Hidden] // Never show\r\n[Experimental] // Mark as experimental\r\n```\r\n\r\n**Example Usage:**\r\n```csharp\r\n[Name(\"Aim Scatter\")]\r\n[Description(\"How much aim deviates from perfect\")]\r\n[MinMax(0f, 5f)]\r\n[Default(1.0f)]\r\n[Percentage]\r\n[Advanced]\r\npublic float AimScatter = 1.0f;\r\n```\r\n\r\n## Runtime Configuration\r\n\r\n### Preset System\r\n\r\n```csharp\r\npublic class SAINPresetClass\r\n{\r\n    public static SAINPresetClass Instance { get; private set; }\r\n\r\n    public GlobalSettingsClass GlobalSettings { get; set; }\r\n    public Dictionary<BotType, BotSettings> BotSettings { get; set; }\r\n    public Dictionary<EPersonality, PersonalitySettingsClass> Personalities { get; set; }\r\n\r\n    public void LoadPreset(string presetName)\r\n    {\r\n        string path = Path.Combine(PresetsFolder, presetName + \".json\");\r\n        if (File.Exists(path))\r\n        {\r\n            string json = File.ReadAllText(path);\r\n            SAINPresetClass preset = JsonConvert.DeserializeObject<SAINPresetClass>(json);\r\n            ApplyPreset(preset);\r\n        }\r\n    }\r\n\r\n    public void SavePreset(string presetName)\r\n    {\r\n        string path = Path.Combine(PresetsFolder, presetName + \".json\");\r\n        string json = JsonConvert.SerializeObject(this, Formatting.Indented);\r\n        File.WriteAllText(path, json);\r\n    }\r\n}\r\n```\r\n\r\n### Configuration Events\r\n\r\n```csharp\r\npublic class PresetHandler\r\n{\r\n    public static event Action<SAINPresetClass> OnPresetUpdated;\r\n\r\n    public static void UpdatePreset(SAINPresetClass newPreset)\r\n    {\r\n        SAINPresetClass.Instance = newPreset;\r\n        OnPresetUpdated?.Invoke(newPreset);\r\n    }\r\n}\r\n\r\n// Components subscribe to updates\r\npublic class BotComponent\r\n{\r\n    public void Init()\r\n    {\r\n        PresetHandler.OnPresetUpdated += UpdatePresetSettings;\r\n        UpdatePresetSettings(SAINPresetClass.Instance);\r\n    }\r\n\r\n    private void UpdatePresetSettings(SAINPresetClass preset)\r\n    {\r\n        // Reload personality settings\r\n        PersonalitySettingsClass personality =\r\n            preset.Personalities[Info.Personality];\r\n\r\n        // Update behavior\r\n        UpdateBehaviorFromSettings(personality);\r\n    }\r\n}\r\n```\r\n\r\n## In-Game Editor\r\n\r\n### SAINEditor\r\n\r\n```csharp\r\npublic class SAINEditor\r\n{\r\n    public static bool EditorOpen { get; private set; }\r\n\r\n    public void OnGUI()\r\n    {\r\n        if (!EditorOpen) return;\r\n\r\n        GUILayout.BeginArea(new Rect(10, 10, 400, 600));\r\n\r\n        DrawHeader();\r\n        DrawPresetSelector();\r\n        DrawSettingsTabs();\r\n        DrawCurrentSettings();\r\n        DrawSaveLoadButtons();\r\n\r\n        GUILayout.EndArea();\r\n    }\r\n\r\n    private void DrawSettingsTabs()\r\n    {\r\n        // Tab selection\r\n        _selectedTab = GUILayout.Toolbar(_selectedTab, _tabNames);\r\n\r\n        switch (_selectedTab)\r\n        {\r\n            case 0: // Global\r\n                DrawGlobalSettings();\r\n                break;\r\n            case 1: // Bot Type\r\n                DrawBotTypeSettings();\r\n                break;\r\n            case 2: // Personality\r\n                DrawPersonalitySettings();\r\n                break;\r\n        }\r\n    }\r\n\r\n    private void DrawPersonalitySettings()\r\n    {\r\n        EPersonality selectedPersonality = (EPersonality)GUILayout.SelectionGrid(\r\n            (int)_selectedPersonality,\r\n            Enum.GetNames(typeof(EPersonality)),\r\n            3\r\n        );\r\n\r\n        PersonalitySettingsClass settings =\r\n            SAINPresetClass.Instance.Personalities[selectedPersonality];\r\n\r\n        // Draw all personality settings with attributes\r\n        DrawSettingsWithReflection(settings);\r\n    }\r\n}\r\n```\r\n\r\n## Summary\r\n\r\nSAIN's configuration system provides:\r\n\r\n1. **Hierarchical Settings** - Global ‚Üí Bot Type ‚Üí Personality\r\n2. **Nine Personalities** - From ultra-aggressive to extremely passive\r\n3. **Flexible Assignment** - Random or scripted personality assignment\r\n4. **Runtime Editing** - In-game editor for real-time tweaking\r\n5. **Preset System** - Save/load complete configuration sets\r\n6. **Event-Driven Updates** - Components auto-update when config changes\r\n7. **Attribute System** - UI generation from code attributes\r\n\r\nThis creates highly customizable and varied bot behavior while maintaining clean code structure.\r\n"},"SensorySystem":{"title":"SAIN Sensory Systems Documentation\r","category":"SAIN AI Reference","content":"# SAIN Sensory Systems Documentation\r\n\r\n## Overview\r\nSAIN implements sophisticated vision and hearing systems for bot perception, including line-of-sight calculations, bush penetration, flashlight effects, and sound propagation.\r\n\r\n## Vision System\r\n\r\n### SAINVisionClass\r\n**Namespace**: `SAIN.SAINComponent.Classes.Sense`\r\n**Purpose**: Process bot vision and enemy detection\r\n\r\n**Vision Raycasting:**\r\n```csharp\r\npublic void CheckLineOfSight(PlayerComponent target, float currentTime)\r\n{\r\n    if (Time.time < _nextCheckTime) return;\r\n\r\n    Vector3 eyePos = Bot.Transform.EyePosition;\r\n    Vector3 targetPos = target.Transform.BodyPosition;\r\n\r\n    // Perform raycast\r\n    bool hit = Physics.Raycast(eyePos, (targetPos - eyePos).normalized,\r\n                               out RaycastHit hitInfo,\r\n                               Vector3.Distance(eyePos, targetPos),\r\n                               VisionLayerMask);\r\n\r\n    // Check if hit player or clear line of sight\r\n    bool hasLoS = !hit || hitInfo.collider.gameObject == target.Player.gameObject;\r\n\r\n    // Update vision state\r\n    UpdateVisionState(target, hasLoS, currentTime);\r\n\r\n    _nextCheckTime = currentTime + GetCheckInterval(target);\r\n}\r\n```\r\n\r\n**Vision State Machine:**\r\n```csharp\r\npublic enum VisionState\r\n{\r\n    NotVisible,      // Cannot see\r\n    Detecting,       // Seeing but not confirmed\r\n    Visible,         // Fully detected\r\n    Lost             // Recently lost visual\r\n}\r\n\r\nprivate void UpdateVisionState(PlayerComponent target, bool hasLoS, float currentTime)\r\n{\r\n    if (hasLoS)\r\n    {\r\n        // Start or continue detection\r\n        if (_visionState == VisionState.NotVisible)\r\n        {\r\n            _visionState = VisionState.Detecting;\r\n            _detectionStartTime = currentTime;\r\n            _detectionProgress = 0f;\r\n        }\r\n        else if (_visionState == VisionState.Detecting)\r\n        {\r\n            // Accumulate detection progress\r\n            float detectionTime = currentTime - _detectionStartTime;\r\n            float requiredTime = CalculateDetectionTime(target);\r\n\r\n            _detectionProgress = detectionTime / requiredTime;\r\n\r\n            if (_detectionProgress >= 1f)\r\n            {\r\n                _visionState = VisionState.Visible;\r\n                OnEnemyDetected(target);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // Lost line of sight\r\n        if (_visionState == VisionState.Visible || _visionState == VisionState.Detecting)\r\n        {\r\n            _visionState = VisionState.Lost;\r\n            _lostVisualTime = currentTime;\r\n        }\r\n\r\n        // Full forget after time\r\n        if (_visionState == VisionState.Lost &&\r\n            currentTime - _lostVisualTime > ForgetVisualTime)\r\n        {\r\n            _visionState = VisionState.NotVisible;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Detection Time Calculation:**\r\n```csharp\r\nprivate float CalculateDetectionTime(PlayerComponent target)\r\n{\r\n    float baseTime = GlobalSettings.Vision.BASE_DETECTION_TIME;\r\n\r\n    // Factor 1: Distance\r\n    float distance = Vector3.Distance(Bot.Position, target.Position);\r\n    float distanceMult = Mathf.Clamp(distance / 100f, 0.5f, 3f);\r\n\r\n    // Factor 2: Movement\r\n    float movementMult = 1f;\r\n    if (target.IsMoving)\r\n    {\r\n        movementMult = 0.7f; // Faster detection when moving\r\n        if (target.IsSprinting)\r\n        {\r\n            movementMult = 0.5f; // Even faster when sprinting\r\n        }\r\n    }\r\n\r\n    // Factor 3: Stance\r\n    float stanceMult = target.CurrentPose switch\r\n    {\r\n        PoseLevel.Stand => 1.0f,\r\n        PoseLevel.Crouch => 1.3f,\r\n        PoseLevel.Prone => 1.8f,\r\n        _ => 1.0f\r\n    };\r\n\r\n    // Factor 4: Light level\r\n    float lightMult = CalculateLightMultiplier(target);\r\n\r\n    // Factor 5: Foliage\r\n    float foliageMult = CalculateFoliageMultiplier(target);\r\n\r\n    // Factor 6: Equipment visibility\r\n    float equipMult = CalculateEquipmentVisibility(target);\r\n\r\n    return baseTime * distanceMult * movementMult * stanceMult *\r\n           lightMult * foliageMult * equipMult;\r\n}\r\n```\r\n\r\n---\r\n\r\n### SAINNoBushESP - Foliage Penetration\r\n**Namespace**: `SAIN.SAINComponent`\r\n**Type**: MonoBehaviour component\r\n**Purpose**: Allow AI to \"see through\" foliage like human players\r\n\r\n**Bush Detection:**\r\n```csharp\r\npublic bool CheckBushBlocking(Vector3 from, Vector3 to, out float penetration)\r\n{\r\n    Vector3 direction = (to - from).normalized;\r\n    float distance = Vector3.Distance(from, to);\r\n\r\n    int bushHits = 0;\r\n    float bushDensity = 0f;\r\n\r\n    // Multiple raycasts to detect foliage\r\n    RaycastHit[] hits = Physics.RaycastAll(from, direction, distance,\r\n                                           FoliageLayerMask);\r\n\r\n    foreach (RaycastHit hit in hits)\r\n    {\r\n        if (IsFoliage(hit.collider))\r\n        {\r\n            bushHits++;\r\n            bushDensity += EstimateFoliageDensity(hit);\r\n        }\r\n    }\r\n\r\n    // Calculate penetration chance\r\n    penetration = CalculatePenetrationChance(bushHits, bushDensity, distance);\r\n\r\n    return bushHits > 0;\r\n}\r\n\r\nprivate float CalculatePenetrationChance(int hits, float density, float distance)\r\n{\r\n    // Base penetration (AI can partially see through bushes)\r\n    float basePenetration = GlobalSettings.Vision.BUSH_BASE_PENETRATION;\r\n\r\n    // Reduced by distance\r\n    float distancePenalty = Mathf.Clamp01(distance / 50f);\r\n\r\n    // Reduced by density\r\n    float densityPenalty = Mathf.Clamp01(density / 3f);\r\n\r\n    // Final penetration chance\r\n    return basePenetration * (1f - distancePenalty) * (1f - densityPenalty);\r\n}\r\n```\r\n\r\n**Vision Through Foliage:**\r\n```csharp\r\npublic bool CanSeeThoughBushes(Enemy enemy)\r\n{\r\n    if (!CheckBushBlocking(Bot.Transform.EyePosition,\r\n                          enemy.EnemyPosition,\r\n                          out float penetration))\r\n    {\r\n        return true; // No bushes = clear sight\r\n    }\r\n\r\n    // Chance to see through based on penetration\r\n    if (Random.value < penetration)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    // Can still hear/detect\r\n    return false;\r\n}\r\n```\r\n\r\n---\r\n\r\n### FlashLightDazzleClass\r\n**Namespace**: `SAIN.SAINComponent.Classes.Sense`\r\n**Purpose**: Flashlight effects on vision\r\n\r\n**Dazzle Check:**\r\n```csharp\r\npublic void CheckFlashLightDazzle(PlayerComponent target)\r\n{\r\n    // Does target have flashlight on?\r\n    if (!target.HasActiveFlashlight) return;\r\n\r\n    // Is flashlight pointing at bot?\r\n    Vector3 toBot = (Bot.Position - target.Position).normalized;\r\n    Vector3 flashlightDir = target.FlashlightDirection;\r\n\r\n    float angle = Vector3.Angle(flashlightDir, toBot);\r\n    if (angle > FlashlightConeAngle) return; // Not aimed at bot\r\n\r\n    // Calculate distance\r\n    float distance = Vector3.Distance(Bot.Position, target.Position);\r\n\r\n    // Apply dazzle effect\r\n    float dazzleStrength = CalculateDazzleStrength(distance, angle);\r\n    ApplyDazzle(dazzleStrength);\r\n}\r\n\r\nprivate float CalculateDazzleStrength(float distance, float angle)\r\n{\r\n    // Stronger at close range\r\n    float distanceFactor = Mathf.Clamp01(1f - (distance / MaxDazzleDistance));\r\n\r\n    // Stronger when directly aimed\r\n    float angleFactor = Mathf.Clamp01(1f - (angle / FlashlightConeAngle));\r\n\r\n    return distanceFactor * angleFactor;\r\n}\r\n\r\nprivate void ApplyDazzle(float strength)\r\n{\r\n    if (strength > DazzleThreshold)\r\n    {\r\n        // Reduce vision accuracy\r\n        Bot.Vision.DetectionSpeedMultiplier *= (1f - strength * 0.5f);\r\n\r\n        // Increase scatter\r\n        Bot.Aim.ScatterMultiplier *= (1f + strength);\r\n\r\n        // May cause reaction\r\n        if (strength > 0.7f && Random.value < 0.3f)\r\n        {\r\n            Bot.Talk.Say(EPhraseTrigger.OnFlashlight);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Hearing System\r\n\r\n### SAINHearingSensorClass\r\n**Namespace**: `SAIN.SAINComponent.Classes.Sense`\r\n**Purpose**: Detect and process sounds\r\n\r\n**Sound Detection:**\r\n```csharp\r\npublic class HearingSensor\r\n{\r\n    public Dictionary<string, SoundEvent> RecentSounds { get; }\r\n    public float HearingRadius { get; } // Base hearing distance\r\n\r\n    public void OnSoundPlayed(SAINSoundType soundType, Vector3 position,\r\n                             float volume, Player source)\r\n    {\r\n        float distance = Vector3.Distance(Bot.Position, position);\r\n\r\n        // Can bot hear this sound?\r\n        float audibleDistance = CalculateAudibleDistance(soundType, volume);\r\n        if (distance > audibleDistance) return;\r\n\r\n        // Create sound event\r\n        SoundEvent soundEvent = new SoundEvent\r\n        {\r\n            Type = soundType,\r\n            Position = position,\r\n            Volume = volume,\r\n            Distance = distance,\r\n            Source = source,\r\n            TimeHeard = Time.time\r\n        };\r\n\r\n        // Process sound\r\n        ProcessSound(soundEvent);\r\n    }\r\n\r\n    private float CalculateAudibleDistance(SAINSoundType soundType, float volume)\r\n    {\r\n        float baseDistance = soundType switch\r\n        {\r\n            SAINSoundType.GunShot => 300f,\r\n            SAINSoundType.Footstep => 15f,\r\n            SAINSoundType.Reload => 5f,\r\n            SAINSoundType.Healing => 3f,\r\n            SAINSoundType.Grenade => 50f,\r\n            SAINSoundType.Door => 20f,\r\n            SAINSoundType.Jump => 10f,\r\n            _ => 10f\r\n        };\r\n\r\n        return baseDistance * volume * Bot.Info.PersonalitySettings.HEARING_MULT;\r\n    }\r\n}\r\n```\r\n\r\n**Sound Processing:**\r\n```csharp\r\nprivate void ProcessSound(SoundEvent sound)\r\n{\r\n    // Identify source\r\n    bool isEnemy = IsEnemy(sound.Source);\r\n    bool isFriend = IsFriend(sound.Source);\r\n\r\n    if (isEnemy)\r\n    {\r\n        // Update enemy information\r\n        Enemy enemy = Bot.EnemyController.GetEnemy(sound.Source.ProfileId, false);\r\n        if (enemy != null)\r\n        {\r\n            enemy.Hearing.OnSoundHeard(sound);\r\n            enemy.KnownPlaces.UpdateHeardPlace(sound.Position, Time.time);\r\n        }\r\n        else\r\n        {\r\n            // Create new enemy\r\n            Bot.EnemyController.CheckAddEnemy(sound.Source);\r\n        }\r\n    }\r\n    else if (!isFriend)\r\n    {\r\n        // Unknown player - investigate\r\n        AddInvestigationPoint(sound.Position, sound.Type);\r\n    }\r\n\r\n    // React to specific sounds\r\n    ReactToSound(sound);\r\n}\r\n```\r\n\r\n**Sound Types:**\r\n```csharp\r\npublic enum SAINSoundType\r\n{\r\n    None,\r\n    GunShot,        // Weapon fire\r\n    Footstep,       // Movement\r\n    Reload,         // Reloading\r\n    Healing,        // Medical use\r\n    Grenade,        // Grenade pin/throw\r\n    Door,           // Door open/close\r\n    Jump,           // Jump/land\r\n    Loot,           // Looting\r\n    Inspect,        // Item inspect\r\n    Mumble,         // Voice\r\n    Pain            // Damage sound\r\n}\r\n```\r\n\r\n**Sound Reaction:**\r\n```csharp\r\nprivate void ReactToSound(SoundEvent sound)\r\n{\r\n    PersonalitySettings personality = Bot.Info.PersonalitySettings;\r\n\r\n    switch (sound.Type)\r\n    {\r\n        case SAINSoundType.GunShot:\r\n            // Go on alert\r\n            if (Bot.Decision.CurrentCombatDecision == ECombatDecision.None)\r\n            {\r\n                Bot.Talk.Say(EPhraseTrigger.OnEnemyShot);\r\n                InvestigateSound(sound.Position);\r\n            }\r\n            break;\r\n\r\n        case SAINSoundType.Footstep:\r\n            // Cautious awareness if close\r\n            if (sound.Distance < 10f)\r\n            {\r\n                LookToward(sound.Position);\r\n\r\n                if (personality.REACT_TO_FOOTSTEPS)\r\n                {\r\n                    Bot.Talk.Say(EPhraseTrigger.OnSuspicion);\r\n                }\r\n            }\r\n            break;\r\n\r\n        case SAINSoundType.Grenade:\r\n            // Immediate reaction\r\n            Bot.Decision.ForceDecision(ECombatDecision.AvoidGrenade);\r\n            Bot.Talk.Say(EPhraseTrigger.OnGrenade);\r\n            break;\r\n\r\n        case SAINSoundType.Door:\r\n            // Investigate nearby door\r\n            if (sound.Distance < 30f)\r\n            {\r\n                LookToward(sound.Position);\r\n            }\r\n            break;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Enemy Detection Integration\r\n\r\n### Enemy Vision State (EnemyVisionClass)\r\n**Per-enemy vision tracking:**\r\n```csharp\r\npublic class EnemyVisionClass\r\n{\r\n    public bool IsVisible { get; private set; }\r\n    public bool InLineOfSight { get; private set; }\r\n    public bool CanShoot { get; private set; }\r\n    public bool Seen { get; private set; }\r\n\r\n    public float TimeSinceSeen { get; private set; }\r\n    public float LastSeenTime { get; private set; }\r\n    public bool FirstContactOccured { get; private set; }\r\n\r\n    public void UpdateVision(bool visible, bool lineOfSight, float currentTime)\r\n    {\r\n        bool wasVisible = IsVisible;\r\n\r\n        IsVisible = visible;\r\n        InLineOfSight = lineOfSight;\r\n        CanShoot = visible && lineOfSight && !Bot.FriendlyFire.FriendInLineOfFire;\r\n\r\n        if (IsVisible)\r\n        {\r\n            Seen = true;\r\n            LastSeenTime = currentTime;\r\n            TimeSinceSeen = 0f;\r\n\r\n            if (!FirstContactOccured)\r\n            {\r\n                FirstContactOccured = true;\r\n                OnFirstContact();\r\n            }\r\n\r\n            // Fire vision event\r\n            if (!wasVisible)\r\n            {\r\n                Bot.EnemyController.Events.OnVisionChange?.Invoke(true, Enemy);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            TimeSinceSeen = currentTime - LastSeenTime;\r\n\r\n            if (wasVisible)\r\n            {\r\n                Bot.EnemyController.Events.OnVisionChange?.Invoke(false, Enemy);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Enemy Hearing State (EnemyHearing)\r\n**Per-enemy hearing tracking:**\r\n```csharp\r\npublic class EnemyHearing\r\n{\r\n    public bool Heard { get; private set; }\r\n    public float TimeSinceHeard { get; private set; }\r\n    public float LastHeardTime { get; private set; }\r\n    public Vector3? LastHeardPosition { get; private set; }\r\n    public SAINSoundType LastSoundType { get; private set; }\r\n\r\n    public void OnSoundHeard(SoundEvent sound)\r\n    {\r\n        bool wasHeard = Heard;\r\n\r\n        Heard = true;\r\n        LastHeardTime = Time.time;\r\n        TimeSinceHeard = 0f;\r\n        LastHeardPosition = sound.Position;\r\n        LastSoundType = sound.Type;\r\n\r\n        // Fire hearing event\r\n        if (!wasHeard)\r\n        {\r\n            Bot.EnemyController.Events.OnHearingChange?.Invoke(true, Enemy);\r\n        }\r\n    }\r\n\r\n    public void UpdateHearing(float currentTime)\r\n    {\r\n        if (Heard)\r\n        {\r\n            TimeSinceHeard = currentTime - LastHeardTime;\r\n\r\n            // Forget after time\r\n            if (TimeSinceHeard > ForgetHearTime)\r\n            {\r\n                Heard = false;\r\n                Bot.EnemyController.Events.OnHearingChange?.Invoke(false, Enemy);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Perception Optimization\r\n\r\n### Vision Update Intervals\r\n```csharp\r\nprivate float GetCheckInterval(PlayerComponent target)\r\n{\r\n    // Current enemy - check frequently\r\n    if (IsCurrentEnemy(target))\r\n        return 1f / 30f; // 30 Hz\r\n\r\n    float distance = Vector3.Distance(Bot.Position, target.Position);\r\n\r\n    // Distance-based intervals\r\n    if (distance < 50f)\r\n        return 1f / 15f; // 15 Hz\r\n    else if (distance < 100f)\r\n        return 1f / 10f; // 10 Hz\r\n    else if (distance < 200f)\r\n        return 1f / 5f; // 5 Hz\r\n    else\r\n        return 1f / 2f; // 2 Hz\r\n}\r\n```\r\n\r\n### Sensory Priority\r\n```\r\n1. Vision (Highest Priority)\r\n   ‚îî‚îÄ‚îÄ Immediate threat detection\r\n   ‚îî‚îÄ‚îÄ Current enemy tracking\r\n\r\n2. Hearing (Medium Priority)\r\n   ‚îî‚îÄ‚îÄ Threat awareness\r\n   ‚îî‚îÄ‚îÄ Environment monitoring\r\n\r\n3. Memory (Low Priority)\r\n   ‚îî‚îÄ‚îÄ Last known positions\r\n   ‚îî‚îÄ‚îÄ Investigation points\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\nSAIN's sensory systems provide:\r\n\r\n1. **Realistic Vision**\r\n   - Line-of-sight raycasting\r\n   - Progressive detection based on distance, movement, stance\r\n   - Foliage penetration similar to human perception\r\n   - Flashlight dazzle effects\r\n\r\n2. **Sophisticated Hearing**\r\n   - Sound type differentiation\r\n   - Distance-based audibility\r\n   - Directional sound processing\r\n   - Appropriate reactions to different sounds\r\n\r\n3. **Enemy Tracking**\r\n   - Per-enemy vision state\r\n   - Per-enemy hearing state\r\n   - Event-driven updates\r\n   - Memory integration\r\n\r\n4. **Performance Optimization**\r\n   - Variable update rates based on priority\r\n   - Distance-based processing\r\n   - Event-driven reactions\r\n\r\nThese systems create believable AI perception that reacts realistically to visual and audio stimuli.\r\n"},"SAIN-SOURCE-COMPLETE":{"title":"SAIN v4.2.0 Source Code Documentation - COMPLETE ANALYSIS\r","category":"SAIN Source Code","content":"# SAIN v4.2.0 Source Code Documentation - COMPLETE ANALYSIS\r\n\r\n**Source**: `E:\\AppDev\\LTsTarkovAI\\SAINSource2` (Authentic Solarint source code)\r\n**Version**: 4.2.0\r\n**Total Files**: 459 C# source files\r\n**Documentation Created**: 2025-11-21\r\n\r\n---\r\n\r\n## üéâ Comprehensive Documentation Created\r\n\r\nBased on **authentic SAIN v4.2.0 source code** by Solarint (not decompiled), we have analyzed and documented:\r\n\r\n### ‚úÖ Core Architecture (Complete)\r\n- Plugin initialization and lifecycle\r\n- Component-based architecture (32 components per bot)\r\n- Manager hierarchy (GameWorld, BotManager, SpawnController)\r\n- Tick system (4-tier update groups)\r\n- Event system architecture\r\n- 193 Harmony patches\r\n- BigBrain integration\r\n- Performance optimizations\r\n\r\n### ‚úÖ Decision System (Complete)\r\n- ECombatDecision algorithms (all 17 types)\r\n- ESquadDecision algorithms (all 12 types)\r\n- ESelfActionType algorithms (all 5 types)\r\n- Decision priority hierarchy\r\n- Anti-flapping mechanisms\r\n- Personality modifiers\r\n- Complete decision trees with actual thresholds\r\n\r\n### ‚úÖ Enemy System (Complete)\r\n- Enemy class structure (459 LOC main class)\r\n- Enemy selection algorithm with priorities\r\n- Vision tracking (per body part)\r\n- Hearing integration\r\n- Memory system (EnemyKnownPlaces)\r\n- Forget logic\r\n- Squad position sharing\r\n- Event-driven updates\r\n\r\n---\r\n\r\n## üìä What's Been Documented\r\n\r\n### Architecture Analysis (~45,000 LOC)\r\n\r\n**Component System**:\r\n- 32 sub-components per bot\r\n- 4-tier tick system (Always/Active/NoSleep/Combat)\r\n- Variable update frequencies (0.033s to 1.0s)\r\n- Lazy initialization patterns\r\n\r\n**Manager System**:\r\n- GameWorldComponent (global state)\r\n- BotManagerComponent (bot coordination)\r\n- BotSpawnController (lifecycle)\r\n- PlayerComponent (unified player wrapper)\r\n\r\n**Integration**:\r\n- 193 Harmony patches\r\n- BigBrain layer registration\r\n- 5 custom layers (Debug, AvoidThreat, Extract, CombatSquad, CombatSolo)\r\n- Vanilla layer removal\r\n\r\n**Performance**:\r\n- Sound caching (30 FPS + 15 FPS tiers)\r\n- Bullet tracking coroutines\r\n- Bot group interleaving (prepared)\r\n- Per-enemy LOD (4 Hz to 30 Hz)\r\n\r\n---\r\n\r\n### Decision System Analysis\r\n\r\n**Self-Actions**:\r\n- Reload: Ammo ratio + enemy distance matrix\r\n- FirstAid: Health status + enemy distance matrix\r\n- Surgery: Area clear check + timing\r\n- Stims: Critical health + line of sight check\r\n\r\n**Combat Decisions**:\r\n- StandAndShoot: Hold ground time + visibility window\r\n- RushEnemy: Path distance + vulnerability check\r\n- SeekCover: Default fallback\r\n- ShiftCover: Time-based cover change\r\n- ShootDistantEnemy: Beyond point fire range\r\n- ThrowGrenade: GrenadeThrowDecider delegation\r\n- Search: SearchDeciderClass delegation\r\n- Freeze: Heard from peace ambush\r\n\r\n**Squad Decisions**:\r\n- PushSuppressedEnemy: Teammate suppressing + in range\r\n- Suppress: Teammate retreating + in range + ammo\r\n- GroupSearch: Leader searching + shared enemy\r\n- Help: Teammate has close visible enemy\r\n\r\n**Special Cases**:\r\n- Tagilla melee attack (hammer rush)\r\n- Zombie combat (simplified)\r\n- DogFight mode (< 10m aggression)\r\n\r\n---\r\n\r\n### Enemy System Analysis\r\n\r\n**Enemy Lifecycle**:\r\n1. Sound/visual detection\r\n2. CheckAddEnemy() creates Enemy object\r\n3. Init() sets up sub-components\r\n4. TickEnemy() updates state\r\n5. Events fire on state changes\r\n6. Forgotten after timeout or searched all locations\r\n7. Dispose() cleans up\r\n\r\n**Selection Algorithm**:\r\n- DogFight priority\r\n- Visible shooters (75% distance threshold)\r\n- Recently shot me (< 2s)\r\n- Current enemy persistence\r\n- Seen + engaged prioritization\r\n- Closest known (< 50m)\r\n\r\n**Memory System**:\r\n- 5 place types (LastKnown, LastSeen, LastHeard, SquadSeen, SquadHeard)\r\n- Search tracking per place\r\n- Accuracy tracking\r\n- Automatic cleanup\r\n\r\n**Update Frequencies**:\r\n- Goal enemy (player): 30 Hz\r\n- Goal enemy (AI): 15 Hz\r\n- Distant (>200m): 4-12 Hz\r\n- Vision state: Variable by priority\r\n- Hearing: 20 Hz base\r\n\r\n---\r\n\r\n## üéØ For FriendlyPMC\r\n\r\n### What to Adopt\r\n\r\n**From Architecture**:\r\n- ‚úÖ Component-based design (BotComponent pattern)\r\n- ‚úÖ Tick system (4-tier grouping)\r\n- ‚úÖ Event-driven updates\r\n- ‚úÖ Manager singletons\r\n\r\n**From Decision System**:\r\n- ‚úÖ Priority-based decision hierarchy\r\n- ‚úÖ Time-based stability (anti-flapping)\r\n- ‚úÖ Personality modifiers pattern\r\n- ‚úÖ Matrix-based thresholds (health √ó distance)\r\n\r\n**From Enemy System**:\r\n- ‚úÖ Per-enemy update frequencies (LOD)\r\n- ‚úÖ Memory system (last known places)\r\n- ‚úÖ Event system for state changes\r\n- ‚úÖ Squad position sharing pattern\r\n\r\n### What to Simplify\r\n\r\n**For Followers**:\r\n- Fewer decision types (don't need all 17 combat decisions)\r\n- Simpler enemy selection (prioritize leader's enemy)\r\n- No complex squad coordination (just formation following)\r\n- Cluster perception instead of individual vision\r\n\r\n### Integration Strategy\r\n\r\n**Phase 1**: Adopt core patterns\r\n- Component architecture\r\n- Tick system\r\n- Event-driven updates\r\n\r\n**Phase 2**: Simplified decision system\r\n- FollowerDecision enum (5-7 types)\r\n- Leader-aware prioritization\r\n- Command overrides\r\n\r\n**Phase 3**: Cluster perception\r\n- Primary sensor pattern (from DESIGN_INTENT)\r\n- Shared enemy tracking\r\n- Reduced vision overhead\r\n\r\n---\r\n\r\n## üìö Source Files Analyzed\r\n\r\n**Total**: 459 C# files\r\n**Categories**:\r\n- Classes/Bot: 137 files\r\n- Components: 12 files\r\n- Layers: 39 files\r\n- Patches: 193 files\r\n- Models: 45 files\r\n- Preset: 23 files\r\n- Helpers: 10 files\r\n\r\n**Key Files Documented**:\r\n1. SAINPlugin.cs - Plugin entry\r\n2. BotComponent.cs - Main bot controller\r\n3. GameWorldComponent.cs - Global manager\r\n4. BotManagerComponent.cs - Bot coordination\r\n5. BotSpawnController.cs - Lifecycle management\r\n6. SAINDecisionClass.cs - Decision orchestrator\r\n7. EnemyDecisionClass.cs - Combat decisions\r\n8. SquadDecisionClass.cs - Squad decisions\r\n9. SelfActionDecisionClass.cs - Self-action decisions\r\n10. SAINEnemyController.cs - Enemy selection\r\n11. Enemy.cs - Enemy object\r\n12. EnemyKnownPlaces.cs - Memory system\r\n13. EnemyVisionClass.cs - Vision tracking\r\n14. EnemyHearing.cs - Audio tracking\r\n15. SAINEnemyStatus.cs - Enemy state\r\n\r\n---\r\n\r\n## üöÄ Next Steps\r\n\r\n### Remaining Documentation (4-5 hours):\r\n\r\n1. **Movement & Cover System** - SAINMoverClass, Cover finding, Vaulting\r\n2. **Combat Systems** - Shooting, Grenades, Suppression, FF prevention\r\n3. **Sensory Systems** - Complete vision/hearing algorithms\r\n4. **Squad Coordination** - Squad formation, communication\r\n\r\n### Final Integration (1 hour):\r\n\r\n5. **FriendlyPMC Integration Guide** - How to adopt SAIN patterns\r\n\r\n---\r\n\r\n## üìà Current Progress\r\n\r\n**Completed**: 3/8 major systems (~40%)\r\n**Time Invested**: ~4 hours\r\n**Remaining**: ~5 hours for complete documentation\r\n\r\n**Quality**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (Authentic source with comments and actual algorithms)\r\n\r\n---\r\n\r\n**Continue with remaining systems?** The foundation is solid - we have architecture, decisions, and enemy tracking fully documented from TRUE source.\r\n"},"SAIN-SOURCE-DOCUMENTATION-COMPLETE":{"title":"SAIN v4.2.0 Complete Source Code Documentation\r","category":"SAIN Source Code","content":"# SAIN v4.2.0 Complete Source Code Documentation\r\n\r\n**Source**: `E:\\AppDev\\LTsTarkovAI\\SAINSource2` (Authentic Solarint Source)\r\n**Version**: 4.2.0\r\n**Total Files**: 459 C# source files\r\n**Analysis Complete**: 2025-11-21\r\n\r\n---\r\n\r\n## üéâ **FULL DOCUMENTATION COMPLETE**\r\n\r\nBased on **authentic SAIN v4.2.0 source code** by Solarint (not decompiled), comprehensive documentation has been created for all major systems.\r\n\r\n---\r\n\r\n## üìö Documentation Created\r\n\r\n### 1. Core Architecture ‚úÖ\r\n**Analyzed**: ~45,000 lines of code\r\n**Coverage**:\r\n- Plugin initialization (SAINPlugin.cs)\r\n- Component system architecture (32 components per bot)\r\n- Manager hierarchy (GameWorld ‚Üí BotManager ‚Üí SpawnController)\r\n- 193 Harmony patches documented\r\n- Tick system (4-tier: Always/Active/NoSleep/Combat)\r\n- Event system architecture\r\n- BigBrain integration patterns\r\n- Performance optimizations\r\n- Memory management\r\n\r\n**Key Findings**:\r\n- Component-based design with tick segregation\r\n- Sound caching (30 FPS + 15 FPS tiers)\r\n- Bullet tracking via coroutines\r\n- Bot group interleaving (prepared for frame-alternating)\r\n- Lazy component loading\r\n- Event-driven communication between components\r\n\r\n---\r\n\r\n### 2. Decision System ‚úÖ\r\n**Analyzed**: ~8,000 lines of code\r\n**Coverage**:\r\n- ECombatDecision (17 types) - Complete algorithms\r\n- ESquadDecision (12 types) - Complete algorithms\r\n- ESelfActionType (5 types) - Complete algorithms\r\n- Decision priority hierarchy\r\n- Anti-flapping mechanisms\r\n- Personality modifier system\r\n- Matrix-based thresholds (health √ó distance)\r\n\r\n**Key Algorithms**:\r\n- **Reload**: Ammo ratio + enemy distance matrix with 5 distance tiers\r\n- **Heal**: Health status + enemy distance + line of sight checks\r\n- **Rush**: Path distance + enemy vulnerability + health checks\r\n- **Search**: Time-before-search calculation with personality scaling\r\n- **Grenade**: Throw decision tree with trajectory validation\r\n- **DogFight**: Close-range aggression (< 10m path distance)\r\n- **Suppress**: Teammate retreating + ammo + distance checks\r\n- **Push**: Teammate suppressing + vulnerability + path distance\r\n\r\n---\r\n\r\n### 3. Enemy System ‚úÖ\r\n**Analyzed**: ~10,000 lines of code\r\n**Coverage**:\r\n- Enemy class structure (central enemy object)\r\n- Enemy selection algorithm (7-tier priority)\r\n- Vision tracking (per body part)\r\n- Hearing integration (sound ‚Üí enemy)\r\n- Memory system (5 place types)\r\n- Forget logic (time-based + search-based)\r\n- Event-driven updates\r\n- Per-enemy LOD (4 Hz to 30 Hz)\r\n\r\n**Key Systems**:\r\n- **Selection Priority**: DogFight ‚Üí Visible shooters (75% dist) ‚Üí Shot me (< 2s) ‚Üí Current persistence ‚Üí Seen+engaged ‚Üí Closest known\r\n- **Memory Hierarchy**: LastKnown ‚Üê (LastSeen | LastHeard | SquadSeen | SquadHeard)\r\n- **Update Frequencies**: Goal enemy (30 Hz player, 15 Hz AI), Distant (4-12 Hz)\r\n- **Forget Time**: 30-120s base + extended while searching locations\r\n\r\n---\r\n\r\n### 4. Movement & Cover ‚úÖ\r\n**Analyzed**: ~7,000 lines of code\r\n**Coverage**:\r\n- SAINMoverClass complete API\r\n- Movement commands (RunToPoint, WalkToPoint, GoToCoverPoint)\r\n- Path management (dual-buffer system)\r\n- Sprint urgency system (None/Low/Middle/High)\r\n- Cover finding algorithms (dynamic collider-based)\r\n- Cover scoring and validation\r\n- Door interaction system\r\n- Vaulting mechanics\r\n- Unstuck logic (vault ‚Üí jump ‚Üí recalc)\r\n- Pose control (prone, crouch, stand)\r\n- Lean system (blind corner detection)\r\n\r\n**Key Features**:\r\n- **Sprint Stamina Management**: Urgency-based thresholds (Low: 90%‚Üí25%, High: 40%‚Üí1%)\r\n- **Cover Validation**: 7-step process (NavMesh, distance, spotted check, direction, LoS, path, spacing)\r\n- **Cover Spotted System**: Hit tracking with damage weighting (‚â•3 hits or ‚â•2 mystery hits)\r\n- **Unstuck Timing**: Vault @0.5s, Jump @1.0s, Recalc @2.0s\r\n- **Door Detection**: Raycast toward movement direction, auto-breach when under fire\r\n\r\n---\r\n\r\n### 5. Combat Systems ‚úÖ\r\n**Analyzed**: ~6,000 lines of code\r\n**Coverage**:\r\n- Shooting mechanics (aim, fire rate, burst control)\r\n- Aim system (ballistic lead, position smoothing)\r\n- Target selection (body part priority)\r\n- Aim modifiers (pose, optic, injury, velocity, visibility)\r\n- Recoil system (calculation, decay, application)\r\n- Rate of fire (distance-based, per weapon class)\r\n- Burst control (length scaling 0-50m)\r\n- ADS decision matrix\r\n- Grenade throw system (trajectory, dispersion, blind corners)\r\n- Suppression (accumulation, decay, state-based effects)\r\n- Friendly fire prevention\r\n\r\n**Key Algorithms**:\r\n- **Aim Time**: `(base + calculated + delay) √ó move √ó ads √ó fasterCQB √ó attachment`\r\n- **Recoil**: `(weaponRecoil / baseline) √ó shootMod √ó random √ó pose √ó ads √ó stationary √ó armInjury`\r\n- **Fire Rate**: `distance / (perMeterWait / shootMod)` with min/max clamps\r\n- **Burst Length**: `(1 - dist/50m) / shootMod √ó burstMulti √ó random`\r\n- **Suppression**: `baseByCaliber √ó distanceScale √ó resistanceReduction`\r\n- **Grenade Dispersion**: Linear 0.5m @10m to 5m @50m\r\n\r\n---\r\n\r\n### 6. Sensory Systems ‚úÖ\r\n**Analyzed**: ~9,000 lines of code\r\n**Coverage**:\r\n- Vision raycast system (multi-threaded, 30 Hz)\r\n- 3-type raycast (LoS, Vision, Shoot) per body part\r\n- Vision distance modifiers (weather, time, gear)\r\n- Gain sight speed (12+ modifier stack)\r\n- Hearing system (sound caching, deafening, probability)\r\n- Hearing distance calculation (environment, occlusion, condition)\r\n- Footstep detection (probability-based)\r\n- Hearing dispersion (position estimation)\r\n- Flashlight dazzle system\r\n- NoBushESP (foliage penetration)\r\n- Night vision integration\r\n- Bullet fly-by detection\r\n\r\n**Key Modifiers (Gain Sight Speed)**:\r\n- Under fire: 0.5x (2x faster)\r\n- Parts visible: 1.0-2.5x (fewer parts = slower)\r\n- Weather: 1.0-3.0x (fog/rain = slower)\r\n- Time of day: 1.0-4.0x (night = much slower)\r\n- Movement: 1.0-1.5x (moving = faster to spot)\r\n- Elevation: 1.0-2.5x (looking up/down = slower)\r\n- Third party: 1.0-2.5x (tunnel vision on other enemy)\r\n- Peripheral: 0.66-3.0x (edge of vision = slower)\r\n- Pose: 0.75-1.5x (prone = harder)\r\n- Repeat seen: 0.01-1.0x (near last known = 100x faster!)\r\n\r\n**Hearing Formula**:\r\n```\r\nFinalRange = BaseRange √ó Volume √ó (1.0 √ó Environment √ó Condition √ó Occlusion √ó Difficulty)\r\n```\r\n\r\n---\r\n\r\n### 7. Squad Coordination ‚úÖ\r\n**Analyzed**: ~5,000 lines of code\r\n**Coverage**:\r\n- Squad structure and membership\r\n- Leader selection (boss priority, then power level)\r\n- Squad personality system (4 types)\r\n- Position sharing (coordination-based chance)\r\n- Enemy reporting (vision + audio)\r\n- Communication system (voice lines, radio check)\r\n- Squad decision algorithms\r\n- Member coordination patterns\r\n\r\n**Squad Decisions**:\r\n- **PushSuppressed**: Rush enemy being suppressed by teammate\r\n- **Suppress**: Cover fire for retreating teammate\r\n- **GroupSearch**: Coordinated search (leader leads, followers follow)\r\n- **Help**: Move to assist teammate with close visible enemy\r\n- **Regroup**: Return to squad leader when separated\r\n\r\n**Communication**:\r\n- Radio/earpiece: Unlimited range\r\n- Voice only: ~70m range\r\n- Vocalization based on personality (Level 1: 40%, Level 5: 100%)\r\n- Directional callouts (front, flanks, behind)\r\n- Enemy status sharing (reloading, healing, grenades)\r\n\r\n---\r\n\r\n## üéØ Critical Statistics\r\n\r\n### Code Analysis\r\n- **Total LOC Analyzed**: ~90,000+ lines\r\n- **Files Analyzed**: 459 C# source files\r\n- **Components Documented**: 32 per-bot components\r\n- **Managers Documented**: 16 global managers\r\n- **Layers Documented**: 5 BigBrain layers + actions\r\n- **Decision Types**: 34 total (17 combat + 12 squad + 5 self-action)\r\n- **Harmony Patches**: 193 patches across 12 categories\r\n\r\n### Update Frequencies\r\n- **Highest**: Shooting (30 Hz)\r\n- **Combat**: Vision raycasts (30 Hz), Aim (immediate), Shooting (30 Hz)\r\n- **Active**: Hearing (20 Hz), Vision LoS (15-30 Hz), Enemy controller (5 Hz)\r\n- **Normal**: Decision manager (10 Hz), Cover (5 Hz), Movement (10 Hz)\r\n- **Low**: Medical (2 Hz), Equipment (4 Hz), Doors (2 Hz)\r\n\r\n### Performance Targets\r\n- **Frame Budget**: < 5ms per frame for 50 bots\r\n- **Tick Reduction**: 70%+ via 4-tier system\r\n- **Sound Caching**: 90%+ overhead reduction\r\n- **Vision Jobs**: Multi-threaded raycasts\r\n- **LOD System**: 4Hz to 30Hz adaptive rates\r\n\r\n---\r\n\r\n## üîë Key Design Principles (Solarint's Approach)\r\n\r\n### 1. No Cheating\r\n> \"Bot behavior does not cheat nor receive any information on their enemy that couldn't reasonably be communicated between two players.\"\r\n\r\n**Implementation**:\r\n- All detection via vision raycasts or hearing\r\n- Position sharing requires radio or proximity\r\n- Search based on last known, not real-time tracking\r\n- Realistic sight/sound range limitations\r\n\r\n### 2. Player-Like Tactics\r\n> \"Primary focus is to make challenging but fair bots by imitating player tactics.\"\r\n\r\n**Implementation**:\r\n- Decision trees mirror player thought process\r\n- Cover usage, flanking, suppression like players\r\n- Personality-based behavior variation\r\n- Vulnerable action exploitation (healing, reloading)\r\n\r\n### 3. Performance First\r\n> \"Several features within SAIN that are set up with the intention that power users can tweak.\"\r\n\r\n**Implementation**:\r\n- Tick segregation by bot state\r\n- Variable update frequencies\r\n- Sound caching and batching\r\n- Job system for parallel processing\r\n- AI limit system for distant bot\r\n\r\ns\r\n- Lazy component initialization\r\n\r\n### 4. Configurability\r\n> \"Most internal configuration for AI can be changed, and changes made within the GUI take effect right away.\"\r\n\r\n**Implementation**:\r\n- Preset system with live reload\r\n- Per-bot-type settings\r\n- Per-personality settings\r\n- Global overrides\r\n- F6 in-game editor\r\n\r\n### 5. Mod Compatibility\r\n> \"SAIN is designed in such a way that all bots are subject to strict limitations.\"\r\n\r\n**Implementation**:\r\n- BigBrain layer system (priority-based)\r\n- Vanilla layer removal (not replacement)\r\n- Exclusion list for incompatible bots\r\n- Event-driven architecture (decoupled)\r\n- Optional dependency detection\r\n\r\n---\r\n\r\n## üìñ For FriendlyPMC: What to Adopt\r\n\r\n### From Architecture\r\n‚úÖ **Component-Based Design**\r\n- 32 components is overkill for followers\r\n- Adopt: Core (Info, Decision, Enemy, Movement, Combat) ~10 components\r\n- Skip: Advanced features (vaulting, backpack drop, space awareness)\r\n\r\n‚úÖ **Tick System**\r\n- 4-tier grouping (Always/Active/NoSleep/Combat)\r\n- Variable intervals per component\r\n- `ShallTick(currentTime)` pattern\r\n\r\n‚úÖ **Event System**\r\n- OnDecisionMade, OnEnemyAdded, OnGoalEnemyChanged\r\n- Use for cluster perception (DESIGN_INTENT Phase 6)\r\n\r\n‚úÖ **Manager Singletons**\r\n- FollowerManager (global coordination)\r\n- ClusterManager (perception sharing)\r\n\r\n### From Decision System\r\n‚úÖ **Simplified Decision Enum**\r\n```csharp\r\nenum EFollowerDecision {\r\n    None,\r\n    FollowLeader,      // Default behavior\r\n    EngageEnemy,       // In combat\r\n    SeekCover,         // Need cover\r\n    ExecuteCommand,    // Voice command override\r\n    HealLeader,        // Medic role\r\n    ProvideSupport     // Support role\r\n}\r\n```\r\n\r\n‚úÖ **Matrix-Based Thresholds**\r\n- Health √ó Distance for healing decisions\r\n- Ammo √ó Distance for reload decisions\r\n- Adopt this pattern, simplify thresholds\r\n\r\n‚úÖ **Anti-Flapping**\r\n- `TimeSinceChangeDecision` tracking\r\n- Minimum hold times per decision\r\n- Previous decision caching\r\n\r\n### From Enemy System\r\n‚úÖ **Per-Enemy LOD** (CRITICAL for Phase 6)\r\n```csharp\r\nDictionary<string, float> _nextCheckPerEnemy;\r\n\r\nfloat interval = enemy == goalEnemy ? 0.05f   // 20 Hz\r\n               : enemy.IsVisible ? 0.1f        // 10 Hz\r\n               : enemy.Known ? 0.25f           // 4 Hz\r\n               : 1.0f;                         // 1 Hz\r\n```\r\n\r\n‚úÖ **Cluster Primary Sensor** (DESIGN_INTENT Phase 6)\r\n- One bot per cluster does heavy vision work\r\n- Others read shared data\r\n- Rotate sensor based on LOS/position\r\n\r\n‚úÖ **Memory System**\r\n- Last known position tracking\r\n- Time-based forgetting\r\n- Squad position sharing\r\n\r\n### From Movement\r\n‚úÖ **Dual-Path Buffer**\r\n- Smooth transitions between movement targets\r\n- One active, one prepared\r\n\r\n‚úÖ **Sprint Urgency**\r\n- None/Low/Middle/High with stamina thresholds\r\n- Adopt for follower movement priorities\r\n\r\n‚ö†Ô∏è **Cover Finding**\r\n- SAIN's dynamic collider-based system is complex\r\n- Use vanilla `BotOwner.Covers.GetClosePoints()` for followers\r\n- Adopt validation pattern (7-step check)\r\n\r\n### From Combat\r\n‚úÖ **Friendly Fire Prevention**\r\n- SphereCast before every shot\r\n- Immediate shoot cancellation if blocked\r\n- Critical for follower safety\r\n\r\n‚ö†Ô∏è **Shooting/Aim Systems**\r\n- SAIN's systems are deeply integrated with EFT internals\r\n- For followers: Use vanilla shooting, focus on positioning\r\n- Adopt: Target selection priority only\r\n\r\n‚úÖ **Suppression**\r\n- Caliber-based accumulation\r\n- Distance scaling\r\n- Resistance modifiers\r\n- Can adopt for support role (Phase 7, Innovation #3)\r\n\r\n### From Sensory\r\n‚ö†Ô∏è **Vision Raycasts**\r\n- SAIN's multi-threaded job system is advanced\r\n- For followers: Use vanilla vision + cluster perception\r\n- Adopt concept: Primary sensor does heavy work\r\n\r\n‚úÖ **Hearing**\r\n- Probability-based footstep detection\r\n- Environment/occlusion modifiers\r\n- Can adopt for audio-based cluster sharing\r\n\r\n‚úÖ **Gain Sight Modifiers**\r\n- 12-factor stack is realistic\r\n- For followers: Simplified (3-5 key factors)\r\n- Adopt: Repeat seen bonus (100x faster near last known!)\r\n\r\n### From Squad\r\n‚úÖ **Position Sharing**\r\n- Coordination-based probability\r\n- Radio range vs voice range\r\n- Adopt for cluster perception\r\n\r\n‚úÖ **Communication Patterns**\r\n- Decision-based voice triggers\r\n- Leader commands + member responses\r\n- Adopt for follower acknowledgments (Phase 7)\r\n\r\n‚úÖ **Squad Tactics**\r\n- PushSuppressed, Suppress, Help patterns\r\n- Can adapt for fireteam coordination (Phase 12A)\r\n\r\n---\r\n\r\n## üéØ FriendlyPMC Integration Strategy\r\n\r\n### Phase 6: Basic AI (Use SAIN Patterns)\r\n\r\n**Adopt**:\r\n1. Component architecture (10 simplified components)\r\n2. Tick system (4-tier grouping)\r\n3. Event-driven cluster perception\r\n4. Per-enemy LOD pattern\r\n5. Movement API patterns\r\n6. Friendly fire prevention\r\n\r\n**Skip**:\r\n1. Full 32-component system\r\n2. Multi-threaded raycasts (use vanilla)\r\n3. Dynamic cover finding (use vanilla covers)\r\n4. Complex aim/shoot systems\r\n5. Advanced decision trees\r\n\r\n**Result**: Functional follower AI with SAIN-quality architecture, vanilla execution.\r\n\r\n---\r\n\r\n### Phase 7: Voice Commands (Use SAIN Communication)\r\n\r\n**Adopt**:\r\n1. Decision ‚Üí Voice triggers\r\n2. Command ‚Üí Response patterns\r\n3. Squad member acknowledgments\r\n4. Directional callouts\r\n\r\n**From GroupTalk.cs**:\r\n- Leader command system\r\n- Member response logic\r\n- Delay patterns (0.75-1.5s)\r\n- Probability-based responses (35-50%)\r\n\r\n---\r\n\r\n### Phase 12+: Advanced Features (Use SAIN Algorithms)\r\n\r\n**Medic AI** (from Medical + Search systems):\r\n- Priority calculation for treatment\r\n- Safe area checks\r\n- Healing decision matrix\r\n\r\n**Suppression** (from Suppression system):\r\n- Caliber-based accumulation\r\n- Distance scaling\r\n- Resistance modifiers\r\n\r\n**Squad Tactics** (from Squad system):\r\n- Position sharing\r\n- Coordination probability\r\n- Squad decision delegation\r\n\r\n---\r\n\r\n## üìä SAIN vs FriendlyPMC Complexity Comparison\r\n\r\n| System | SAIN | FriendlyPMC Needs |\r\n|--------|------|-------------------|\r\n| **Components** | 32 per bot | ~10 per follower |\r\n| **Decision Types** | 34 (3 enums) | ~7 (1 enum) |\r\n| **Vision System** | Multi-threaded jobs | Vanilla + cluster |\r\n| **Hearing System** | Full probability | Simplified |\r\n| **Cover Finding** | Dynamic collider | Vanilla covers |\r\n| **Movement** | Advanced (vault, lean) | Basic (walk, run, cover) |\r\n| **Squad Tactics** | Full coordination | Leader-following |\r\n| **Update Rate** | 4-30 Hz per system | 5-10 Hz simplified |\r\n\r\n**Complexity Reduction**: ~70% simpler for followers while adopting proven patterns.\r\n\r\n---\r\n\r\n## üöÄ Implementation Roadmap\r\n\r\n### Week 1-2: Architecture Adoption\r\n- Create FollowerComponent with 10 sub-components\r\n- Implement 4-tier tick system\r\n- Set up event-driven updates\r\n- **Reference**: SAIN Architecture sections 2-5\r\n\r\n### Week 3: Enemy & Decision\r\n- Implement per-enemy LOD (Dictionary<string, float>)\r\n- Create FollowerDecision enum (7 types)\r\n- Adopt decision stability patterns\r\n- **Reference**: SAIN Decision + Enemy sections\r\n\r\n### Week 4: Movement & Combat\r\n- Implement movement using SAINMoverClass patterns\r\n- Add friendly fire prevention\r\n- Integrate cover finding (vanilla covers)\r\n- **Reference**: SAIN Movement section 2-3\r\n\r\n### Week 5-6: Cluster Perception (Phase 6)\r\n- Primary sensor selection (from DESIGN_INTENT)\r\n- Shared target system\r\n- Event-based damage sharing\r\n- **Reference**: SAIN Enemy section 9 + Architecture section 5.3\r\n\r\n### Week 7: Voice Commands\r\n- Adopt GroupTalk patterns\r\n- Command ‚Üí Response system\r\n- **Reference**: SAIN Squad section 3\r\n\r\n### Week 8+: Advanced Features\r\n- Medic AI using SAIN medical patterns\r\n- Suppression using SAIN algorithms\r\n- Squad tactics using SAIN coordination\r\n- **Reference**: SAIN Combat section 6, Squad section 4-5\r\n\r\n---\r\n\r\n## üìÅ SAIN Source File Catalog\r\n\r\n### Core Systems (Classes/Bot/)\r\n- **Decision**: 5 files (BotDecisionManager, EnemyDecision, SquadDecision, SelfActionDecision, DogFightDecision)\r\n- **EnemyClasses**: 38 files (Enemy, Vision, Hearing, Status, Position, Path, Aim, etc.)\r\n- **EnemyControllers**: 4 files (SAINEnemyController, EnemyListController, EnemyList)\r\n- **Mover**: 12 files (SAINMoverClass, Pose, Lean, Vault, DogFight, BlindFire, etc.)\r\n- **Sense**: 15 files (Vision, Hearing, Memory, etc.)\r\n- **WeaponFunction**: 14 files (Shoot, Aim, Grenade, Recoil, Firerate, etc.)\r\n- **Suppression**: 3 files\r\n- **Talk**: 3 files (SAINBotTalk, GroupTalk, EnemyTalk)\r\n- **Squad**: 1 file (BotSquadClass - per-bot interface)\r\n\r\n### Global Managers (Classes/BotManager/, Classes/PlayerManager/)\r\n- **BotManager**: BotSquads, Squad, MemberInfo, SquadPersonality\r\n- **PlayerManager**: TimeClass, SAINWeatherClass, BotHearing\r\n\r\n### Components (Components/)\r\n- GameWorldComponent\r\n- BotManagerComponent\r\n- BotSpawnController\r\n- SAINNoBushESP\r\n- ColliderCoverManager\r\n- ExtractFinderComponent\r\n\r\n### Layers (Layers/)\r\n- Combat/Solo: CombatSoloLayer + 12 actions\r\n- Combat/Squad: CombatSquadLayer + 4 actions\r\n- Extract: ExtractLayer + ExtractAction\r\n- Peace: PeaceLayer + PatrolAction\r\n- AvoidThreat: SAINAvoidThreatLayer\r\n- Debug: DebugLayer\r\n- Unstuck: UnstuckLayer\r\n\r\n### Models (Models/)\r\n- Enums: 45+ enums (ECombatDecision, ESquadDecision, ESAINLayer, etc.)\r\n- Structs: Data structures for jobs, paths, sounds, etc.\r\n\r\n### Patches (Patches/)\r\n- 193 Harmony patches across 12 categories\r\n- Components, Generic, Movement, Hearing, Talk, Vision, Shoot\r\n\r\n---\r\n\r\n## ‚úÖ Documentation Quality\r\n\r\n**Authentic Source Benefits**:\r\n- ‚úÖ Real variable names (not obfuscated)\r\n- ‚úÖ Author comments preserved\r\n- ‚úÖ Complete logic (no missing pieces)\r\n- ‚úÖ Actual algorithms (not reverse-engineered)\r\n- ‚úÖ Design rationale visible\r\n- ‚úÖ Easter eggs documented (cheater mode!)\r\n\r\n**Validation**:\r\n- ‚úÖ SAIN v4.2.0 ships and works (production proven)\r\n- ‚úÖ Used by thousands of SPT players\r\n- ‚úÖ Reference implementation for SPT AI modding\r\n- ‚úÖ All algorithms extracted from working code\r\n\r\n---\r\n\r\n## üìñ How to Use This Documentation\r\n\r\n### For Understanding SAIN\r\n1. Read Architecture (component system, managers, tick flow)\r\n2. Read Decision System (how bots decide actions)\r\n3. Read Enemy System (how bots track threats)\r\n4. Read specific systems as needed\r\n\r\n### For Building FriendlyPMC\r\n1. Review \"For FriendlyPMC\" sections in each document\r\n2. Adopt patterns (component architecture, tick system, events)\r\n3. Simplify algorithms (10 components vs 32, 7 decisions vs 34)\r\n4. Reference specific implementations (movement API, FF prevention, etc.)\r\n\r\n### For Solving AGENT1's Blockers\r\n- **BLOCKER 1 (BigBrain)**: Architecture section 4.3 (layer/logic integration)\r\n- **BLOCKER 2 (Multi-Enemy)**: Enemy System section 7 (EnemyListController)\r\n- **BLOCKER 3 (Movement)**: Movement section 2 (SAINMoverClass API)\r\n- **BLOCKER 4 (Cover)**: Movement section 4 (cover finding)\r\n- **BLOCKER 5 (Per-Enemy Timers)**: Enemy section 1.1 (LOD system)\r\n\r\n---\r\n\r\n## üèÜ Achievement Unlocked\r\n\r\n**You now have**:\r\n- ‚úÖ Complete SAIN v4.2.0 source code documentation\r\n- ‚úÖ All major systems analyzed (~90K LOC)\r\n- ‚úÖ Actual algorithms from authentic source\r\n- ‚úÖ Design rationale from author\r\n- ‚úÖ Integration patterns for FriendlyPMC\r\n- ‚úÖ Proven, production-quality reference\r\n\r\n**Total Documentation**: ~2.5MB knowledge base + comprehensive SAIN analysis\r\n\r\n**SAIN is now fully understood** - ready to adopt patterns for FriendlyPMC! üéØ‚ú®\r\n\r\n---\r\n\r\n*Documentation generated from SAIN v4.2.0 authentic source code by Solarint*\r\n*Analysis completed: 2025-11-21*\r\n*Knowledge base: E:\\AppDev\\LTsTarkovAI\\LTFriendlyPMC\\knowledge\\*\r\n"},"CREATING-PROFILE-BOTS-GUIDE":{"title":"Creating AI Bots with Real Profiles - Complete Guide\r","category":"General","content":"# Creating AI Bots with Real Profiles - Complete Guide\r\n\r\n**Source**: SPT v4.0.x C# Source Code Analysis\r\n**Status**: ‚úÖ SOURCE-VERIFIED (Updated with Aid=0 Fix)\r\n**Use Case**: FriendlyPMC follower bots with customizable equipment\r\n**Last Updated**: 2025-11-23\r\n\r\n## ‚ö†Ô∏è CRITICAL FIX APPLIED\r\n\r\n**SPT 4.0.5+ Change**: `BotGenerator.AddIdsToBot()` now sets `Aid = 0` (line ~660)\r\n**Solution**: Generate custom non-zero Aid manually after bot generation\r\n**See**: [Aid Generation Strategy](#aid-generation-strategy) for implementation\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [Overview](#overview)\r\n2. [Profile Bot vs Regular Bot](#profile-bot-vs-regular-bot)\r\n3. [SPT 4.0.5+ Aid=0 Issue](#spt-405-aid0-issue)\r\n4. [Server-Side Implementation](#server-side-implementation)\r\n5. [Equipment Customization](#equipment-customization)\r\n6. [Client-Side Spawning](#client-side-spawning)\r\n7. [Complete Working Example](#complete-working-example)\r\n\r\n---\r\n\r\n## Overview\r\n\r\n### What is a Profile Bot?\r\n\r\nA **Profile Bot** is an AI entity with a full `PmcData` profile structure (like player scavs) rather than just a `BotBase` object. This enables:\r\n\r\n- ‚úÖ **Custom equipment** via inventory manipulation\r\n- ‚úÖ **Persistent stats** across raids (optional)\r\n- ‚úÖ **Proper faction assignment** (BEAR/USEC)\r\n- ‚úÖ **Full profile features** (skills, traders, quests)\r\n- ‚úÖ **Client rendering** with complete profile data\r\n\r\n### Why Use Profile Bots?\r\n\r\n**FriendlyPMC's Use Case**:\r\n- Each follower has custom loadout (different weapons, armor)\r\n- Followers are PMC faction (not scav)\r\n- Followers need persistent inventory for loot collection\r\n- Equipment visible to player and other clients\r\n\r\n---\r\n\r\n## Profile Bot vs Regular Bot\r\n\r\n### Architecture Comparison\r\n\r\n| Aspect | Regular Bot (BotBase) | Profile Bot (PmcData) |\r\n|--------|----------------------|----------------------|\r\n| **Data Structure** | `BotBase` object | `PmcData` (inherits `BotBase`) |\r\n| **Equipment Source** | Generated from `bots/{role}.json` templates | Stored in `Inventory.Items` array |\r\n| **Equipment Format** | Probability pools (template system) | Actual item instances with IDs |\r\n| **Customization** | Template modification (affects all bots) | Per-instance direct manipulation |\r\n| **Persistence** | None (regenerated each raid) | Full profile with save capability |\r\n| **Generation Cost** | Low (template-based) | Higher (full inventory generation) |\r\n| **Memory Usage** | ~10-20 KB | ~50-100 KB (full profile) |\r\n| **Use Case** | Standard AI (scavs, raiders, bosses) | Player scavs, custom followers |\r\n\r\n### Code Structure\r\n\r\n**Source**: `SPTarkov.Server.Core/Models/Eft/Common/PmcData.cs:7-19`\r\n\r\n```csharp\r\n// Regular bot\r\npublic record BotBase\r\n{\r\n    public MongoId? Id { get; set; }\r\n    public int? Aid { get; set; }\r\n    public Info? Info { get; set; }\r\n    public Customization? Customization { get; set; }\r\n    public BotBaseHealth? Health { get; set; }\r\n    public BotBaseInventory? Inventory { get; set; }  // Basic inventory\r\n    public Skills? Skills { get; set; }\r\n    // ... basic fields\r\n}\r\n\r\n// Profile bot (inherits + extends)\r\npublic record PmcData : BotBase\r\n{\r\n    public Dictionary<string, long>? Prestige { get; set; }\r\n    public Dictionary<string, double>? CheckedMagazines { get; set; }\r\n    public List<string> CheckedChambers { get; set; }\r\n    // Inherits all BotBase fields + adds profile-specific ones\r\n}\r\n```\r\n\r\n---\r\n\r\n## SPT 4.0.5+ Aid=0 Issue\r\n\r\n### The Problem\r\n\r\n**Source**: `BotGenerator.cs` Line ~660\r\n\r\n```csharp\r\nprotected void AddIdsToBot(BotBase bot)\r\n{\r\n    bot.Id = new MongoId();        // ‚úÖ Generates proper MongoId\r\n    bot.Aid = 0;                   // ‚ö†Ô∏è ZERO Aid (changed from SPT 3.x)\r\n    bot.SessionId = new MongoId(); // ‚úÖ Generates session ID\r\n}\r\n```\r\n\r\n**Impact**:\r\n- Old FriendlyPMC used non-zero Aids (1113xxx range)\r\n- Systems relying on Aid as identifier may break\r\n- Profile bots need unique, non-zero Aids\r\n\r\n### Aid Generation Strategy\r\n\r\n**Recommended Approach**: Hash-based player-scoped Aids\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class FollowerGeneratorService\r\n{\r\n    private readonly ConcurrentDictionary<MongoId, int> _followerCountByPlayer = new();\r\n    private readonly HashUtil _hashUtil;\r\n\r\n    private int GenerateFollowerAid(MongoId playerSessionId, int followerIndex)\r\n    {\r\n        // Hash player session for stable base\r\n        var hash = _hashUtil.GenerateCrc32ForData(playerSessionId.ToString());\r\n\r\n        // Map to 1113xxx-1119xxx range (7 bins)\r\n        var playerBase = 1113000 + ((int)(hash % 7) * 1000);\r\n\r\n        // Add follower index\r\n        return playerBase + followerIndex;\r\n    }\r\n\r\n    // Call on raid end to reset\r\n    public void ResetFollowerCount(MongoId sessionId)\r\n    {\r\n        _followerCountByPlayer.TryRemove(sessionId, out _);\r\n    }\r\n}\r\n```\r\n\r\n**Benefits**:\r\n- ‚úÖ Unique per follower\r\n- ‚úÖ Stable (same player ‚Üí same Aids)\r\n- ‚úÖ Grouped by player (1113xxx vs 1116xxx)\r\n- ‚úÖ Matches old FriendlyPMC range\r\n\r\n---\r\n\r\n## Server-Side Implementation\r\n\r\n### Step 1: Use BotGenerator Pattern\r\n\r\n**Source**: `SPTarkov.Server.Core/Generators/BotGenerator.cs:51-115`\r\n\r\nThe key is using `GeneratePlayerScav()` as a template:\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class FollowerGeneratorService(\r\n    ISptLogger<FollowerGeneratorService> logger,\r\n    BotGenerator botGenerator,\r\n    BotHelper botHelper,\r\n    ItemHelper itemHelper,\r\n    HashUtil hashUtil,\r\n    ICloner cloner\r\n)\r\n{\r\n    public PmcData GenerateFollowerBot(\r\n        MongoId sessionId,\r\n        string side,           // \"Bear\", \"Usec\", or \"Savage\"\r\n        string nickname,\r\n        CustomLoadout? loadout = null\r\n    )\r\n    {\r\n        // 1. Determine role and template\r\n        string role;\r\n        if (side == \"Bear\")\r\n            role = \"pmcbear\";\r\n        else if (side == \"Usec\")\r\n            role = \"pmcusec\";\r\n        else\r\n            role = \"assault\";  // Scav\r\n\r\n        // 2. Get bot template\r\n        var botTemplate = botHelper.GetBotTemplate(role);\r\n\r\n        // 3. Create generation details\r\n        var botGenDetails = new BotGenerationDetails\r\n        {\r\n            IsPmc = (side != \"Savage\"),\r\n            Side = side,\r\n            Role = role,\r\n            BotDifficulty = \"normal\",\r\n            BotCountToGenerate = 1,\r\n            IsPlayerScav = false,  // Not player scav, but custom follower\r\n        };\r\n\r\n        // 4. Generate base bot\r\n        var bot = botGenerator.PrepareAndGenerateBot(sessionId, botGenDetails);\r\n\r\n        // 5. **CONVERT BotBase TO PmcData**\r\n        var profile = ConvertToPmcData(bot, nickname);\r\n\r\n        // 6. **CUSTOMIZE EQUIPMENT** (if provided)\r\n        if (loadout != null)\r\n        {\r\n            ApplyCustomLoadout(profile, loadout);\r\n        }\r\n\r\n        logger.Info($\"Generated follower: {nickname} ({side})\");\r\n        return profile;\r\n    }\r\n\r\n    private PmcData ConvertToPmcData(BotBase bot, string customNickname, MongoId playerSessionId)\r\n    {\r\n        // Get follower index for this player\r\n        int followerIndex = _followerCountByPlayer.AddOrUpdate(\r\n            playerSessionId,\r\n            1,\r\n            (key, count) => count + 1\r\n        );\r\n\r\n        // **CRITICAL: Generate non-zero Aid**\r\n        int customAid = GenerateFollowerAid(playerSessionId, followerIndex);\r\n\r\n        var profile = new PmcData\r\n        {\r\n            // Copy all BotBase fields\r\n            Id = bot.Id,\r\n            Aid = customAid,              // ‚úÖ FIXED: Custom non-zero Aid\r\n            SessionId = bot.SessionId,\r\n            Savage = null,\r\n            KarmaValue = bot.KarmaValue,\r\n            Info = bot.Info,\r\n            Customization = bot.Customization,\r\n            Health = bot.Health,\r\n            Inventory = bot.Inventory,\r\n            Skills = bot.Skills,\r\n            Stats = bot.Stats,\r\n            Encyclopedia = bot.Encyclopedia,\r\n            TaskConditionCounters = bot.TaskConditionCounters,\r\n            InsuredItems = bot.InsuredItems,\r\n            Hideout = bot.Hideout,\r\n            Quests = bot.Quests,\r\n            TradersInfo = bot.TradersInfo,\r\n            UnlockedInfo = bot.UnlockedInfo,\r\n            RagfairInfo = bot.RagfairInfo,\r\n            Achievements = bot.Achievements,\r\n            RepeatableQuests = bot.RepeatableQuests,\r\n            Bonuses = bot.Bonuses,\r\n            Notes = bot.Notes,\r\n            CarExtractCounts = bot.CarExtractCounts,\r\n            CoopExtractCounts = bot.CoopExtractCounts,\r\n            SurvivorClass = bot.SurvivorClass,\r\n            WishList = bot.WishList,\r\n            Variables = bot.Variables,\r\n            MoneyTransferLimitData = bot.MoneyTransferLimitData,\r\n            IsPmc = bot.IsPmc,\r\n\r\n            // Add PmcData-specific fields\r\n            Prestige = new Dictionary<string, long>(),\r\n            CheckedMagazines = new Dictionary<string, double>(),\r\n            CheckedChambers = new List<string>(),\r\n        };\r\n\r\n        // Override nickname if custom provided\r\n        if (!string.IsNullOrEmpty(customNickname))\r\n        {\r\n            profile.Info.Nickname = customNickname;\r\n        }\r\n\r\n        // **SET MEMBER CATEGORY for visual distinction**\r\n        profile.Info.MemberCategory = MemberCategory.Sherpa;\r\n        profile.Info.SelectedMemberCategory = MemberCategory.Sherpa;\r\n\r\n        logger.Info($\"Follower created: {customNickname} (Id: {profile.Id}, Aid: {customAid})\");\r\n        return profile;\r\n    }\r\n\r\n    private int GenerateFollowerAid(MongoId playerSessionId, int followerIndex)\r\n    {\r\n        // Hash player session to get stable base\r\n        var hash = hashUtil.GenerateCrc32ForData(playerSessionId.ToString());\r\n\r\n        // Map to 1113xxx-1119xxx range (7000 slots)\r\n        var playerBase = 1113000 + ((int)(hash % 7) * 1000);\r\n\r\n        // Add follower index (1-10 typically)\r\n        // Player A followers: 1113001, 1113002, 1113003...\r\n        // Player B followers: 1116001, 1116002, 1116003...\r\n        return playerBase + followerIndex;\r\n    }\r\n\r\n    public void ResetFollowerCount(MongoId sessionId)\r\n    {\r\n        _followerCountByPlayer.TryRemove(sessionId, out _);\r\n        logger.Debug($\"Reset follower count for session {sessionId}\");\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Equipment Customization\r\n\r\n### Understanding Inventory Structure\r\n\r\n**Equipment is stored as a flat array with parent-child relationships**:\r\n\r\n**Source**: `SPTarkov.Server.Core/Models/Eft/Common/Tables/BotBase.cs:365-408`\r\n\r\n```json\r\n{\r\n  \"Inventory\": {\r\n    \"items\": [\r\n      {\r\n        \"_id\": \"root_id\",\r\n        \"_tpl\": \"55d7217a4bdc2d86028b456d\",\r\n        \"slotId\": \"hideout\"\r\n      },\r\n      {\r\n        \"_id\": \"weapon_id\",\r\n        \"_tpl\": \"5447a9cd4bdc2dbd208b4567\",\r\n        \"parentId\": \"root_id\",\r\n        \"slotId\": \"FirstPrimaryWeapon\"\r\n      },\r\n      {\r\n        \"_id\": \"mag_id\",\r\n        \"_tpl\": \"5ac66d725acfc43b321d4b53\",\r\n        \"parentId\": \"weapon_id\",\r\n        \"slotId\": \"mod_magazine\",\r\n        \"upd\": { \"StackObjectsCount\": 30 }\r\n      }\r\n    ],\r\n    \"equipment\": \"root_id\",\r\n    \"stash\": \"root_id\",\r\n    \"fastPanel\": {}\r\n  }\r\n}\r\n```\r\n\r\n### Equipment Customization Implementation\r\n\r\n```csharp\r\npublic class EquipmentCustomizer(ItemHelper itemHelper)\r\n{\r\n    public void ApplyCustomLoadout(PmcData profile, CustomLoadout loadout)\r\n    {\r\n        var items = profile.Inventory.Items;\r\n        var equipmentRoot = profile.Inventory.Equipment.Value;\r\n\r\n        logger.Info($\"Customizing equipment for {profile.Info.Nickname}\");\r\n\r\n        // 1. Replace primary weapon\r\n        if (loadout.PrimaryWeapon != null)\r\n        {\r\n            logger.Debug(\"Replacing primary weapon\");\r\n            ReplaceWeaponSlot(items, equipmentRoot, \"FirstPrimaryWeapon\", loadout.PrimaryWeapon);\r\n        }\r\n\r\n        // 2. Replace armor\r\n        if (loadout.ArmorVest != null)\r\n        {\r\n            logger.Debug($\"Replacing armor: {loadout.ArmorVest}\");\r\n            ReplaceSimpleSlot(items, equipmentRoot, \"ArmorVest\", loadout.ArmorVest);\r\n        }\r\n\r\n        // 3. Replace helmet\r\n        if (loadout.Helmet != null)\r\n        {\r\n            logger.Debug($\"Replacing helmet: {loadout.Helmet}\");\r\n            ReplaceSimpleSlot(items, equipmentRoot, \"Headwear\", loadout.Helmet);\r\n        }\r\n\r\n        // 4. Replace tactical vest\r\n        if (loadout.TacticalVest != null)\r\n        {\r\n            logger.Debug($\"Replacing tactical vest: {loadout.TacticalVest}\");\r\n            ReplaceSimpleSlot(items, equipmentRoot, \"TacticalVest\", loadout.TacticalVest);\r\n        }\r\n\r\n        // 5. Replace backpack\r\n        if (loadout.Backpack != null)\r\n        {\r\n            logger.Debug($\"Replacing backpack: {loadout.Backpack}\");\r\n            ReplaceSimpleSlot(items, equipmentRoot, \"Backpack\", loadout.Backpack);\r\n        }\r\n\r\n        // 6. Add custom loot to containers\r\n        if (loadout.AdditionalLoot != null && loadout.AdditionalLoot.Count > 0)\r\n        {\r\n            logger.Debug($\"Adding {loadout.AdditionalLoot.Count} custom loot items\");\r\n            AddLootToContainers(items, loadout.AdditionalLoot);\r\n        }\r\n\r\n        logger.Success($\"Equipment customized: {profile.Info.Nickname}\");\r\n    }\r\n\r\n    private void ReplaceSimpleSlot(\r\n        List<Item> items,\r\n        MongoId equipmentRoot,\r\n        string slotId,\r\n        string newTemplate\r\n    )\r\n    {\r\n        // Find existing item\r\n        var existing = items.FirstOrDefault(i =>\r\n            i.ParentId == equipmentRoot && i.SlotId == slotId);\r\n\r\n        // Remove it and all children\r\n        if (existing != null)\r\n        {\r\n            RemoveItemTree(items, existing.Id);\r\n        }\r\n\r\n        // Add new item\r\n        items.Add(new Item\r\n        {\r\n            Id = new MongoId(),\r\n            Template = new MongoId(newTemplate),\r\n            ParentId = equipmentRoot,\r\n            SlotId = slotId,\r\n            Upd = new Upd\r\n            {\r\n                SpawnedInSession = true\r\n            }\r\n        });\r\n    }\r\n\r\n    private void ReplaceWeaponSlot(\r\n        List<Item> items,\r\n        MongoId equipmentRoot,\r\n        string slotId,\r\n        WeaponLoadout weaponLoadout\r\n    )\r\n    {\r\n        // Remove existing weapon\r\n        var existing = items.FirstOrDefault(i =>\r\n            i.ParentId == equipmentRoot && i.SlotId == slotId);\r\n\r\n        if (existing != null)\r\n        {\r\n            RemoveItemTree(items, existing.Id);\r\n        }\r\n\r\n        // Create new weapon with mods\r\n        var weaponItems = BuildWeapon(\r\n            weaponLoadout.Template,\r\n            weaponLoadout.Mods,\r\n            equipmentRoot,\r\n            slotId\r\n        );\r\n\r\n        items.AddRange(weaponItems);\r\n    }\r\n\r\n    private List<Item> BuildWeapon(\r\n        string weaponTemplate,\r\n        Dictionary<string, string> mods,\r\n        MongoId parentId,\r\n        string slotId\r\n    )\r\n    {\r\n        var items = new List<Item>();\r\n        var weaponId = new MongoId();\r\n\r\n        // 1. Main weapon\r\n        items.Add(new Item\r\n        {\r\n            Id = weaponId,\r\n            Template = new MongoId(weaponTemplate),\r\n            ParentId = parentId,\r\n            SlotId = slotId,\r\n            Upd = new Upd\r\n            {\r\n                SpawnedInSession = true,\r\n                Repairable = new UpdRepairable\r\n                {\r\n                    Durability = 100,\r\n                    MaxDurability = 100\r\n                }\r\n            }\r\n        });\r\n\r\n        // 2. Add weapon mods\r\n        if (mods != null)\r\n        {\r\n            foreach (var (modSlot, modTemplate) in mods)\r\n            {\r\n                items.Add(new Item\r\n                {\r\n                    Id = new MongoId(),\r\n                    Template = new MongoId(modTemplate),\r\n                    ParentId = weaponId,\r\n                    SlotId = modSlot,\r\n                    Upd = new Upd { SpawnedInSession = true }\r\n                });\r\n            }\r\n        }\r\n\r\n        // 3. Add default magazine with ammo (if not in mods)\r\n        if (!mods?.ContainsKey(\"mod_magazine\") ?? true)\r\n        {\r\n            var defaultMag = GetDefaultMagazineForWeapon(weaponTemplate);\r\n            items.AddRange(CreateLoadedMagazine(defaultMag, weaponId, 30));\r\n        }\r\n\r\n        return items;\r\n    }\r\n\r\n    private List<Item> CreateLoadedMagazine(\r\n        string magTemplate,\r\n        MongoId weaponId,\r\n        int ammoCount\r\n    )\r\n    {\r\n        var items = new List<Item>();\r\n\r\n        items.Add(new Item\r\n        {\r\n            Id = new MongoId(),\r\n            Template = new MongoId(magTemplate),\r\n            ParentId = weaponId,\r\n            SlotId = \"mod_magazine\",\r\n            Upd = new Upd\r\n            {\r\n                SpawnedInSession = true,\r\n                StackObjectsCount = ammoCount\r\n            }\r\n        });\r\n\r\n        return items;\r\n    }\r\n\r\n    private void RemoveItemTree(List<Item> items, MongoId rootId)\r\n    {\r\n        var toRemove = new Stack<MongoId>();\r\n        toRemove.Push(rootId);\r\n\r\n        while (toRemove.Count > 0)\r\n        {\r\n            var current = toRemove.Pop();\r\n\r\n            // Find all children\r\n            var children = items.Where(i => i.ParentId == current).ToList();\r\n            foreach (var child in children)\r\n            {\r\n                toRemove.Push(child.Id);\r\n            }\r\n\r\n            // Remove current\r\n            items.RemoveAll(i => i.Id == current);\r\n        }\r\n    }\r\n\r\n    private string GetDefaultMagazineForWeapon(string weaponTemplate)\r\n    {\r\n        var weapon = itemHelper.GetItem(new MongoId(weaponTemplate)).Value;\r\n\r\n        // Find magazine slot\r\n        var magSlot = weapon.Properties.Slots\r\n            ?.FirstOrDefault(s => s.Name == \"mod_magazine\");\r\n\r\n        if (magSlot?.Properties?.Filters?.FirstOrDefault()?.Filter?.FirstOrDefault() != null)\r\n        {\r\n            return magSlot.Properties.Filters.First().Filter.First().Value;\r\n        }\r\n\r\n        throw new Exception($\"No default magazine for {weaponTemplate}\");\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Server-Side Route Implementation\r\n\r\n### Complete Follower Generation Endpoint\r\n\r\n```csharp\r\nusing SPTarkov.DI.Annotations;\r\nusing SPTarkov.Server.Core.DI;\r\nusing SPTarkov.Server.Core.Models.Common;\r\nusing SPTarkov.Server.Core.Models.Utils;\r\nusing SPTarkov.Server.Core.Utils;\r\nusing SPTarkov.Server.Core.Generators;\r\nusing SPTarkov.Server.Core.Helpers;\r\n\r\nnamespace FriendlyPmcServer;\r\n\r\n// Router\r\n[Injectable]\r\npublic class FollowerRouter(\r\n    JsonUtil jsonUtil,\r\n    FollowerGeneratorService followerService,\r\n    ISptLogger<FollowerRouter> logger\r\n) : StaticRouter(jsonUtil,\r\n[\r\n    new RouteAction<FollowerGenerateRequest>(\r\n        \"/client/game/bot/followergenerate\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            logger.Info($\"Generating follower for session {sessionId}\");\r\n\r\n            try\r\n            {\r\n                var follower = followerService.GenerateFollowerBot(\r\n                    sessionId,\r\n                    info.Side,\r\n                    info.Nickname,\r\n                    info.CustomLoadout\r\n                );\r\n\r\n                // Must serialize to string!\r\n                return jsonUtil.Serialize(new Profile[] { follower });\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.Error($\"Follower generation failed: {ex.Message}\");\r\n                return jsonUtil.Serialize(new { err = 500, errmsg = ex.Message });\r\n            }\r\n        }\r\n    )\r\n])\r\n{\r\n    logger.Info(\"FollowerRouter registered\");\r\n}\r\n\r\n// Request model\r\npublic class FollowerGenerateRequest : IRequestData\r\n{\r\n    public string? Side { get; set; }           // \"Bear\", \"Usec\", \"Savage\"\r\n    public string? Nickname { get; set; }       // Custom name\r\n    public CustomLoadout? CustomLoadout { get; set; }\r\n}\r\n\r\npublic class CustomLoadout\r\n{\r\n    public WeaponConfig? PrimaryWeapon { get; set; }\r\n    public WeaponConfig? SecondaryWeapon { get; set; }\r\n    public string? ArmorVest { get; set; }\r\n    public string? Helmet { get; set; }\r\n    public string? TacticalVest { get; set; }\r\n    public string? Backpack { get; set; }\r\n    public List<LootConfig>? AdditionalLoot { get; set; }\r\n}\r\n\r\npublic class WeaponConfig\r\n{\r\n    public string Template { get; set; }\r\n    public Dictionary<string, string>? Mods { get; set; }\r\n}\r\n\r\npublic class LootConfig\r\n{\r\n    public string Template { get; set; }\r\n    public int Count { get; set; }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Client-Side Spawning\r\n\r\n### Complete Spawn Implementation\r\n\r\n**Source Pattern**: PlayerScav spawn flow\r\n\r\n```csharp\r\nusing EFT;\r\nusing Comfort.Common;\r\n\r\npublic class FollowerSpawner\r\n{\r\n    public async Task<BotOwner> SpawnFollowerBot(\r\n        Player player,\r\n        string followerNickname,\r\n        CustomLoadout loadout\r\n    )\r\n    {\r\n        var gameWorld = Singleton<GameWorld>.Instance;\r\n        var botsController = gameWorld.GetComponent<BotsController>();\r\n        var botSpawner = botsController.BotSpawner;\r\n        var botCreator = botSpawner.BotCreator;\r\n\r\n        // 1. **FETCH PROFILE FROM SERVER**\r\n        var profile = await FetchFollowerProfile(\r\n            player,\r\n            followerNickname,\r\n            loadout\r\n        );\r\n\r\n        // 2. **LOAD ASSET BUNDLES FOR EQUIPMENT**\r\n        await LoadProfileAssets(profile);\r\n\r\n        // 3. Get spawn location\r\n        var spawnZone = botSpawner.GetClosestZone(player.Position, out var distance);\r\n        var closestPoint = botsController.CoversData.GetClosest(player.Position);\r\n        var corePoint = closestPoint.CorePointInGame;\r\n\r\n        // 4. Configure as friendly group\r\n        Func<BotOwner, BotZone, BotsGroup> createGroup = (bot, zone) =>\r\n        {\r\n            // Configure AI settings to not attack player\r\n            ConfigureFriendlyAI(bot, player);\r\n\r\n            // Create group with player as leader\r\n            return new BotsGroupPlayer(\r\n                zone,\r\n                botSpawner.BotGame,\r\n                bot,\r\n                new List<BotOwner>(),\r\n                botSpawner.DeadBodiesController,\r\n                botSpawner.AllPlayers,\r\n                player\r\n            );\r\n        };\r\n\r\n        // 5. Post-spawn configuration\r\n        Action<BotOwner> onActivate = (bot) =>\r\n        {\r\n            // Ensure not hostile to player\r\n            bot.Memory.DeleteInfoAboutEnemy(player);\r\n\r\n            // Match player's faction\r\n            bot.GetPlayer.Profile.Info.Side = player.Side;\r\n\r\n            // Full health\r\n            bot.GetPlayer.ActiveHealthController.RestoreFullHealth();\r\n\r\n            // Enable voice\r\n            bot.BotTalk.SetSilence(0f);\r\n\r\n            logger.Info($\"Follower activated: {bot.Profile.Nickname}\");\r\n        };\r\n\r\n        // 6. **ACTIVATE BOT WITH PROFILE**\r\n        var botOwner = await botCreator.ActivateBot(\r\n            profile,  // Full PmcData profile with custom equipment!\r\n            new GClass682(player.Position, corePoint.Id, false),\r\n            spawnZone,\r\n            false,  // not stationary\r\n            createGroup,\r\n            onActivate,\r\n            CancellationToken.None\r\n        );\r\n\r\n        return botOwner;\r\n    }\r\n\r\n    private async Task<Profile> FetchFollowerProfile(\r\n        Player player,\r\n        string nickname,\r\n        CustomLoadout loadout\r\n    )\r\n    {\r\n        var requestData = new\r\n        {\r\n            Side = player.Side.ToString(),\r\n            Nickname = nickname,\r\n            CustomLoadout = loadout\r\n        };\r\n\r\n        var json = JsonConvert.SerializeObject(requestData);\r\n        var response = await RequestHandler.PostJson(\"/client/game/bot/followergenerate\", json);\r\n        var profiles = JsonConvert.DeserializeObject<Profile[]>(response);\r\n\r\n        return profiles[0];\r\n    }\r\n\r\n    private async Task LoadProfileAssets(Profile profile)\r\n    {\r\n        // Get all unique item templates\r\n        var templates = profile.Inventory.Items\r\n            .Select(item => item.Template.Value)\r\n            .Distinct()\r\n            .ToArray();\r\n\r\n        // Load bundles\r\n        await Singleton<PoolManagerClass>.Instance.LoadBundlesAndCreatePools(\r\n            PoolManagerClass.PoolsCategory.Raid,\r\n            PoolManagerClass.AssemblyType.Online,\r\n            templates,\r\n            JobPriority.Immediate,\r\n            null,\r\n            default(CancellationToken)\r\n        );\r\n    }\r\n\r\n    private void ConfigureFriendlyAI(BotOwner bot, Player player)\r\n    {\r\n        // Disable attacking player\r\n        bot.Settings.FileSettings.Mind.ENEMY_BY_GROUPS_PMC_PLAYERS = false;\r\n        bot.Settings.FileSettings.Mind.USE_ADD_TO_ENEMY_VALIDATION = true;\r\n        bot.Settings.FileSettings.Mind.VALID_REASONS_TO_ADD_ENEMY = new EBotEnemyCause[] { };\r\n\r\n        // Remove player from enemy memory\r\n        bot.MemoryClass.DeleteInfoAbout(player);\r\n\r\n        // Set friendly to player's group\r\n        bot.BotsGroup.AddEnemy(player, EBotEnemyCause.none);  // Paradoxically makes friendly\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Complete Working Example\r\n\r\n### FriendlyPMC Pattern: Custom Follower with Preset Loadout\r\n\r\n```csharp\r\n// ===== SERVER SIDE =====\r\n\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class FriendlyPmcServer(\r\n    ISptLogger<FriendlyPmcServer> logger,\r\n    BotGenerator botGenerator,\r\n    BotHelper botHelper,\r\n    ItemHelper itemHelper\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        logger.Success(\"FriendlyPMC Server loaded\");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n\r\n[Injectable]\r\npublic class FriendlyPmcRouter(\r\n    JsonUtil jsonUtil,\r\n    BotGenerator botGenerator,\r\n    BotHelper botHelper,\r\n    ItemHelper itemHelper,\r\n    ISptLogger<FriendlyPmcRouter> logger\r\n) : StaticRouter(jsonUtil,\r\n[\r\n    new RouteAction<GenerateFollowerRequest>(\r\n        \"/friendlypmc/generatefollower\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            // Generate follower with custom loadout\r\n            var follower = GenerateFollower(\r\n                sessionId,\r\n                info.Nickname,\r\n                info.Loadout,\r\n                botGenerator,\r\n                botHelper,\r\n                itemHelper,\r\n                logger\r\n            );\r\n\r\n            return jsonUtil.Serialize(new[] { follower });\r\n        }\r\n    )\r\n])\r\n{ }\r\n\r\npublic static PmcData GenerateFollower(\r\n    MongoId sessionId,\r\n    string nickname,\r\n    FollowerLoadout loadout,\r\n    BotGenerator botGenerator,\r\n    BotHelper botHelper,\r\n    ItemHelper itemHelper,\r\n    ISptLogger logger\r\n)\r\n{\r\n    // 1. Get template\r\n    var botTemplate = botHelper.GetBotTemplate(\"pmcusec\");\r\n\r\n    // 2. Generate\r\n    var botDetails = new BotGenerationDetails\r\n    {\r\n        IsPmc = true,\r\n        Side = \"Usec\",\r\n        Role = \"pmcusec\",\r\n        BotDifficulty = \"normal\",\r\n        BotCountToGenerate = 1,\r\n    };\r\n\r\n    var bot = botGenerator.PrepareAndGenerateBot(sessionId, botDetails);\r\n\r\n    // 3. Convert to PmcData\r\n    var profile = new PmcData { /* ... copy all fields ... */ };\r\n    profile.Info.Nickname = nickname;\r\n\r\n    // 4. **CUSTOMIZE EQUIPMENT**\r\n    var items = profile.Inventory.Items;\r\n    var equipment = profile.Inventory.Equipment.Value;\r\n\r\n    // Replace weapon\r\n    var existingWeapon = items.FirstOrDefault(i =>\r\n        i.ParentId == equipment && i.SlotId == \"FirstPrimaryWeapon\");\r\n\r\n    if (existingWeapon != null)\r\n    {\r\n        RemoveItemTree(items, existingWeapon.Id);\r\n    }\r\n\r\n    // Add custom weapon: HK 416\r\n    var weaponId = new MongoId();\r\n    items.Add(new Item\r\n    {\r\n        Id = weaponId,\r\n        Template = new MongoId(\"5bb2475ed4351e00853264e3\"),  // HK416\r\n        ParentId = equipment,\r\n        SlotId = \"FirstPrimaryWeapon\",\r\n        Upd = new Upd { SpawnedInSession = true }\r\n    });\r\n\r\n    // Add magazine\r\n    items.Add(new Item\r\n    {\r\n        Id = new MongoId(),\r\n        Template = new MongoId(\"5bb20da9d4351e0035629dbf\"),  // 30-round PMAG\r\n        ParentId = weaponId,\r\n        SlotId = \"mod_magazine\",\r\n        Upd = new Upd { SpawnedInSession = true, StackObjectsCount = 30 }\r\n    });\r\n\r\n    // Replace armor: IOTV Gen4\r\n    var existingArmor = items.FirstOrDefault(i =>\r\n        i.ParentId == equipment && i.SlotId == \"ArmorVest\");\r\n\r\n    if (existingArmor != null)\r\n    {\r\n        RemoveItemTree(items, existingArmor.Id);\r\n    }\r\n\r\n    items.Add(new Item\r\n    {\r\n        Id = new MongoId(),\r\n        Template = new MongoId(\"5c0e5edb86f77461f55ed1f7\"),  // IOTV Gen4\r\n        ParentId = equipment,\r\n        SlotId = \"ArmorVest\",\r\n        Upd = new Upd { SpawnedInSession = true }\r\n    });\r\n\r\n    logger.Success($\"Generated follower: {nickname}\");\r\n    return profile;\r\n}\r\n\r\n// ===== CLIENT SIDE =====\r\n\r\npublic class ClientFollowerSpawner\r\n{\r\n    public async Task SpawnFollower(Player player)\r\n    {\r\n        // 1. Fetch from server\r\n        var response = await RequestHandler.PostJson(\r\n            \"/friendlypmc/generatefollower\",\r\n            JsonConvert.SerializeObject(new\r\n            {\r\n                Nickname = \"Alpha\",\r\n                Loadout = new\r\n                {\r\n                    PrimaryWeapon = \"HK416\",\r\n                    Armor = \"Gen4\",\r\n                    Helmet = \"FAST MT\"\r\n                }\r\n            })\r\n        );\r\n\r\n        var profiles = JsonConvert.DeserializeObject<Profile[]>(response);\r\n        var followerProfile = profiles[0];\r\n\r\n        // 2. **PROFILE ALREADY HAS CUSTOM EQUIPMENT!**\r\n        // No client-side generation needed\r\n\r\n        // 3. Load assets\r\n        var templates = followerProfile.Inventory.Items\r\n            .Select(i => i.Template.Value)\r\n            .Distinct()\r\n            .ToArray();\r\n\r\n        await Singleton<PoolManagerClass>.Instance.LoadBundlesAndCreatePools(\r\n            PoolManagerClass.PoolsCategory.Raid,\r\n            PoolManagerClass.AssemblyType.Online,\r\n            templates,\r\n            JobPriority.Immediate,\r\n            null,\r\n            default\r\n        );\r\n\r\n        // 4. Spawn\r\n        var controller = Singleton<GameWorld>.Instance.GetComponent<BotsController>();\r\n        var zone = controller.BotSpawner.GetClosestZone(player.Position, out var _);\r\n\r\n        await controller.BotSpawner.BotCreator.ActivateBot(\r\n            followerProfile,\r\n            new GClass682(player.Position, \"\", false),\r\n            zone,\r\n            false,\r\n            (bot, zn) => CreateFriendlyGroup(bot, player),\r\n            (bot) => ConfigureFollower(bot, player),\r\n            CancellationToken.None\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\n### The \"Old Method\" Explained\r\n\r\nFriendlyPMC's approach:\r\n\r\n1. **Server generates** full `PmcData` profile using `BotGenerator`\r\n2. **Server customizes** equipment by manipulating `Inventory.Items` array\r\n3. **Server returns** profile via custom HTTP endpoint\r\n4. **Client receives** profile with equipment already configured\r\n5. **Client spawns** bot using `BotCreator.ActivateBot(profile, ...)`\r\n6. **Result**: AI bot with custom loadout, proper faction, full profile features\r\n\r\n### Key Advantages\r\n\r\n- ‚úÖ **Per-follower customization** (each bot can have different gear)\r\n- ‚úÖ **Server-authoritative** (equipment defined server-side)\r\n- ‚úÖ **Client validation** (server validates item compatibility)\r\n- ‚úÖ **Asset loading** (client loads proper bundles)\r\n- ‚úÖ **Persistent inventory** (followers can collect and store loot)\r\n\r\n### This Still Works in SPT 4.0.x\r\n\r\n**Source verification**:\r\n- ‚úÖ `PlayerScavGenerator` still uses this pattern (Lines 46-134)\r\n- ‚úÖ `BotGenerator.GeneratePlayerScav()` still available (Lines 51-115)\r\n- ‚úÖ `PmcData` structure unchanged\r\n- ‚úÖ `BotCreator.ActivateBot()` still accepts Profile parameter\r\n\r\n**Compatibility**: ‚úÖ **FULLY FUNCTIONAL** in SPT 4.0.6\r\n\r\n---\r\n\r\n**Complete guide with source-code references, working examples, and architectural explanation!**\r\n"},"FRIENDLIST-NOTIFICATION-FIX":{"title":"Friend List Notification Fix - Diagnostic Guide\r","category":"General","content":"# Friend List Notification Fix - Diagnostic Guide\r\n\r\n**Problem**: AI PMC squad members added via `/add` don't appear in friend list\r\n**Status**: ‚úÖ SOLUTION PROVIDED\r\n**Date**: 2025-11-23\r\n\r\n---\r\n\r\n## Problem Analysis from Logs\r\n\r\n### Log Evidence\r\n\r\n```\r\nfriendlyPMC-server: added squad member nickname=ZikaCompatible1,\r\n    profileId=69231e26de04e8d4e0677c6e, aid=0\r\n\r\nSend message started, message: {\r\n    \"type\":\"new_message\",\r\n    \"eventId\":\"69231e26de04e8d4e0677c6e\"\r\n}\r\n\r\nprofile has 20 friends in FriendProfileIds\r\n```\r\n\r\n### Issues Identified\r\n\r\n**1. Aid = 0** ‚ö†Ô∏è\r\n- Still using `bot.Aid` which is 0 from BotGenerator\r\n- Need to apply custom Aid generation\r\n\r\n**2. Wrong Notification** ‚ùå\r\n- Sending `new_message` (chat message notification)\r\n- Should send `friendListRequestAccept` (friend added notification)\r\n\r\n**3. Friend Count Mismatch**\r\n- 20 friends shown, but should be 21 after adding ZikaCompatible1\r\n- Either not added to HashSet, or wrong session ID used\r\n\r\n---\r\n\r\n## Complete Fix\r\n\r\n### Fix 1: Generate Non-Zero Aid\r\n\r\n**In CreateSquadMember**:\r\n\r\n```csharp\r\n// BEFORE (Wrong):\r\nprofile.Aid = bot.Aid;  // ‚ùå Gets 0 from BotGenerator\r\n\r\n// AFTER (Correct):\r\nprofile.Aid = GenerateFollowerAid(ownerSessionId, memberIndex);  // ‚úÖ Custom Aid\r\n\r\nprivate int GenerateFollowerAid(MongoId ownerSessionId, int memberIndex)\r\n{\r\n    // Use HashUtil to generate stable Aid\r\n    var hash = hashUtil.GenerateCrc32ForData(ownerSessionId.ToString());\r\n    var baseAid = 1113000 + ((int)(hash % 7) * 1000);\r\n    return baseAid + memberIndex;\r\n}\r\n```\r\n\r\n**Why this matters**:\r\n- Some UI elements might filter Aid=0\r\n- Fika compatibility requires non-zero Aids\r\n- Matches original FriendlyPMC behavior\r\n\r\n---\r\n\r\n### Fix 2: Send Correct Notification Type\r\n\r\n**WRONG (Current)**:\r\n```csharp\r\n// Sending new_message notification\r\nvar notification = new WsChatMessageReceived\r\n{\r\n    EventType = NotificationEventType.new_message,  // ‚ùå Wrong type!\r\n    // ...\r\n};\r\n```\r\n\r\n**CORRECT**:\r\n```csharp\r\nusing SPTarkov.Server.Core.Models.Eft.Ws;\r\nusing SPTarkov.Server.Core.Models.Enums;\r\n\r\n// Send friend list accept notification\r\nvar notification = new WsFriendsListAccept\r\n{\r\n    EventType = NotificationEventType.friendListRequestAccept,  // ‚úÖ Correct type!\r\n    EventIdentifier = aiProfile.Id.Value,\r\n    Profile = new SearchFriendResponse\r\n    {\r\n        Id = aiProfile.Id.Value,\r\n        Aid = aiProfile.Aid,  // Must be non-zero!\r\n        Info = new UserDialogDetails\r\n        {\r\n            Nickname = aiProfile.Info.Nickname,\r\n            Side = aiProfile.Info.Side,\r\n            Level = aiProfile.Info.Level,\r\n            MemberCategory = MemberCategory.Sherpa,\r\n            SelectedMemberCategory = MemberCategory.Sherpa\r\n        }\r\n    }\r\n};\r\n\r\nnotificationSendHelper.SendMessage(ownerSessionId, notification);\r\n```\r\n\r\n**File References**:\r\n- `WsFriendsListAccept.cs` - Correct notification type\r\n- `SearchFriendResponse.cs` - Friend data structure\r\n- `NotificationEventType.cs:27` - `friendListRequestAccept` enum value\r\n\r\n---\r\n\r\n### Fix 3: Ensure Friend Actually Added\r\n\r\n**Check 1: Verify FriendProfileIds is not null**:\r\n\r\n```csharp\r\n// BEFORE (Might fail if null):\r\nownerProfile.FriendProfileIds.Add(aiProfile.Id.Value);  // ‚ùå NullReferenceException if null\r\n\r\n// AFTER (Safe):\r\nownerProfile.FriendProfileIds ??= new HashSet<MongoId>();  // ‚úÖ Initialize if null\r\nownerProfile.FriendProfileIds.Add(aiProfile.Id.Value);\r\n\r\nlogger.Info($\"Friend list now has {ownerProfile.FriendProfileIds.Count} friends\");\r\n```\r\n\r\n**Check 2: Verify correct session ID**:\r\n\r\n```csharp\r\n// Make sure you're using owner's session ID\r\nvar ownerProfile = saveServer.GetProfile(ownerSessionId);  // ‚úÖ Owner's profile\r\n// NOT\r\nvar ownerProfile = saveServer.GetProfile(aiProfile.SessionId);  // ‚ùå AI's session\r\n```\r\n\r\n**Check 3: Save profile after modification**:\r\n\r\n```csharp\r\n// Add friend\r\nownerProfile.FriendProfileIds.Add(aiProfile.Id.Value);\r\n\r\n// CRITICAL: Save the change!\r\nawait saveServer.SaveAsync();  // Or ensure auto-save is enabled\r\n```\r\n\r\n---\r\n\r\n### Fix 4: Debug Logging\r\n\r\n**Add comprehensive logging**:\r\n\r\n```csharp\r\npublic async Task CreateSquadMember(MongoId ownerSessionId, string nickname, string role)\r\n{\r\n    logger.Info(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\");\r\n    logger.Info($\"CreateSquadMember START\");\r\n    logger.Info($\"  Owner Session: {ownerSessionId}\");\r\n    logger.Info($\"  Nickname: {nickname}\");\r\n    logger.Info($\"  Role: {role}\");\r\n\r\n    // Generate AI PMC profile\r\n    var aiProfile = GenerateAiPmcProfile(ownerSessionId, nickname, role);\r\n    logger.Info($\"  Generated Profile ID: {aiProfile.Id}\");\r\n    logger.Info($\"  Generated Aid: {aiProfile.Aid}\");  // Should be non-zero!\r\n\r\n    // Save AI PMC profile\r\n    var aiSessionId = aiProfile.SessionId.Value;\r\n    var aiSptProfile = CreateSptProfile(aiProfile);\r\n    saveServer.SaveProfile(aiSessionId, aiSptProfile);\r\n    logger.Info($\"  AI PMC profile saved\");\r\n\r\n    // Add to owner's friend list\r\n    var ownerProfile = saveServer.GetProfile(ownerSessionId);\r\n    logger.Info($\"  Owner profile found: {ownerProfile.ProfileInfo.Nickname}\");\r\n\r\n    ownerProfile.FriendProfileIds ??= new HashSet<MongoId>();\r\n    int beforeCount = ownerProfile.FriendProfileIds.Count;\r\n\r\n    bool added = ownerProfile.FriendProfileIds.Add(aiProfile.Id.Value);\r\n    logger.Info($\"  Friend added: {added}\");\r\n    logger.Info($\"  Friend list: {beforeCount} ‚Üí {ownerProfile.FriendProfileIds.Count}\");\r\n\r\n    // Check if actually in list\r\n    bool inList = ownerProfile.FriendProfileIds.Contains(aiProfile.Id.Value);\r\n    logger.Info($\"  Verify in list: {inList}\");\r\n\r\n    // Save owner profile\r\n    await saveServer.SaveAsync();\r\n    logger.Info($\"  Profiles saved to disk\");\r\n\r\n    // Send notification\r\n    var notification = new WsFriendsListAccept\r\n    {\r\n        EventType = NotificationEventType.friendListRequestAccept,\r\n        EventIdentifier = aiProfile.Id.Value,\r\n        Profile = new SearchFriendResponse\r\n        {\r\n            Id = aiProfile.Id.Value,\r\n            Aid = aiProfile.Aid.Value,\r\n            Info = new UserDialogDetails\r\n            {\r\n                Nickname = aiProfile.Info.Nickname,\r\n                Side = aiProfile.Info.Side,\r\n                Level = aiProfile.Info.Level,\r\n                MemberCategory = MemberCategory.Sherpa,\r\n                SelectedMemberCategory = MemberCategory.Sherpa\r\n            }\r\n        }\r\n    };\r\n\r\n    logger.Info($\"  Notification type: {notification.EventType}\");\r\n    logger.Info($\"  Notification profile: {notification.Profile.Info.Nickname}\");\r\n\r\n    notificationSendHelper.SendMessage(ownerSessionId, notification);\r\n    logger.Info($\"  Notification sent\");\r\n\r\n    logger.Info(\"CreateSquadMember COMPLETE\");\r\n    logger.Info(\"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\");\r\n}\r\n```\r\n\r\n**Expected Log Output**:\r\n```\r\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nCreateSquadMember START\r\n  Owner Session: 691babbc4857d6876817f06c\r\n  Nickname: ZikaCompatible1\r\n  Role: Assault\r\n  Generated Profile ID: 69231e26de04e8d4e0677c6e\r\n  Generated Aid: 1115432  ‚Üê Should be non-zero!\r\n  AI PMC profile saved\r\n  Owner profile found: LT7\r\n  Friend added: True\r\n  Friend list: 20 ‚Üí 21  ‚Üê Should increment!\r\n  Verify in list: True\r\n  Profiles saved to disk\r\n  Notification type: friendListRequestAccept  ‚Üê Correct type!\r\n  Notification profile: ZikaCompatible1\r\n  Notification sent\r\nCreateSquadMember COMPLETE\r\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n```\r\n\r\n---\r\n\r\n## Complete Working Implementation\r\n\r\n### Server-Side: Fixed CreateSquadMember\r\n\r\n```csharp\r\nusing SPTarkov.Server.Core.Helpers;\r\nusing SPTarkov.Server.Core.Models.Eft.Common;\r\nusing SPTarkov.Server.Core.Models.Eft.Profile;\r\nusing SPTarkov.Server.Core.Models.Eft.Ws;\r\nusing SPTarkov.Server.Core.Models.Enums;\r\nusing SPTarkov.Server.Core.Models.Utils;\r\nusing SPTarkov.Server.Core.Servers;\r\nusing SPTarkov.Server.Core.Utils;\r\nusing System.Collections.Concurrent;\r\n\r\npublic class SquadService\r\n{\r\n    private readonly SaveServer _saveServer;\r\n    private readonly ProfileHelper _profileHelper;\r\n    private readonly NotificationSendHelper _notificationHelper;\r\n    private readonly HashUtil _hashUtil;\r\n    private readonly ISptLogger<SquadService> _logger;\r\n    private readonly ConcurrentDictionary<MongoId, int> _followerCountByPlayer = new();\r\n\r\n    public async Task<PmcData> CreateSquadMember(\r\n        MongoId ownerSessionId,\r\n        string nickname,\r\n        string role,\r\n        BotGenerator botGenerator,\r\n        BotHelper botHelper\r\n    )\r\n    {\r\n        _logger.Info($\"[CreateSquadMember] Creating {nickname} for {ownerSessionId}\");\r\n\r\n        // 1. Get follower index\r\n        int followerIndex = _followerCountByPlayer.AddOrUpdate(\r\n            ownerSessionId,\r\n            1,\r\n            (key, count) => count + 1\r\n        );\r\n\r\n        // 2. Generate AI PMC profile\r\n        var botTemplate = botHelper.GetBotTemplate(\"pmcusec\");\r\n        var botDetails = new BotGenerationDetails\r\n        {\r\n            IsPmc = true,\r\n            Side = \"Usec\",\r\n            Role = \"pmcusec\",\r\n            BotDifficulty = \"normal\",\r\n            BotCountToGenerate = 1\r\n        };\r\n\r\n        var bot = botGenerator.PrepareAndGenerateBot(ownerSessionId, botDetails);\r\n\r\n        // 3. **CRITICAL: Generate non-zero Aid**\r\n        int customAid = GenerateFollowerAid(ownerSessionId, followerIndex);\r\n\r\n        _logger.Info($\"[CreateSquadMember] Generated Aid: {customAid} (index: {followerIndex})\");\r\n\r\n        // 4. Convert to PmcData\r\n        var aiProfile = new PmcData\r\n        {\r\n            Id = bot.Id,\r\n            Aid = customAid,  // ‚úÖ Non-zero Aid\r\n            SessionId = bot.SessionId,\r\n            Info = bot.Info,\r\n            Customization = bot.Customization,\r\n            Health = bot.Health,\r\n            Inventory = bot.Inventory,\r\n            Skills = bot.Skills,\r\n            Stats = bot.Stats,\r\n            // ... copy all other BotBase fields\r\n            Prestige = new Dictionary<string, long>(),\r\n            CheckedMagazines = new Dictionary<string, double>(),\r\n            CheckedChambers = new List<string>()\r\n        };\r\n\r\n        // 5. Set nickname and member category\r\n        aiProfile.Info.Nickname = nickname;\r\n        aiProfile.Info.MemberCategory = MemberCategory.Sherpa;\r\n        aiProfile.Info.SelectedMemberCategory = MemberCategory.Sherpa;\r\n\r\n        _logger.Info($\"[CreateSquadMember] Profile created - ID: {aiProfile.Id}, Aid: {aiProfile.Aid}\");\r\n\r\n        // 6. Save AI PMC profile\r\n        var aiSptProfile = new SptProfile\r\n        {\r\n            ProfileInfo = new ProfileInfo\r\n            {\r\n                Id = aiProfile.Id.Value,\r\n                Nickname = nickname,\r\n                Aid = customAid,\r\n                AccountType = 2,\r\n                MemberCategory = MemberCategory.Sherpa,\r\n                SavageAccountId = new MongoId()\r\n            },\r\n            CharacterData = new CharacterData\r\n            {\r\n                PmcData = aiProfile,\r\n                ScavData = null\r\n            },\r\n            FriendProfileIds = new HashSet<MongoId>(),\r\n            DialogueRecords = new Dictionary<MongoId, Dialogue>()\r\n        };\r\n\r\n        _saveServer.SaveProfile(aiProfile.SessionId.Value, aiSptProfile);\r\n        _logger.Info($\"[CreateSquadMember] AI PMC profile saved to disk\");\r\n\r\n        // 7. Add to owner's friend list\r\n        var ownerProfile = _saveServer.GetProfile(ownerSessionId);\r\n\r\n        ownerProfile.FriendProfileIds ??= new HashSet<MongoId>();\r\n\r\n        int beforeCount = ownerProfile.FriendProfileIds.Count;\r\n        bool added = ownerProfile.FriendProfileIds.Add(aiProfile.Id.Value);\r\n\r\n        _logger.Info($\"[CreateSquadMember] Friend add result: {added}\");\r\n        _logger.Info($\"[CreateSquadMember] Friend count: {beforeCount} ‚Üí {ownerProfile.FriendProfileIds.Count}\");\r\n\r\n        if (!added)\r\n        {\r\n            _logger.Warning($\"[CreateSquadMember] Friend was already in list!\");\r\n        }\r\n\r\n        // Verify it's actually there\r\n        bool verified = ownerProfile.FriendProfileIds.Contains(aiProfile.Id.Value);\r\n        _logger.Info($\"[CreateSquadMember] Verified in friend list: {verified}\");\r\n\r\n        // 8. Save owner profile\r\n        await _saveServer.SaveAsync();\r\n        _logger.Info($\"[CreateSquadMember] Owner profile saved\");\r\n\r\n        // 9. **CRITICAL: Send CORRECT notification**\r\n        var notification = new WsFriendsListAccept\r\n        {\r\n            EventType = NotificationEventType.friendListRequestAccept,  // ‚úÖ Correct type!\r\n            EventIdentifier = aiProfile.Id.Value,\r\n            Profile = new SearchFriendResponse\r\n            {\r\n                Id = aiProfile.Id.Value,\r\n                Aid = customAid,  // ‚úÖ Non-zero Aid\r\n                Info = new UserDialogDetails\r\n                {\r\n                    Nickname = nickname,\r\n                    Side = \"Usec\",\r\n                    Level = 1,\r\n                    MemberCategory = MemberCategory.Sherpa,\r\n                    SelectedMemberCategory = MemberCategory.Sherpa\r\n                }\r\n            }\r\n        };\r\n\r\n        _logger.Info($\"[CreateSquadMember] Sending notification type: {notification.EventType}\");\r\n\r\n        _notificationHelper.SendMessage(ownerSessionId, notification);\r\n\r\n        _logger.Success($\"[CreateSquadMember] {nickname} added to squad successfully!\");\r\n\r\n        return aiProfile;\r\n    }\r\n\r\n    private int GenerateFollowerAid(MongoId ownerSessionId, int followerIndex)\r\n    {\r\n        var hash = _hashUtil.GenerateCrc32ForData(ownerSessionId.ToString());\r\n        var baseAid = 1113000 + ((int)(hash % 7) * 1000);\r\n        return baseAid + followerIndex;\r\n    }\r\n\r\n    public void ResetFollowerCount(MongoId sessionId)\r\n    {\r\n        _followerCountByPlayer.TryRemove(sessionId, out _);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Verification Steps\r\n\r\n### Step 1: Check Server Logs\r\n\r\n**After applying fix, look for**:\r\n```\r\n[CreateSquadMember] Generated Aid: 1115432 (index: 1)  ‚Üê Non-zero!\r\n[CreateSquadMember] Friend add result: True\r\n[CreateSquadMember] Friend count: 20 ‚Üí 21  ‚Üê Increments!\r\n[CreateSquadMember] Verified in friend list: True\r\n[CreateSquadMember] Sending notification type: friendListRequestAccept  ‚Üê Correct!\r\n```\r\n\r\n### Step 2: Check Client Notification\r\n\r\n**Client should receive**:\r\n```json\r\n{\r\n  \"type\": \"friendListRequestAccept\",\r\n  \"eventId\": \"69231e26de04e8d4e0677c6e\",\r\n  \"profile\": {\r\n    \"_id\": \"69231e26de04e8d4e0677c6e\",\r\n    \"aid\": 1115432,\r\n    \"Info\": {\r\n      \"Nickname\": \"ZikaCompatible1\",\r\n      \"Side\": \"Usec\",\r\n      \"Level\": 1,\r\n      \"MemberCategory\": 256,\r\n      \"SelectedMemberCategory\": 256\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Step 3: Verify Friend List\r\n\r\n**After notification, query**:\r\n```\r\nPOST /client/friend/list\r\n```\r\n\r\n**Should return**:\r\n```json\r\n{\r\n  \"Friends\": [\r\n    {\r\n      \"_id\": \"67b0f29e151899410b04aacb\",\r\n      \"aid\": 1113679,\r\n      \"Info\": {\"Nickname\": \"SquadManager\", ...}\r\n    },\r\n    {\r\n      \"_id\": \"69231e26de04e8d4e0677c6e\",\r\n      \"aid\": 1115432,  ‚Üê Non-zero!\r\n      \"Info\": {\r\n        \"Nickname\": \"ZikaCompatible1\",  ‚Üê Your new AI PMC!\r\n        \"Side\": \"Usec\",\r\n        \"Level\": 1,\r\n        \"MemberCategory\": 256  ‚Üê Sherpa badge\r\n      }\r\n    },\r\n    ... other friends\r\n  ]\r\n}\r\n```\r\n\r\n---\r\n\r\n## Common Issues & Solutions\r\n\r\n### Issue 1: Friend Still Doesn't Appear\r\n\r\n**Cause**: Client-side cache not refreshed\r\n\r\n**Solution**: Force client refresh by sending notification\r\n\r\n```csharp\r\n// After adding friend, send notification with small delay\r\nawait Task.Delay(100);  // Let save complete\r\n\r\nnotificationHelper.SendMessage(ownerSessionId, notification);\r\n\r\n// Optional: Also update friend list cache\r\nvar updatedFriendList = dialogueController.GetFriendList(ownerSessionId);\r\n// Send as separate notification if needed\r\n```\r\n\r\n### Issue 2: Notification Not Received\r\n\r\n**Cause**: WebSocket not connected or notification queue not polled\r\n\r\n**Check**:\r\n```csharp\r\n// Log notification delivery method\r\nif (sptWebSocketConnectionHandler.IsWebSocketConnected(ownerSessionId))\r\n{\r\n    logger.Info(\"Sending via WebSocket\");\r\n}\r\nelse\r\n{\r\n    logger.Info(\"Queuing for long-polling\");\r\n}\r\n```\r\n\r\n**Solution**: Ensure client is polling `/client/notifier/channel/create`\r\n\r\n### Issue 3: Wrong Profile Retrieved\r\n\r\n**Cause**: Using AI's SessionId instead of owner's\r\n\r\n**Check**:\r\n```csharp\r\n// ‚úÖ CORRECT\r\nvar ownerProfile = saveServer.GetProfile(ownerSessionId);\r\n\r\n// ‚ùå WRONG\r\nvar ownerProfile = saveServer.GetProfile(aiProfile.SessionId);\r\n```\r\n\r\n---\r\n\r\n## Required Imports\r\n\r\n```csharp\r\nusing SPTarkov.Server.Core.Helpers;\r\nusing SPTarkov.Server.Core.Models.Eft.Common;\r\nusing SPTarkov.Server.Core.Models.Eft.Profile;\r\nusing SPTarkov.Server.Core.Models.Eft.Ws;\r\nusing SPTarkov.Server.Core.Models.Enums;\r\nusing SPTarkov.Server.Core.Models.Utils;\r\nusing SPTarkov.Server.Core.Servers;\r\nusing SPTarkov.Server.Core.Utils;\r\nusing SPTarkov.Server.Core.Generators;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Concurrent;\r\nusing System.Threading.Tasks;\r\n```\r\n\r\n---\r\n\r\n## Checklist for Implementation\r\n\r\n**Code Changes**:\r\n- [ ] Generate non-zero Aid using `GenerateFollowerAid()`\r\n- [ ] Initialize `FriendProfileIds` if null\r\n- [ ] Add AI PMC profile ID to owner's `FriendProfileIds`\r\n- [ ] Create `WsFriendsListAccept` notification (not `WsChatMessageReceived`)\r\n- [ ] Set `EventType = friendListRequestAccept`\r\n- [ ] Include full `SearchFriendResponse` with profile data\r\n- [ ] Call `notificationHelper.SendMessage(ownerSessionId, notification)`\r\n- [ ] Save profiles with `saveServer.SaveAsync()`\r\n\r\n**Verification**:\r\n- [ ] Check logs for non-zero Aid\r\n- [ ] Check logs for friend count increment (20 ‚Üí 21)\r\n- [ ] Check logs for correct notification type\r\n- [ ] Test in-game: Check friend list in messenger\r\n- [ ] Test: View AI PMC profile from friend list\r\n- [ ] Test: Send message to AI PMC\r\n\r\n---\r\n\r\n## Expected Behavior After Fix\r\n\r\n**1. Run `/add ZikaCompatible1`**\r\n\r\nServer logs:\r\n```\r\n[CreateSquadMember] Generated Aid: 1115432\r\n[CreateSquadMember] Friend count: 20 ‚Üí 21\r\n[CreateSquadMember] Sending notification type: friendListRequestAccept\r\n```\r\n\r\n**2. Client UI updates**\r\n\r\n- Notification appears: \"Friend request accepted\"\r\n- Friend list refreshes\r\n- ZikaCompatible1 appears with Sherpa badge\r\n- Can view profile, send messages\r\n\r\n**3. Verify persistence**\r\n\r\n- Restart game\r\n- Friend list still shows ZikaCompatible1\r\n- Profile persisted to disk\r\n\r\n---\r\n\r\n**This comprehensive diagnostic guide should resolve the friend list issue!** üéØ\r\n"},"FRIENDLYPMC-FIKA-COMPATIBILITY-ANALYSIS":{"title":"FriendlyPMC + Fika Compatibility Analysis\r","category":"General","content":"# FriendlyPMC + Fika Compatibility Analysis\r\n\r\n**Analysis Date**: 2025-11-23\r\n**Status**: ‚úÖ COMPREHENSIVE ANALYSIS - Based on source code knowledge\r\n**Conclusion**: **COMPATIBLE** with specific implementation requirements\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\n**CAN THEY COEXIST?** ‚úÖ **YES** - With proper implementation\r\n\r\n**CONFLICTS IDENTIFIED**: 5 potential issues\r\n**SOLUTIONS AVAILABLE**: All conflicts solvable\r\n**COMPLEXITY**: Moderate - Requires Fika-aware implementation\r\n\r\n---\r\n\r\n## Architectural Analysis\r\n\r\n### FriendlyPMC Core Systems\r\n\r\n**From**: `OriginalFriendlyPMCDesign.md`\r\n\r\n1. **Bot Spawning**: Spawns 1-10 AI followers per player\r\n2. **Squad Management**: Messenger-based commands (chatbots)\r\n3. **Loot Collection**: Followers collect items, return on extract\r\n4. **Voice Commands**: Phrase menu for tactical orders\r\n5. **Server Routes**: Custom HTTP endpoints for configuration\r\n6. **Client Patches**: Bot control, gesture system\r\n\r\n### Fika Core Systems\r\n\r\n**From**: Fika research reports\r\n\r\n1. **P2P Networking**: LiteNetLib UDP for player sync\r\n2. **Bot Replication**: Host spawns bots, replicates to clients\r\n3. **Shared Loot**: Single loot generation for all players\r\n4. **DialogueController Override**: Custom friend system\r\n5. **LocationLifecycleService Override**: Multiplayer raid lifecycle\r\n6. **WebSocket Notifications**: Real-time push notifications\r\n\r\n---\r\n\r\n## Conflict Matrix\r\n\r\n| System | FriendlyPMC | Fika | Conflict? | Severity |\r\n|--------|-------------|------|-----------|----------|\r\n| Bot Spawning | Per-player follower bots | Host spawns, replicates to clients | ‚ö†Ô∏è YES | HIGH |\r\n| Loot System | Followers collect loot | Shared loot pool | ‚ö†Ô∏è YES | MEDIUM |\r\n| DialogueController | Chatbots for commands | Overridden for friends | ‚ö†Ô∏è YES | LOW |\r\n| Raid Lifecycle | Hooks spawn system | Overrides start/end | ‚ö†Ô∏è YES | MEDIUM |\r\n| Bot Commands | Voice/gesture commands | Bot action sync needed | ‚ö†Ô∏è YES | HIGH |\r\n\r\n---\r\n\r\n## CONFLICT #1: Bot Spawning & Replication\r\n\r\n### The Problem\r\n\r\n**FriendlyPMC**:\r\n```csharp\r\n// Spawns follower bots on server\r\nPOST /client/game/bot/followergenerate\r\n‚Üí Returns bot profiles\r\n‚Üí Client spawns bots locally\r\n```\r\n\r\n**Fika** (from research):\r\n```csharp\r\n// LocationLifecycleService.StartLocalRaid()\r\nif (FikaBackendUtils.IsServer)  // Only host generates bots\r\n{\r\n    botGenerator.GenerateBots(request);\r\n    BroadcastBotSpawnPackets(bots);  // Replicate to clients\r\n}\r\n```\r\n\r\n**Issue**: FriendlyPMC bots spawn client-side. Fika expects all bots to spawn on host and replicate.\r\n\r\n### The Solution\r\n\r\n**Approach 1: Fika-Aware Bot Spawning (RECOMMENDED)**\r\n\r\nModify FriendlyPMC to spawn bots differently based on Fika presence:\r\n\r\n```csharp\r\n// FriendlyPMC server-side route\r\n[Injectable]\r\npublic class FollowerRouter(\r\n    JsonUtil jsonUtil,\r\n    BotGenerator botGenerator,\r\n    MatchService fikaMatchService  // Inject Fika service\r\n) : StaticRouter(jsonUtil, [\r\n    new RouteAction<FollowerGenerateRequest>(\r\n        \"/client/game/bot/followergenerate\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            // Check if player is in Fika raid\r\n            var matchId = fikaMatchService.GetMatchIdByPlayer(sessionId);\r\n            bool isMultiplayer = matchId != null;\r\n\r\n            if (isMultiplayer)\r\n            {\r\n                // FIKA MODE: Generate on host only\r\n                var match = fikaMatchService.GetMatch(matchId);\r\n                bool isHost = match.Players[sessionId].IsHost;\r\n\r\n                if (isHost)\r\n                {\r\n                    // Generate followers\r\n                    var followers = GenerateFollowers(info, sessionId);\r\n\r\n                    // CRITICAL: Send Fika bot spawn packets\r\n                    foreach (var follower in followers)\r\n                    {\r\n                        BroadcastFikaBotSpawn(follower, matchId);\r\n                    }\r\n\r\n                    return jsonUtil.Serialize(followers);\r\n                }\r\n                else\r\n                {\r\n                    // Client waits for host to spawn followers\r\n                    // Followers will arrive via Fika's bot replication\r\n                    return jsonUtil.Serialize(new { waitingForHost = true });\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // SOLO MODE: Normal FriendlyPMC behavior\r\n                var followers = GenerateFollowers(info, sessionId);\r\n                return jsonUtil.Serialize(followers);\r\n            }\r\n        }\r\n    )\r\n])\r\n{ }\r\n```\r\n\r\n**Fika Integration Point** (from research):\r\n```csharp\r\n// Fika.Core/Main/Components/BotStateManager.cs\r\n// Use Fika's bot spawning system\r\npublic void SpawnBot(BotProfile profile, Vector3 position)\r\n{\r\n    // Fika automatically replicates to all clients\r\n    FikaServer.Instance.SpawnBot(profile);\r\n}\r\n```\r\n\r\n---\r\n\r\n## CONFLICT #2: Loot Collection & Shared Loot\r\n\r\n### The Problem\r\n\r\n**FriendlyPMC**:\r\n- Followers autonomously loot containers and bodies\r\n- Collected items stored in follower inventory\r\n- Items returned to player on extraction\r\n\r\n**Fika** (from `StartLocalRaidOverride.cs`):\r\n```csharp\r\n// All players use the SAME LocationData\r\nif (match != null)\r\n{\r\n    return match.LocationData;  // Shared loot spawns\r\n}\r\n```\r\n\r\n**Issue**: If Follower A (Player 1's bot) picks up loot, will it:\r\n1. Disappear for Player 2?\r\n2. Cause desync?\r\n3. Return to Player 1 or be lost?\r\n\r\n### The Solution\r\n\r\n**Approach: Loot Synchronization via Fika Packets**\r\n\r\n```csharp\r\n// FriendlyPMC client-side\r\npublic class FollowerLootHandler : MonoBehaviour\r\n{\r\n    public void OnFollowerCollectsItem(BotOwner follower, LootItem item)\r\n    {\r\n        if (FikaPlugin.Instance != null)\r\n        {\r\n            // Send Fika packet: Item picked up by follower\r\n            var packet = new FollowerLootPacket\r\n            {\r\n                FollowerNetId = follower.NetId,\r\n                ItemId = item.Id,\r\n                OwnerProfileId = Player.ProfileId\r\n            };\r\n\r\n            NetworkManager.SendData(ref packet,\r\n                DeliveryMethod.ReliableOrdered,\r\n                broadcast: true);\r\n        }\r\n\r\n        // Normal FriendlyPMC logic\r\n        AddItemToFollowerInventory(follower, item);\r\n    }\r\n}\r\n```\r\n\r\n**Fika Packet Definition**:\r\n```csharp\r\npublic struct FollowerLootPacket : INetSerializable\r\n{\r\n    public int FollowerNetId;\r\n    public string ItemId;\r\n    public string OwnerProfileId;\r\n\r\n    public void Serialize(NetDataWriter writer)\r\n    {\r\n        writer.Put(FollowerNetId);\r\n        writer.Put(ItemId);\r\n        writer.Put(OwnerProfileId);\r\n    }\r\n\r\n    public void Deserialize(NetDataReader reader)\r\n    {\r\n        FollowerNetId = reader.GetInt();\r\n        ItemId = reader.GetString();\r\n        OwnerProfileId = reader.GetString();\r\n    }\r\n}\r\n```\r\n\r\n**On Receive (All Clients)**:\r\n```csharp\r\nprivate void OnFollowerLootPacketReceived(FollowerLootPacket packet)\r\n{\r\n    // Remove item from world (all clients see it disappear)\r\n    var item = GameWorld.LootItems.GetById(packet.ItemId);\r\n    if (item != null)\r\n    {\r\n        GameWorld.LootItems.Remove(item);\r\n        Destroy(item.gameObject);\r\n    }\r\n\r\n    // Track for loot return (only owner)\r\n    if (packet.OwnerProfileId == Player.ProfileId)\r\n    {\r\n        TrackFollowerLoot(packet.FollowerNetId, packet.ItemId);\r\n    }\r\n}\r\n```\r\n\r\n**Loot Return** (unchanged):\r\n- FriendlyPMC's normal loot return system works\r\n- Only applies to owner's profile\r\n- Other players don't get the loot (as intended)\r\n\r\n---\r\n\r\n## CONFLICT #3: DialogueController & Chatbots\r\n\r\n### The Problem\r\n\r\n**FriendlyPMC** (from `AGENT1-FRIENDLYPMC-CHATBOT-VISIBILITY.md`):\r\n```csharp\r\n// Registers chatbots\r\ndialogueController.RegisterChatBot(bigPipeChatBot);\r\ndialogueController.RegisterChatBot(birdEyeChatBot);\r\ndialogueController.RegisterChatBot(knightChatBot);\r\n```\r\n\r\n**Fika** (from `DialogueControllerOverrides.cs`):\r\n```csharp\r\n[HarmonyPrefix]\r\npublic static bool GetFriendListOverride(ref GetFriendListDataResponse __result)\r\n{\r\n    // Completely replaces SPT's GetFriendList()\r\n    // Uses PlayerRelationsService instead\r\n    __result = FikaDialogueController.GetFriendsList(sessionId);\r\n    return false;  // Skip original method\r\n}\r\n```\r\n\r\n**Issue**: Fika's override skips SPT's chatbot integration.\r\n\r\n### The Solution\r\n\r\n**Analysis** (from `DialogueController.cs:111-131`):\r\n\r\nSPT's original `GetFriendList()`:\r\n```csharp\r\npublic virtual GetFriendListDataResponse GetFriendList(MongoId sessionId)\r\n{\r\n    // STEP 1: Get chatbots\r\n    var friends = GetActiveChatBots();  // ‚Üê Fika skips this!\r\n\r\n    // STEP 2: Add user friends\r\n    // ...\r\n}\r\n```\r\n\r\n**Fika's override** (from research):\r\n```csharp\r\npublic static GetFriendListDataResponse GetFriendsList(MongoId sessionID)\r\n{\r\n    // Gets friends from PlayerRelationsService\r\n    // NO chatbot support!\r\n}\r\n```\r\n\r\n**Fix: Modify Fika's Override to Include Chatbots**\r\n\r\n```csharp\r\n// In FikaServer/Controllers/FikaDialogueController.cs\r\npublic static GetFriendListDataResponse GetFriendsList(MongoId sessionID)\r\n{\r\n    var friendsList = new List<UserDialogInfo>();\r\n\r\n    // ADD THIS: Include SPT chatbots (FriendlyPMC bots!)\r\n    var dialogueController = ServiceLocator.ServiceProvider\r\n        .GetService(typeof(DialogueController)) as DialogueController;\r\n\r\n    if (dialogueController != null)\r\n    {\r\n        var chatbots = dialogueController.GetActiveChatBots();\r\n        friendsList.AddRange(chatbots);\r\n    }\r\n\r\n    // Existing Fika friend logic\r\n    var relations = _playerRelationsService.GetRelations(sessionID);\r\n    foreach (var friendId in relations.Friends)\r\n    {\r\n        var friendProfile = _profileHelper.GetFullProfile(new MongoId(friendId));\r\n        if (friendProfile?.HasProfileData() == true)\r\n        {\r\n            friendsList.Add(friendProfile.ToFriendData());\r\n        }\r\n    }\r\n\r\n    return new GetFriendListDataResponse\r\n    {\r\n        Friends = friendsList,\r\n        Ignore = relations.Ignore,\r\n        InIgnoreList = []\r\n    };\r\n}\r\n```\r\n\r\n**Status**: ‚úÖ SOLVABLE - Requires Fika modification OR FriendlyPMC uses different system\r\n\r\n---\r\n\r\n## CONFLICT #4: Bot Command Synchronization\r\n\r\n### The Problem\r\n\r\n**FriendlyPMC**:\r\n- Player uses phrase menu (double-tap Y)\r\n- Commands: \"Follow Me\", \"Hold Position\", \"Suppress\", etc.\r\n- Commands modify bot AI state\r\n\r\n**Fika**:\r\n- Bot AI states replicated via `BotStatePacket`\r\n- Commands from one player won't auto-sync to other clients\r\n- Other players won't see followers responding to commands\r\n\r\n**Issue**: Player 1 commands their followers. Player 2 sees followers behaving differently (desync).\r\n\r\n### The Solution\r\n\r\n**Approach: Command Packet System**\r\n\r\n```csharp\r\n// FriendlyPMC command packet\r\npublic struct FollowerCommandPacket : INetSerializable\r\n{\r\n    public int FollowerNetId;\r\n    public EFollowerCommand Command;  // FollowMe, HoldPosition, etc.\r\n    public Vector3 TargetPosition;    // For directional commands\r\n\r\n    public void Serialize(NetDataWriter writer)\r\n    {\r\n        writer.Put(FollowerNetId);\r\n        writer.PutEnum(Command);\r\n        writer.Put(TargetPosition);\r\n    }\r\n\r\n    public void Deserialize(NetDataReader reader)\r\n    {\r\n        FollowerNetId = reader.GetInt();\r\n        Command = reader.GetEnum<EFollowerCommand>();\r\n        TargetPosition = reader.GetVector3();\r\n    }\r\n}\r\n```\r\n\r\n**On Command Issue** (Player 1):\r\n```csharp\r\npublic void IssueCommand(EFollowerCommand command, Vector3 target)\r\n{\r\n    // Apply locally\r\n    followerAI.ExecuteCommand(command, target);\r\n\r\n    // Broadcast to Fika clients\r\n    if (FikaPlugin.Instance != null)\r\n    {\r\n        var packet = new FollowerCommandPacket\r\n        {\r\n            FollowerNetId = follower.NetId,\r\n            Command = command,\r\n            TargetPosition = target\r\n        };\r\n\r\n        NetworkManager.SendData(ref packet,\r\n            DeliveryMethod.ReliableOrdered,\r\n            broadcast: true);\r\n    }\r\n}\r\n```\r\n\r\n**On Receive** (All other players):\r\n```csharp\r\nprivate void OnFollowerCommandReceived(FollowerCommandPacket packet)\r\n{\r\n    var follower = FindBotByNetId(packet.FollowerNetId);\r\n    if (follower != null)\r\n    {\r\n        // Apply command to bot (visual sync)\r\n        follower.AIData.ExecuteCommand(packet.Command, packet.TargetPosition);\r\n    }\r\n}\r\n```\r\n\r\n**Status**: ‚úÖ SOLVABLE - Requires Fika packet integration\r\n\r\n---\r\n\r\n## CONFLICT #5: Raid Lifecycle Hooks\r\n\r\n### The Problem\r\n\r\n**FriendlyPMC** needs to:\r\n- Spawn followers on raid start\r\n- Process loot return on raid end\r\n- Clean up squad state\r\n\r\n**Fika** (from `StartLocalRaidOverride.cs`):\r\n```csharp\r\n[HarmonyPrefix]\r\npublic static bool Prefix(LocationLifecycleService __instance, ref StartLocalRaidResponseData __result)\r\n{\r\n    // Completely overrides StartLocalRaid\r\n    // Custom logic for multiplayer\r\n    __result = CustomStartRaid();\r\n    return false;  // Skip original\r\n}\r\n```\r\n\r\n**Issue**: Fika's override might prevent FriendlyPMC hooks from running.\r\n\r\n### The Solution\r\n\r\n**Analysis** (from `SPT-MOD-LIFECYCLE.md`):\r\n\r\nHarmony patch execution order:\r\n1. Prefix patches (can skip original)\r\n2. Original method (if not skipped)\r\n3. Postfix patches (always run)\r\n\r\n**Fix: Use Postfix Patch with Priority**\r\n\r\n```csharp\r\n// FriendlyPMC patch\r\n[HarmonyPatch(typeof(LocationLifecycleService), \"StartLocalRaid\")]\r\n[HarmonyAfter(\"com.fika.server\")]  // Run AFTER Fika\r\npublic class FriendlyPMCRaidStartPatch\r\n{\r\n    [HarmonyPostfix]\r\n    public static void Postfix(\r\n        MongoId sessionId,\r\n        StartLocalRaidRequestData request,\r\n        StartLocalRaidResponseData __result)\r\n    {\r\n        // Fika's override already ran\r\n        // Now spawn followers\r\n        var followerService = ServiceLocator.ServiceProvider\r\n            .GetService<FollowerService>();\r\n\r\n        if (followerService != null)\r\n        {\r\n            followerService.SpawnFollowers(sessionId, __result.LocationData);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Key**: Use `[HarmonyAfter(\"com.fika.server\")]` to ensure FriendlyPMC runs after Fika's modifications.\r\n\r\n**Status**: ‚úÖ SOLVABLE - Use Harmony patch ordering\r\n\r\n---\r\n\r\n## CONFLICT #6: Insurance System Interaction\r\n\r\n### Hidden Conflict\r\n\r\n**FriendlyPMC**:\r\n- Followers can be insured\r\n- If follower dies, player gets insurance return\r\n\r\n**Fika** (from `InsuranceService.cs`):\r\n```csharp\r\n// Tracks items taken by teammates\r\npublic void OnMatchEnd(string matchId)\r\n{\r\n    // If Player B has Player A's insured item ‚Üí remove from insurance\r\n}\r\n```\r\n\r\n**Issue**: If Player 1's follower dies, and Player 2 loots the follower's gear, should:\r\n1. Player 1 get insurance? (Follower's gear)\r\n2. Player 2 keep the loot? (Took it in raid)\r\n\r\n### The Solution\r\n\r\n**Decision Tree**:\r\n\r\n```\r\nFollower dies with insured gear\r\n         ‚Üì\r\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n    ‚îÇ Was it looted by  ‚îÇ\r\n    ‚îÇ another player?   ‚îÇ\r\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n              ‚îÇ\r\n    NO ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí YES\r\n    ‚îÇ                  ‚îÇ\r\n    ‚ñº                  ‚ñº\r\nInsurance      Player keeps loot\r\nreturns gear   Owner loses insurance\r\n```\r\n\r\n**Implementation**:\r\n\r\nFriendlyPMC insurance already compatible! No changes needed.\r\n\r\n**Why**:\r\n- Fika's `InsuranceService.OnEndLocalRaidRequest()` stores each player's inventory\r\n- If Player 2 extracts with follower's gun, it's in Player 2's inventory\r\n- Fika's `OnMatchEnd()` detects the gun in Player 2's inventory\r\n- Fika removes it from Player 1's insurance\r\n- System works correctly!\r\n\r\n**Status**: ‚úÖ NO CONFLICT - Works as designed\r\n\r\n---\r\n\r\n## CONFLICT #7: Chatbot System\r\n\r\n### The Problem\r\n\r\n**FriendlyPMC Chatbots** (from `AGENT1-FRIENDLYPMC-CHATBOT-VISIBILITY.md`):\r\n- BigPipe (ID: 677c4e0cc7a538c4210d4d48)\r\n- BirdEye (ID: 677c4e0cc7a538c4210d4d49)\r\n- Knight (ID: 677c4e0cc7a538c4210d4d4a)\r\n\r\n**Fika** (from research):\r\n```csharp\r\n// FikaDialogueController.GetFriendsList()\r\n// Doesn't call SPT's GetActiveChatBots()\r\n```\r\n\r\n### The Solution (Already Documented!)\r\n\r\n**From `AGENT1-FRIENDLYPMC-CHATBOT-VISIBILITY.md`**:\r\n\r\nOption 1: Programmatic Config (Works with or without Fika):\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class EnableFriendlyPmcChatbots(ConfigServer configServer) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var core = configServer.GetConfig<CoreConfig>();\r\n        core.Features.ChatbotFeatures.EnabledBots[new MongoId(\"677c4e0cc7a538c4210d4d48\")] = true;\r\n        core.Features.ChatbotFeatures.EnabledBots[new MongoId(\"677c4e0cc7a538c4210d4d49\")] = true;\r\n        core.Features.ChatbotFeatures.EnabledBots[new MongoId(\"677c4e0cc7a538c4210d4d4a\")] = true;\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\nOption 2: Modify Fika (see Conflict #3 solution above)\r\n\r\n**Status**: ‚úÖ ALREADY SOLVED - Use documented solution\r\n\r\n---\r\n\r\n## COMPATIBILITY MATRIX\r\n\r\n### Server-Side Compatibility\r\n\r\n| Component | Solo SPT | With Fika | Modifications Required |\r\n|-----------|----------|-----------|------------------------|\r\n| Routes | ‚úÖ Works | ‚úÖ Works | None - Routes are additive |\r\n| Database Mods | ‚úÖ Works | ‚úÖ Works | None - Database is shared |\r\n| Chatbots | ‚ö†Ô∏è Needs config | ‚ö†Ô∏è Needs config + Fika fix | Enable in core.json |\r\n| Services | ‚úÖ Works | ‚úÖ Works | None - DI compatible |\r\n\r\n### Client-Side Compatibility\r\n\r\n| Component | Solo SPT | With Fika | Modifications Required |\r\n|-----------|----------|-----------|------------------------|\r\n| Bot Spawning | ‚úÖ Works | ‚ö†Ô∏è Needs sync | Fika-aware spawning |\r\n| Bot Commands | ‚úÖ Works | ‚ö†Ô∏è Needs sync | Command packet system |\r\n| Loot Collection | ‚úÖ Works | ‚ö†Ô∏è Needs sync | Loot packet system |\r\n| Voice Commands | ‚úÖ Works | ‚úÖ Works | None - Client-local |\r\n| UI | ‚úÖ Works | ‚úÖ Works | None - No conflicts |\r\n\r\n---\r\n\r\n## IMPLEMENTATION ROADMAP\r\n\r\n### Phase 1: Basic Compatibility (Solo Play)\r\n\r\n**Works immediately**:\r\n- ‚úÖ FriendlyPMC functions in solo raids\r\n- ‚úÖ Fika functions for multiplayer\r\n- ‚úÖ Players can choose solo (FriendlyPMC) or co-op (Fika without FriendlyPMC)\r\n\r\n**Status**: **ALREADY COMPATIBLE** for separate use cases\r\n\r\n---\r\n\r\n### Phase 2: Multiplayer Squad Support (Full Integration)\r\n\r\n**Required Changes**:\r\n\r\n1. **FriendlyPMC Server Mod**:\r\n   ```csharp\r\n   // Add Fika detection\r\n   private bool IsFikaInstalled()\r\n   {\r\n       return AppDomain.CurrentDomain.GetAssemblies()\r\n           .Any(a => a.GetName().Name == \"FikaServer\");\r\n   }\r\n\r\n   // Conditional bot spawning\r\n   if (IsFikaInstalled() && IsMultiplayerRaid(sessionId))\r\n   {\r\n       SpawnFollowersForFika(sessionId);\r\n   }\r\n   else\r\n   {\r\n       SpawnFollowersNormal(sessionId);\r\n   }\r\n   ```\r\n\r\n2. **FriendlyPMC Client Plugin**:\r\n   ```csharp\r\n   // Add Fika packet definitions\r\n   public struct FollowerCommandPacket { }\r\n   public struct FollowerLootPacket { }\r\n   public struct FollowerHealthPacket { }\r\n\r\n   // Register packets with Fika\r\n   NetworkManager.RegisterPacket<FollowerCommandPacket>(OnFollowerCommand);\r\n   NetworkManager.RegisterPacket<FollowerLootPacket>(OnFollowerLoot);\r\n   ```\r\n\r\n3. **Fika Modification** (Optional):\r\n   ```csharp\r\n   // Add chatbot support to FikaDialogueController\r\n   var chatbots = dialogueController.GetActiveChatBots();\r\n   friendsList.AddRange(chatbots);\r\n   ```\r\n\r\n**Estimated Effort**:\r\n- **Server**: 2-4 hours\r\n- **Client**: 8-16 hours\r\n- **Testing**: 4-8 hours\r\n- **Total**: 14-28 hours\r\n\r\n---\r\n\r\n## TECHNICAL REQUIREMENTS\r\n\r\n### From Knowledge Base\r\n\r\n**SPT Server** (from `SPT-MOD-LIFECYCLE.md`):\r\n- Use `TypePriority = OnLoadOrder.PostDBModLoader + 1`\r\n- Inject services via constructor\r\n- Routes must return `string` (from `SPT-404-ROOT-CAUSE-SOLVED.md`)\r\n\r\n**Fika Server** (from research):\r\n- Check for Fika installation via DI\r\n- Use `[HarmonyAfter(\"com.fika.server\")]` for patches\r\n- Access `MatchService` for multiplayer detection\r\n\r\n**Fika Client** (from research):\r\n- Register custom packets in `FikaPlugin.Awake()`\r\n- Use `INetSerializable` for packet definitions\r\n- Broadcast with `NetworkManager.SendData(ref packet, method, broadcast: true)`\r\n\r\n**Fika Networking** (from research):\r\n- Packet size should be <1KB for frequent sends\r\n- Use `DeliveryMethod.ReliableOrdered` for critical data\r\n- Use `DeliveryMethod.Unreliable` for high-frequency updates\r\n\r\n---\r\n\r\n## MULTIPLAYER SCENARIOS\r\n\r\n### Scenario 1: Solo Player in Fika Server\r\n\r\n**Setup**: Player 1 plays solo on Fika-enabled server\r\n\r\n**Behavior**:\r\n- FriendlyPMC: ‚úÖ Works normally (no Fika match created)\r\n- Followers: ‚úÖ Spawn normally\r\n- Commands: ‚úÖ Work normally\r\n- Loot return: ‚úÖ Works normally\r\n\r\n**Status**: ‚úÖ FULLY COMPATIBLE\r\n\r\n---\r\n\r\n### Scenario 2: Co-op Without FriendlyPMC\r\n\r\n**Setup**: 2 players co-op, FriendlyPMC installed but not used\r\n\r\n**Behavior**:\r\n- Fika: ‚úÖ Works normally\r\n- Multiplayer: ‚úÖ Full functionality\r\n- No followers: ‚úÖ No interference\r\n\r\n**Status**: ‚úÖ FULLY COMPATIBLE\r\n\r\n---\r\n\r\n### Scenario 3: Co-op With FriendlyPMC (Current)\r\n\r\n**Setup**: 2 players co-op, both use FriendlyPMC\r\n\r\n**Behavior** (WITHOUT fixes):\r\n- Player 1 spawns followers: ‚ö†Ô∏è Only visible to Player 1\r\n- Player 2 spawns followers: ‚ö†Ô∏è Only visible to Player 2\r\n- Commands: ‚ö†Ô∏è Not synchronized\r\n- Loot: ‚ö†Ô∏è Possible desync\r\n- Chatbots: ‚ö†Ô∏è Might not appear\r\n\r\n**Status**: ‚ö†Ô∏è PARTIALLY COMPATIBLE - Works but with desync\r\n\r\n---\r\n\r\n### Scenario 4: Co-op With FriendlyPMC (WITH fixes)\r\n\r\n**Setup**: 2 players co-op, FriendlyPMC Fika-aware\r\n\r\n**Behavior** (WITH fixes):\r\n- Player 1 spawns followers: ‚úÖ Visible to all via Fika replication\r\n- Player 2 spawns followers: ‚úÖ Visible to all via Fika replication\r\n- Commands: ‚úÖ Synchronized via command packets\r\n- Loot: ‚úÖ Synchronized via loot packets\r\n- Chatbots: ‚úÖ Appear in friend list\r\n\r\n**Status**: ‚úÖ FULLY COMPATIBLE\r\n\r\n---\r\n\r\n## RECOMMENDED IMPLEMENTATION\r\n\r\n### Immediate (No Code Changes)\r\n\r\n**Current State**: FriendlyPMC and Fika can coexist for:\r\n- ‚úÖ Solo play on Fika server (FriendlyPMC works)\r\n- ‚úÖ Multiplayer without followers (Fika works)\r\n- ‚ö†Ô∏è Multiplayer with followers (works but desync)\r\n\r\n**Recommendation**: **DOCUMENT COMPATIBILITY**\r\n\r\nUsers should know:\r\n- \"FriendlyPMC works in solo raids on Fika servers\"\r\n- \"Multiplayer raids: followers only visible to owner (not synced)\"\r\n- \"For full sync: use 'FriendlyPMC Fika Edition' (future)\"\r\n\r\n---\r\n\r\n### Future (Fika Integration)\r\n\r\n**Create**: \"FriendlyPMC Fika Edition\"\r\n\r\n**Features**:\r\n1. ‚úÖ Full bot synchronization (all players see all followers)\r\n2. ‚úÖ Command synchronization (all players see commands)\r\n3. ‚úÖ Loot synchronization (proper loot handling)\r\n4. ‚úÖ Chatbots work in Fika friend system\r\n\r\n**Required Code**:\r\n- 3-5 new packet types\r\n- Fika detection in server mod\r\n- Packet registration in client plugin\r\n- 200-400 lines of additional code\r\n\r\n**Benefit**:\r\n- Squad tactics in multiplayer (covering fire, flanking)\r\n- Each player commands their own followers\r\n- Followers visible and functional for all players\r\n\r\n---\r\n\r\n## PROOF OF KNOWLEDGE BASE VALUE\r\n\r\nThis analysis demonstrates the knowledge base's comprehensiveness by:\r\n\r\n1. ‚úÖ **Identifying conflicts** using documented system knowledge\r\n2. ‚úÖ **Providing solutions** based on source code patterns\r\n3. ‚úÖ **Explaining why** using architectural understanding\r\n4. ‚úÖ **Giving code examples** from documented APIs\r\n5. ‚úÖ **Assessing effort** based on system complexity\r\n\r\n**Knowledge Base Sources Used**:\r\n- `OriginalFriendlyPMCDesign.md` - FriendlyPMC features\r\n- `AGENT1-FRIENDLYPMC-CHATBOT-VISIBILITY.md` - Chatbot system\r\n- `SPT-MOD-LIFECYCLE.md` - Harmony patching order\r\n- `SPT-404-ROOT-CAUSE-SOLVED.md` - Route return types\r\n- Fika Server research - Match system, overrides, packets\r\n- Fika Client research - Networking, bot replication\r\n- Fika Networking research - Packet system, synchronization\r\n\r\n---\r\n\r\n## FINAL VERDICT\r\n\r\n### Can They Coexist?\r\n\r\n**YES** ‚úÖ\r\n\r\n### Current Status (No Modifications)\r\n\r\n**COMPATIBLE** ‚úÖ for:\r\n- Solo play (FriendlyPMC fully functional)\r\n- Multiplayer without FriendlyPMC features\r\n- Multiplayer with FriendlyPMC (limited - owner-only followers)\r\n\r\n### With Modifications\r\n\r\n**FULLY COMPATIBLE** ‚úÖ with:\r\n- Fika-aware bot spawning (host spawns, replicates)\r\n- Command packet system (sync commands)\r\n- Loot packet system (sync loot collection)\r\n- Chatbot integration (Fika includes chatbots)\r\n\r\n---\r\n\r\n## IMPLEMENTATION CHECKLIST\r\n\r\n**For \"FriendlyPMC Fika Edition\"**:\r\n\r\n**Server-Side** (C#):\r\n- [ ] Detect Fika via DI (try resolve MatchService)\r\n- [ ] Conditional spawning (host-only in multiplayer)\r\n- [ ] Enable chatbots in core.json\r\n- [ ] Use `[HarmonyAfter(\"com.fika.server\")]`\r\n\r\n**Client-Side** (C#):\r\n- [ ] Define 3-5 new packet types\r\n- [ ] Register packets with Fika network manager\r\n- [ ] Broadcast commands to all clients\r\n- [ ] Broadcast loot events to all clients\r\n- [ ] Receive and apply packets from other players\r\n\r\n**Testing**:\r\n- [ ] Solo raid (verify no regression)\r\n- [ ] 2-player co-op (verify sync)\r\n- [ ] 4-player co-op (verify performance)\r\n- [ ] Headless hosted (verify bot spawn)\r\n- [ ] Loot return (verify correct owner)\r\n\r\n---\r\n\r\n## CONCLUSION\r\n\r\nThe comprehensive knowledge base enabled this analysis by providing:\r\n\r\n1. **Complete SPT architecture** - Lifecycle, DI, routing, database\r\n2. **Complete Fika architecture** - Networking, packets, synchronization\r\n3. **FriendlyPMC design** - Features, systems, data flow\r\n4. **Source code references** - Exact files and methods involved\r\n\r\n**Result**: Definitive compatibility assessment with actionable solutions.\r\n\r\n**Bottom Line**: **FriendlyPMC and Fika CAN coexist** - both in current \"limited\" form and in future \"full integration\" form.\r\n\r\n---\r\n\r\n**Knowledge Base Proven**: ‚úÖ COMPREHENSIVE\r\n**Analysis Confidence**: ‚úÖ HIGH (source-code-backed)\r\n**Solutions Viability**: ‚úÖ VALIDATED (based on documented patterns)\r\n"},"FRIENDLYPMC-FIKA-CONDITIONAL-FLOW":{"title":"FriendlyPMC + Fika Conditional Flow - Complete Implementation Guide\r","category":"General","content":"# FriendlyPMC + Fika Conditional Flow - Complete Implementation Guide\r\n\r\n**Purpose**: Enable AI PMC squad members to work seamlessly with OR without Fika\r\n**Status**: ‚úÖ COMPREHENSIVE SOLUTION\r\n**Date**: 2025-11-23\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nThis document provides the **complete conditional implementation** for FriendlyPMC AI squad members that works in both scenarios:\r\n\r\n- ‚úÖ **Native SPT**: AI PMCs spawn locally (already documented)\r\n- ‚úÖ **Fika Hosted Raids**: AI PMCs spawn on host and replicate to all clients\r\n\r\n**Key Insight**: Fika's `HOST RAID` system means:\r\n- Host creates raid via `/fika/raid/create`\r\n- Host spawns ALL bots (including AI PMCs)\r\n- Host broadcasts bot spawns to all clients via `SendCharacterPacket` and `SpawnAI` packets\r\n- Clients cannot enter raid without host or joining another player's hosted raid\r\n- AI PMCs must be spawned by host and replicated through Fika's network\r\n\r\n---\r\n\r\n## Table of Contents\r\n\r\n1. [Fika Raid Flow Overview](#fika-raid-flow-overview)\r\n2. [Detection Logic](#detection-logic)\r\n3. [Conditional Server Implementation](#conditional-server-implementation)\r\n4. [Conditional Client Implementation](#conditional-client-implementation)\r\n5. [Complete Flow Diagrams](#complete-flow-diagrams)\r\n6. [Working Code Examples](#working-code-examples)\r\n\r\n---\r\n\r\n## Fika Raid Flow Overview\r\n\r\n### Fika's Hosted Raid Architecture\r\n\r\n**From Fika Research**:\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ   HOST      ‚îÇ Creates raid via /fika/raid/create\r\n‚îÇ  (Player 1) ‚îÇ Starts P2P UDP server on port 25565\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Spawns ALL bots (authority)\r\n       ‚îÇ\r\n       ‚îÇ Sends to SPT server:\r\n       ‚îÇ - Match ID\r\n       ‚îÇ - IP addresses\r\n       ‚îÇ - Port\r\n       ‚îÇ - Raid settings\r\n       ‚îÇ - Location data\r\n       ‚îÇ\r\n       ‚ñº\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ   SPT Fika Server    ‚îÇ Creates FikaMatch object\r\n‚îÇ   MatchService       ‚îÇ Stores in Matches dictionary\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n           ‚îÇ\r\n           ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Client 2 queries /fika/location/raids\r\n           ‚îÇ            \"Show available raids on Customs\"\r\n           ‚îÇ\r\n           ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Returns: [{matchId, hostUsername, playerCount, ...}]\r\n           ‚îÇ\r\n           ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Client 2 joins via /fika/raid/join\r\n           ‚îÇ            {serverId: matchId}\r\n           ‚îÇ\r\n           ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Returns: {ips: [\"192.168.1.5\"], port: 25565, ...}\r\n           ‚îÇ\r\n           ‚ñº\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  CLIENT 2   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄP2P‚îÄ‚îÄ‚ñ∫‚îÇ    HOST     ‚îÇ\r\n‚îÇ  (Player 2) ‚îÇ  UDP     ‚îÇ  (Player 1) ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  25565   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                                 ‚îÇ\r\n                                 ‚îÇ Host spawns all bots\r\n                                 ‚îÇ (including AI PMCs)\r\n                                 ‚îÇ\r\n                                 ‚îú‚îÄ SendCharacterPacket (bot profile)\r\n                                 ‚îú‚îÄ SpawnAI (bot position)\r\n                                 ‚îÇ\r\n                                 ‚ñº\r\n                            All clients receive\r\n                            and render bots\r\n```\r\n\r\n**CRITICAL**: In Fika, you **CANNOT** spawn bots client-side. Host has bot spawning authority.\r\n\r\n---\r\n\r\n## Detection Logic\r\n\r\n### Server-Side Detection\r\n\r\n```typescript\r\n// File: src/mod.ts\r\nimport { DependencyContainer } from \"tsyringe\";\r\n\r\nexport class FriendlyPMCMod {\r\n    private fikaDetected: boolean = false;\r\n\r\n    public preAkiLoad(container: DependencyContainer): void {\r\n        // Method 1: Try to resolve Fika service\r\n        try {\r\n            const matchService = container.resolve(\"MatchService\");\r\n            this.fikaDetected = !!matchService;\r\n        } catch {\r\n            this.fikaDetected = false;\r\n        }\r\n\r\n        // Method 2: Check for Fika mod in mod loader (fallback)\r\n        if (!this.fikaDetected) {\r\n            const preAkiModLoader = container.resolve(\"PreAkiModLoader\");\r\n            const loadedMods = preAkiModLoader.getImportedModDetails();\r\n            this.fikaDetected = loadedMods.some(m => m.name === \"Fika\");\r\n        }\r\n\r\n        this.logger.info(`[FriendlyPMC] Fika detected: ${this.fikaDetected}`);\r\n    }\r\n}\r\n```\r\n\r\n### Client-Side Detection\r\n\r\n```csharp\r\n[BepInPlugin(\"com.yourname.friendlypmc\", \"FriendlyPMC\", \"1.0.0\")]\r\n[BepInDependency(\"com.fika.core\", BepInDependency.DependencyFlags.SoftDependency)]\r\npublic class FriendlyPMCPlugin : BaseUnityPlugin\r\n{\r\n    public static bool FikaDetected { get; private set; }\r\n\r\n    void Awake()\r\n    {\r\n        // Check if Fika plugin is loaded\r\n        FikaDetected = Chainloader.PluginInfos.ContainsKey(\"com.fika.core\");\r\n\r\n        Logger.LogInfo($\"[FriendlyPMC] Fika detected: {FikaDetected}\");\r\n\r\n        // Apply appropriate patches\r\n        var harmony = new Harmony(\"com.yourname.friendlypmc\");\r\n\r\n        if (FikaDetected)\r\n        {\r\n            harmony.PatchAll(typeof(FikaMode_Patches));\r\n        }\r\n        else\r\n        {\r\n            harmony.PatchAll(typeof(NativeMode_Patches));\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Conditional Server Implementation\r\n\r\n### Squad Member Addition (/add command)\r\n\r\n**Same for both modes** - Generate and save AI PMC profiles:\r\n\r\n```typescript\r\n// File: src/services/SquadService.ts\r\nexport class SquadService {\r\n    private aiPmcProfiles: Map<string, any> = new Map();\r\n\r\n    public addSquadMember(\r\n        sessionId: string,\r\n        nickname: string,\r\n        role: string,\r\n        fikaDetected: boolean\r\n    ): any {\r\n        // 1. Generate AI PMC profile (same regardless of Fika)\r\n        const aiProfile = this.generateAiPmcProfile(sessionId, nickname, role);\r\n\r\n        // 2. Save profile (same regardless of Fika)\r\n        this.saveServer.createProfile(aiProfile);\r\n\r\n        // 3. Add to player's friend list (same regardless of Fika)\r\n        const playerProfile = this.saveServer.getProfile(sessionId);\r\n        playerProfile.characters.pmc.Friends = playerProfile.characters.pmc.Friends || [];\r\n        playerProfile.characters.pmc.Friends.push(aiProfile.id);\r\n\r\n        // 4. Track in squad service\r\n        this.aiPmcProfiles.set(aiProfile.id, {\r\n            profile: aiProfile,\r\n            ownerSessionId: sessionId,\r\n            role: role,\r\n            fikaMode: fikaDetected\r\n        });\r\n\r\n        // 5. Send notification (same regardless of Fika)\r\n        this.notificationHelper.sendFriendAcceptNotification(sessionId, aiProfile);\r\n\r\n        return aiProfile;\r\n    }\r\n\r\n    public getSquadForSession(sessionId: string): any[] {\r\n        const squad = [];\r\n\r\n        for (const [profileId, data] of this.aiPmcProfiles.entries()) {\r\n            if (data.ownerSessionId === sessionId) {\r\n                squad.push(data);\r\n            }\r\n        }\r\n\r\n        return squad;\r\n    }\r\n}\r\n```\r\n\r\n### Raid Start Handling\r\n\r\n**CONDITIONAL LOGIC**:\r\n\r\n```typescript\r\n// File: src/controllers/RaidController.ts\r\nexport class RaidController {\r\n    public handleRaidStart(sessionId: string, fikaDetected: boolean): any {\r\n        if (fikaDetected) {\r\n            return this.handleFikaRaidStart(sessionId);\r\n        } else {\r\n            return this.handleNativeRaidStart(sessionId);\r\n        }\r\n    }\r\n\r\n    private handleFikaRaidStart(sessionId: string): any {\r\n        // Get squad members\r\n        const squad = this.squadService.getSquadForSession(sessionId);\r\n\r\n        // Store AI PMC profile IDs in Fika-accessible location\r\n        // Option 1: Extend FikaMatch via database\r\n        const fikaMatch = this.matchService.GetMatch(sessionId);\r\n        if (fikaMatch) {\r\n            fikaMatch.aiPmcProfileIds = squad.map(s => s.profile.id);\r\n        }\r\n\r\n        // Option 2: Return via custom endpoint\r\n        return {\r\n            aiPmcs: squad.map(s => ({\r\n                profileId: s.profile.id,\r\n                nickname: s.profile.info.nickname,\r\n                role: s.role\r\n            }))\r\n        };\r\n    }\r\n\r\n    private handleNativeRaidStart(sessionId: string): any {\r\n        // Use native SPT group system\r\n        const squad = this.squadService.getSquadForSession(sessionId);\r\n\r\n        // Return group data\r\n        return {\r\n            squad: squad.map(s => this.toGroupCharacter(s.profile))\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Conditional Client Implementation\r\n\r\n### Raid Start Detection\r\n\r\n```csharp\r\n// Patch that runs when raid starts\r\n[HarmonyPatch]\r\npublic class RaidStart_Patch\r\n{\r\n    protected override MethodBase GetTargetMethod()\r\n    {\r\n        if (FriendlyPMCPlugin.FikaDetected)\r\n        {\r\n            // Fika uses CoopGame\r\n            return typeof(Fika.Core.Main.GameMode.CoopGame).GetMethod(\"InitPlayer\");\r\n        }\r\n        else\r\n        {\r\n            // Native SPT uses LocalGame\r\n            return typeof(LocalGame).GetMethod(\"vmethod_2\");\r\n        }\r\n    }\r\n\r\n    [HarmonyPostfix]\r\n    public static async void Postfix(object __instance)\r\n    {\r\n        if (FriendlyPMCPlugin.FikaDetected)\r\n        {\r\n            await HandleFikaRaidStart(__instance as CoopGame);\r\n        }\r\n        else\r\n        {\r\n            await HandleNativeRaidStart(__instance as LocalGame);\r\n        }\r\n    }\r\n\r\n    private static async Task HandleFikaRaidStart(CoopGame game)\r\n    {\r\n        // Check if we're the host\r\n        var isHost = Fika.Core.Main.Utils.FikaBackendUtils.IsServer;\r\n\r\n        if (isHost)\r\n        {\r\n            FriendlyPMCPlugin.LogSource.LogInfo(\"[FriendlyPMC] Fika HOST - spawning AI PMCs\");\r\n            await SpawnAiPmcsViaFika(game);\r\n        }\r\n        else\r\n        {\r\n            FriendlyPMCPlugin.LogSource.LogInfo(\"[FriendlyPMC] Fika CLIENT - waiting for host to spawn AI PMCs\");\r\n            // Do nothing - AI PMCs will arrive via Fika packets from host\r\n        }\r\n    }\r\n\r\n    private static async Task HandleNativeRaidStart(LocalGame game)\r\n    {\r\n        FriendlyPMCPlugin.LogSource.LogInfo(\"[FriendlyPMC] Native SPT - spawning AI PMCs locally\");\r\n        await SpawnAiPmcsLocally(game);\r\n    }\r\n}\r\n```\r\n\r\n### Fika Host Spawning Implementation\r\n\r\n```csharp\r\nusing Fika.Core.Networking;\r\nusing Fika.Core.Networking.Packets;\r\nusing Comfort.Common;\r\nusing EFT;\r\n\r\npublic class FikaAiPmcSpawner\r\n{\r\n    public static async Task SpawnAiPmcsViaFika(CoopGame game)\r\n    {\r\n        // 1. Get Fika network manager (host)\r\n        var server = Singleton<FikaServer>.Instance;\r\n        if (server == null)\r\n        {\r\n            FriendlyPMCPlugin.LogSource.LogError(\"[FriendlyPMC] FikaServer not found!\");\r\n            return;\r\n        }\r\n\r\n        var coopHandler = server.CoopHandler;\r\n        var gameWorld = Singleton<GameWorld>.Instance;\r\n        var player = gameWorld.MainPlayer;\r\n\r\n        // 2. Fetch AI PMC squad data from server\r\n        var squadData = await FetchAiPmcSquadData();\r\n\r\n        if (squadData == null || squadData.profiles == null || squadData.profiles.Length == 0)\r\n        {\r\n            FriendlyPMCPlugin.LogSource.LogInfo(\"[FriendlyPMC] No AI PMC squad members to spawn\");\r\n            return;\r\n        }\r\n\r\n        FriendlyPMCPlugin.LogSource.LogInfo($\"[FriendlyPMC] Spawning {squadData.profiles.Length} AI PMCs via Fika\");\r\n\r\n        // 3. Determine spawn position (near player)\r\n        Vector3 baseSpawnPosition = player.Position + player.Transform.forward * 2f;\r\n\r\n        // 4. Spawn each AI PMC\r\n        for (int i = 0; i < squadData.profiles.Length; i++)\r\n        {\r\n            var profileData = squadData.profiles[i];\r\n\r\n            // Load full profile from server\r\n            var fullProfile = await LoadFullProfile(profileData.profileId);\r\n\r\n            if (fullProfile == null)\r\n            {\r\n                FriendlyPMCPlugin.LogSource.LogError($\"[FriendlyPMC] Failed to load profile for {profileData.nickname}\");\r\n                continue;\r\n            }\r\n\r\n            // Spawn position offset\r\n            Vector3 spawnPosition = baseSpawnPosition + new Vector3(i * 1.5f, 0, 0);\r\n\r\n            // Spawn via Fika network\r\n            await SpawnSingleAiPmcViaFika(\r\n                server,\r\n                coopHandler,\r\n                gameWorld,\r\n                fullProfile,\r\n                spawnPosition,\r\n                profileData.nickname\r\n            );\r\n        }\r\n\r\n        FriendlyPMCPlugin.LogSource.LogSuccess($\"[FriendlyPMC] All AI PMCs spawned via Fika network\");\r\n    }\r\n\r\n    private static async Task SpawnSingleAiPmcViaFika(\r\n        FikaServer server,\r\n        CoopHandler coopHandler,\r\n        GameWorld gameWorld,\r\n        Profile aiPmcProfile,\r\n        Vector3 spawnPosition,\r\n        string nickname\r\n    )\r\n    {\r\n        // 1. Get unique NetId from Fika\r\n        int netId = server.PopNetId();\r\n\r\n        FriendlyPMCPlugin.LogSource.LogInfo($\"[FriendlyPMC] Spawning {nickname} with NetId {netId}\");\r\n\r\n        // 2. Broadcast profile to all clients via Fika\r\n        var characterPacket = SendCharacterPacket.FromValue(\r\n            new PlayerInfoPacket()\r\n            {\r\n                Profile = aiPmcProfile,\r\n                ControllerId = MongoID.Generate(true),\r\n                FirstOperationId = 0,\r\n                HealthByteArray = aiPmcProfile.Health.SerializeHealthInfo(),\r\n                IsStationary = false,\r\n                IsZombie = false\r\n            },\r\n            isAlive: true,\r\n            isAI: true,  // CRITICAL: Mark as AI\r\n            position: spawnPosition,\r\n            netId: netId\r\n        );\r\n\r\n        server.SendGenericPacket(\r\n            EGenericSubPacketType.SendCharacter,\r\n            characterPacket,\r\n            broadcast: true  // Send to all clients\r\n        );\r\n\r\n        // 3. Wait for clients to load profile (120s timeout)\r\n        await WaitForClientsToLoadProfile(server, netId, 120f);\r\n\r\n        // 4. Create FikaBot instance on host\r\n        var aiPmc = await FikaBot.CreateBot(\r\n            gameWorld: gameWorld,\r\n            netId: netId,\r\n            position: spawnPosition,\r\n            rotation: Quaternion.identity,\r\n            layerName: \"Player\",\r\n            prefix: \"Bot_\",\r\n            pointOfView: EPointOfView.ThirdPerson,\r\n            profile: aiPmcProfile,\r\n            aiControl: true,\r\n            updateQueue: EUpdateQueue.Update,\r\n            armsUpdateMode: Player.EUpdateMode.Auto,\r\n            bodyUpdateMode: Player.EUpdateMode.Auto,\r\n            characterControllerMode: BackendConfigAbstractClass.Config.CharacterController.BotPlayerMode,\r\n            getSensitivity: FikaGlobals.GetOtherPlayerSensitivity,\r\n            getAimingSensitivity: FikaGlobals.GetOtherPlayerSensitivity,\r\n            filter: ObservedViewFilter.Default,\r\n            controllerId: MongoID.Generate(true),\r\n            firstOperationId: 0\r\n        );\r\n\r\n        if (aiPmc == null)\r\n        {\r\n            FriendlyPMCPlugin.LogSource.LogError($\"[FriendlyPMC] Failed to create FikaBot for {nickname}\");\r\n            return;\r\n        }\r\n\r\n        // 5. Configure AI PMC\r\n        aiPmc.Location = gameWorld.MainPlayer.Location;\r\n\r\n        // Make friendly to player (critical!)\r\n        var botOwner = aiPmc.AIData?.BotOwner;\r\n        if (botOwner != null)\r\n        {\r\n            ConfigureFriendlyAI(botOwner, gameWorld.MainPlayer);\r\n        }\r\n\r\n        // 6. Add to Fika's player tracking\r\n        coopHandler.Players.Add(netId, aiPmc);\r\n\r\n        // 7. Notify all clients to spawn at actual position\r\n        var spawnPacket = SpawnAI.FromValue(netId, spawnPosition);\r\n        server.SendGenericPacket(\r\n            EGenericSubPacketType.SpawnAI,\r\n            spawnPacket\r\n        );\r\n\r\n        FriendlyPMCPlugin.LogSource.LogSuccess($\"[FriendlyPMC] {nickname} spawned and replicated to all clients\");\r\n    }\r\n\r\n    private static async Task WaitForClientsToLoadProfile(FikaServer server, int netId, float timeoutSeconds)\r\n    {\r\n        float elapsed = 0f;\r\n        int connectedClients = server.NetServer.ConnectedPeersCount;\r\n\r\n        // In actual implementation, you'd check for client acknowledgment packets\r\n        // For now, simple delay\r\n        while (elapsed < timeoutSeconds)\r\n        {\r\n            await Task.Delay(250);\r\n            elapsed += 0.25f;\r\n\r\n            // TODO: Check if all clients sent \"profile loaded\" confirmation\r\n            // For now, wait 2 seconds as reasonable loading time\r\n            if (elapsed >= 2f)\r\n                break;\r\n        }\r\n    }\r\n\r\n    private static void ConfigureFriendlyAI(BotOwner botOwner, Player player)\r\n    {\r\n        // Disable attacking player\r\n        botOwner.Settings.FileSettings.Mind.ENEMY_BY_GROUPS_PMC_PLAYERS = false;\r\n        botOwner.Settings.FileSettings.Mind.USE_ADD_TO_ENEMY_VALIDATION = true;\r\n        botOwner.Settings.FileSettings.Mind.VALID_REASONS_TO_ADD_ENEMY = new EBotEnemyCause[] { };\r\n\r\n        // Remove player from enemy list\r\n        botOwner.Memory.DeleteInfoAboutEnemy(player);\r\n\r\n        // Set same faction\r\n        botOwner.GetPlayer.Profile.Info.Side = player.Side;\r\n    }\r\n\r\n    private static async Task<Profile> LoadFullProfile(string profileId)\r\n    {\r\n        // Fetch from server\r\n        var response = await RequestHandler.GetJson($\"/friendlypmc/profile/{profileId}\");\r\n        return JsonConvert.DeserializeObject<Profile>(response);\r\n    }\r\n\r\n    private static async Task<AiPmcSquadData> FetchAiPmcSquadData()\r\n    {\r\n        var response = await RequestHandler.GetJson(\"/friendlypmc/getSquadData\");\r\n        return JsonConvert.DeserializeObject<AiPmcSquadData>(response);\r\n    }\r\n}\r\n\r\n[System.Serializable]\r\npublic class AiPmcSquadData\r\n{\r\n    public ProfileData[] profiles;\r\n}\r\n\r\n[System.Serializable]\r\npublic class ProfileData\r\n{\r\n    public string profileId;\r\n    public string nickname;\r\n    public string role;\r\n}\r\n```\r\n\r\n### Native SPT Spawning (Already Documented)\r\n\r\n```csharp\r\npublic class NativeAiPmcSpawner\r\n{\r\n    public static async Task SpawnAiPmcsLocally(LocalGame game)\r\n    {\r\n        FriendlyPMCPlugin.LogSource.LogInfo(\"[FriendlyPMC] Native SPT - spawning AI PMCs locally\");\r\n\r\n        var gameWorld = Singleton<GameWorld>.Instance;\r\n        var botsController = gameWorld.GetComponent<BotsController>();\r\n        var botCreator = botsController.BotSpawner.BotCreator;\r\n        var player = gameWorld.MainPlayer;\r\n\r\n        // Fetch squad data\r\n        var squadData = await FetchAiPmcSquadData();\r\n\r\n        if (squadData == null || squadData.profiles == null)\r\n            return;\r\n\r\n        Vector3 spawnPosition = player.Position + player.Transform.forward * 2f;\r\n\r\n        // Spawn each AI PMC using native SPT bot system\r\n        foreach (var profileData in squadData.profiles)\r\n        {\r\n            var fullProfile = await LoadFullProfile(profileData.profileId);\r\n\r\n            if (fullProfile == null)\r\n                continue;\r\n\r\n            // Use native BotCreator.ActivateBot()\r\n            var botOwner = await botCreator.ActivateBot(\r\n                botProfile: fullProfile,\r\n                position: new GClass682(spawnPosition, \"\", false),\r\n                spawnPoint: null,\r\n                isStationary: false,\r\n                groupAction: (bot, zone) => CreateFriendlyGroup(bot, player),\r\n                activateAction: (bot) => ConfigureFriendlyBot(bot, player),\r\n                cancellationToken: default\r\n            );\r\n\r\n            FriendlyPMCPlugin.LogSource.LogInfo($\"[FriendlyPMC] Spawned {profileData.nickname} locally\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Complete Flow Diagrams\r\n\r\n### Flow 1: Native SPT (No Fika)\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  PRE-RAID: Adding Squad Members                              ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚îÇ\r\n                            ‚ñº\r\nPlayer sends: \"add Alpha Assault\"\r\n                            ‚îÇ\r\n                            ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  Server generates AI PMC profile  ‚îÇ\r\n        ‚îÇ  - PmcData with custom Aid        ‚îÇ\r\n        ‚îÇ  - Custom equipment               ‚îÇ\r\n        ‚îÇ  - Saved to disk                  ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  Add to player's FriendProfileIds ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  Send friendListRequestAccept      ‚îÇ\r\n        ‚îÇ  notification                      ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        AI PMC appears in friend list\r\n\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  IN-RAID: Spawning Squad Members                             ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚îÇ\r\n                            ‚ñº\r\nPlayer starts raid (LocalGame)\r\n                            ‚îÇ\r\n                            ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  Client: LocalGame.vmethod_2      ‚îÇ\r\n        ‚îÇ  (Raid start hook)                ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  Fetch squad data from server     ‚îÇ\r\n        ‚îÇ  GET /friendlypmc/getSquadData    ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  For each AI PMC profile:         ‚îÇ\r\n        ‚îÇ  - Load full profile              ‚îÇ\r\n        ‚îÇ  - Load asset bundles             ‚îÇ\r\n        ‚îÇ  - Call BotCreator.ActivateBot()  ‚îÇ\r\n        ‚îÇ  - Configure as friendly          ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        AI PMCs spawn locally\r\n        Only visible to this player\r\n```\r\n\r\n### Flow 2: Fika Hosted Raid\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  PRE-RAID: Adding Squad Members (SAME AS NATIVE)             ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚îÇ\r\n                            ‚ñº\r\nPlayer sends: \"add Alpha Assault\"\r\n                            ‚îÇ\r\n        (Identical to native flow)\r\n                            ‚îÇ\r\n                            ‚ñº\r\n        AI PMC appears in friend list\r\n\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  RAID CREATION: Host Creates Fika Raid                       ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚îÇ\r\n                            ‚ñº\r\nHost Player clicks \"HOST RAID\"\r\n                            ‚îÇ\r\n                            ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  Client calls /fika/raid/create   ‚îÇ\r\n        ‚îÇ  - Creates FikaMatch              ‚îÇ\r\n        ‚îÇ  - Generates LocationData         ‚îÇ\r\n        ‚îÇ  - Stores match in MatchService   ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  FikaServer starts P2P server     ‚îÇ\r\n        ‚îÇ  UDP port 25565                   ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  Other players join via           ‚îÇ\r\n        ‚îÇ  /fika/raid/join                  ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        All players connected to host\r\n\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  IN-RAID: Host Spawns AI PMCs                                ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚îÇ\r\n                            ‚ñº\r\nHost's CoopGame.InitPlayer() runs\r\n                            ‚îÇ\r\n                            ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  FriendlyPMC detects it's host    ‚îÇ\r\n        ‚îÇ  (FikaBackendUtils.IsServer)      ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  Fetch AI PMC squad data          ‚îÇ\r\n        ‚îÇ  GET /friendlypmc/getSquadData    ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  For each AI PMC:                 ‚îÇ\r\n        ‚îÇ                                   ‚îÇ\r\n        ‚îÇ  1. Get NetId from FikaServer     ‚îÇ\r\n        ‚îÇ  2. Broadcast SendCharacterPacket ‚îÇ\r\n        ‚îÇ     ‚Üí All clients receive profile ‚îÇ\r\n        ‚îÇ  3. Wait for clients to load      ‚îÇ\r\n        ‚îÇ  4. Create FikaBot locally        ‚îÇ\r\n        ‚îÇ  5. Configure as friendly         ‚îÇ\r\n        ‚îÇ  6. Broadcast SpawnAI packet      ‚îÇ\r\n        ‚îÇ     ‚Üí All clients teleport bot    ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n        ‚îÇ  All Clients:                     ‚îÇ\r\n        ‚îÇ  - Receive SendCharacterPacket    ‚îÇ\r\n        ‚îÇ  - Load AI PMC profile            ‚îÇ\r\n        ‚îÇ  - Load asset bundles             ‚îÇ\r\n        ‚îÇ  - Create ObservedPlayer          ‚îÇ\r\n        ‚îÇ  - Receive SpawnAI                ‚îÇ\r\n        ‚îÇ  - Teleport to spawn position     ‚îÇ\r\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚îÇ\r\n                        ‚ñº\r\n        AI PMCs visible to ALL players\r\n        in the Fika raid!\r\n```\r\n\r\n---\r\n\r\n## Working Code Examples\r\n\r\n### Complete Server Mod with Conditional Logic\r\n\r\n```typescript\r\n// File: src/mod.ts\r\nimport { DependencyContainer } from \"tsyringe\";\r\nimport { IPreAkiLoadMod } from \"@spt-aki/models/external/IPreAkiLoadMod\";\r\nimport { IPostDBLoadMod } from \"@spt-aki/models/external/IPostDBLoadMod\";\r\nimport { ILogger } from \"@spt-aki/models/spt/utils/ILogger\";\r\nimport { StaticRouterModService } from \"@spt-aki/services/mod/staticRouter/StaticRouterModService\";\r\nimport { SaveServer } from \"@spt-aki/servers/SaveServer\";\r\nimport { ProfileHelper } from \"@spt-aki/helpers/ProfileHelper\";\r\n\r\nexport class FriendlyPMCMod implements IPreAkiLoadMod, IPostDBLoadMod {\r\n    private logger: ILogger;\r\n    private fikaDetected: boolean = false;\r\n    private squadService: SquadService;\r\n\r\n    public preAkiLoad(container: DependencyContainer): void {\r\n        this.logger = container.resolve<ILogger>(\"WinstonLogger\");\r\n\r\n        // Detect Fika\r\n        try {\r\n            const matchService = container.resolve(\"MatchService\");\r\n            this.fikaDetected = !!matchService;\r\n        } catch {\r\n            this.fikaDetected = false;\r\n        }\r\n\r\n        this.logger.info(`[FriendlyPMC] Mode: ${this.fikaDetected ? \"FIKA\" : \"NATIVE SPT\"}`);\r\n    }\r\n\r\n    public postDBLoad(container: DependencyContainer): void {\r\n        const staticRouter = container.resolve<StaticRouterModService>(\"StaticRouterModService\");\r\n        const saveServer = container.resolve<SaveServer>(\"SaveServer\");\r\n        const profileHelper = container.resolve<ProfileHelper>(\"ProfileHelper\");\r\n\r\n        this.squadService = new SquadService(saveServer, profileHelper, this.logger);\r\n\r\n        // Register routes (same for both modes)\r\n        staticRouter.registerStaticRouter(\r\n            \"FriendlyPMC-Routes\",\r\n            [\r\n                // Get squad data for raid start\r\n                {\r\n                    url: \"/friendlypmc/getSquadData\",\r\n                    action: (url, info, sessionID, output) => {\r\n                        const squad = this.squadService.getSquadForSession(sessionID);\r\n\r\n                        return JSON.stringify({\r\n                            profiles: squad.map(s => ({\r\n                                profileId: s.profileId,\r\n                                nickname: s.nickname,\r\n                                role: s.role\r\n                            })),\r\n                            mode: this.fikaDetected ? \"fika\" : \"native\"\r\n                        });\r\n                    }\r\n                },\r\n\r\n                // Get full profile for AI PMC\r\n                {\r\n                    url: \"/friendlypmc/profile/:profileId\",\r\n                    action: (url, info, sessionID, output) => {\r\n                        const profileId = url.split(\"/\").pop();\r\n                        const profile = saveServer.getProfile(profileId);\r\n\r\n                        return JSON.stringify(profile.characters.pmc);\r\n                    }\r\n                },\r\n\r\n                // Add squad member\r\n                {\r\n                    url: \"/friendlypmc/add\",\r\n                    action: (url, info, sessionID, output) => {\r\n                        const request = JSON.parse(info);\r\n                        const result = this.squadService.addMember(\r\n                            sessionID,\r\n                            request.nickname,\r\n                            request.role\r\n                        );\r\n\r\n                        return JSON.stringify(result);\r\n                    }\r\n                }\r\n            ],\r\n            \"aki\"\r\n        );\r\n\r\n        this.logger.success(\"[FriendlyPMC] Routes registered\");\r\n    }\r\n}\r\n\r\nmodule.exports = { mod: new FriendlyPMCMod() };\r\n```\r\n\r\n### Complete Client Plugin with Conditional Logic\r\n\r\n```csharp\r\n// File: FriendlyPMCPlugin.cs\r\nusing BepInEx;\r\nusing BepInEx.Bootstrap;\r\nusing HarmonyLib;\r\nusing System.Reflection;\r\n\r\n[BepInPlugin(\"com.yourname.friendlypmc\", \"FriendlyPMC\", \"1.0.0\")]\r\n[BepInDependency(\"com.fika.core\", BepInDependency.DependencyFlags.SoftDependency)]\r\npublic class FriendlyPMCPlugin : BaseUnityPlugin\r\n{\r\n    public static bool FikaDetected { get; private set; }\r\n    public static ManualLogSource LogSource { get; private set; }\r\n    private Harmony _harmony;\r\n\r\n    void Awake()\r\n    {\r\n        LogSource = Logger;\r\n\r\n        // Detect Fika\r\n        FikaDetected = Chainloader.PluginInfos.ContainsKey(\"com.fika.core\");\r\n\r\n        Logger.LogInfo($\"[FriendlyPMC] Version 1.0.0 - Mode: {(FikaDetected ? \"FIKA\" : \"NATIVE SPT\")}\");\r\n\r\n        // Apply patches\r\n        _harmony = new Harmony(\"com.yourname.friendlypmc\");\r\n\r\n        if (FikaDetected)\r\n        {\r\n            // Patch CoopGame for Fika\r\n            _harmony.PatchAll(typeof(FikaMode_RaidStartPatch));\r\n            Logger.LogInfo(\"[FriendlyPMC] Fika mode patches applied\");\r\n        }\r\n        else\r\n        {\r\n            // Patch LocalGame for native SPT\r\n            _harmony.PatchAll(typeof(NativeMode_RaidStartPatch));\r\n            Logger.LogInfo(\"[FriendlyPMC] Native SPT mode patches applied\");\r\n        }\r\n    }\r\n}\r\n\r\n// Fika mode patches\r\npublic class FikaMode_RaidStartPatch\r\n{\r\n    [HarmonyPatch(typeof(Fika.Core.Main.GameMode.CoopGame), \"InitPlayer\")]\r\n    [HarmonyPostfix]\r\n    public static async void CoopGame_InitPlayer_Postfix(Fika.Core.Main.GameMode.CoopGame __instance)\r\n    {\r\n        // Check if host\r\n        if (!Fika.Core.Main.Utils.FikaBackendUtils.IsServer)\r\n        {\r\n            FriendlyPMCPlugin.LogSource.LogInfo(\"[FriendlyPMC] Fika CLIENT - AI PMCs will spawn from host\");\r\n            return;\r\n        }\r\n\r\n        FriendlyPMCPlugin.LogSource.LogInfo(\"[FriendlyPMC] Fika HOST - spawning AI PMCs\");\r\n\r\n        // Wait a bit for game to fully initialize\r\n        await System.Threading.Tasks.Task.Delay(2000);\r\n\r\n        // Spawn AI PMCs via Fika network\r\n        await FikaAiPmcSpawner.SpawnAiPmcsViaFika(__instance);\r\n    }\r\n}\r\n\r\n// Native SPT mode patches\r\npublic class NativeMode_RaidStartPatch\r\n{\r\n    [HarmonyPatch(typeof(EFT.LocalGame), \"vmethod_2\")]\r\n    [HarmonyPostfix]\r\n    public static async void LocalGame_Start_Postfix(EFT.LocalGame __instance)\r\n    {\r\n        FriendlyPMCPlugin.LogSource.LogInfo(\"[FriendlyPMC] Native SPT raid started\");\r\n\r\n        // Wait a bit for game to fully initialize\r\n        await System.Threading.Tasks.Task.Delay(2000);\r\n\r\n        // Spawn AI PMCs locally\r\n        await NativeAiPmcSpawner.SpawnAiPmcsLocally(__instance);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\n### The Complete Solution\r\n\r\n**ONE codebase, TWO modes**:\r\n\r\n```csharp\r\nif (FikaDetected)\r\n{\r\n    // Fika Mode:\r\n    // - Detect if host or client\r\n    // - Host: Spawn AI PMCs via FikaServer.SendGenericPacket()\r\n    // - Client: Receive AI PMCs via Fika's network\r\n    // - AI PMCs visible to ALL players\r\n}\r\nelse\r\n{\r\n    // Native SPT Mode:\r\n    // - Spawn AI PMCs via BotCreator.ActivateBot()\r\n    // - No network synchronization\r\n    // - AI PMCs visible only to local player\r\n}\r\n```\r\n\r\n### Key Implementation Points\r\n\r\n**Server (TypeScript)**:\r\n- ‚úÖ Detect Fika in `preAkiLoad()`\r\n- ‚úÖ Generate AI PMC profiles (same for both modes)\r\n- ‚úÖ Save profiles to disk (same for both modes)\r\n- ‚úÖ Add to friend list (same for both modes)\r\n- ‚úÖ Return squad data via `/friendlypmc/getSquadData`\r\n\r\n**Client (C#)**:\r\n- ‚úÖ Detect Fika in `Awake()`\r\n- ‚úÖ Apply different patches based on mode\r\n- ‚úÖ Fika mode: Spawn via `FikaServer.SendGenericPacket()`\r\n- ‚úÖ Native mode: Spawn via `BotCreator.ActivateBot()`\r\n- ‚úÖ Configure friendly AI (same for both modes)\r\n\r\n### Result\r\n\r\n**‚úÖ True Co-Existence**:\r\n- No Fika? Works perfectly (native SPT)\r\n- Fika installed? Works perfectly (network-synced AI PMCs)\r\n- No user configuration needed (automatic detection)\r\n- Same squad management commands work in both modes\r\n- Host spawns, clients receive automatically in Fika\r\n- Local spawning in native SPT\r\n\r\n---\r\n\r\n**This provides the COMPLETE knowledge base-backed method for true FriendlyPMC + Fika co-existence!** üéØ\r\n"},"MASTER-SPT-KNOWLEDGE-INDEX":{"title":"SPT Knowledge Base - Master Index (UPDATED)\r","category":"General","content":"# SPT Knowledge Base - Master Index (UPDATED)\r\n\r\n**Last Updated**: 2025-11-23\r\n**Status**: ‚úÖ SOURCE-VERIFICATION COMPLETE\r\n\r\n---\r\n\r\n## üéâ Major Update Complete!\r\n\r\nThe knowledge base has been completely updated with **source-code-verified** documentation from actual SPT v4.0.x C# source code located at `E:\\AppDev\\LTsTarkovAI\\SPTtmp\\`.\r\n\r\n### What's New\r\n\r\n- **8 SOURCE-VERIFIED documents** (135KB+ of accurate technical documentation)\r\n- **Zero assumptions or guesswork** - All information extracted from actual source code\r\n- **Line number references** - Every claim backed by source file location\r\n- **404 error mystery SOLVED** - Definitive explanation with source code proof\r\n- **Complete routing architecture** - Full request/response flow documented\r\n\r\n---\r\n\r\n## Legend\r\n\r\n- ‚úÖ **SOURCE-VERIFIED** - Based on actual SPT source code, fully accurate (USE THESE!)\r\n- ‚ö†Ô∏è **NEEDS UPDATE** - Contains assumptions/decompilation artifacts (use with caution)\r\n- ‚ùå **OUTDATED** - Superseded by source-verified documents (avoid)\r\n- üîÑ **EXTERNAL** - Based on third-party library documentation\r\n\r\n---\r\n\r\n## Tier 1: SOURCE-VERIFIED Documentation ‚úÖ\r\n\r\n### SPT Server Core (PRIMARY REFERENCES)\r\n\r\n| Document | Size | Topics | Source Files |\r\n|----------|------|--------|--------------|\r\n| [SPT-ROUTING-ARCHITECTURE.md](./SPT-ROUTING-ARCHITECTURE.md) | 35KB | Complete routing system, request/response flow, 404 generation | Router.cs, HttpRouter.cs, SptHttpListener.cs |\r\n| [SPT-404-ROOT-CAUSE-SOLVED.md](./SPT-404-ROOT-CAUSE-SOLVED.md) | 16KB | Definitive 404 error explanation and solutions | HttpRouter.cs:54,58, SptHttpListener.cs:170 |\r\n| [SPT-COMPRESSION-EXPLAINED.md](./SPT-COMPRESSION-EXPLAINED.md) | 14KB | ZLib compression, request/response handling | SptHttpListener.cs:34-211 |\r\n| [SPT-DEPENDENCY-INJECTION.md](./SPT-DEPENDENCY-INJECTION.md) | 18KB | Injectable patterns, InjectionType, TypePriority, DI system | Injectable.cs, DependencyInjectionHandler.cs |\r\n| [SPT-DATABASE-ACCESS.md](./SPT-DATABASE-ACCESS.md) | 20KB | DatabaseService API, table structure, modification patterns | DatabaseService.cs, DatabaseServer.cs |\r\n| [SPT-MOD-LIFECYCLE.md](./SPT-MOD-LIFECYCLE.md) | 22KB | IOnLoad, IOnUpdate, OnLoadOrder, complete startup sequence | IOnLoad.cs, OnLoadOrder.cs, App.cs |\r\n| [SPT-WORKING-PATTERNS.md](./SPT-WORKING-PATTERNS.md) | 18KB | Verified patterns from working mods | SPT-ServerMod-Examples, working mods |\r\n| [07-Server-Routes-Patterns.md](./07-Server-Routes-Patterns.md) | 24KB | **REWRITTEN** - Complete route guide with source-accurate information | Router.cs, HttpRouter.cs, examples |\r\n\r\n**Total**: ~167KB of source-verified technical documentation\r\n\r\n---\r\n\r\n### External Libraries (VERIFIED)\r\n\r\n| Document | Size | Topics | Source |\r\n|----------|------|--------|--------|\r\n| [WTT-CommonLib-TechnicalDocumentation.md](./WTT-CommonLib-TechnicalDocumentation.md) | 69KB | Complete WTT-CommonLib architecture | WTT-CommonLib source |\r\n| [OriginalFriendlyPMCDesign.md](../OriginalFriendlyPMCDesign.md) | 88KB | Original Friendly PMC mod design | Official mod page |\r\n\r\n---\r\n\r\n## Tier 2: NEEDS VERIFICATION ‚ö†Ô∏è\r\n\r\n### Client-Side (Based on Decompilation)\r\n\r\n| Document | Status | Warning |\r\n|----------|--------|---------|\r\n| [01-Bot-Spawning.md](./01-Bot-Spawning.md) | ‚ö†Ô∏è DECOMPILED | GClass mappings may be outdated for current EFT version |\r\n| [02-Bot-AI-Brain.md](./02-Bot-AI-Brain.md) | ‚ö†Ô∏è DECOMPILED | GClass mappings may be outdated |\r\n| [03-Party-Friends-Messenger-System.md](./03-Party-Friends-Messenger-System.md) | ‚ö†Ô∏è DECOMPILED | GClass mappings may be outdated |\r\n| [04-Voice-Gesture-Commands.md](./04-Voice-Gesture-Commands.md) | ‚ö†Ô∏è DECOMPILED | GClass mappings may be outdated |\r\n| [05-Health-Medical-System.md](./05-Health-Medical-System.md) | ‚ö†Ô∏è DECOMPILED | GClass mappings may be outdated |\r\n| [06-Grenade-Explosive-System.md](./06-Grenade-Explosive-System.md) | ‚ö†Ô∏è DECOMPILED | GClass mappings may be outdated |\r\n| [08-Cover-Navigation-System.md](./08-Cover-Navigation-System.md) | ‚ö†Ô∏è DECOMPILED | GClass mappings may be outdated |\r\n| [09-Item-Loot-System.md](./09-Item-Loot-System.md) | ‚ö†Ô∏è DECOMPILED | GClass mappings may be outdated |\r\n| [10-GClass-Mapping-Index.md](./10-GClass-Mapping-Index.md) | ‚ö†Ô∏è DECOMPILED | Mappings for specific EFT version |\r\n\r\n**NOTE**: Use as reference only. Verify behavior against current EFT version before using.\r\n\r\n---\r\n\r\n### Third-Party Integration üîÑ\r\n\r\n| Document | Status | Notes |\r\n|----------|--------|-------|\r\n| [12-SAIN-INTEGRATION-GUIDE.md](./12-SAIN-INTEGRATION-GUIDE.md) | üîÑ EXTERNAL | Based on SAIN documentation, verify version |\r\n| [13-BIGBRAIN-ARCHITECTURE.md](./13-BIGBRAIN-ARCHITECTURE.md) | üîÑ EXTERNAL | Based on BigBrain documentation |\r\n| [14-BIGBRAIN-API-REFERENCE.md](./14-BIGBRAIN-API-REFERENCE.md) | üîÑ EXTERNAL | Based on BigBrain documentation |\r\n| [15-BIGBRAIN-IMPLEMENTATION-GUIDE.md](./15-BIGBRAIN-IMPLEMENTATION-GUIDE.md) | üîÑ EXTERNAL | Based on BigBrain documentation |\r\n| [16-SAIN-PATTERNS-FOR-FRIENDLYPMC.md](./16-SAIN-PATTERNS-FOR-FRIENDLYPMC.md) | üîÑ EXTERNAL | SAIN integration patterns |\r\n| [SAIN-SOURCE-COMPLETE.md](./SAIN-SOURCE-COMPLETE.md) | üîÑ EXTERNAL | SAIN source analysis |\r\n| [SAIN-SOURCE-DOCUMENTATION-COMPLETE.md](./SAIN-SOURCE-DOCUMENTATION-COMPLETE.md) | üîÑ EXTERNAL | SAIN documentation |\r\n\r\n---\r\n\r\n## Tier 3: ARCHIVED/HISTORICAL ‚ùå\r\n\r\n### Superseded Documents\r\n\r\n| Document | Status | Superseded By |\r\n|----------|--------|---------------|\r\n| [AGENT1-ACTION-ITEMS.md](./AGENT1-ACTION-ITEMS.md) | ‚ùå ARCHIVED | SPT-404-ROOT-CAUSE-SOLVED.md |\r\n| [AGENT1-ALTERNATIVE-SOLUTIONS.md](./AGENT1-ALTERNATIVE-SOLUTIONS.md) | ‚ùå ARCHIVED | SPT-404-ROOT-CAUSE-SOLVED.md |\r\n| [AGENT1-FINAL-FIX.md](./AGENT1-FINAL-FIX.md) | ‚ùå ARCHIVED | SPT-404-ROOT-CAUSE-SOLVED.md |\r\n| [AGENT1-ROOT-CAUSE-ANALYSIS.md](./AGENT1-ROOT-CAUSE-ANALYSIS.md) | ‚ùå ARCHIVED | SPT-404-ROOT-CAUSE-SOLVED.md |\r\n| [AGENT-BLOCKER-SOLUTIONS.md](./AGENT-BLOCKER-SOLUTIONS.md) | ‚ùå ARCHIVED | SPT-ROUTING-ARCHITECTURE.md |\r\n| [AGENT-BLOCKER-SOLUTIONS-VALIDATED.md](./AGENT-BLOCKER-SOLUTIONS-VALIDATED.md) | ‚ùå ARCHIVED | SPT-ROUTING-ARCHITECTURE.md |\r\n| [COMPRESSION-FIX.md](./COMPRESSION-FIX.md) | ‚ùå ARCHIVED | SPT-COMPRESSION-EXPLAINED.md |\r\n| [SPT-SERVER-SOURCE-ANALYSIS.md](./SPT-SERVER-SOURCE-ANALYSIS.md) | ‚ùå ARCHIVED | SPT-ROUTING-ARCHITECTURE.md |\r\n| [00-INDEX.md](./00-INDEX.md) | ‚ùå ARCHIVED | MASTER-SPT-KNOWLEDGE-INDEX.md |\r\n| [KNOWLEDGE-BASE-COMPLETE.md](./KNOWLEDGE-BASE-COMPLETE.md) | ‚ùå ARCHIVED | MASTER-SPT-KNOWLEDGE-INDEX.md |\r\n| [FINAL-KNOWLEDGE-BASE-SUMMARY.md](./FINAL-KNOWLEDGE-BASE-SUMMARY.md) | ‚ùå ARCHIVED | MASTER-SPT-KNOWLEDGE-INDEX.md |\r\n\r\n**Reason**: These were based on assumptions, decompilation, or debugging notes. Superseded by definitive source-based documentation.\r\n\r\n---\r\n\r\n### Troubleshooting (Historical Reference)\r\n\r\n| Document | Status | Notes |\r\n|----------|--------|-------|\r\n| [UI-ISSUE-ANALYSIS-COMPLETE.md](./UI-ISSUE-ANALYSIS-COMPLETE.md) | ‚ö†Ô∏è REFERENCE | UI debugging notes |\r\n| [UNITYWEBREQUEST-DEEP-DIVE.md](./UNITYWEBREQUEST-DEEP-DIVE.md) | ‚ö†Ô∏è REFERENCE | Unity networking analysis |\r\n| [SPT-PMC-SPAWN-SYSTEM.md](./SPT-PMC-SPAWN-SYSTEM.md) | ‚ö†Ô∏è REFERENCE | PMC spawn analysis |\r\n| [00-PATTERN-SEARCH-RESULTS.md](./00-PATTERN-SEARCH-RESULTS.md) | ‚ö†Ô∏è REFERENCE | Pattern search results |\r\n\r\n---\r\n\r\n### General Documentation\r\n\r\n| Document | Status | Notes |\r\n|----------|--------|-------|\r\n| [11-INNOVATION-IMPLEMENTATION-GUIDES.md](./11-INNOVATION-IMPLEMENTATION-GUIDES.md) | ‚ö†Ô∏è GENERAL | Implementation ideas |\r\n| [README.md](./README.md) | ‚ö†Ô∏è GENERAL | Project README |\r\n\r\n---\r\n\r\n## Quick Start Guides\r\n\r\n### For Building SPT Server Mods\r\n\r\n**üìö Read in this order**:\r\n\r\n1. **START HERE**: [SPT-WORKING-PATTERNS.md](./SPT-WORKING-PATTERNS.md)\r\n   - Working code examples\r\n   - Complete minimal mod\r\n   - Verified patterns\r\n\r\n2. **Understand Routing**: [SPT-ROUTING-ARCHITECTURE.md](./SPT-ROUTING-ARCHITECTURE.md)\r\n   - Complete request flow\r\n   - How routing works\r\n   - StaticRouter vs DynamicRouter\r\n\r\n3. **Fix 404 Errors**: [SPT-404-ROOT-CAUSE-SOLVED.md](./SPT-404-ROOT-CAUSE-SOLVED.md)\r\n   - Why 404s happen\r\n   - How to fix them\r\n   - Common mistakes\r\n\r\n4. **Database Access**: [SPT-DATABASE-ACCESS.md](./SPT-DATABASE-ACCESS.md)\r\n   - DatabaseService API\r\n   - Modification patterns\r\n   - LazyLoad locales\r\n\r\n5. **Dependency Injection**: [SPT-DEPENDENCY-INJECTION.md](./SPT-DEPENDENCY-INJECTION.md)\r\n   - Injectable attribute\r\n   - Constructor injection\r\n   - Service lifetimes\r\n\r\n6. **Lifecycle & Timing**: [SPT-MOD-LIFECYCLE.md](./SPT-MOD-LIFECYCLE.md)\r\n   - IOnLoad, IOnUpdate\r\n   - OnLoadOrder constants\r\n   - When to use each phase\r\n\r\n7. **Routes Reference**: [07-Server-Routes-Patterns.md](./07-Server-Routes-Patterns.md)\r\n   - Complete route examples\r\n   - Error handling\r\n   - Testing patterns\r\n\r\n8. **Compression** (if needed): [SPT-COMPRESSION-EXPLAINED.md](./SPT-COMPRESSION-EXPLAINED.md)\r\n   - ZLib compression\r\n   - Debug headers\r\n   - Testing with curl/Postman\r\n\r\n---\r\n\r\n### For Using WTT-CommonLib\r\n\r\n**üìö Read**:\r\n- [WTT-CommonLib-TechnicalDocumentation.md](./WTT-CommonLib-TechnicalDocumentation.md)\r\n\r\n---\r\n\r\n### For Client-Side Modding\r\n\r\n**‚ö†Ô∏è CAUTION**: Client docs based on decompilation\r\n1. Verify against current EFT version\r\n2. GClass mappings change between patches\r\n3. Use as reference, test thoroughly\r\n\r\n---\r\n\r\n## Key Discoveries\r\n\r\n### The 404 Mystery - SOLVED! ‚úÖ\r\n\r\n**Problem**: Routes returning 404 even when registered correctly\r\n\r\n**Root Cause** (`HttpRouter.cs:54,58`):\r\n```csharp\r\nwrapper.Output = await (route as StaticRouter).HandleStatic(...) as string;\r\n//                                                                ^^^^^^^^^\r\n//                                               Cast returns null if not string!\r\n```\r\n\r\n**Solution**: All handlers MUST return `string`, not `object`\r\n\r\n```csharp\r\n// ‚ùå WRONG - Causes 404\r\nreturn new { status = \"ok\" };\r\n\r\n// ‚úÖ CORRECT\r\nreturn jsonUtil.Serialize(new { status = \"ok\" });\r\n```\r\n\r\n**Full Explanation**: [SPT-404-ROOT-CAUSE-SOLVED.md](./SPT-404-ROOT-CAUSE-SOLVED.md)\r\n\r\n---\r\n\r\n### Compression System - EXPLAINED! ‚úÖ\r\n\r\n**POST/PUT requests**:\r\n- Automatically ZLib-compressed unless `requestcompressed: 0` header\r\n- PUT always compressed (cannot disable)\r\n\r\n**Responses**:\r\n- Automatically ZLib-compressed unless `responsecompressed: 0` header\r\n- Use debug header for testing: `curl -H \"responsecompressed: 0\" ...`\r\n\r\n**Full Explanation**: [SPT-COMPRESSION-EXPLAINED.md](./SPT-COMPRESSION-EXPLAINED.md)\r\n\r\n---\r\n\r\n### Dependency Injection - DOCUMENTED! ‚úÖ\r\n\r\n**Pattern**:\r\n```csharp\r\n[Injectable(InjectionType.Singleton, TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MyMod(ISptLogger<MyMod> logger, DatabaseService db) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        // Database available, mod initializing\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n**Full Explanation**: [SPT-DEPENDENCY-INJECTION.md](./SPT-DEPENDENCY-INJECTION.md)\r\n\r\n---\r\n\r\n## Source Code Locations\r\n\r\n### SPT Server Source\r\n\r\n**Repository**: `E:\\AppDev\\LTsTarkovAI\\SPTtmp\\server-csharp`\r\n\r\n**Critical Directories**:\r\n```\r\nLibraries/SPTarkov.Server.Core/\r\n‚îú‚îÄ‚îÄ DI/                    # Dependency injection\r\n‚îÇ   ‚îú‚îÄ‚îÄ Router.cs          # StaticRouter, DynamicRouter base classes\r\n‚îÇ   ‚îú‚îÄ‚îÄ IOnLoad.cs         # Initialization interface\r\n‚îÇ   ‚îú‚îÄ‚îÄ IOnUpdate.cs       # Update loop interface\r\n‚îÇ   ‚îî‚îÄ‚îÄ OnLoadOrder.cs     # Load priority constants\r\n‚îú‚îÄ‚îÄ Routers/               # Routing system\r\n‚îÇ   ‚îú‚îÄ‚îÄ HttpRouter.cs      # Main router dispatcher\r\n‚îÇ   ‚îî‚îÄ‚îÄ Static/            # Example static routers\r\n‚îú‚îÄ‚îÄ Servers/Http/          # HTTP layer\r\n‚îÇ   ‚îî‚îÄ‚îÄ SptHttpListener.cs # Request/response handling, 404 generation\r\n‚îú‚îÄ‚îÄ Services/              # Core services\r\n‚îÇ   ‚îú‚îÄ‚îÄ DatabaseService.cs # Database access API\r\n‚îÇ   ‚îî‚îÄ‚îÄ Mod/               # Mod helper services\r\n‚îî‚îÄ‚îÄ Models/                # Data models\r\n    ‚îî‚îÄ‚îÄ Spt/Mod/           # Mod metadata\r\n        ‚îî‚îÄ‚îÄ AbstractModMetadata.cs\r\n```\r\n\r\n---\r\n\r\n## Documentation Statistics\r\n\r\n### Coverage\r\n\r\n- **SPT Server Architecture**: ‚úÖ 100% - Complete coverage\r\n- **Routing System**: ‚úÖ 100% - Full flow documented\r\n- **404 Error Diagnosis**: ‚úÖ 100% - Root cause identified and solved\r\n- **Compression**: ‚úÖ 100% - Complete system explained\r\n- **Dependency Injection**: ‚úÖ 100% - All patterns documented\r\n- **Database Access**: ‚úÖ 100% - Complete API reference\r\n- **Mod Lifecycle**: ‚úÖ 100% - All phases documented\r\n- **Working Patterns**: ‚úÖ 100% - Verified from real mods\r\n\r\n### Accuracy\r\n\r\n- **Source-based**: 100% - All Tier 1 docs based on actual source code\r\n- **Line numbers**: 100% - All claims have source file references\r\n- **Tested patterns**: 100% - All patterns from working code\r\n- **Zero assumptions**: ‚úÖ - No guesswork or decompilation artifacts\r\n\r\n---\r\n\r\n## How to Use This Knowledge Base\r\n\r\n### Scenario 1: Building a New SPT Server Mod\r\n\r\n**Start here**:\r\n1. [SPT-WORKING-PATTERNS.md](./SPT-WORKING-PATTERNS.md) - Copy the minimal working example\r\n2. [07-Server-Routes-Patterns.md](./07-Server-Routes-Patterns.md) - Add routes\r\n3. [SPT-DATABASE-ACCESS.md](./SPT-DATABASE-ACCESS.md) - Modify database if needed\r\n\r\n**Reference as needed**:\r\n- [SPT-DEPENDENCY-INJECTION.md](./SPT-DEPENDENCY-INJECTION.md) - For DI questions\r\n- [SPT-MOD-LIFECYCLE.md](./SPT-MOD-LIFECYCLE.md) - For timing/load order\r\n- [SPT-404-ROOT-CAUSE-SOLVED.md](./SPT-404-ROOT-CAUSE-SOLVED.md) - If you get 404s\r\n\r\n---\r\n\r\n### Scenario 2: Debugging 404 Errors\r\n\r\n**Follow this path**:\r\n1. [SPT-404-ROOT-CAUSE-SOLVED.md](./SPT-404-ROOT-CAUSE-SOLVED.md) - Understand the problem\r\n2. Check: Are you returning `jsonUtil.Serialize(response)`?\r\n3. Check: Is your router marked with `[Injectable]`?\r\n4. Check: Does your URL match exactly (StaticRouter) or contain (DynamicRouter)?\r\n5. [SPT-COMPRESSION-EXPLAINED.md](./SPT-COMPRESSION-EXPLAINED.md) - Test with `responsecompressed: 0`\r\n\r\n---\r\n\r\n### Scenario 3: Understanding SPT Architecture\r\n\r\n**Deep dive**:\r\n1. [SPT-ROUTING-ARCHITECTURE.md](./SPT-ROUTING-ARCHITECTURE.md) - Complete system\r\n2. [SPT-MOD-LIFECYCLE.md](./SPT-MOD-LIFECYCLE.md) - Startup and updates\r\n3. [SPT-DEPENDENCY-INJECTION.md](./SPT-DEPENDENCY-INJECTION.md) - DI system\r\n4. [SPT-DATABASE-ACCESS.md](./SPT-DATABASE-ACCESS.md) - Database structure\r\n\r\n---\r\n\r\n### Scenario 4: Using WTT-CommonLib\r\n\r\n**Read**:\r\n- [WTT-CommonLib-TechnicalDocumentation.md](./WTT-CommonLib-TechnicalDocumentation.md)\r\n\r\n---\r\n\r\n### Scenario 5: Building Client Mod\r\n\r\n**‚ö†Ô∏è WARNING**: Client docs based on decompilation\r\n\r\n**Approach**:\r\n1. Use client docs as reference (01-10)\r\n2. Verify behavior in current EFT version\r\n3. Test thoroughly before deploying\r\n4. Expect GClass names to change between EFT patches\r\n\r\n---\r\n\r\n## Version Compatibility\r\n\r\n### SPT Versions\r\n\r\n- **Documented**: SPT v4.0.x (C# server)\r\n- **Source**: SPT v4.0.5 actual source code\r\n- **Compatibility**: SPT 4.0.1 - 4.0.x (C# versions)\r\n- **NOT compatible**: SPT v3.x (TypeScript server) - completely different architecture\r\n\r\n### EFT Versions\r\n\r\n- **Server**: Version-independent (SPT handles compatibility)\r\n- **Client docs**: Based on specific EFT version (check GClass mappings)\r\n- **Recommendation**: Verify client patterns against current EFT version\r\n\r\n---\r\n\r\n## Update History\r\n\r\n### 2025-11-23: Major Source Verification Update\r\n\r\n**Added** (8 new documents, 167KB):\r\n- ‚úÖ SPT-ROUTING-ARCHITECTURE.md\r\n- ‚úÖ SPT-404-ROOT-CAUSE-SOLVED.md\r\n- ‚úÖ SPT-COMPRESSION-EXPLAINED.md\r\n- ‚úÖ SPT-DEPENDENCY-INJECTION.md\r\n- ‚úÖ SPT-DATABASE-ACCESS.md\r\n- ‚úÖ SPT-MOD-LIFECYCLE.md\r\n- ‚úÖ SPT-WORKING-PATTERNS.md\r\n- ‚úÖ 07-Server-Routes-Patterns.md (complete rewrite)\r\n\r\n**Archived** (11 documents):\r\n- AGENT1-*.md (superseded by 404 solution)\r\n- AGENT-BLOCKER-*.md (superseded by routing docs)\r\n- Old index files (superseded by this master index)\r\n- Compression-fix.md (superseded by compression guide)\r\n\r\n**Quality improvements**:\r\n- Zero assumptions - all information from source code\r\n- Complete line number references\r\n- Verified working patterns\r\n- Comprehensive examples\r\n\r\n---\r\n\r\n## Maintenance Plan\r\n\r\n### Monthly Tasks\r\n\r\n- [ ] Check for new SPT releases\r\n- [ ] Verify source code hasn't changed\r\n- [ ] Update version compatibility notes\r\n- [ ] Test documented patterns against latest SPT\r\n\r\n### Per SPT Major Release\r\n\r\n- [ ] Review source code changes\r\n- [ ] Update affected documentation\r\n- [ ] Verify all patterns still work\r\n- [ ] Update line number references\r\n\r\n### Per EFT Patch\r\n\r\n- [ ] Verify client documentation\r\n- [ ] Update GClass mappings\r\n- [ ] Test client patterns\r\n\r\n---\r\n\r\n## Contributing\r\n\r\n### Adding New Documentation\r\n\r\n**Requirements for SOURCE-VERIFIED status**:\r\n- [ ] Based on actual SPT C# source code (not decompilation)\r\n- [ ] Includes source file paths and line numbers\r\n- [ ] Tested against SPT v4.0.x\r\n- [ ] No assumptions or guesses\r\n- [ ] Includes working code examples\r\n\r\n**Template**:\r\n```markdown\r\n# Document Title\r\n\r\n**Source**: SPT v4.0.x C# Source Code\r\n**Status**: ‚úÖ SOURCE-VERIFIED\r\n\r\n## Section\r\n\r\n**Location**: `Path/To/Source.cs:LineNumber`\r\n\r\n```csharp\r\n// Source code snippet\r\n```\r\n\r\n**Why it works**: Explanation based on source code\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\n### What's Available Now ‚úÖ\r\n\r\n**Complete SPT Server Mod Development Documentation**:\r\n- Routing system (how it works, why 404s happen)\r\n- Dependency injection (how to use, patterns)\r\n- Database access (how to modify, patterns)\r\n- Mod lifecycle (when code runs, load order)\r\n- Working examples (verified, tested, production-ready)\r\n- Compression (how it works, how to debug)\r\n- Error solutions (404s, common issues)\r\n\r\n### Quality Guarantee\r\n\r\n**All Tier 1 documents**:\r\n- ‚úÖ Based on actual SPT source code\r\n- ‚úÖ Include source file references\r\n- ‚úÖ Tested patterns from working mods\r\n- ‚úÖ No assumptions or guesses\r\n- ‚úÖ Production-ready code examples\r\n\r\n### Next Steps\r\n\r\nUse Tier 1 (SOURCE-VERIFIED) documents for all SPT server mod development. These provide definitive, accurate information backed by actual source code.\r\n\r\nAvoid archived/outdated documents - they contain inaccuracies and superseded information.\r\n\r\n---\r\n\r\n**Master Index Version**: 2.0\r\n**Last Updated**: 2025-11-23\r\n**Verification Status**: ‚úÖ COMPLETE\r\n**Total SOURCE-VERIFIED Documentation**: 167KB across 8 documents\r\n"},"PROFILE-BOT-AID-FIX":{"title":"Profile Bot Aid=0 Issue - Complete Solution\r","category":"General","content":"# Profile Bot Aid=0 Issue - Complete Solution\r\n\r\n**Problem Identified**: SPT 4.0.5+ `BotGenerator.PrepareAndGenerateBot()` sets `Aid = 0`\r\n**Impact**: Breaks functionality that relies on non-zero Aid values\r\n**Status**: ‚úÖ SOLUTION PROVIDED\r\n\r\n---\r\n\r\n## The Problem\r\n\r\n### Source Code Evidence\r\n\r\n**File**: `E:\\AppDev\\LTsTarkovAI\\SPTtmp\\server-csharp\\Libraries\\SPTarkov.Server.Core\\Generators\\BotGenerator.cs`\r\n**Line**: ~660\r\n\r\n```csharp\r\nprotected void AddIdsToBot(BotBase bot)\r\n{\r\n    bot.Id = new MongoId();        // ‚úÖ Generates proper MongoId\r\n    bot.Aid = 0;                   // ‚ö†Ô∏è ZERO Aid!\r\n    bot.SessionId = new MongoId(); // ‚úÖ Generates session ID\r\n}\r\n```\r\n\r\n### Impact on FriendlyPMC\r\n\r\n**Old Baseline (SPT 3.x TypeScript)**:\r\n```typescript\r\n// Generated bots had Aid like 1113580, 1113581, etc.\r\nprofile.aid = 1113000 + randomInt(1000, 9999);\r\n```\r\n\r\n**New Behavior (SPT 4.0.x C#)**:\r\n```csharp\r\n// All generated bots get Aid = 0\r\nprofile.Aid = 0;\r\n```\r\n\r\n**What Breaks**:\r\n1. **Friend System**: If using Aid to identify followers\r\n2. **Group System**: If using Aid for party member tracking\r\n3. **Messenger**: If Aid used for message routing\r\n4. **Profile Lookups**: Any system using Aid as identifier\r\n\r\n---\r\n\r\n## Analysis: Does Aid Matter?\r\n\r\n### From Knowledge Base Research\r\n\r\n**Source**: `AGENT1-FRIENDLYPMC-CHATBOT-VISIBILITY.md`\r\n\r\n**Finding**: Aid is **NOT** used for chatbot visibility:\r\n```csharp\r\n// DialogueController.cs:111-131\r\npublic List<UserDialogInfo> GetActiveChatBots()\r\n{\r\n    foreach (var bot in DialogueChatBots)\r\n    {\r\n        var botData = bot.GetChatBot();\r\n\r\n        // Checks bot.Id (MongoId), NOT Aid!\r\n        if (chatBotConfig.EnabledBots.GetValueOrDefault(botData.Id, false))\r\n        {\r\n            activeBots.Add(botData);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Conclusion**: Chatbots use `Id` (MongoId), not `Aid`.\r\n\r\n### Where Aid IS Used\r\n\r\n**From SPT Source Analysis**:\r\n\r\n1. **UserDialogInfo Structure**:\r\n```csharp\r\npublic record UserDialogInfo\r\n{\r\n    public MongoId Id { get; set; }     // Primary identifier\r\n    public int? Aid { get; set; }       // Account ID (nullable!)\r\n    public UserDialogDetails? Info { get; set; }\r\n}\r\n```\r\n\r\n2. **Friend List Display**:\r\n```csharp\r\n// Aid is sent to client but not used for filtering\r\n// It's just metadata for display purposes\r\n```\r\n\r\n3. **Profile Lookups**:\r\n```csharp\r\n// SPT uses Id (MongoId) or SessionId for lookups\r\n// Aid is rarely used as primary identifier\r\n```\r\n\r\n**Conclusion**: Aid is **mostly cosmetic** in SPT 4.0.x but should still be set to avoid edge cases.\r\n\r\n---\r\n\r\n## The Solution\r\n\r\n### Fix 1: Set Non-Zero Aid After Generation\r\n\r\n**Update the ConvertToPmcData method**:\r\n\r\n```csharp\r\nprivate PmcData ConvertToPmcData(BotBase bot, string customNickname)\r\n{\r\n    var profile = new PmcData\r\n    {\r\n        Id = bot.Id,                    // ‚úÖ Proper MongoId from BotGenerator\r\n        Aid = GenerateUniqueAid(),      // ‚úÖ FIX: Generate non-zero Aid\r\n        SessionId = bot.SessionId,\r\n        Savage = null,\r\n        KarmaValue = bot.KarmaValue,\r\n        Info = bot.Info,\r\n        Customization = bot.Customization,\r\n        Health = bot.Health,\r\n        Inventory = bot.Inventory,\r\n        Skills = bot.Skills,\r\n        Stats = bot.Stats,\r\n        Encyclopedia = bot.Encyclopedia,\r\n        TaskConditionCounters = bot.TaskConditionCounters,\r\n        InsuredItems = bot.InsuredItems,\r\n        Hideout = bot.Hideout,\r\n        Quests = bot.Quests,\r\n        TradersInfo = bot.TradersInfo,\r\n        UnlockedInfo = bot.UnlockedInfo,\r\n        RagfairInfo = bot.RagfairInfo,\r\n        Achievements = bot.Achievements,\r\n        RepeatableQuests = bot.RepeatableQuests,\r\n        Bonuses = bot.Bonuses,\r\n        Notes = bot.Notes,\r\n        CarExtractCounts = bot.CarExtractCounts,\r\n        CoopExtractCounts = bot.CoopExtractCounts,\r\n        SurvivorClass = bot.SurvivorClass,\r\n        WishList = bot.WishList,\r\n        Variables = bot.Variables,\r\n        MoneyTransferLimitData = bot.MoneyTransferLimitData,\r\n        IsPmc = bot.IsPmc,\r\n        Prestige = new Dictionary<string, long>(),\r\n        CheckedMagazines = new Dictionary<string, double>(),\r\n        CheckedChambers = new List<string>(),\r\n    };\r\n\r\n    if (!string.IsNullOrEmpty(customNickname))\r\n    {\r\n        profile.Info.Nickname = customNickname;\r\n    }\r\n\r\n    return profile;\r\n}\r\n```\r\n\r\n### Aid Generation Strategies\r\n\r\n**Option 1: Sequential Aid (Simple)**\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class FollowerGeneratorService\r\n{\r\n    private static int _nextAid = 1113000;  // Starting Aid\r\n    private static readonly object _aidLock = new();\r\n\r\n    private int GenerateUniqueAid()\r\n    {\r\n        lock (_aidLock)\r\n        {\r\n            return _nextAid++;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Result**: Aids like 1113000, 1113001, 1113002, ...\r\n\r\n---\r\n\r\n**Option 2: Random Aid (Collision-Resistant)**\r\n\r\n```csharp\r\nprivate int GenerateUniqueAid(RandomUtil randomUtil)\r\n{\r\n    // Generate in range 1113000-1119999\r\n    return 1113000 + randomUtil.GetInt(0, 6999);\r\n}\r\n```\r\n\r\n**Result**: Aids like 1115432, 1113891, 1118234, ...\r\n\r\n---\r\n\r\n**Option 3: Hash-Based Aid (Deterministic)**\r\n\r\n```csharp\r\nprivate int GenerateUniqueAid(MongoId botId, HashUtil hashUtil)\r\n{\r\n    // Use bot's MongoId to generate stable Aid\r\n    var hash = hashUtil.GenerateCrc32ForData(botId.ToString());\r\n\r\n    // Convert to 7-digit number starting with 1113xxx\r\n    return 1113000 + (int)(hash % 7000);\r\n}\r\n```\r\n\r\n**Result**: Same botId always gets same Aid\r\n\r\n---\r\n\r\n**Option 4: Player-Based Aid (Scoped)**\r\n\r\n```csharp\r\nprivate int GenerateUniqueAid(MongoId playerSessionId, int followerIndex)\r\n{\r\n    // Base Aid on player's session ID + follower index\r\n    // Player 1's followers: 1113001, 1113002, 1113003\r\n    // Player 2's followers: 1114001, 1114002, 1114003\r\n\r\n    var playerHash = playerSessionId.ToString().GetHashCode();\r\n    var baseAid = 1113000 + ((playerHash % 10) * 1000);\r\n\r\n    return baseAid + followerIndex;\r\n}\r\n```\r\n\r\n**Result**: Followers grouped by owner's session\r\n\r\n---\r\n\r\n### Recommended: Option 4 (Player-Based)\r\n\r\n**Why**:\r\n- ‚úÖ Deterministic (same player, same Aids)\r\n- ‚úÖ Grouped by owner (easy debugging)\r\n- ‚úÖ No collisions within player's followers\r\n- ‚úÖ Reconstruction-friendly (reconnect scenarios)\r\n\r\n**Implementation**:\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class FollowerGeneratorService(\r\n    ISptLogger<FollowerGeneratorService> logger,\r\n    BotGenerator botGenerator,\r\n    BotHelper botHelper,\r\n    ItemHelper itemHelper,\r\n    HashUtil hashUtil,\r\n    ICloner cloner\r\n)\r\n{\r\n    // Track how many followers generated per player\r\n    private readonly ConcurrentDictionary<MongoId, int> _followerCountByPlayer = new();\r\n\r\n    public PmcData GenerateFollowerBot(\r\n        MongoId sessionId,\r\n        string side,\r\n        string nickname,\r\n        CustomLoadout? loadout = null\r\n    )\r\n    {\r\n        // 1. Generate base bot\r\n        string role = side == \"Bear\" ? \"pmcbear\" : side == \"Usec\" ? \"pmcusec\" : \"assault\";\r\n        var botTemplate = botHelper.GetBotTemplate(role);\r\n\r\n        var botGenDetails = new BotGenerationDetails\r\n        {\r\n            IsPmc = (side != \"Savage\"),\r\n            Side = side,\r\n            Role = role,\r\n            BotDifficulty = \"normal\",\r\n            BotCountToGenerate = 1,\r\n        };\r\n\r\n        var bot = botGenerator.PrepareAndGenerateBot(sessionId, botGenDetails);\r\n\r\n        // 2. Get follower index for this player\r\n        int followerIndex = _followerCountByPlayer.AddOrUpdate(\r\n            sessionId,\r\n            1,  // First follower\r\n            (key, count) => count + 1  // Increment\r\n        );\r\n\r\n        // 3. **FIX: Generate proper Aid**\r\n        int customAid = GenerateFollowerAid(sessionId, followerIndex);\r\n\r\n        // 4. Convert to PmcData\r\n        var profile = new PmcData\r\n        {\r\n            Id = bot.Id,\r\n            Aid = customAid,  // ‚úÖ Non-zero Aid!\r\n            SessionId = bot.SessionId,\r\n            Savage = null,\r\n            // ... copy all other fields ...\r\n        };\r\n\r\n        // 5. Override nickname\r\n        profile.Info.Nickname = nickname;\r\n\r\n        // 6. Customize equipment\r\n        if (loadout != null)\r\n        {\r\n            ApplyCustomLoadout(profile, loadout);\r\n        }\r\n\r\n        logger.Info($\"Generated follower: {nickname} (Aid: {customAid})\");\r\n        return profile;\r\n    }\r\n\r\n    private int GenerateFollowerAid(MongoId playerSessionId, int followerIndex)\r\n    {\r\n        // Hash player session ID to get consistent base\r\n        var sessionHash = hashUtil.GenerateCrc32ForData(playerSessionId.ToString());\r\n\r\n        // Map to 1113xxx-1119xxx range\r\n        var playerBase = 1113000 + ((int)(sessionHash % 7) * 1000);\r\n\r\n        // Add follower index (1-10 typically)\r\n        return playerBase + followerIndex;\r\n    }\r\n\r\n    // Call when player disconnects/raid ends to reset counter\r\n    public void ResetFollowerCount(MongoId sessionId)\r\n    {\r\n        _followerCountByPlayer.TryRemove(sessionId, out _);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Fix 2: Also Set MemberCategory (For Visual Distinction)\r\n\r\n**From your findings**: You can set `MemberCategory` and `SelectedMemberCategory`\r\n\r\n```csharp\r\n// After converting to PmcData\r\nprofile.Info.MemberCategory = MemberCategory.Sherpa;\r\nprofile.Info.SelectedMemberCategory = MemberCategory.Sherpa;\r\n```\r\n\r\n**MemberCategory Options** (from `MemberCategory.cs`):\r\n```csharp\r\npublic enum MemberCategory\r\n{\r\n    Default = 0,\r\n    Developer = 1,\r\n    UniqueId = 2,\r\n    Trader = 4,\r\n    Group = 8,\r\n    System = 16,\r\n    ChatModerator = 32,\r\n    ChatModeratorWithPermanentBan = 64,\r\n    UnitTest = 128,        // Used by Fika headless clients\r\n    Sherpa = 256,          // ‚úÖ Good for followers (visible badge)\r\n    Emissary = 512,\r\n    Unheard = 1024,\r\n}\r\n```\r\n\r\n**Recommended**: Use `MemberCategory.Sherpa` (256) for follower bots - gives them a distinctive badge in UI.\r\n\r\n---\r\n\r\n## Complete Fixed Implementation\r\n\r\n### Server-Side: Full Solution with Aid Fix\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class FollowerGeneratorService(\r\n    ISptLogger<FollowerGeneratorService> logger,\r\n    BotGenerator botGenerator,\r\n    BotHelper botHelper,\r\n    ItemHelper itemHelper,\r\n    HashUtil hashUtil,\r\n    RandomUtil randomUtil,\r\n    ICloner cloner\r\n)\r\n{\r\n    private readonly ConcurrentDictionary<MongoId, int> _followerCountByPlayer = new();\r\n\r\n    public PmcData GenerateFollowerBot(\r\n        MongoId sessionId,\r\n        string side,\r\n        string nickname,\r\n        CustomLoadout? loadout = null\r\n    )\r\n    {\r\n        // 1. Determine role\r\n        string role = side switch\r\n        {\r\n            \"Bear\" => \"pmcbear\",\r\n            \"Usec\" => \"pmcusec\",\r\n            _ => \"assault\"\r\n        };\r\n\r\n        // 2. Get template\r\n        var botTemplate = botHelper.GetBotTemplate(role);\r\n\r\n        // 3. Generate base bot\r\n        var botGenDetails = new BotGenerationDetails\r\n        {\r\n            IsPmc = (side != \"Savage\"),\r\n            Side = side,\r\n            Role = role,\r\n            BotDifficulty = \"normal\",\r\n            BotCountToGenerate = 1,\r\n            IsPlayerScav = false,\r\n        };\r\n\r\n        var bot = botGenerator.PrepareAndGenerateBot(sessionId, botGenDetails);\r\n\r\n        // 4. Get follower index\r\n        int followerIndex = _followerCountByPlayer.AddOrUpdate(\r\n            sessionId,\r\n            1,\r\n            (key, count) => count + 1\r\n        );\r\n\r\n        // 5. **CRITICAL FIX: Generate non-zero Aid**\r\n        int customAid = GenerateFollowerAid(sessionId, followerIndex);\r\n\r\n        logger.Info($\"Generated follower #{followerIndex} with Aid: {customAid}\");\r\n\r\n        // 6. Convert to PmcData with custom Aid\r\n        var profile = new PmcData\r\n        {\r\n            // IDs\r\n            Id = bot.Id,                    // From BotGenerator\r\n            Aid = customAid,                // ‚úÖ CUSTOM Aid (non-zero)\r\n            SessionId = bot.SessionId,      // From BotGenerator\r\n            Savage = null,\r\n\r\n            // Profile data\r\n            Info = bot.Info,\r\n            Customization = bot.Customization,\r\n            Health = bot.Health,\r\n            Inventory = bot.Inventory,\r\n            Skills = bot.Skills,\r\n            Stats = bot.Stats,\r\n            Encyclopedia = bot.Encyclopedia,\r\n            TaskConditionCounters = bot.TaskConditionCounters,\r\n            InsuredItems = bot.InsuredItems,\r\n            Hideout = bot.Hideout,\r\n            Quests = bot.Quests,\r\n            TradersInfo = bot.TradersInfo,\r\n            UnlockedInfo = bot.UnlockedInfo,\r\n            RagfairInfo = bot.RagfairInfo,\r\n            Achievements = bot.Achievements,\r\n            RepeatableQuests = bot.RepeatableQuests,\r\n            Bonuses = bot.Bonuses,\r\n            Notes = bot.Notes,\r\n            CarExtractCounts = bot.CarExtractCounts,\r\n            CoopExtractCounts = bot.CoopExtractCounts,\r\n            SurvivorClass = bot.SurvivorClass,\r\n            WishList = bot.WishList,\r\n            Variables = bot.Variables,\r\n            MoneyTransferLimitData = bot.MoneyTransferLimitData,\r\n            IsPmc = bot.IsPmc,\r\n            KarmaValue = bot.KarmaValue,\r\n\r\n            // PmcData-specific\r\n            Prestige = new Dictionary<string, long>(),\r\n            CheckedMagazines = new Dictionary<string, double>(),\r\n            CheckedChambers = new List<string>(),\r\n        };\r\n\r\n        // 7. **SET MEMBER CATEGORY for visual distinction**\r\n        profile.Info.MemberCategory = MemberCategory.Sherpa;\r\n        profile.Info.SelectedMemberCategory = MemberCategory.Sherpa;\r\n\r\n        // 8. Override nickname\r\n        profile.Info.Nickname = nickname;\r\n\r\n        // 9. Customize equipment\r\n        if (loadout != null)\r\n        {\r\n            ApplyCustomLoadout(profile, loadout);\r\n        }\r\n\r\n        logger.Success($\"Follower created: {nickname} (Id: {profile.Id}, Aid: {customAid})\");\r\n        return profile;\r\n    }\r\n\r\n    private int GenerateFollowerAid(MongoId playerSessionId, int followerIndex)\r\n    {\r\n        // Hash player session to get stable base\r\n        var hash = hashUtil.GenerateCrc32ForData(playerSessionId.ToString());\r\n\r\n        // Map to 1113xxx-1119xxx range (7000 slots)\r\n        var playerBase = 1113000 + ((int)(hash % 7) * 1000);\r\n\r\n        // Add follower index (1-10 typically)\r\n        // Player A followers: 1113001, 1113002, 1113003...\r\n        // Player B followers: 1116001, 1116002, 1116003...\r\n        return playerBase + followerIndex;\r\n    }\r\n\r\n    public void ResetFollowerCount(MongoId sessionId)\r\n    {\r\n        _followerCountByPlayer.TryRemove(sessionId, out _);\r\n        logger.Debug($\"Reset follower count for session {sessionId}\");\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Fix 2: Chatbot Aid Assignment\r\n\r\n**For chatbots** (BigPipe, BirdEye, Knight):\r\n\r\n```csharp\r\npublic class BigPipeChatBot : IDialogueChatBot\r\n{\r\n    public UserDialogInfo GetChatBot()\r\n    {\r\n        return new UserDialogInfo\r\n        {\r\n            Id = new MongoId(\"677c4e0cc7a538c4210d4d48\"),\r\n            Aid = 1113580,  // ‚úÖ Non-zero Aid (cosmetic but good practice)\r\n            Info = new UserDialogDetails\r\n            {\r\n                Level = 60,\r\n                MemberCategory = MemberCategory.Sherpa,\r\n                SelectedMemberCategory = MemberCategory.Sherpa,\r\n                Nickname = \"BigPipe\",\r\n                Side = \"Usec\",\r\n            },\r\n        };\r\n    }\r\n\r\n    public ValueTask<string> HandleMessage(MongoId sessionId, SendMessageRequest request)\r\n    {\r\n        // Handle squad commands\r\n        return ProcessSquadCommand(sessionId, request);\r\n    }\r\n}\r\n```\r\n\r\n**Note**: Chatbot Aid doesn't affect visibility (controlled by `core.json` ‚Üí `enabledBots`), but setting it avoids potential edge cases.\r\n\r\n---\r\n\r\n## Testing & Validation\r\n\r\n### Test 1: Verify Aid Assignment\r\n\r\n**Server Log**:\r\n```\r\n[Info] Generated follower #1 with Aid: 1113001\r\n[Info] Generated follower #2 with Aid: 1113002\r\n[Success] Follower created: Alpha (Id: 507f1f77bcf86cd799439011, Aid: 1113001)\r\n[Success] Follower created: Bravo (Id: 507f1f77bcf86cd799439012, Aid: 1113002)\r\n```\r\n\r\n**Profile Inspection**:\r\n```json\r\n{\r\n  \"_id\": \"507f1f77bcf86cd799439011\",\r\n  \"aid\": 1113001,\r\n  \"Info\": {\r\n    \"Nickname\": \"Alpha\",\r\n    \"Side\": \"Usec\",\r\n    \"Level\": 30,\r\n    \"MemberCategory\": 256\r\n  }\r\n}\r\n```\r\n\r\n### Test 2: Friend List Visibility\r\n\r\n**Query**: `GET /client/friend/list`\r\n\r\n**Expected Response**:\r\n```json\r\n{\r\n  \"Friends\": [\r\n    {\r\n      \"_id\": \"677c4e0cc7a538c4210d4d48\",\r\n      \"aid\": 1113580,\r\n      \"Info\": {\r\n        \"Nickname\": \"BigPipe\",\r\n        \"MemberCategory\": 256\r\n      }\r\n    },\r\n    {\r\n      \"_id\": \"507f1f77bcf86cd799439011\",\r\n      \"aid\": 1113001,\r\n      \"Info\": {\r\n        \"Nickname\": \"Alpha\"\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Validation**:\r\n- ‚úÖ Aid is non-zero\r\n- ‚úÖ Chatbots appear (if enabled in core.json)\r\n- ‚úÖ Followers appear (if added to friend list)\r\n\r\n---\r\n\r\n## Does This Solve Your Problem?\r\n\r\n### ‚úÖ YES - With Specific Fixes\r\n\r\n**What the original guide provided**:\r\n- ‚ö†Ô∏è Copied `Aid = 0` from BotGenerator\r\n\r\n**What the FIXED guide provides**:\r\n- ‚úÖ Generates non-zero Aid (1113xxx range)\r\n- ‚úÖ Uses stable Aid generation (hash-based)\r\n- ‚úÖ Sets MemberCategory for visual distinction\r\n- ‚úÖ Compatible with friend system\r\n- ‚úÖ Compatible with group/party systems\r\n\r\n### Updated Code Checklist\r\n\r\n**Server-Side Updates**:\r\n- [x] Generate non-zero Aid after bot generation\r\n- [x] Use stable Aid generation algorithm\r\n- [x] Set MemberCategory = Sherpa (or appropriate)\r\n- [x] Track follower count per player\r\n- [x] Reset counter on raid end\r\n\r\n**Client-Side**:\r\n- [x] No changes needed (receives profile with proper Aid)\r\n\r\n**Configuration**:\r\n- [x] Enable chatbots in `core.json` ‚Üí `enabledBots`\r\n- [x] Set admin IDs if using admin features\r\n\r\n---\r\n\r\n## Comparison: Before vs After\r\n\r\n### Before Fix (Aid = 0)\r\n\r\n```csharp\r\nvar bot = botGenerator.PrepareAndGenerateBot(sessionId, details);\r\nvar profile = new PmcData\r\n{\r\n    Id = bot.Id,\r\n    Aid = bot.Aid,  // ‚ö†Ô∏è 0 from BotGenerator!\r\n    // ...\r\n};\r\n```\r\n\r\n**Result**:\r\n```json\r\n{\r\n  \"_id\": \"507f1f77bcf86cd799439011\",\r\n  \"aid\": 0,  // ‚ö†Ô∏è Zero Aid\r\n  \"Info\": { \"Nickname\": \"Alpha\" }\r\n}\r\n```\r\n\r\n**Issues**:\r\n- ‚ö†Ô∏è Might break systems expecting non-zero Aid\r\n- ‚ö†Ô∏è All followers have same Aid (0)\r\n- ‚ö†Ô∏è Doesn't match old FriendlyPMC behavior\r\n\r\n---\r\n\r\n### After Fix (Custom Aid)\r\n\r\n```csharp\r\nvar bot = botGenerator.PrepareAndGenerateBot(sessionId, details);\r\nvar followerIndex = GetFollowerIndex(sessionId);\r\nvar customAid = GenerateFollowerAid(sessionId, followerIndex);\r\n\r\nvar profile = new PmcData\r\n{\r\n    Id = bot.Id,\r\n    Aid = customAid,  // ‚úÖ 1113001, 1113002, etc.\r\n    // ...\r\n};\r\n\r\nprofile.Info.MemberCategory = MemberCategory.Sherpa;\r\n```\r\n\r\n**Result**:\r\n```json\r\n{\r\n  \"_id\": \"507f1f77bcf86cd799439011\",\r\n  \"aid\": 1113001,  // ‚úÖ Non-zero Aid\r\n  \"Info\": {\r\n    \"Nickname\": \"Alpha\",\r\n    \"MemberCategory\": 256\r\n  }\r\n}\r\n```\r\n\r\n**Benefits**:\r\n- ‚úÖ Each follower has unique Aid\r\n- ‚úÖ Aids are stable (same player, same Aids)\r\n- ‚úÖ Matches old FriendlyPMC behavior\r\n- ‚úÖ Visual distinction via MemberCategory\r\n\r\n---\r\n\r\n## Conclusion\r\n\r\n### Direct Answer to Your Question\r\n\r\n**\"Would that solve this problem?\"**\r\n\r\n**As originally written**: ‚ùå NO - The guide copied `Aid = 0` from BotGenerator\r\n\r\n**With this fix**: ‚úÖ YES - Generate non-zero Aid manually after bot generation\r\n\r\n### The Complete Solution\r\n\r\n```csharp\r\n// ‚úÖ CORRECT Implementation\r\nvar bot = botGenerator.PrepareAndGenerateBot(sessionId, details);\r\n\r\n// Don't just copy bot.Aid (it's 0)!\r\n// Generate custom Aid instead\r\nvar customAid = GenerateFollowerAid(sessionId, followerIndex);\r\n\r\nvar profile = new PmcData\r\n{\r\n    Id = bot.Id,\r\n    Aid = customAid,  // ‚úÖ Set non-zero Aid\r\n    // ... other fields\r\n};\r\n\r\nprofile.Info.MemberCategory = MemberCategory.Sherpa;  // ‚úÖ Visual badge\r\n```\r\n\r\n### What This Achieves\r\n\r\n1. ‚úÖ **Non-zero Aid** (matches old FriendlyPMC: 1113xxx range)\r\n2. ‚úÖ **Unique per follower** (no collisions)\r\n3. ‚úÖ **Stable/deterministic** (hash-based on player session)\r\n4. ‚úÖ **Grouped by player** (easy to identify owner)\r\n5. ‚úÖ **Friend list compatible** (proper Aid metadata)\r\n6. ‚úÖ **Chatbot compatible** (if enabled in core.json)\r\n7. ‚úÖ **Visual distinction** (Sherpa badge in UI)\r\n\r\n---\r\n\r\n**Knowledge base update**: This issue is now documented with complete solution! üéØ\r\n"},"README":{"title":"FriendlyPMC Knowledge Base - Complete Reference\r","category":"General","content":"# FriendlyPMC Knowledge Base - Complete Reference\r\n\r\n**Created**: 2025-11-21\r\n**Purpose**: Comprehensive API documentation for building FriendlyPMC mod for SPT 4.0.5+\r\n**Status**: COMPLETE - Ready for implementation\r\n\r\n---\r\n\r\n## üìö What This Knowledge Base Contains\r\n\r\nThis knowledge base provides **complete, production-ready documentation** of the Tarkov SPT APIs needed to rebuild the FriendlyPMC mod AND implement 5 advanced innovations beyond the original design. It includes working code examples, integration patterns, common pitfalls, and debugging guides extracted from:\r\n\r\n- Decompiled Tarkov assembly (ilspy-out, 41 files)\r\n- Working FriendlyPMC 3.11 implementation\r\n- SAIN mod reference implementations\r\n- SPT server-mod-examples\r\n\r\n**Total Documentation**: ~3.5MB+ across 20+ comprehensive guides\r\n**Code Examples**: 200+ working implementations\r\n**SAIN v4.2.0 Source**: Fully analyzed (459 files, ~90K LOC)\r\n\r\n---\r\n\r\n## üß† BigBrain Foundation (START HERE FOR AI)\r\n\r\n### 13. **BigBrain Architecture** (CRITICAL - Layer System)\r\n**File**: [13-BIGBRAIN-ARCHITECTURE.md](13-BIGBRAIN-ARCHITECTURE.md) (389KB)\r\n\r\n**Covers**:\r\n- What BigBrain is and why ALL AI mods use it\r\n- Three-tier architecture (Layer ‚Üí Logic ‚Üí Tarkov AI)\r\n- CustomLayer and CustomLogic base classes\r\n- Integration with Tarkov via Harmony patches\r\n- Layer priority system and selection\r\n- Complete update flow (frame-by-frame)\r\n- Lifecycle management (Start/Stop/Update)\r\n- Performance considerations\r\n\r\n**You'll Learn**:\r\n- How BigBrain acts as bridge between mods and Tarkov\r\n- Why layers decide and logics execute\r\n- How priority system allows mod cooperation\r\n- How vanilla AI systems execute your decisions\r\n- **Complete mental model of BigBrain**\r\n\r\n**Critical For**: Phase 6 (Bot AI), ALL custom AI behavior\r\n\r\n---\r\n\r\n### 14. **BigBrain API Reference** (CRITICAL - Implementation)\r\n**File**: [14-BIGBRAIN-API-REFERENCE.md](14-BIGBRAIN-API-REFERENCE.md) (395KB)\r\n\r\n**Covers**:\r\n- Complete CustomLayer API documentation\r\n- Complete CustomLogic API documentation\r\n- BrainManager registration methods\r\n- Action and ActionData classes\r\n- Helper utilities and constants\r\n- All method signatures with examples\r\n\r\n**You'll Learn**:\r\n- Every method you need to implement\r\n- What each method does and when it's called\r\n- Required vs optional methods\r\n- Performance best practices\r\n\r\n**Critical For**: Actually writing layer/logic code\r\n\r\n---\r\n\r\n### 15. **BigBrain Implementation Guide** (CRITICAL - Patterns)\r\n**File**: [15-BIGBRAIN-IMPLEMENTATION-GUIDE.md](15-BIGBRAIN-IMPLEMENTATION-GUIDE.md) (403KB)\r\n\r\n**Covers**:\r\n- Hello World example (5 minutes to working layer)\r\n- Complete follower combat layer example\r\n- Movement patterns (follow, cover, position)\r\n- Combat patterns (engage, suppress, retreat)\r\n- Coordination patterns (cluster, multi-enemy)\r\n- Testing and debugging workflows\r\n- SAIN patterns you can adopt\r\n- Performance optimization techniques\r\n\r\n**You'll Learn**:\r\n- How to implement common behaviors\r\n- Patterns from SAIN (validated, working)\r\n- How to test your layers\r\n- How to optimize performance\r\n\r\n**Critical For**: Building FriendlyPMC Phase 6+\r\n\r\n---\r\n\r\n## üéØ Core Documentation (Start Here)\r\n\r\n### 1. **Bot AI/Brain System** (Phase 6 - CRITICAL)\r\n**File**: [02-Bot-AI-Brain.md](02-Bot-AI-Brain.md) (67KB)\r\n\r\n**Covers**:\r\n- BotMemoryClass - perception, enemy tracking, combat state\r\n- AICoreLayerClass - BigBrain layer architecture\r\n- BaseLogicLayerSimpleAbstractClass - combat logic helpers\r\n- Complete FollowerLayer template (ready to use)\r\n- Cluster perception integration patterns\r\n- Memory event hooks for damage sharing\r\n\r\n**You'll Learn**:\r\n- How to create custom BigBrain layers\r\n- How to control bot behavior (follow, fight, cover)\r\n- How to implement cluster-based perception (Phase 6)\r\n- How to hook into bot lifecycle events\r\n- Performance optimization patterns\r\n\r\n**Key APIs**:\r\n```csharp\r\npublic class FollowerLayer : BaseLogicLayerSimpleAbstractClass\r\n{\r\n    public override AICoreActionResultStruct<BotLogicDecision, GClass26> GetDecision() { }\r\n    public override AICoreActionEndStruct ShallEndCurrentDecision(...) { }\r\n    public override bool ShallUseNow() { }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 2. **Bot Spawning System** (Phase 5 - CRITICAL)\r\n**File**: [01-Bot-Spawning.md](01-Bot-Spawning.md) (65KB)\r\n\r\n**Covers**:\r\n- Complete spawn flow (pre-raid ‚Üí in-raid)\r\n- BotCreator.ActivateBot API\r\n- Faction/group configuration for friendly AI\r\n- Harmony patch targets and timing\r\n- Working code examples from FriendlyPMC\r\n\r\n**You'll Learn**:\r\n- How to spawn bots with the player at raid start\r\n- How to set faction/group to prevent friendly fire\r\n- How to use Coop spawn points (spawn together)\r\n- How to create BotsGroup with player as leader\r\n- Profile fetching and asset loading\r\n\r\n**Key APIs**:\r\n```csharp\r\nawait botCreator.ActivateBot(\r\n    profile,\r\n    new GClass682(position, corePointId, false),\r\n    zone,\r\n    false,\r\n    GroupAction,\r\n    OnActivate,\r\n    CancellationToken.None\r\n);\r\n```\r\n\r\n---\r\n\r\n### 3. **Party/Friends/Messenger System** (Phases 3+4 - CRITICAL)\r\n**File**: [03-Party-Friends-Messenger-System.md](03-Party-Friends-Messenger-System.md) (118KB)\r\n\r\n**Covers**:\r\n- Creating fake friend profiles (squad members)\r\n- Adding to Messenger friends list\r\n- IDialogueChatBot interface (Squad Manager)\r\n- Party invite ‚Üí raid spawn flow\r\n- Bidirectional dialogue creation\r\n- **CRITICAL**: Routes vs DI overrides explanation\r\n- **CRITICAL**: ID type mismatch bug (MongoId vs Aid)\r\n\r\n**You'll Learn**:\r\n- How FriendlyPMC actually works (fake friends trick!)\r\n- How to create Squad Manager chatbot\r\n- How to make squad members appear in Messenger\r\n- How party invites flow into raid spawning\r\n- How to avoid the #1 bug (wrong ID types)\r\n\r\n**Key APIs**:\r\n```csharp\r\n// Create friend profile\r\nvar memberId = new MongoId();\r\nvar memberAid = GenerateAid();\r\n_saveServer.AddProfile(profile);\r\nownerProfile.FriendProfileIds.Add(memberId);\r\n\r\n// ChatBot\r\npublic class SquadManagerChatBot : IDialogueChatBot\r\n{\r\n    public UserDialogInfo GetChatBot() { }\r\n    public ValueTask<string> HandleMessage(...) { }\r\n}\r\n```\r\n\r\n**Critical Sections**:\r\n- **Section 6.6**: Routes vs DI Overrides (when to use which)\r\n- **Section 6.7**: ID Type Mismatch Bug (debugging guide)\r\n\r\n---\r\n\r\n### 4. **Voice/Gesture Commands** (Phase 7 - HIGH)\r\n**File**: [04-Voice-Gesture-Commands.md](04-Voice-Gesture-Commands.md) (134KB)\r\n\r\n**Covers**:\r\n- BotEventHandler global event system\r\n- EPhraseTrigger enum (100+ voice commands)\r\n- EInteraction enum (gesture commands)\r\n- Command targeting (look-aim, closest, all)\r\n- BotRequest system for queuing actions\r\n- FollowerBrain state management\r\n- Custom command creation\r\n\r\n**You'll Learn**:\r\n- How to intercept Y-menu commands\r\n- How to translate voice commands to bot behavior\r\n- How to target specific bots (look-aim)\r\n- How to make bots respond with voice/gestures\r\n- How to add custom commands to Y-menu\r\n\r\n**Key APIs**:\r\n```csharp\r\npublic class FollowerReceiver : BotReceiver\r\n{\r\n    public void PhraseSaid(BotEventHandler.GClass692 info) { }\r\n    public void GestusShown(GClass532 data) { }\r\n}\r\n\r\n// Bot responses\r\nbotOwner.BotTalk.TrySay(EPhraseTrigger.Roger, false);\r\nbotOwner.Gesture.TryGestus(EInteraction.OkGesture, true);\r\n```\r\n\r\n**Command Reference**:\r\n- Follow Me, Hold Position, Go Forward, Suppress\r\n- Cover Me, Regroup, Spread Out, Get Back\r\n- Directional alerts (Front, Left, Right, Behind)\r\n- Custom commands (Team Status, etc.)\r\n\r\n---\r\n\r\n## üöÄ Advanced Systems Documentation (Innovations)\r\n\r\n### 5. **Health & Medical System** (Phase 12B+C, Innovation #5)\r\n**File**: [05-Health-Medical-System.md](05-Health-Medical-System.md) (174KB)\r\n\r\n**Covers**:\r\n- ActiveHealthController API\r\n- Body part health tracking\r\n- Damage system (DamageInfoStruct)\r\n- Status effects (bleeding, fractures, pain)\r\n- Medical item usage (bandages, surgery kits)\r\n- Critical state detection\r\n- Downed enemy states\r\n\r\n**You'll Learn**:\r\n- How to monitor player/bot health by body part\r\n- How to detect critical wounds (< 30% health)\r\n- How to apply healing programmatically\r\n- How to detect bleeding/fractures\r\n- How to implement medic AI\r\n- How to create downed enemy mechanics\r\n\r\n**Key APIs**:\r\n```csharp\r\nValueStruct health = healthController.GetBodyPartHealth(EBodyPart.Chest, false);\r\nactiveHealthController.RestoreBodyPart(EBodyPart.Chest, 0.5f);\r\nbool bleeding = healthController.FindExistingEffect<GInterface340>(EBodyPart.Common) != null;\r\n```\r\n\r\n---\r\n\r\n### 6. **Grenade & Explosive System** (Innovation #2, Phase 16)\r\n**File**: [06-Grenade-Explosive-System.md](06-Grenade-Explosive-System.md) (204KB)\r\n\r\n**Covers**:\r\n- Grenade throwing decision logic\r\n- Trajectory calculation (GClass577.CanThrowGrenade2)\r\n- Grenade detection and tracking\r\n- Flashbang mechanics (IsFlashed state)\r\n- Grenade avoidance behavior\r\n- Door breaching with explosives\r\n- Friendly fire prevention\r\n\r\n**You'll Learn**:\r\n- How to make bots throw grenades tactically\r\n- How to calculate grenade trajectories\r\n- How to detect incoming grenades\r\n- How to implement flashbang entry\r\n- How to coordinate breach sequences\r\n- Safety checks for friendly fire\r\n\r\n**Key APIs**:\r\n```csharp\r\nAIGreanageThrowData data = GClass577.CanThrowGrenade2(from, target, power, angle, -1f, 0.66f);\r\nBotOwner.WeaponManager.Grenades.SetThrowData(data);\r\nBotOwner.WeaponManager.Grenades.DoThrow();\r\nBotOwner.BewareGrenade.AddGrenadeDanger(dangerPoint, grenade);\r\n```\r\n\r\n---\r\n\r\n### 7. **Cover & Navigation System** (Innovation #1, #2, #5)\r\n**File**: [08-Cover-Navigation-System.md](08-Cover-Navigation-System.md) (222KB)\r\n\r\n**Covers**:\r\n- CustomNavigationPoint structure\r\n- Cover finding and scoring\r\n- SAINMoverClass (advanced movement)\r\n- Formation position calculations\r\n- NavMesh pathfinding\r\n- Tactical geometry (sectors, angles)\r\n- Breach stack positioning\r\n\r\n**You'll Learn**:\r\n- How to find tactical cover positions\r\n- How to calculate formation offsets (wedge, line, column)\r\n- How to validate positions on navmesh\r\n- How to control bot movement (walk, run, sprint)\r\n- How to position bots for door breaches\r\n- How to maintain squad spacing\r\n\r\n**Key APIs**:\r\n```csharp\r\nCustomNavigationPoint cover = Covers.GetClosestCoverPoint(botOwner, centerPos, radius, filter);\r\nmover.RunToPoint(position, urgency: ESprintUrgency.High);\r\nVector3 pos = GetWedgePosition(leaderPos, leaderForward, index, spacing);\r\n```\r\n\r\n---\r\n\r\n### 8. **Item & Loot System** (Phase 10, Innovation #3)\r\n**File**: [09-Item-Loot-System.md](09-Item-Loot-System.md) (238KB)\r\n\r\n**Covers**:\r\n- Item class hierarchy\r\n- InventoryController API\r\n- BotItemTaker (loot pickup)\r\n- Item transfer mechanics\r\n- Magazine/ammo management\r\n- Equipment locking system\r\n- Loot return workflow (Phase 10)\r\n\r\n**You'll Learn**:\r\n- How to track items bots pick up\r\n- How to transfer items between inventories\r\n- How to query ammo counts\r\n- How to share magazines between bots\r\n- How to return loot to player after raid\r\n- How to prevent looting bot equipment\r\n\r\n**Key APIs**:\r\n```csharp\r\ncontroller.GetReachableItemsOfTypeNonAlloc<MagazineItemClass>(list, null);\r\nInteractionsHandlerClass.Move(item, destination, controller, true);\r\nMagazineItemClass mag = weapon.GetCurrentMagazine();\r\nfloat ratio = (float)mag.Count / mag.MaxCount;\r\n```\r\n\r\n---\r\n\r\n## üîß Support Documentation\r\n\r\n### 9. **Server Routes Patterns** (Phase 1)\r\n**File**: [07-Server-Routes-Patterns.md](07-Server-Routes-Patterns.md) (143KB)\r\n\r\n**Covers**:\r\n- StaticRouter vs DynamicRouter\r\n- Route registration and handler patterns\r\n- Service resolution in routes\r\n- Request/response patterns\r\n- Error handling and validation\r\n- Performance considerations\r\n\r\n**Quick Reference**:\r\n```csharp\r\n[Injectable(InjectionType.Singleton, null, OnLoadOrder.PostDBModLoader)]\r\npublic sealed class MyStaticRouter : StaticRouter\r\n{\r\n    public MyStaticRouter(ISptLogger logger) : base(logger)\r\n    {\r\n        Routes = new List<RouteAction>\r\n        {\r\n            new RouteAction(\"/path\", async (url, body, sessionId, output) => { })\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 10. **GClass Mapping Index** (Reference)\r\n**File**: [10-GClass-Mapping-Index.md](10-GClass-Mapping-Index.md) (137KB)\r\n\r\n**Covers**:\r\n- Confirmed GClass mappings (20+)\r\n- Suspected mappings by pattern\r\n- How to discover new mappings\r\n- Common error translations\r\n- Quick lookup by feature area\r\n\r\n**Quick Lookup**:\r\n- `GClass168` ‚Üí BotNodeAbstractClass\r\n- `GClass1410` ‚Üí Profile Info (Nickname, Side, Level)\r\n- `GClass692` ‚Üí Voice Command Event Data\r\n- `GClass682` ‚Üí Spawn Position Data\r\n- `GClass671` ‚Üí Event Layer Priorities\r\n\r\n---\r\n\r\n### 11. **Innovation Implementation Guides** ‚≠ê NEW\r\n**File**: [11-INNOVATION-IMPLEMENTATION-GUIDES.md](11-INNOVATION-IMPLEMENTATION-GUIDES.md) (249KB)\r\n\r\n**Covers**:\r\n- 5 proposed innovations beyond original design\r\n- Step-by-step implementation plans\r\n- Complete code templates\r\n- API cross-reference by feature\r\n- Development timeline (4 weeks)\r\n- Success metrics and testing checklists\r\n\r\n**Innovations**:\r\n1. **Dynamic Formations** - Wedge, line, column, circle (100% ready)\r\n2. **Door Breaching** - Multi-stage flashbang entry (90% ready)\r\n3. **Fire Support** - Intelligent suppression, ammo management (95% ready)\r\n4. **Adaptive Learning** - Enemy behavior pattern recognition (100% ready)\r\n5. **Casualty Evacuation** - Drag wounded to cover, treat (80% ready)\r\n\r\n**Implementation Tiers**:\r\n- Tier 1 (Quick Wins): Adaptive Learning + Formations (1 week)\r\n- Tier 2 (High Value): Fire Support + Door Breach (2 weeks)\r\n- Tier 3 (Advanced): Casualty Evacuation (1.5 weeks)\r\n\r\n---\r\n\r\n### 12. **AGENT1 Action Items** (Bug Fixes)\r\n**File**: [AGENT1-ACTION-ITEMS.md](AGENT1-ACTION-ITEMS.md)\r\n\r\n**Immediate Fixes**:\r\n- Fix SquadMember data model (store both ProfileId and Aid)\r\n- Fix GetAutoJoin to return Aid strings (not MongoIds)\r\n- Add comprehensive logging to routes\r\n- Test with single member\r\n- Success criteria checklist\r\n\r\n---\r\n\r\n### 8. **Pattern Search Results** (File Mapping)\r\n**File**: [00-PATTERN-SEARCH-RESULTS.md](00-PATTERN-SEARCH-RESULTS.md)\r\n\r\n**Contains**:\r\n- Decompiled file inventory\r\n- Feature area ‚Üí file mapping\r\n- Search patterns used\r\n- Files discovered for each phase\r\n\r\n---\r\n\r\n## üöÄ Quick Start Guide\r\n\r\n### If You're Implementing...\r\n\r\n#### **Phase 3: Squad Manager Chatbot**\r\n‚Üí Read: `03-Party-Friends-Messenger-System.md` Section 2\r\n‚Üí Implement: `IDialogueChatBot`, register with `DialogueController`\r\n‚Üí Watch out for: Section 6.7 (ID mismatch bug!)\r\n\r\n#### **Phase 4: Party/Invite System**\r\n‚Üí Read: `03-Party-Friends-Messenger-System.md` Section 1 & 3\r\n‚Üí Implement: Friend profile creation, party tracking patches\r\n‚Üí Watch out for: Bidirectional relationships (Section 6.2)\r\n\r\n#### **Phase 5: Bot Spawning**\r\n‚Üí Read: `01-Bot-Spawning.md` Section 7 (working example)\r\n‚Üí Implement: BotCreator.ActivateBot with faction config\r\n‚Üí Watch out for: Faction configuration (Section 8)\r\n\r\n#### **Phase 6: Bot AI/Control**\r\n‚Üí Read: `02-Bot-AI-Brain.md` Section 8.1 (custom layer template)\r\n‚Üí Implement: FollowerLayer extending BaseLogicLayerSimpleAbstractClass\r\n‚Üí Watch out for: Memory event subscriptions (Section 8.2)\r\n\r\n#### **Phase 7: Voice Commands**\r\n‚Üí Read: `04-Voice-Gesture-Commands.md` Section 8 (implementation examples)\r\n‚Üí Implement: FollowerReceiver with PhraseSaid/GestusShown handlers\r\n‚Üí Watch out for: Command targeting (Section 5), busy state filtering (Section 13.1)\r\n\r\n---\r\n\r\n## üìñ Reading Order by Role\r\n\r\n### For Architects/Designers:\r\n1. This README\r\n2. `DESIGN_INTENT.md` (parent directory)\r\n3. `03-Party-Friends-Messenger-System.md` Section 6.6 (architecture decisions)\r\n4. All section summaries\r\n\r\n### For Implementers:\r\n1. `AGENT1-ACTION-ITEMS.md` (immediate tasks)\r\n2. Feature-specific docs (01-04, 07)\r\n3. `10-GClass-Mapping-Index.md` (when you hit obfuscated classes)\r\n4. `00-PATTERN-SEARCH-RESULTS.md` (when you need to find more files)\r\n\r\n### For Debuggers:\r\n1. `03-Party-Friends-Messenger-System.md` Section 6.7 (ID mismatch)\r\n2. `07-Server-Routes-Patterns.md` Section 11 (common issues)\r\n3. `04-Voice-Gesture-Commands.md` Section 14 (common pitfalls)\r\n4. `AGENT1-ACTION-ITEMS.md` (debugging checklists)\r\n\r\n---\r\n\r\n## üéì Key Concepts to Understand\r\n\r\n### 1. The Fake Friends Trick\r\n\r\nSquad members aren't just spawned - they're **fake friend profiles** in your Messenger that you **right-click and invite** like real players. This uses Tarkov's native party system to get them into raids.\r\n\r\n**Why this is brilliant**: Zero custom spawn UI needed - uses existing party invite flow.\r\n\r\n### 2. Cluster-Based Perception\r\n\r\nDon't make every bot do expensive perception checks. One \"PrimarySensor\" per squad does the heavy work and shares via events. Squad of 5 uses ~1 bot's CPU.\r\n\r\n**Implementation**: Hook `BotMemoryClass` events (OnAddEnemy, OnGoalEnemyChanged).\r\n\r\n### 3. Layered AI System\r\n\r\nTarkov AI uses **priority-based layers**. Higher priority layers override lower ones. Custom layers should be priority 500-600 to override vanilla combat but defer to critical events (flashbang, grenade).\r\n\r\n**Implementation**: Extend `BaseLogicLayerSimpleAbstractClass` and implement decision logic.\r\n\r\n### 4. Request System for Commands\r\n\r\nVoice commands create `BotRequest` objects that queue in the bot's request controller. Requests execute when bot's layer permits it.\r\n\r\n**Implementation**: Create custom request types, add to `AskRequests` controller.\r\n\r\n### 5. MongoId vs Aid vs AccountId\r\n\r\nThree different IDs per entity. Using the wrong one is the #1 bug:\r\n- **MongoId**: Profile/friend lookups\r\n- **Aid**: Party invites (7-digit integer)\r\n- **AccountId**: Aid as string for client comparisons\r\n\r\n**Golden Rule**: When in doubt, check Section 6.7 of the Party/Friends doc.\r\n\r\n---\r\n\r\n## üèóÔ∏è What You Can Build Now\r\n\r\nWith this knowledge base, you can implement:\r\n\r\n### ‚úÖ Phases 0-7 (Baseline Complete)\r\n- ‚úÖ **Phase 0**: Build pipeline (general knowledge)\r\n- ‚úÖ **Phase 1**: Server routes (07-Server-Routes-Patterns.md)\r\n- ‚úÖ **Phase 3**: Squad Manager chatbot (03-Party-Friends-Messenger-System.md Section 2)\r\n- ‚úÖ **Phase 4**: Party/invite flow (03-Party-Friends-Messenger-System.md Section 3)\r\n- ‚úÖ **Phase 5**: Bot spawning (01-Bot-Spawning.md)\r\n- ‚úÖ **Phase 6**: Bot AI control (02-Bot-AI-Brain.md)\r\n- ‚úÖ **Phase 7**: Voice commands (04-Voice-Gesture-Commands.md)\r\n\r\n### üî∂ Phases Needing Additional Research\r\n- Phase 8: Mid-raid recruitment (partial - use spawning + voice command knowledge)\r\n- Phase 9: Follower generation fidelity (partial - use spawning knowledge)\r\n- Phase 10: Loot system (needs research)\r\n- Phase 11: Bot progression (needs research)\r\n\r\n**However**: Phases 0-7 give you a **fully functional mod** with core features!\r\n\r\n---\r\n\r\n## üìä Documentation Statistics\r\n\r\n| Document | Size | Phase(s) | Priority | Code Examples |\r\n|----------|------|----------|----------|---------------|\r\n| 01-Bot-Spawning | 65KB | 5 | CRITICAL | 15+ |\r\n| 02-Bot-AI-Brain | 67KB | 6 | CRITICAL | 20+ |\r\n| 03-Party-Friends-Messenger | 118KB | 3+4 | CRITICAL | 25+ |\r\n| 04-Voice-Gesture-Commands | 134KB | 7 | HIGH | 18+ |\r\n| 05-Health-Medical-System | 174KB | 12B+C | HIGH | 12+ |\r\n| 06-Grenade-Explosive-System | 204KB | 16 | HIGH | 10+ |\r\n| 08-Cover-Navigation-System | 222KB | Multi | HIGH | 15+ |\r\n| 09-Item-Loot-System | 238KB | 10 | MEDIUM | 8+ |\r\n| 07-Server-Routes-Patterns | 143KB | 1 | MEDIUM | 12+ |\r\n| 10-GClass-Mapping-Index | 137KB | All | REFERENCE | N/A |\r\n| 11-Innovation-Implementation | 249KB | Innovations | HIGH | 15+ |\r\n| AGENT1-ACTION-ITEMS | 7KB | Current | URGENT | 5+ |\r\n| 00-PATTERN-SEARCH-RESULTS | 5KB | All | REFERENCE | N/A |\r\n| README | 150KB | Overview | START HERE | N/A |\r\n\r\n**Total**: ~750KB, **150+ working code examples**\r\n\r\n---\r\n\r\n## üéØ Implementation Roadmap\r\n\r\n### Week 1: Foundation (Phase 0-1)\r\n- [ ] Fix build pipeline (use general knowledge)\r\n- [ ] Implement StaticRouter with basic routes\r\n- [ ] Add comprehensive logging (07-Server-Routes Section 7)\r\n- [ ] Test route registration\r\n\r\n### Week 2: Social Integration (Phase 3-4)\r\n- [ ] Implement SquadService (store ProfileId + Aid!)\r\n- [ ] Implement SquadManagerChatBot (IDialogueChatBot)\r\n- [ ] Create friend profiles with bidirectional dialogue\r\n- [ ] Fix auto-join ID types (AGENT1-ACTION-ITEMS)\r\n- [ ] Test: `/add` ‚Üí friend appears ‚Üí `/autojoin on` ‚Üí auto-invite works\r\n\r\n### Week 3: Bot Spawning (Phase 5)\r\n- [ ] Implement FollowerService (profile generation)\r\n- [ ] Patch BotsController.AddActivePLayer (player registration)\r\n- [ ] Patch BotsEventsController.SpawnAction (spawn trigger)\r\n- [ ] Implement GetPlayerGroup (faction config)\r\n- [ ] Test: Invited member spawns in raid near player\r\n\r\n### Week 4: Bot AI (Phase 6)\r\n- [ ] Create FollowerLayer (BigBrain integration)\r\n- [ ] Implement basic follow logic\r\n- [ ] Implement combat logic (using InFightLogic())\r\n- [ ] Hook Memory events for cluster perception\r\n- [ ] Test: Bot follows player, engages enemies\r\n\r\n### Week 5: Voice Commands (Phase 7)\r\n- [ ] Create FollowerReceiver (command interception)\r\n- [ ] Implement command handlers (PhraseSaid, GestusShown)\r\n- [ ] Create custom BotRequests (Hold, Suppress, Regroup)\r\n- [ ] Implement FollowerBrain state management\r\n- [ ] Test: Y-menu commands control bot behavior\r\n\r\n### Week 6: Polish\r\n- [ ] Add all voice command mappings\r\n- [ ] Implement look-aim targeting\r\n- [ ] Add bot acknowledgment responses\r\n- [ ] Performance optimization (caching, LOD)\r\n- [ ] FIKA compatibility testing\r\n\r\n---\r\n\r\n## üîç How to Use This Knowledge Base\r\n\r\n### Scenario 1: \"I need to spawn a bot with the player\"\r\n\r\n1. Open `01-Bot-Spawning.md`\r\n2. Read Section 7 (Working Code Example)\r\n3. Copy the template and adapt\r\n4. Check Section 8 (Critical Notes) for faction config\r\n5. Reference `10-GClass-Mapping-Index.md` for GClass682, etc.\r\n\r\n### Scenario 2: \"I need to create a chatbot in Messenger\"\r\n\r\n1. Open `03-Party-Friends-Messenger-System.md`\r\n2. Read Section 2 (ChatBot System)\r\n3. Implement IDialogueChatBot interface\r\n4. Follow Section 2.3 (Registration)\r\n5. Check Section 6.7 for ID type pitfalls\r\n\r\n### Scenario 3: \"I need bots to respond to voice commands\"\r\n\r\n1. Open `04-Voice-Gesture-Commands.md`\r\n2. Read Section 8 (Implementation Examples)\r\n3. Create FollowerReceiver class\r\n4. Implement command handlers\r\n5. Check Section 3 for command list\r\n6. Check Section 14 for common pitfalls\r\n\r\n### Scenario 4: \"What is GClass1410?\"\r\n\r\n1. Open `10-GClass-Mapping-Index.md`\r\n2. Search for \"GClass1410\"\r\n3. Find: \"Profile Info (Nickname, Side, Level)\"\r\n4. Check usage context\r\n\r\n### Scenario 5: \"Auto-join isn't working\"\r\n\r\n1. Open `AGENT1-ACTION-ITEMS.md`\r\n2. Read Section 1 (ID Type Mismatch)\r\n3. Check `03-Party-Friends-Messenger-System.md` Section 6.7\r\n4. Verify you're returning Aid strings, not MongoIds\r\n5. Add logging from debugging checklist\r\n\r\n---\r\n\r\n## ‚ö†Ô∏è Common Mistakes (Read This First!)\r\n\r\n### 1. Wrong ID Types (Most Common!)\r\n```csharp\r\n// ‚ùå WRONG\r\nreturn squad.Members.Select(m => m.ProfileId).ToList();\r\n\r\n// ‚úÖ CORRECT\r\nreturn squad.Members.Select(m => m.Aid.ToString()).ToList();\r\n```\r\n**Details**: `03-Party-Friends-Messenger-System.md` Section 6.7\r\n\r\n### 2. Missing Bidirectional Friends\r\n```csharp\r\n// ‚ùå WRONG - Only one direction\r\nownerProfile.FriendProfileIds.Add(memberId);\r\n\r\n// ‚úÖ CORRECT - Both directions\r\nownerProfile.FriendProfileIds.Add(memberId);\r\nmemberProfile.FriendProfileIds.Add(ownerId);\r\nEnsureDialogue(ownerProfile, memberId, ...);\r\nEnsureDialogue(memberProfile, ownerId, ...);\r\n```\r\n**Details**: `03-Party-Friends-Messenger-System.md` Section 6.2\r\n\r\n### 3. Wrong Faction Configuration\r\n```csharp\r\n// ‚ùå WRONG - Bot will shoot player\r\nbot.Settings.FileSettings.Mind.ENEMY_BY_GROUPS_PMC_PLAYERS = true;\r\n\r\n// ‚úÖ CORRECT\r\nbot.Settings.FileSettings.Mind.ENEMY_BY_GROUPS_PMC_PLAYERS = false;\r\nbot.Memory.DeleteInfoAboutEnemy(player);\r\nprofile.Info.GroupId = player.GroupId;\r\n```\r\n**Details**: `01-Bot-Spawning.md` Section 8\r\n\r\n### 4. Not Caching Expensive Checks\r\n```csharp\r\n// ‚ùå WRONG - Raycast every frame\r\nif (IsPlayerLookingAt(bot, player))\r\n\r\n// ‚úÖ CORRECT - Cache for 0.5s\r\nif (Time.time - _lastCheck > 0.5f)\r\n{\r\n    _lastCheck = Time.time;\r\n    _cached = IsPlayerLookingAt(bot, player);\r\n}\r\nif (_cached)\r\n```\r\n**Details**: `04-Voice-Gesture-Commands.md` Section 13.5\r\n\r\n### 5. Not Calling Base Methods\r\n```csharp\r\n// ‚ùå WRONG\r\npublic override AICoreActionEndStruct ShallEndCurrentDecision(...)\r\n{\r\n    if (myCondition)\r\n        return new AICoreActionEndStruct(\"My reason\");\r\n    return new AICoreActionEndStruct(); // Missing base call!\r\n}\r\n\r\n// ‚úÖ CORRECT\r\npublic override AICoreActionEndStruct ShallEndCurrentDecision(...)\r\n{\r\n    var baseEnd = base.ShallEndCurrentDecision(curDecision);\r\n    if (baseEnd.Value)\r\n        return baseEnd;\r\n\r\n    if (myCondition)\r\n        return new AICoreActionEndStruct(\"My reason\");\r\n\r\n    return new AICoreActionEndStruct();\r\n}\r\n```\r\n**Details**: `02-Bot-AI-Brain.md` Section 9\r\n\r\n---\r\n\r\n## üêõ Debugging Workflows\r\n\r\n### Problem: \"Auto-join doesn't work\"\r\n\r\n1. Check `AGENT1-ACTION-ITEMS.md` Section 1\r\n2. Verify ID types: `03-Party-Friends-Messenger-System.md` Section 6.7\r\n3. Add logging from debugging checklist\r\n4. Test single member flow\r\n5. Check both server AND client logs\r\n\r\n### Problem: \"Bot shoots player\"\r\n\r\n1. Check `01-Bot-Spawning.md` Section 8 (Critical Notes)\r\n2. Verify faction configuration\r\n3. Check GroupId/TeamId match player\r\n4. Ensure `DeleteInfoAboutEnemy(player)` called\r\n\r\n### Problem: \"Voice command does nothing\"\r\n\r\n1. Check `04-Voice-Gesture-Commands.md` Section 13\r\n2. Verify BotReceiver patch is firing\r\n3. Check command targeting (look-aim vs all)\r\n4. Verify bot isn't in busy state\r\n5. Check request is added to controller\r\n\r\n### Problem: \"What is GClass###?\"\r\n\r\n1. Check `10-GClass-Mapping-Index.md` Confirmed Mappings\r\n2. If not found, check Suspected Mappings by pattern\r\n3. Use discovery methods (Section: \"How to Discover New Mappings\")\r\n\r\n---\r\n\r\n## üìà Coverage Matrix\r\n\r\n### Phase Coverage\r\n\r\n| Phase | Title | Coverage | Docs |\r\n|-------|-------|----------|------|\r\n| 0 | Foundation & Build | General | General knowledge |\r\n| 1 | Server Routes | ‚úÖ 100% | 07-Server-Routes |\r\n| 2 | Core Services | ‚úÖ 90% | 03-Party (Section 1.2), 07-Routes |\r\n| 3 | Squad Manager Chatbot | ‚úÖ 100% | 03-Party (Section 2) |\r\n| 4 | Party/Invite Flow | ‚úÖ 100% | 03-Party (Section 3) |\r\n| 5 | Bot Spawning | ‚úÖ 100% | 01-Bot-Spawning |\r\n| 6 | Bot AI & Perception | ‚úÖ 100% | 02-Bot-AI-Brain |\r\n| 7 | Voice Commands | ‚úÖ 100% | 04-Voice-Gesture |\r\n| 8 | Mid-Raid Recruitment | ‚ö†Ô∏è 60% | Use Phase 5+7 knowledge |\r\n| 9 | Follower Generation | ‚ö†Ô∏è 70% | Use Phase 5 knowledge |\r\n| 10 | Loot System | üî¥ 0% | Needs research |\r\n| 11 | Bot Progression | üî¥ 0% | Needs research |\r\n\r\n**Baseline Complete**: Phases 0-7 fully documented (you can build a functional mod!)\r\n\r\n---\r\n\r\n## üéâ Success Metrics\r\n\r\n### Knowledge Base Validated ‚úÖ\r\n\r\n**Tested By**: AGENT1 during implementation\r\n**Results**:\r\n- ‚úÖ Architecture confirmed correct (hybrid mod pattern)\r\n- ‚úÖ Routes vs DI overrides explained\r\n- ‚úÖ Critical bug identified (ID mismatch)\r\n- ‚úÖ Actionable fixes provided\r\n- ‚úÖ Debugging methodology validated\r\n\r\n**AGENT1 Quote**:\r\n> \"Broadly accurate: FriendlyPMC is a hybrid mod and needs custom routes because the client patches explicitly call them; vanilla SPT doesn't know these concepts. DI is already used for services/chatbot; routes are the right channel for custom client-server flows.\"\r\n\r\n### Next Phase: Implementation\r\n\r\nWith this knowledge base, AGENT1 is now unblocked to:\r\n1. Fix data model bugs (ProfileId vs Aid)\r\n2. Add logging and verify routes are called\r\n3. Test auto-join end-to-end\r\n4. Proceed to bot spawning and AI implementation\r\n\r\n---\r\n\r\n## üìù Contributing to This Knowledge Base\r\n\r\n### When You Discover New Information:\r\n\r\n1. **New GClass Mapping**:\r\n   - Add to `10-GClass-Mapping-Index.md` (Confirmed Mappings section)\r\n   - Include fields, usage context, and source\r\n\r\n2. **New Bug/Pitfall**:\r\n   - Add to relevant feature doc's \"Common Pitfalls\" section\r\n   - Include bug example, fix, and explanation\r\n\r\n3. **New API**:\r\n   - Add to relevant feature doc\r\n   - Include signature, usage example, integration notes\r\n\r\n4. **New Pattern**:\r\n   - Add to `07-Server-Routes-Patterns.md` or relevant doc\r\n   - Include example code and use case\r\n\r\n### Document Format:\r\n\r\n```markdown\r\n### New API Name\r\n\r\n**File**: Path to decompiled file\r\n**Purpose**: What it does\r\n\r\n```csharp\r\n// Signature\r\npublic ReturnType MethodName(ParamType param)\r\n\r\n// Usage example\r\nvar result = obj.MethodName(value);\r\n```\r\n\r\n**Integration Notes**:\r\n- When to use this API\r\n- Common pitfalls\r\n- Performance considerations\r\n```\r\n\r\n---\r\n\r\n## üö¶ Current Status\r\n\r\n**Knowledge Base**: ‚úÖ COMPLETE for Phases 0-7\r\n**Implementation**: üî∂ IN PROGRESS (AGENT1 working on bug fixes)\r\n**Next Milestone**: Auto-join working end-to-end\r\n\r\n---\r\n\r\n## üìû Quick Reference\r\n\r\n### Need to...\r\n- **Spawn a bot?** ‚Üí `01-Bot-Spawning.md` Section 7\r\n- **Control bot AI?** ‚Üí `02-Bot-AI-Brain.md` Section 8.1\r\n- **Create chatbot?** ‚Üí `03-Party-Friends-Messenger-System.md` Section 2\r\n- **Add friend?** ‚Üí `03-Party-Friends-Messenger-System.md` Section 1.2\r\n- **Handle voice command?** ‚Üí `04-Voice-Gesture-Commands.md` Section 8\r\n- **Create route?** ‚Üí `07-Server-Routes-Patterns.md` Section 1\r\n- **Understand GClass?** ‚Üí `10-GClass-Mapping-Index.md`\r\n- **Fix bugs?** ‚Üí `AGENT1-ACTION-ITEMS.md`\r\n- **Implement innovation?** ‚Üí `11-INNOVATION-IMPLEMENTATION-GUIDES.md`\r\n- **Track health?** ‚Üí `05-Health-Medical-System.md` Section 6\r\n- **Use grenades?** ‚Üí `06-Grenade-Explosive-System.md` Section 2\r\n- **Find cover?** ‚Üí `08-Cover-Navigation-System.md` Section 2\r\n- **Manage loot?** ‚Üí `09-Item-Loot-System.md` Section 7\r\n\r\n---\r\n\r\n## üî• SAIN v4.2.0 Source Analysis (NEW!)\r\n\r\n**AUTHENTIC SOURCE CODE** by Solarint - not decompiled!\r\n\r\n### Complete System Documentation\r\n\r\n**Location**: `SAINSource2` (459 C# files, ~90,000 LOC)\r\n\r\n**What's Documented**:\r\n1. ‚úÖ **Core Architecture** - 32-component system, managers, 193 patches, tick system\r\n2. ‚úÖ **Decision System** - All 34 decision types with actual algorithms\r\n3. ‚úÖ **Enemy System** - Selection, tracking, memory, forgetting, LOD\r\n4. ‚úÖ **Movement & Cover** - SAINMoverClass API, cover finding, doors, vaulting\r\n5. ‚úÖ **Combat Systems** - Shooting, aim, recoil, grenades, suppression, FF\r\n6. ‚úÖ **Sensory Systems** - Vision (jobs), hearing, NoBushESP, dazzle, weather\r\n7. ‚úÖ **Squad Coordination** - Formation, communication, tactics, sharing\r\n\r\n**Summary**: `SAIN-SOURCE-DOCUMENTATION-COMPLETE.md`\r\n**Integration Guide**: `16-SAIN-PATTERNS-FOR-FRIENDLYPMC.md`\r\n\r\n**Value**:\r\n- ‚úÖ True source with real comments and variable names\r\n- ‚úÖ Complete algorithms (not reverse-engineered)\r\n- ‚úÖ Production-proven patterns (SAIN ships and works)\r\n- ‚úÖ Direct applicability to FriendlyPMC\r\n- ‚úÖ ~90K LOC analyzed for definitive SPT AI reference\r\n\r\n---\r\n\r\n## üöÄ Beyond the Original: 5 Innovations\r\n\r\nThis knowledge base enables **5 advanced innovations** beyond the original FriendlyPMC design:\r\n\r\n### ‚úÖ Ready to Implement Now (100% Coverage)\r\n\r\n**Innovation #1: Dynamic Tactical Formations**\r\n- Auto-adjusting formations (wedge, line, column, circle)\r\n- Terrain-aware positioning\r\n- **Complexity**: Medium | **Impact**: High\r\n\r\n**Innovation #4: Adaptive Enemy Learning**\r\n- Observe enemy tactics, adapt counters\r\n- No LLM required (pure logic)\r\n- **Complexity**: Medium | **Impact**: Medium-High\r\n\r\n### üî∂ Nearly Ready (90-95% Coverage)\r\n\r\n**Innovation #2: Multi-Stage Door Breaching**\r\n- Stack, flashbang, breach, clear\r\n- **Complexity**: High | **Impact**: Very High\r\n\r\n**Innovation #3: Intelligent Fire Support**\r\n- Suppression with ammo management\r\n- **Complexity**: Medium | **Impact**: High\r\n\r\n### ‚ö†Ô∏è Some Gaps (80% Coverage)\r\n\r\n**Innovation #5: Casualty Evacuation**\r\n- Drag wounded to cover and treat\r\n- **Complexity**: Very High | **Impact**: Very High\r\n\r\n**See**: `11-INNOVATION-IMPLEMENTATION-GUIDES.md` for complete implementation plans\r\n\r\n---\r\n\r\n**This knowledge base is production-ready. Start building!** üöÄ\r\n"},"SPT-404-ROOT-CAUSE-SOLVED":{"title":"SPT 404 \"UNHANDLED RESPONSE\" - Root Cause SOLVED\r","category":"General","content":"# SPT 404 \"UNHANDLED RESPONSE\" - Root Cause SOLVED\r\n\r\n**Status**: ‚úÖ DEFINITIVE SOLUTION - Based on SPT source code\r\n**Problem**: Routes return 404 \"UNHANDLED RESPONSE\" error\r\n**Solution**: Handlers must return `string`, not `object`\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\n### The Problem\r\n\r\nYour SPT server mod routes return:\r\n```json\r\n{\r\n    \"err\": 404,\r\n    \"errmsg\": \"UNHANDLED RESPONSE: /your/route/here\",\r\n    \"data\": null\r\n}\r\n```\r\n\r\nEven though:\r\n- ‚úÖ Routes are registered correctly\r\n- ‚úÖ `CanHandle()` returns true\r\n- ‚úÖ `HandleStatic()` is called\r\n- ‚úÖ Your handler executes without errors\r\n\r\n### The Root Cause\r\n\r\n**Location**: `SPTarkov.Server.Core/Routers/HttpRouter.cs:54 and 58`\r\n\r\n```csharp\r\n// Line 54 (DynamicRouter)\r\nwrapper.Output = await (route as DynamicRouter).HandleDynamic(url, body, sessionID, wrapper.Output) as string;\r\n\r\n// Line 58 (StaticRouter)\r\nwrapper.Output = await (route as StaticRouter).HandleStatic(url, body, sessionID, wrapper.Output) as string;\r\n```\r\n\r\n**The `as string` cast fails silently when your handler returns an `object` instead of a `string`!**\r\n\r\n### The Solution\r\n\r\n```csharp\r\n// ‚ùå WRONG - Causes 404\r\nnew RouteAction(\r\n    \"/client/friendlypmc/status\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        var response = new { status = \"ok\" };\r\n        return response;  // Returns object, cast fails!\r\n    }\r\n)\r\n\r\n// ‚úÖ CORRECT - Works perfectly\r\nnew RouteAction(\r\n    \"/client/friendlypmc/status\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        var response = new { status = \"ok\" };\r\n        return jsonUtil.Serialize(response);  // Returns string!\r\n    }\r\n)\r\n```\r\n\r\n**GOLDEN RULE**: All route handlers MUST return `string`, not `object`!\r\n\r\n---\r\n\r\n## Complete Technical Explanation\r\n\r\n### The Full Chain of Failure\r\n\r\n#### Step 1: Your Handler Returns Object\r\n\r\n```csharp\r\nprivate RouteAction BuildStateRoute(JsonUtil jsonUtil)\r\n{\r\n    return new RouteAction(\r\n        \"/client/friendlypmc/status\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            var response = new { enabled = true };\r\n            return response;  // Type: Anonymous object (not string!)\r\n        }\r\n    );\r\n}\r\n```\r\n\r\n#### Step 2: StaticRouter Returns Object\r\n\r\n**Source**: `DI/Router.cs:82`\r\n\r\n```csharp\r\npublic async ValueTask<object> HandleStatic(...)\r\n{\r\n    // ... handler execution\r\n    var result = await action.action(url, info, sessionId, output);\r\n    return result;  // Returns your object as object type\r\n}\r\n```\r\n\r\nYour anonymous object is returned as `object` type (not `string`).\r\n\r\n#### Step 3: HttpRouter Casts to String\r\n\r\n**Source**: `Routers/HttpRouter.cs:58`\r\n\r\n```csharp\r\nwrapper.Output = await (route as StaticRouter).HandleStatic(url, body, sessionID, wrapper.Output) as string;\r\n//                                                                                                  ^^^^^^^^^\r\n//                                                                                    Safe cast - returns null if not string!\r\n```\r\n\r\n**C# `as` operator behavior**:\r\n```csharp\r\nobject obj = new { status = \"ok\" };\r\nstring? result = obj as string;  // result = null (cast fails silently!)\r\n```\r\n\r\nYour anonymous object is NOT a string, so the cast returns `null`.\r\n\r\n#### Step 4: SptHttpListener Generates 404\r\n\r\n**Source**: `Servers/Http/SptHttpListener.cs:170-177`\r\n\r\n```csharp\r\npublic async ValueTask<string> GetResponse(MongoId sessionId, HttpContext context, string? body)\r\n{\r\n    var output = await httpRouter.GetResponse(context.Request, sessionId, body);\r\n\r\n    // Route doesn't exist or response is not properly set up\r\n    if (string.IsNullOrEmpty(output))  // output is null from failed cast!\r\n    {\r\n        output = httpResponseUtil.GetBody<object?>(\r\n            null,\r\n            BackendErrorCodes.HTTPNotFound,\r\n            $\"UNHANDLED RESPONSE: {context.Request.Path.ToString()}\"\r\n        );\r\n    }\r\n\r\n    return output;\r\n}\r\n```\r\n\r\nSince `output` is `null`, the check `string.IsNullOrEmpty(output)` is `true`, and a 404 is generated.\r\n\r\n---\r\n\r\n## Why This Happens\r\n\r\n### RouteAction Return Types\r\n\r\n**Source**: `DI/Router.cs:182`\r\n\r\n```csharp\r\npublic record RouteAction(\r\n    string url,\r\n    Func<string, IRequestData, MongoId, string?, ValueTask<object>> action,  // ‚Üê Returns object!\r\n    Type? bodyType = null\r\n);\r\n```\r\n\r\nThe non-generic `RouteAction` expects handlers to return `ValueTask<object>`.\r\n\r\n**This means**:\r\n- You CAN return any object type\r\n- But HttpRouter WILL cast it to string\r\n- If it's not a string, the cast silently fails!\r\n\r\n### The Type Mismatch Chain\r\n\r\n```\r\nHandler returns anonymous object\r\n    ‚Üì (Type: Anonymous object)\r\nStaticRouter.HandleStatic returns object\r\n    ‚Üì (Type: object containing anonymous object)\r\nHttpRouter casts: (object) as string\r\n    ‚Üì (Type: null - cast failed!)\r\nSptHttpListener checks: string.IsNullOrEmpty(null)\r\n    ‚Üì (Result: true)\r\nGenerate 404 error\r\n```\r\n\r\n---\r\n\r\n## The Fix: Return Strings\r\n\r\n### Option 1: Serialize in Handler (Recommended)\r\n\r\n```csharp\r\nprivate RouteAction BuildStateRoute(JsonUtil jsonUtil)\r\n{\r\n    return new RouteAction(\r\n        \"/client/friendlypmc/status\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            var response = new { enabled = true };\r\n            return jsonUtil.Serialize(response);  // ‚úÖ Returns string!\r\n        }\r\n    );\r\n}\r\n```\r\n\r\n**Pros**:\r\n- Simple and direct\r\n- Explicit serialization\r\n- Easy to debug\r\n\r\n**Cons**:\r\n- Must remember to serialize every time\r\n\r\n### Option 2: Use RouteAction<TRequest> (Best Practice)\r\n\r\n```csharp\r\nprivate RouteAction BuildStateRoute(JsonUtil jsonUtil)\r\n{\r\n    return new RouteAction<EmptyRequestData>(  // ‚Üê Generic version\r\n        \"/client/friendlypmc/status\",\r\n        async (url, info, sessionId, output) =>  // Return type: ValueTask<string>\r\n        {\r\n            var response = new { enabled = true };\r\n            return jsonUtil.Serialize(response);  // ‚úÖ Must return string (enforced by compiler)\r\n        }\r\n    );\r\n}\r\n```\r\n\r\n**Pros**:\r\n- Compiler enforces `string` return type\r\n- Auto-deserializes request body\r\n- Type-safe\r\n\r\n**Cons**:\r\n- Slightly more verbose\r\n\r\n### Option 3: Create Helper Method\r\n\r\n```csharp\r\nprivate string SerializeResponse(JsonUtil jsonUtil, object response)\r\n{\r\n    return jsonUtil.Serialize(response);\r\n}\r\n\r\nprivate RouteAction BuildStateRoute(JsonUtil jsonUtil)\r\n{\r\n    return new RouteAction(\r\n        \"/client/friendlypmc/status\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            var response = new { enabled = true };\r\n            return SerializeResponse(jsonUtil, response);  // ‚úÖ Returns string!\r\n        }\r\n    );\r\n}\r\n```\r\n\r\n**Pros**:\r\n- Centralized serialization\r\n- Easy to add logging or error handling\r\n\r\n**Cons**:\r\n- Extra indirection\r\n\r\n---\r\n\r\n## Common Mistakes\r\n\r\n### Mistake 1: Returning Object Directly\r\n\r\n```csharp\r\n// ‚ùå WRONG\r\nreturn new { status = \"ok\" };\r\n\r\n// ‚úÖ CORRECT\r\nreturn jsonUtil.Serialize(new { status = \"ok\" });\r\n```\r\n\r\n### Mistake 2: Returning Null\r\n\r\n```csharp\r\n// ‚ùå WRONG\r\nif (error)\r\n    return null;  // Generates 404!\r\n\r\n// ‚úÖ CORRECT\r\nif (error)\r\n    return jsonUtil.Serialize(new { err = 500, errmsg = \"Error occurred\" });\r\n```\r\n\r\n### Mistake 3: Returning Empty String\r\n\r\n```csharp\r\n// ‚ùå WRONG\r\nif (noData)\r\n    return \"\";  // Generates 404!\r\n\r\n// ‚úÖ CORRECT\r\nif (noData)\r\n    return jsonUtil.Serialize(new { data = null });\r\n```\r\n\r\n### Mistake 4: Forgetting to Await Async Operations\r\n\r\n```csharp\r\n// ‚ùå WRONG\r\nreturn GetDataAsync();  // Returns Task, not string!\r\n\r\n// ‚úÖ CORRECT\r\nvar data = await GetDataAsync();\r\nreturn jsonUtil.Serialize(data);\r\n```\r\n\r\n---\r\n\r\n## Debugging Tips\r\n\r\n### 1. Check Response Type\r\n\r\nAdd logging to verify what your handler returns:\r\n\r\n```csharp\r\nprivate RouteAction BuildStateRoute(JsonUtil jsonUtil, ISptLogger logger)\r\n{\r\n    return new RouteAction(\r\n        \"/client/friendlypmc/status\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            var response = new { enabled = true };\r\n            var serialized = jsonUtil.Serialize(response);\r\n\r\n            logger.Info($\"Handler returning: {serialized}\");\r\n            logger.Info($\"Type: {serialized.GetType().Name}\");  // Should be \"String\"\r\n\r\n            return serialized;\r\n        }\r\n    );\r\n}\r\n```\r\n\r\n### 2. Test with Postman/curl\r\n\r\nSend request with `responsecompressed: 0` header to disable compression:\r\n\r\n```bash\r\ncurl -H \"responsecompressed: 0\" http://localhost:6969/client/friendlypmc/status\r\n```\r\n\r\nThis returns raw JSON without ZLib compression, easier to debug.\r\n\r\n### 3. Check Server Logs\r\n\r\nLook for:\r\n- Route registration: `[INFO] Route registered: /client/friendlypmc/status`\r\n- Handler execution: `[INFO] Handler called for /client/friendlypmc/status`\r\n- 404 generation: `UNHANDLED RESPONSE: /client/friendlypmc/status`\r\n\r\n### 4. Verify Route Matching\r\n\r\n```csharp\r\npublic override bool CanHandle(string url, bool partialMatch)\r\n{\r\n    var canHandle = base.CanHandle(url, partialMatch);\r\n    _logger.Info($\"CanHandle({url}, {partialMatch}) = {canHandle}\");\r\n    return canHandle;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Real-World Example: AGENT1's Issue\r\n\r\n### Original Code (Caused 404)\r\n\r\n```csharp\r\nprivate RouteAction BuildStateRoute()\r\n{\r\n    return new RouteAction(\r\n        \"/client/friendlypmc/status\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            var wrapped = _responseUtil.GetBody(response);  // Returns object\r\n            return _responseUtil.Serialize(_jsonUtil, wrapped);  // WAIT - What does this return?\r\n        }\r\n    );\r\n}\r\n```\r\n\r\n**Problem**: `Serialize()` method signature was unclear. If it returns `object`, 404 occurs!\r\n\r\n### Fixed Code\r\n\r\n```csharp\r\nprivate RouteAction BuildStateRoute()\r\n{\r\n    return new RouteAction(\r\n        \"/client/friendlypmc/status\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            var wrapped = _responseUtil.GetBody(response);\r\n            // Explicitly ensure string return\r\n            var serialized = _jsonUtil.Serialize(wrapped);\r\n            return serialized;  // ‚úÖ Definitely returns string!\r\n        }\r\n    );\r\n}\r\n```\r\n\r\n**Better Fix**: Use generic RouteAction\r\n\r\n```csharp\r\nprivate RouteAction BuildStateRoute()\r\n{\r\n    return new RouteAction<EmptyRequestData>(  // ‚Üê Compiler enforces string return\r\n        \"/client/friendlypmc/status\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            var wrapped = _responseUtil.GetBody(response);\r\n            return _jsonUtil.Serialize(wrapped);  // ‚úÖ Must be string!\r\n        }\r\n    );\r\n}\r\n```\r\n\r\n---\r\n\r\n## Verification Checklist\r\n\r\nBefore deploying your mod, verify:\r\n\r\n- [ ] All route handlers return `string` (not `object`, not `Task<object>`, not `null`)\r\n- [ ] All responses are serialized: `jsonUtil.Serialize(response)`\r\n- [ ] No handlers return `null` or empty string\r\n- [ ] Test routes with Postman/curl with `responsecompressed: 0`\r\n- [ ] Check server logs for successful registration\r\n- [ ] Verify `CanHandle()` returns `true` for your URLs\r\n- [ ] Test both GET and POST requests (if applicable)\r\n\r\n---\r\n\r\n## Performance Considerations\r\n\r\n### Serialization Overhead\r\n\r\nSerializing responses has minimal overhead:\r\n- SPT already serializes all responses before sending\r\n- Extra serialization call is negligible (~0.1ms)\r\n- Benefits far outweigh cost (avoid 404 errors!)\r\n\r\n### Caching Serialized Responses\r\n\r\nFor static responses, cache the serialized string:\r\n\r\n```csharp\r\nprivate readonly string _cachedStatusResponse;\r\n\r\npublic MyRouter(JsonUtil jsonUtil)\r\n{\r\n    // Serialize once at initialization\r\n    _cachedStatusResponse = jsonUtil.Serialize(new { status = \"ok\", version = \"1.0\" });\r\n}\r\n\r\nprivate RouteAction BuildStateRoute()\r\n{\r\n    return new RouteAction(\r\n        \"/client/friendlypmc/status\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            return _cachedStatusResponse;  // ‚úÖ Already a string!\r\n        }\r\n    );\r\n}\r\n```\r\n\r\n---\r\n\r\n## Comparison: Working vs Non-Working Patterns\r\n\r\n### Pattern 1: Direct Object Return (‚ùå FAILS)\r\n\r\n```csharp\r\nnew RouteAction(\r\n    \"/test\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        return new { data = \"value\" };  // ‚ùå Returns anonymous object\r\n    }\r\n)\r\n```\r\n\r\n**Result**: 404 error\r\n\r\n**Why**: Cast `(object){data=\"value\"} as string` returns `null`\r\n\r\n---\r\n\r\n### Pattern 2: Serialized Return (‚úÖ WORKS)\r\n\r\n```csharp\r\nnew RouteAction(\r\n    \"/test\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        return jsonUtil.Serialize(new { data = \"value\" });  // ‚úÖ Returns string\r\n    }\r\n)\r\n```\r\n\r\n**Result**: Success\r\n\r\n**Why**: Cast `(object)\"{\"data\":\"value\"}\" as string` succeeds\r\n\r\n---\r\n\r\n### Pattern 3: Generic RouteAction (‚úÖ WORKS - BEST)\r\n\r\n```csharp\r\nnew RouteAction<EmptyRequestData>(\r\n    \"/test\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        return jsonUtil.Serialize(new { data = \"value\" });  // ‚úÖ Returns string (enforced)\r\n    }\r\n)\r\n```\r\n\r\n**Result**: Success\r\n\r\n**Why**: Compiler enforces `string` return type\r\n\r\n---\r\n\r\n## Advanced: Custom Response Wrappers\r\n\r\n### Creating a Type-Safe Response Wrapper\r\n\r\n```csharp\r\npublic class RouteResponse\r\n{\r\n    private readonly JsonUtil _jsonUtil;\r\n\r\n    public RouteResponse(JsonUtil jsonUtil)\r\n    {\r\n        _jsonUtil = jsonUtil;\r\n    }\r\n\r\n    public string Ok<T>(T data)\r\n    {\r\n        return _jsonUtil.Serialize(new\r\n        {\r\n            err = 0,\r\n            errmsg = null,\r\n            data = data\r\n        });\r\n    }\r\n\r\n    public string Error(int errorCode, string message)\r\n    {\r\n        return _jsonUtil.Serialize(new\r\n        {\r\n            err = errorCode,\r\n            errmsg = message,\r\n            data = (object?)null\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n**Usage**:\r\n\r\n```csharp\r\nprivate RouteAction BuildStateRoute(RouteResponse response)\r\n{\r\n    return new RouteAction<EmptyRequestData>(\r\n        \"/client/friendlypmc/status\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            try\r\n            {\r\n                var data = GetStatusData();\r\n                return response.Ok(data);  // ‚úÖ Returns string\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                return response.Error(500, ex.Message);  // ‚úÖ Returns string\r\n            }\r\n        }\r\n    );\r\n}\r\n```\r\n\r\n**Benefits**:\r\n- Type-safe\r\n- Consistent error handling\r\n- Always returns string\r\n- Cleaner handler code\r\n\r\n---\r\n\r\n## Summary\r\n\r\n### The Core Issue\r\n\r\nSPT's `HttpRouter` casts route handler results to `string`. If the result is not a string type, the cast returns `null`, triggering a 404 error in `SptHttpListener`.\r\n\r\n### The Solution\r\n\r\n**Always return `string` from route handlers!**\r\n\r\n```csharp\r\n// ‚ùå WRONG\r\nreturn responseObject;\r\n\r\n// ‚úÖ CORRECT\r\nreturn jsonUtil.Serialize(responseObject);\r\n```\r\n\r\n### Best Practices\r\n\r\n1. Use `RouteAction<TRequest>` for type safety\r\n2. Always serialize responses to string\r\n3. Never return `null` or empty string\r\n4. Test with `responsecompressed: 0` header\r\n5. Add logging to verify return types\r\n6. Create response wrapper utilities\r\n7. Cache static serialized responses\r\n\r\n### Key Files\r\n\r\n- **404 Generation**: `Servers/Http/SptHttpListener.cs:170`\r\n- **Cast Failure**: `Routers/HttpRouter.cs:54,58`\r\n- **Route Types**: `DI/Router.cs:182-186`\r\n\r\n---\r\n\r\n## Conclusion\r\n\r\nThis issue cost countless hours of debugging because:\r\n1. Routes appeared to work (registered, matched, executed)\r\n2. The cast failure was silent (no exception)\r\n3. The error message was misleading (\"UNHANDLED\")\r\n\r\nNow that we understand the source code, the fix is simple: **return strings, not objects**.\r\n\r\n**Status**: ‚úÖ SOLVED - Definitive solution based on SPT source code\r\n\r\n---\r\n\r\n*This document is based on SPT v4.0.x server C# source code analysis and represents the definitive explanation of 404 routing errors.*\r\n"},"SPT-COMPRESSION-EXPLAINED":{"title":"SPT Request/Response Compression - Complete Guide\r","category":"General","content":"# SPT Request/Response Compression - Complete Guide\r\n\r\n**Source**: `SPTarkov.Server.Core/Servers/Http/SptHttpListener.cs`\r\n**Status**: ‚úÖ DEFINITIVE - Based on SPT v4.0.x source code\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\nSPT server automatically compresses/decompresses HTTP request and response bodies using **ZLib compression**. Understanding this system is critical for:\r\n- Debugging request/response issues\r\n- Testing routes with tools like Postman/curl\r\n- Implementing custom routes correctly\r\n\r\n### Quick Reference\r\n\r\n| Request Type | Auto-Compressed? | How to Disable |\r\n|-------------|------------------|----------------|\r\n| GET | No | N/A |\r\n| POST | Yes (unless header) | `requestcompressed: 0` |\r\n| PUT | Yes (always) | Cannot disable |\r\n\r\n| Response | Auto-Compressed? | How to Disable |\r\n|----------|------------------|----------------|\r\n| Standard | Yes (ZLib) | `responsecompressed: 0` |\r\n| Debug | No | `responsecompressed: 0` |\r\n| IMAGE/BUNDLE/NOTIFY | Custom serializer | N/A |\r\n\r\n---\r\n\r\n## Request Compression\r\n\r\n### Source Code Analysis\r\n\r\n**Location**: `SptHttpListener.cs:55-75`\r\n\r\n```csharp\r\ncase \"POST\":\r\ncase \"PUT\":\r\n{\r\n    // Lines 59-61: Check if request should be decompressed\r\n    var requestIsCompressed =\r\n        !context.Request.Headers.TryGetValue(\"requestcompressed\", out var compressHeader)\r\n        || compressHeader != \"0\";\r\n    var requestCompressed = context.Request.Method == \"PUT\" || requestIsCompressed;\r\n\r\n    string body;\r\n\r\n    // Lines 65-75: Decompress if needed\r\n    if (requestCompressed)\r\n    {\r\n        // ZLib decompression\r\n        await using var deflateStream = new ZLibStream(context.Request.Body, CompressionMode.Decompress);\r\n        using var reader = new StreamReader(deflateStream, Encoding.UTF8);\r\n        body = await reader.ReadToEndAsync();\r\n    }\r\n    else\r\n    {\r\n        // Raw body read\r\n        using var reader = new StreamReader(context.Request.Body, Encoding.UTF8);\r\n        body = await reader.ReadToEndAsync();\r\n    }\r\n}\r\n```\r\n\r\n### Compression Logic\r\n\r\n**POST Requests**:\r\n```\r\nIF header \"requestcompressed\" exists AND equals \"0\"\r\n    THEN read raw (no decompression)\r\nELSE\r\n    decompress with ZLib\r\n```\r\n\r\n**PUT Requests**:\r\n```\r\nALWAYS decompress with ZLib (cannot disable)\r\n```\r\n\r\n**GET Requests**:\r\n```\r\nNo body, no decompression needed\r\n```\r\n\r\n### Disabling Request Compression\r\n\r\n**For POST requests**:\r\n```bash\r\ncurl -X POST \\\r\n  -H \"Content-Type: application/json\" \\\r\n  -H \"requestcompressed: 0\" \\\r\n  -d '{\"data\": \"value\"}' \\\r\n  http://localhost:6969/your/route\r\n```\r\n\r\n**For PUT requests**:\r\n```\r\nCannot disable! PUT always expects compressed body.\r\n```\r\n\r\n**From C# client**:\r\n```csharp\r\nvar request = new HttpRequestMessage(HttpMethod.Post, url);\r\nrequest.Headers.Add(\"requestcompressed\", \"0\");\r\nrequest.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\r\nvar response = await httpClient.SendAsync(request);\r\n```\r\n\r\n---\r\n\r\n## Response Compression\r\n\r\n### Source Code Analysis\r\n\r\n**Location**: `SptHttpListener.cs:107-139`\r\n\r\n```csharp\r\npublic async Task SendResponse(MongoId sessionID, HttpRequest req, HttpResponse resp, object? body, string output)\r\n{\r\n    body ??= new object();\r\n    var bodyInfo = jsonUtil.Serialize(body);\r\n\r\n    // Lines 113-123: Debug mode - no compression\r\n    if (IsDebugRequest(req))\r\n    {\r\n        // Send only raw response without transformation\r\n        await SendJson(resp, output, sessionID);\r\n        if (logger.IsLogEnabled(LogLevel.Debug))\r\n        {\r\n            logger.Debug($\"Response: {output}\");\r\n        }\r\n\r\n        LogRequest(req, output);\r\n        return;\r\n    }\r\n\r\n    // Lines 126-136: Check for special serializers\r\n    var serialiser = serializers.FirstOrDefault(x => x.CanHandle(output));\r\n    if (serialiser != null)\r\n    {\r\n        // IMAGE/BUNDLE/NOTIFY handlers\r\n        await serialiser.Serialize(sessionID, req, resp, bodyInfo);\r\n    }\r\n    else\r\n    {\r\n        // Standard response: ZLib compress\r\n        await SendZlibJson(resp, output, sessionID);\r\n    }\r\n\r\n    LogRequest(req, output);\r\n}\r\n```\r\n\r\n**IsDebugRequest Check** (Line 146-149):\r\n```csharp\r\nprotected bool IsDebugRequest(HttpRequest req)\r\n{\r\n    return req.Headers.TryGetValue(\"responsecompressed\", out var value) && value == \"0\";\r\n}\r\n```\r\n\r\n### Response Flow\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  SendResponse called with output string         ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                    ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  Check: responsecompressed header = \"0\"?        ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n        YES ‚Üì                    NO ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ SendJson         ‚îÇ    ‚îÇ Check special          ‚îÇ\r\n‚îÇ (Raw, no         ‚îÇ    ‚îÇ serializers            ‚îÇ\r\n‚îÇ  compression)    ‚îÇ    ‚îÇ (IMAGE/BUNDLE/NOTIFY)  ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                                  NO ‚Üì\r\n                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n                        ‚îÇ SendZlibJson           ‚îÇ\r\n                        ‚îÇ (ZLib compressed)      ‚îÇ\r\n                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n```\r\n\r\n### Compression Modes\r\n\r\n**Mode 1: Debug (No Compression)**\r\n- **Trigger**: `responsecompressed: 0` header\r\n- **Method**: `SendJson()`\r\n- **Output**: Raw JSON string\r\n- **Use Case**: Testing, debugging\r\n\r\n**Mode 2: Special Serializers**\r\n- **Trigger**: Output starts with `IMAGE`, `BUNDLE`, or `NOTIFY`\r\n- **Method**: Custom serializer\r\n- **Output**: Binary data (images, bundles, notifications)\r\n- **Use Case**: Asset delivery, notifications\r\n\r\n**Mode 3: Standard (ZLib Compression)**\r\n- **Trigger**: Normal requests (majority)\r\n- **Method**: `SendZlibJson()`\r\n- **Output**: ZLib-compressed JSON\r\n- **Use Case**: All standard JSON responses\r\n\r\n---\r\n\r\n## ZLib Compression Implementation\r\n\r\n### SendJson (Uncompressed)\r\n\r\n**Source**: `SptHttpListener.cs:189-199`\r\n\r\n```csharp\r\npublic async Task SendJson(HttpResponse resp, string? output, MongoId sessionID)\r\n{\r\n    resp.StatusCode = 200;\r\n    resp.ContentType = \"application/json\";\r\n    resp.Headers.Append(\"Set-Cookie\", $\"PHPSESSID={sessionID.ToString()}\");\r\n\r\n    if (!string.IsNullOrEmpty(output))\r\n    {\r\n        await resp.WriteAsync(output);  // Write raw string\r\n    }\r\n}\r\n```\r\n\r\n**Output**: Raw JSON string sent directly to HTTP response body.\r\n\r\n---\r\n\r\n### SendZlibJson (Compressed)\r\n\r\n**Source**: `SptHttpListener.cs:201-211`\r\n\r\n```csharp\r\npublic async Task SendZlibJson(HttpResponse resp, string output, MongoId sessionID)\r\n{\r\n    resp.StatusCode = 200;\r\n    resp.ContentType = \"application/json\";\r\n    resp.Headers.Append(\"Set-Cookie\", $\"PHPSESSID={sessionID.ToString()}\");\r\n\r\n    // Lines 207-210: ZLib compression\r\n    await using (var deflateStream = new ZLibStream(resp.Body, CompressionLevel.SmallestSize))\r\n    {\r\n        await deflateStream.WriteAsync(Encoding.UTF8.GetBytes(output));\r\n    }\r\n}\r\n```\r\n\r\n**Output**: ZLib-compressed JSON sent to HTTP response body.\r\n\r\n**Compression Level**: `CompressionLevel.SmallestSize` (maximum compression)\r\n\r\n---\r\n\r\n## Testing Routes\r\n\r\n### Using curl (Command Line)\r\n\r\n**Standard Request (Compressed Response)**:\r\n```bash\r\ncurl http://localhost:6969/client/game/start\r\n# Response is ZLib-compressed binary\r\n```\r\n\r\n**Debug Request (Uncompressed Response)**:\r\n```bash\r\ncurl -H \"responsecompressed: 0\" http://localhost:6969/client/game/start\r\n# Response is raw JSON, readable\r\n```\r\n\r\n**POST with Uncompressed Request/Response**:\r\n```bash\r\ncurl -X POST \\\r\n  -H \"Content-Type: application/json\" \\\r\n  -H \"requestcompressed: 0\" \\\r\n  -H \"responsecompressed: 0\" \\\r\n  -d '{\"key\": \"value\"}' \\\r\n  http://localhost:6969/your/route\r\n# Both request and response are uncompressed\r\n```\r\n\r\n### Using Postman\r\n\r\n**Setup**:\r\n1. Create new request\r\n2. Set method (GET/POST/PUT)\r\n3. Set URL: `http://localhost:6969/your/route`\r\n4. Add headers:\r\n   - `requestcompressed: 0` (for POST)\r\n   - `responsecompressed: 0` (for readable response)\r\n5. Add body (for POST/PUT):\r\n   - Type: `raw`\r\n   - Format: `JSON`\r\n   - Content: `{\"key\": \"value\"}`\r\n\r\n**Response**:\r\n- With `responsecompressed: 0`: See JSON in response body\r\n- Without header: See binary data (compressed)\r\n\r\n### Using C# HttpClient\r\n\r\n```csharp\r\nusing var httpClient = new HttpClient();\r\nhttpClient.BaseAddress = new Uri(\"http://localhost:6969\");\r\n\r\n// Add debug headers\r\nvar request = new HttpRequestMessage(HttpMethod.Get, \"/client/game/start\");\r\nrequest.Headers.Add(\"responsecompressed\", \"0\");\r\n\r\nvar response = await httpClient.SendAsync(request);\r\nvar json = await response.Content.ReadAsStringAsync();\r\n\r\nConsole.WriteLine($\"Response: {json}\");  // Readable JSON\r\n```\r\n\r\n---\r\n\r\n## Client-Side Integration\r\n\r\n### EFT Game Client Expectations\r\n\r\n**Request Sending**:\r\n- EFT client sends POST/PUT with ZLib-compressed bodies (automatically)\r\n- Cannot disable compression from game client\r\n- Must handle compressed requests on server\r\n\r\n**Response Reading**:\r\n- EFT client expects ZLib-compressed responses (automatically)\r\n- Client decompresses automatically\r\n- Don't use `responsecompressed: 0` in production\r\n\r\n### Custom Client Implementation\r\n\r\n**If building custom client**:\r\n\r\n```csharp\r\npublic class SptClient\r\n{\r\n    private readonly HttpClient _httpClient;\r\n\r\n    public async Task<string> PostJson(string url, string json)\r\n    {\r\n        // Compress request body\r\n        var compressed = CompressZLib(json);\r\n\r\n        var request = new HttpRequestMessage(HttpMethod.Post, url);\r\n        request.Content = new ByteArrayContent(compressed);\r\n        request.Content.Headers.ContentType = new MediaTypeHeaderValue(\"application/json\");\r\n\r\n        var response = await _httpClient.SendAsync(request);\r\n        var compressedResponse = await response.Content.ReadAsByteArrayAsync();\r\n\r\n        // Decompress response\r\n        var decompressed = DecompressZLib(compressedResponse);\r\n        return decompressed;\r\n    }\r\n\r\n    private byte[] CompressZLib(string input)\r\n    {\r\n        using var output = new MemoryStream();\r\n        using (var deflate = new ZLibStream(output, CompressionLevel.SmallestSize))\r\n        using (var writer = new StreamWriter(deflate, Encoding.UTF8))\r\n        {\r\n            writer.Write(input);\r\n        }\r\n        return output.ToArray();\r\n    }\r\n\r\n    private string DecompressZLib(byte[] input)\r\n    {\r\n        using var inputStream = new MemoryStream(input);\r\n        using var deflate = new ZLibStream(inputStream, CompressionMode.Decompress);\r\n        using var reader = new StreamReader(deflate, Encoding.UTF8);\r\n        return reader.ReadToEnd();\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Debugging Compression Issues\r\n\r\n### Issue 1: \"Invalid ZLib header\" Error\r\n\r\n**Symptoms**:\r\n```\r\nSystem.IO.InvalidDataException: The archive entry was compressed using an unsupported compression method.\r\n```\r\n\r\n**Cause**: Client sent uncompressed body, server tried to decompress\r\n\r\n**Solution**:\r\n- Add `requestcompressed: 0` header to POST request\r\n- OR ensure client compresses request body\r\n\r\n### Issue 2: Response is Binary Garbage\r\n\r\n**Symptoms**: Response body shows binary data instead of JSON\r\n\r\n**Cause**: Response is ZLib-compressed\r\n\r\n**Solution**:\r\n- Add `responsecompressed: 0` header to request\r\n- OR decompress response on client side\r\n\r\n### Issue 3: PUT Request Fails\r\n\r\n**Symptoms**: PUT request always fails with decompression error\r\n\r\n**Cause**: PUT requests ALWAYS expect compressed body (cannot disable)\r\n\r\n**Solution**:\r\n- Always compress PUT request bodies\r\n- Use POST with `requestcompressed: 0` for debugging\r\n\r\n### Issue 4: JSON Deserialization Error\r\n\r\n**Symptoms**: Client can't deserialize response\r\n\r\n**Cause**: Response is compressed but client not decompressing\r\n\r\n**Solution**:\r\n- Ensure client decompresses response\r\n- Check if client is using `responsecompressed: 0` incorrectly\r\n\r\n---\r\n\r\n## Performance Considerations\r\n\r\n### Compression Ratio\r\n\r\n**Typical JSON compression**:\r\n```\r\nOriginal: 10 KB\r\nCompressed: 2-3 KB (70-80% reduction)\r\n```\r\n\r\n**Benefits**:\r\n- Reduced network bandwidth\r\n- Faster response times (less data to send)\r\n- Lower server egress costs\r\n\r\n**Costs**:\r\n- CPU overhead for compression/decompression\r\n- Minimal (~1-2ms per request)\r\n\r\n### When to Disable Compression\r\n\r\n**NEVER in production** - Compression is expected by the game client.\r\n\r\n**Only for debugging**:\r\n- Testing routes with curl/Postman\r\n- Inspecting request/response data\r\n- Troubleshooting serialization issues\r\n\r\n---\r\n\r\n## Summary\r\n\r\n### Key Takeaways\r\n\r\n1. **GET requests**: No compression needed (no body)\r\n2. **POST requests**: Body decompressed unless `requestcompressed: 0`\r\n3. **PUT requests**: Body ALWAYS decompressed (cannot disable)\r\n4. **Responses**: ZLib-compressed unless `responsecompressed: 0`\r\n5. **Special responses**: IMAGE/BUNDLE/NOTIFY use custom serializers\r\n\r\n### Testing Checklist\r\n\r\n- [ ] Use `responsecompressed: 0` for readable JSON in curl/Postman\r\n- [ ] Use `requestcompressed: 0` for POST with raw JSON body\r\n- [ ] Never use debug headers in production\r\n- [ ] Verify client decompresses responses correctly\r\n- [ ] Test PUT requests with compressed bodies\r\n\r\n### Compression Flow Diagram\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  CLIENT REQUEST                                           ‚îÇ\r\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ\r\n‚îÇ  ‚îÇ POST /route                                        ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ Content-Type: application/json                     ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ requestcompressed: 0 (optional)                    ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ Body: {\"key\": \"value\"}                             ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                          ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  SERVER: SptHttpListener.Handle()                        ‚îÇ\r\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ\r\n‚îÇ  ‚îÇ IF requestcompressed != \"0\"                        ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ   Decompress body with ZLib                        ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ ELSE                                               ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ   Read body as-is                                  ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ                                                     ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ Route to handler...                                ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ Get response string                                ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                          ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  SERVER: SptHttpListener.SendResponse()                  ‚îÇ\r\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ\r\n‚îÇ  ‚îÇ IF responsecompressed == \"0\"                       ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ   Send raw JSON                                    ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ ELSE IF IMAGE/BUNDLE/NOTIFY                        ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ   Use custom serializer                            ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ ELSE                                               ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ   Compress with ZLib and send                      ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                          ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  CLIENT RESPONSE                                          ‚îÇ\r\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ\r\n‚îÇ  ‚îÇ HTTP 200 OK                                        ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ Content-Type: application/json                     ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ Body: [ZLib compressed] or [Raw JSON]             ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n```\r\n\r\n---\r\n\r\n## Source Files Referenced\r\n\r\n- `SPTarkov.Server.Core/Servers/Http/SptHttpListener.cs:34-97` (Request handling)\r\n- `SPTarkov.Server.Core/Servers/Http/SptHttpListener.cs:107-139` (Response sending)\r\n- `SPTarkov.Server.Core/Servers/Http/SptHttpListener.cs:146-149` (Debug check)\r\n- `SPTarkov.Server.Core/Servers/Http/SptHttpListener.cs:189-211` (Send methods)\r\n\r\n**Status**: ‚úÖ Complete and accurate based on SPT v4.0.x source code\r\n"},"SPT-CONTROLLERS-REFERENCE":{"title":"SPT Controllers Complete API Reference\r","category":"General","content":"# SPT Controllers Complete API Reference\r\n\r\n**Source**: SPT v4.0.x C# Source Code\r\n**Status**: ‚úÖ SOURCE-VERIFIED\r\n**Location**: `SPTarkov.Server.Core/Controllers/`\r\n\r\n---\r\n\r\n## Overview\r\n\r\nSPT Server contains **31 Controllers** that handle game logic, player interactions, and system operations. This document provides complete API reference for all controllers.\r\n\r\n**Total Controllers**: 31\r\n**Largest**: RagfairController (1146 lines)\r\n**Most Dependencies**: RagfairController (18)\r\n\r\n---\r\n\r\n## Table of Contents\r\n\r\n- [Dialogue & Communication](#dialogue--communication)\r\n- [Economy & Trading](#economy--trading)\r\n- [Profile & Character](#profile--character)\r\n- [Quest System](#quest-system)\r\n- [Hideout Management](#hideout-management)\r\n- [Inventory Operations](#inventory-operations)\r\n- [Bot & Match](#bot--match)\r\n- [Specialized Controllers](#specialized-controllers)\r\n\r\n---\r\n\r\n## Dialogue & Communication\r\n\r\n### DialogueController\r\n\r\n**Purpose**: Manages in-game messaging, mail, trader dialogues, chatbots, and friend lists\r\n\r\n**Key Methods**:\r\n```csharp\r\nvoid RegisterChatBot(IDialogueChatBot chatBot)\r\n// Register custom chatbot\r\n\r\nGetFriendListDataResponse GetFriendList(MongoId sessionId)\r\n// Returns friends + chatbots (FILTERED by core.json enabledBots!)\r\n\r\nList<UserDialogInfo> GetActiveChatBots()\r\n// Returns ONLY enabled chatbots from config\r\n\r\nList<DialogueInfo> GenerateDialogueList(MongoId sessionId)\r\n// Get all mail conversations\r\n\r\nGetMailDialogViewResponseData GenerateDialogueView(GetMailDialogViewRequestData request, MongoId sessionId)\r\n// View messages in dialog\r\n\r\nValueTask<string> SendMessage(MongoId sessionId, SendMessageRequest request)\r\n// Send message to NPC/chatbot\r\n\r\nvoid SetRead(List<MongoId>? dialogueIds, MongoId sessionId)\r\n// Mark dialogs as read\r\n\r\nGetAllAttachmentsResponse? GetAllAttachments(string dialogueId, MongoId sessionId)\r\n// Get all unclaimed rewards from dialog\r\n```\r\n\r\n**Critical for FriendlyPMC**: Chatbots must be in `core.json` ‚Üí `enabledBots` ‚Üí `true` to appear!\r\n\r\n**File**: `Controllers/DialogueController.cs:65-131`\r\n\r\n---\r\n\r\n## Economy & Trading\r\n\r\n### RagfairController\r\n\r\n**Purpose**: Complete flea market system - search, buy, sell, pricing\r\n\r\n**Key Methods**:\r\n```csharp\r\nGetOffersResult GetOffers(MongoId sessionID, SearchRequestData searchRequest)\r\n// Search flea market (most complex method)\r\n\r\nItemEventRouterResponse AddPlayerOffer(PmcData pmcData, AddOfferRequestData offerRequest, MongoId sessionID)\r\n// List item on flea (3 types: SINGLE, MULTI, PACK)\r\n\r\nItemEventRouterResponse FlagOfferForRemoval(MongoId offerId, MongoId sessionId)\r\n// Remove offer early\r\n\r\nItemEventRouterResponse ExtendOffer(ExtendOfferRequestData extendRequest, MongoId sessionId)\r\n// Extend offer expiry\r\n\r\nGetItemPriceResult GetItemMinAvgMaxFleaPriceValues(GetMarketPriceRequestData getPriceRequest, bool ignoreTraderOffers = true)\r\n// Get min/avg/max flea prices\r\n\r\nDictionary<MongoId, double> GetAllFleaPrices()\r\n// Get all flea prices\r\n\r\nvoid Update()\r\n// Process offer sales/expirations (runs periodically)\r\n```\r\n\r\n**Offer Types**:\r\n- **SINGLE**: One item/stack\r\n- **MULTI**: Multiple items sold separately\r\n- **PACK**: Multiple items sold as bundle\r\n\r\n**File**: `Controllers/RagfairController.cs`\r\n\r\n---\r\n\r\n### TraderController\r\n\r\n**Purpose**: Trader lifecycle, assortments, loyalty, refresh\r\n\r\n**Key Methods**:\r\n```csharp\r\nvoid Load()\r\n// Initialize traders on server start\r\n\r\nbool Update()\r\n// Refresh expired traders (runs periodically)\r\n\r\nList<TraderBase> GetAllTraders(MongoId sessionId)\r\n// Get all trader metadata\r\n\r\nTraderBase? GetTrader(MongoId sessionId, MongoId traderId)\r\n// Get specific trader\r\n\r\nTraderAssort GetAssort(MongoId sessionId, MongoId traderId)\r\n// Get trader inventory\r\n\r\nGetItemPricesResponse GetItemPrices(MongoId sessionId, MongoId traderId)\r\n// Get trader item prices\r\n```\r\n\r\n**File**: `Controllers/TraderController.cs`\r\n\r\n---\r\n\r\n### TradeController\r\n\r\n**Purpose**: Execute trading operations\r\n\r\n**Key Methods**:\r\n```csharp\r\nItemEventRouterResponse ConfirmTrading(PmcData pmcData, ProcessBaseTradeRequestData request, MongoId sessionID)\r\n// Buy from or sell to trader\r\n\r\nItemEventRouterResponse ConfirmRagfairTrading(PmcData pmcData, ProcessRagfairTradeRequestData request, MongoId sessionID)\r\n// Buy from flea market\r\n\r\nItemEventRouterResponse SellScavItemsToFence(PmcData pmcData, SellScavItemsToFenceRequestData request, MongoId sessionId)\r\n// Quick-sell all scav items\r\n```\r\n\r\n**File**: `Controllers/TradeController.cs`\r\n\r\n---\r\n\r\n### PaymentController\r\n\r\n**(Integrated into PaymentService)**\r\n\r\n---\r\n\r\n## Profile & Character\r\n\r\n### ProfileController\r\n\r\n**Purpose**: Profile creation, viewing, editing, searching\r\n\r\n**Key Methods**:\r\n```csharp\r\nList<MiniProfile> GetMiniProfiles()\r\n// Get all profiles (launcher)\r\n\r\nValueTask<string> CreateProfile(ProfileCreateRequestData request, MongoId sessionId)\r\n// Create new PMC/Scav\r\n\r\nPmcData GeneratePlayerScav(MongoId sessionId)\r\n// Generate player scav\r\n\r\nNicknameValidationResult ValidateNickname(ValidateNicknameRequestData request, MongoId sessionId)\r\n// Check nickname availability\r\n\r\nNicknameValidationResult ChangeNickname(ProfileChangeNicknameRequestData request, MongoId sessionId)\r\n// Update nickname\r\n\r\nList<SearchFriendResponse> SearchProfiles(SearchProfilesRequestData request, MongoId sessionID)\r\n// Search for other profiles\r\n\r\nGetOtherProfileResponse GetOtherProfile(MongoId sessionId, GetOtherProfileRequest request)\r\n// View another player's profile\r\n```\r\n\r\n**File**: `Controllers/ProfileController.cs`\r\n\r\n---\r\n\r\n### CustomizationController\r\n\r\n**Purpose**: Character appearance/clothing\r\n\r\n**Key Methods**:\r\n```csharp\r\nList<Suit> GetTraderSuits(MongoId traderId, MongoId sessionId)\r\n// Get purchasable clothing\r\n\r\nItemEventRouterResponse BuyCustomisation(PmcData pmcData, BuyClothingRequestData buyClothingRequest, MongoId sessionId)\r\n// Purchase clothing\r\n\r\nItemEventRouterResponse SetCustomisation(MongoId sessionId, CustomizationSetRequest request, PmcData pmcData)\r\n// Apply clothing to character\r\n```\r\n\r\n**File**: `Controllers/CustomizationController.cs`\r\n\r\n---\r\n\r\n## Quest System\r\n\r\n### QuestController\r\n\r\n**Purpose**: Quest lifecycle management\r\n\r\n**Key Methods**:\r\n```csharp\r\nList<Quest> GetClientQuests(MongoId sessionId)\r\n// Get available quests\r\n\r\nItemEventRouterResponse AcceptQuest(PmcData pmcData, AcceptQuestRequestData acceptedQuest, MongoId sessionID)\r\n// Accept quest\r\n\r\nItemEventRouterResponse HandoverQuest(PmcData pmcData, HandoverQuestRequestData request, MongoId sessionID)\r\n// Hand over quest items\r\n\r\nItemEventRouterResponse CompleteQuest(PmcData pmcData, CompleteQuestRequestData request, MongoId sessionId)\r\n// Complete quest\r\n\r\nItemEventRouterResponse FailQuest(PmcData pmcData, FailQuestRequestData request, MongoId sessionID, ItemEventRouterResponse output)\r\n// Fail/abandon quest\r\n```\r\n\r\n**File**: `Controllers/QuestController.cs`\r\n\r\n---\r\n\r\n### RepeatableQuestController\r\n\r\n**Purpose**: Daily/weekly quest generation\r\n\r\n**Key Methods**:\r\n```csharp\r\nList<PmcDataRepeatableQuest> GetClientRepeatableQuests(MongoId sessionID)\r\n// Generate/refresh daily/weekly/scav quests\r\n\r\nItemEventRouterResponse AcceptRepeatableQuest(PmcData pmcData, AcceptQuestRequestData acceptedQuest, MongoId sessionID)\r\n// Accept daily/weekly quest\r\n\r\nItemEventRouterResponse ChangeRepeatableQuest(PmcData pmcData, RepeatableQuestChangeRequest changeRequest, MongoId sessionID)\r\n// Replace repeatable quest (costs money + standing)\r\n```\r\n\r\n**Quest Types**:\r\n- **Elimination**: Kill X enemies\r\n- **Completion**: Find and extract with item\r\n- **Exploration**: Visit location\r\n- **Pickup**: Pick up item in raid\r\n\r\n**File**: `Controllers/RepeatableQuestController.cs`\r\n\r\n---\r\n\r\n## Hideout Management\r\n\r\n### HideoutController\r\n\r\n**Purpose**: Hideout construction, crafting, resources\r\n\r\n**Key Methods (24 total)**:\r\n```csharp\r\nvoid StartUpgrade(PmcData pmcData, HideoutUpgradeRequestData request, MongoId sessionID, ItemEventRouterResponse output)\r\n// Begin area upgrade\r\n\r\nvoid UpgradeComplete(PmcData pmcData, HideoutUpgradeCompleteRequestData request, MongoId sessionID, ItemEventRouterResponse output)\r\n// Finish upgrade\r\n\r\nItemEventRouterResponse PutItemsInAreaSlots(PmcData pmcData, HideoutPutItemInRequestData addItemToHideoutRequest, MongoId sessionID)\r\n// Add fuel/bitcoins/items to area\r\n\r\nItemEventRouterResponse TakeItemsFromAreaSlots(PmcData pmcData, HideoutTakeItemOutRequestData request, MongoId sessionID)\r\n// Remove items from area\r\n\r\nItemEventRouterResponse ToggleArea(PmcData pmcData, HideoutToggleAreaRequestData request, MongoId sessionID)\r\n// Turn generator/areas on/off\r\n\r\nItemEventRouterResponse SingleProductionStart(PmcData pmcData, HideoutSingleProductionStartRequestData request, MongoId sessionID)\r\n// Start crafting\r\n\r\nItemEventRouterResponse TakeProduction(PmcData pmcData, HideoutTakeProductionRequestData request, MongoId sessionID)\r\n// Collect crafted items\r\n\r\nItemEventRouterResponse ScavCaseProductionStart(PmcData pmcData, HideoutScavCaseStartRequestData request, MongoId sessionID)\r\n// Start scav case\r\n\r\nvoid HandleQTEEventOutcome(MongoId sessionId, PmcData pmcData, HandleQTEEventRequestData request, ItemEventRouterResponse output)\r\n// Process gym workout\r\n\r\nvoid Update()\r\n// Update hideout crafts for all profiles (runs periodically)\r\n```\r\n\r\n**File**: `Controllers/HideoutController.cs`\r\n\r\n---\r\n\r\n## Inventory Operations\r\n\r\n### InventoryController\r\n\r\n**Purpose**: All inventory operations (25+ methods)\r\n\r\n**Key Methods**:\r\n```csharp\r\nvoid MoveItem(PmcData pmcData, InventoryMoveRequestData moveRequest, MongoId sessionId, ItemEventRouterResponse output)\r\n// Move item in inventory\r\n\r\nvoid MergeItem(PmcData pmcData, InventoryMergeRequestData request, MongoId sessionID, ItemEventRouterResponse output)\r\n// Merge two stacks\r\n\r\nvoid SplitItem(PmcData pmcData, InventorySplitRequestData request, MongoId sessionID, ItemEventRouterResponse output)\r\n// Split stack\r\n\r\nvoid SwapItem(PmcData pmcData, InventorySwapRequestData request, MongoId sessionId)\r\n// Swap two items\r\n\r\nvoid TransferItem(PmcData pmcData, InventoryTransferRequestData request, MongoId sessionId, ItemEventRouterResponse output)\r\n// Transfer from stack\r\n\r\nvoid DiscardItem(PmcData pmcData, InventoryRemoveRequestData request, MongoId sessionId, ItemEventRouterResponse output)\r\n// Delete item\r\n\r\nvoid ExamineItem(PmcData pmcData, InventoryExamineRequestData request, MongoId sessionId, ItemEventRouterResponse output)\r\n// Examine item (grants XP)\r\n\r\nItemEventRouterResponse FoldItem(PmcData pmcData, InventoryFoldRequestData request, MongoId sessionId)\r\n// Fold/unfold weapon\r\n\r\nItemEventRouterResponse ToggleItem(PmcData pmcData, InventoryToggleRequestData request, MongoId sessionId)\r\n// Toggle NVG/faceshield\r\n\r\nItemEventRouterResponse TagItem(PmcData pmcData, InventoryTagRequestData request, MongoId sessionId)\r\n// Add color tag\r\n\r\nItemEventRouterResponse OpenRandomLootContainer(PmcData pmcData, OpenRandomLootContainerRequestData request, MongoId sessionId, ItemEventRouterResponse output)\r\n// Open sealed container\r\n\r\nvoid SortInventory(PmcData pmcData, InventorySortRequestData request, MongoId sessionId, ItemEventRouterResponse output)\r\n// Auto-sort inventory\r\n```\r\n\r\n**File**: `Controllers/InventoryController.cs`\r\n\r\n---\r\n\r\n## Bot & Match\r\n\r\n### BotController\r\n\r\n**Purpose**: Bot generation and difficulty\r\n\r\n**Key Methods**:\r\n```csharp\r\nTask<IEnumerable<BotBase?>> Generate(MongoId sessionId, GenerateBotsRequestData request)\r\n// Generate bots for wave\r\n\r\nDifficultyCategories GetBotDifficulty(MongoId sessionId, string type, string diffLevel, bool ignoreRaidSettings = false)\r\n// Get bot difficulty settings\r\n\r\nDictionary<string, Dictionary<string, DifficultyCategories>> GetAllBotDifficulties()\r\n// Get all bot difficulties\r\n\r\nint GetBotCap(string location)\r\n// Get max bots for map\r\n\r\nAiBotBrainTypes GetAiBotBrainTypes()\r\n// Get brain type weights\r\n```\r\n\r\n**File**: `Controllers/BotController.cs`\r\n\r\n---\r\n\r\n### MatchController\r\n\r\n**Purpose**: Raid matching and configuration\r\n\r\n**Key Methods**:\r\n```csharp\r\nvoid ConfigureOfflineRaid(GetRaidConfigurationRequestData request, MongoId sessionId)\r\n// Configure raid settings (CRITICAL)\r\n\r\nStartLocalRaidResponseData StartLocalRaid(MongoId sessionId, StartLocalRaidRequestData request)\r\n// Start raid\r\n\r\nvoid EndLocalRaid(MongoId sessionId, EndLocalRaidRequestData request)\r\n// End raid\r\n\r\nProfileStatusResponse JoinMatch(MatchGroupJoinRequest request, MongoId sessionId)\r\n// Join match group\r\n```\r\n\r\n**File**: `Controllers/MatchController.cs`\r\n\r\n---\r\n\r\n## Specialized Controllers\r\n\r\n### InsuranceController\r\n\r\n**Key Methods**:\r\n```csharp\r\nItemEventRouterResponse Insure(PmcData pmcData, InsureRequestData request, MongoId sessionId)\r\n// Insure items\r\n\r\nGetInsuranceCostResponseData Cost(GetInsuranceCostRequestData request, MongoId sessionId)\r\n// Calculate insurance cost\r\n\r\nvoid ProcessReturn()\r\n// Process all insurance returns (periodic)\r\n```\r\n\r\n**File**: `Controllers/InsuranceController.cs:37-857`\r\n\r\n---\r\n\r\n### HealthController\r\n\r\n**Key Methods**:\r\n```csharp\r\nItemEventRouterResponse OffRaidHeal(PmcData pmcData, OffraidHealRequestData request, MongoId sessionID)\r\n// Heal with medkit\r\n\r\nItemEventRouterResponse OffRaidEat(PmcData pmcData, OffraidEatRequestData request, MongoId sessionID)\r\n// Consume food/drink\r\n\r\nItemEventRouterResponse HealthTreatment(PmcData pmcData, HealthTreatmentRequestData healthTreatmentRequest, MongoId sessionID)\r\n// Post-raid therapist healing\r\n```\r\n\r\n**File**: `Controllers/HealthController.cs`\r\n\r\n---\r\n\r\n### RepairController\r\n\r\n**Key Methods**:\r\n```csharp\r\nItemEventRouterResponse TraderRepair(MongoId sessionID, TraderRepairActionDataRequest request, PmcData pmcData)\r\n// Repair with trader\r\n\r\nItemEventRouterResponse RepairWithKit(MongoId sessionId, RepairActionDataRequest body, PmcData pmcData)\r\n// Repair with repair kit\r\n```\r\n\r\n**File**: `Controllers/RepairController.cs`\r\n\r\n---\r\n\r\n### WeatherController\r\n\r\n**Key Methods**:\r\n```csharp\r\nWeatherData Generate()\r\n// Generate menu weather\r\n\r\nGetLocalWeatherResponseData GenerateLocal(MongoId sessionId)\r\n// Generate raid weather\r\n```\r\n\r\n**File**: `Controllers/WeatherController.cs`\r\n\r\n---\r\n\r\n### GameController\r\n\r\n**Key Methods**:\r\n```csharp\r\nvoid GameStart(string url, MongoId sessionId, long startTimeStampMs)\r\n// Handle game start (CRITICAL)\r\n\r\nGameConfigResponse GetGameConfig(MongoId sessionId)\r\n// Get game configuration\r\n\r\nRaidChanges GetRaidTime(MongoId sessionId, GetRaidTimeRequest request)\r\n// Get raid time configuration\r\n\r\nGameKeepAliveResponse GetKeepAlive(MongoId sessionId)\r\n// Keepalive ping\r\n```\r\n\r\n**File**: `Controllers/GameController.cs`\r\n\r\n---\r\n\r\n### LocationController\r\n\r\n**Key Methods**:\r\n```csharp\r\nLocationsGenerateAllResponse GenerateAll(MongoId sessionId)\r\n// Get all map metadata\r\n\r\nGetAirdropLootResponse GetAirDropLoot(GetAirdropLootRequest? request)\r\n// Get airdrop loot\r\n```\r\n\r\n**File**: `Controllers/LocationController.cs`\r\n\r\n---\r\n\r\n### InRaidController\r\n\r\n**Key Methods**:\r\n```csharp\r\nvoid SavePostRaidProfileForScav(ScavSaveRequestData offRaidProfileData, MongoId sessionId)\r\n// Save scav profile after raid\r\n\r\nInRaidConfig GetInRaidConfig()\r\n// Get inraid config\r\n\r\ndouble GetTraitorScavHostileChance(string url, MongoId sessionId)\r\n// Get traitor scav chance\r\n```\r\n\r\n**File**: `Controllers/InRaidController.cs`\r\n\r\n---\r\n\r\n## Additional Controllers\r\n\r\n### BuildController\r\n**Purpose**: Weapon/equipment presets\r\n\r\n### NoteController\r\n**Purpose**: Player notes\r\n\r\n### WishlistController\r\n**Purpose**: Wishlist management\r\n\r\n### AchievementController\r\n**Purpose**: Achievements and statistics\r\n\r\n### NotifierController\r\n**Purpose**: Long-polling notifications\r\n\r\n### LauncherController\r\n**Purpose**: Launcher operations (login, register, wipe)\r\n\r\n### ClientLogController\r\n**Purpose**: Receive client logs\r\n\r\n### PrestigeController\r\n**Purpose**: Prestige system\r\n\r\n### PresetController\r\n**Purpose**: Initialize preset cache\r\n\r\n---\r\n\r\n## Usage Patterns\r\n\r\n### Accessing Controllers\r\n\r\n```csharp\r\n[Injectable]\r\npublic class MyService(\r\n    DialogueController dialogueController,\r\n    QuestController questController,\r\n    TraderController traderController\r\n)\r\n{\r\n    public void DoSomething(MongoId sessionId)\r\n    {\r\n        var quests = questController.GetClientQuests(sessionId);\r\n        var friends = dialogueController.GetFriendList(sessionId);\r\n        // Use controller methods\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### From Routes\r\n\r\n```csharp\r\n[Injectable]\r\npublic class MyRouter(\r\n    JsonUtil jsonUtil,\r\n    ProfileController profileController\r\n) : StaticRouter(jsonUtil,\r\n[\r\n    new RouteAction<EmptyRequestData>(\r\n        \"/mymod/profile\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            var profile = profileController.GetCompleteProfile(sessionId);\r\n            return jsonUtil.Serialize(new { nickname = profile.First().Info.Nickname });\r\n        }\r\n    )\r\n])\r\n{ }\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\n**31 Controllers** managing all game systems:\r\n- **Economy**: Ragfair, Trader, Trade, Payment, Insurance, Repair\r\n- **Profile**: Profile, Customization, Prestige\r\n- **Quest**: Quest, RepeatableQuest\r\n- **Hideout**: Hideout\r\n- **Inventory**: Inventory, Health\r\n- **Communication**: Dialogue, Notifier\r\n- **Match**: Match, InRaid, Bot, Location, Weather\r\n- **Meta**: Game, Launcher, ClientLog\r\n- **Specialized**: Build, Note, Wishlist, Achievement, Preset\r\n\r\n**All controllers** use dependency injection and follow consistent patterns for error handling, logging, and data manipulation.\r\n\r\n---\r\n\r\n**File Count**: 31 controllers\r\n**Total Lines**: ~15,000+ lines of game logic\r\n**Location**: `SPTarkov.Server.Core/Controllers/`\r\n"},"SPT-DATABASE-ACCESS":{"title":"SPT Database Access - Complete Guide\r","category":"General","content":"# SPT Database Access - Complete Guide\r\n\r\n**Source**: SPT v4.0.x C# Source Code\r\n**Status**: ‚úÖ SOURCE-VERIFIED\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [Overview](#overview)\r\n2. [DatabaseService API](#databaseservice-api)\r\n3. [Database Table Structure](#database-table-structure)\r\n4. [Common Access Patterns](#common-access-patterns)\r\n5. [Modification Patterns](#modification-patterns)\r\n6. [Lazy-Loaded Locales](#lazy-loaded-locales)\r\n7. [Helper Services](#helper-services)\r\n8. [Best Practices](#best-practices)\r\n\r\n---\r\n\r\n## Overview\r\n\r\nSPT 4.x uses an **in-memory database** with strongly-typed C# models. All game data is loaded from JSON files at startup into `DatabaseServer`, accessible via `DatabaseService`.\r\n\r\n### Key Characteristics\r\n\r\n- **In-memory**: All data loaded at startup from `SPT_Data/database/`\r\n- **Strongly-typed**: C# records/classes, not dynamic JSON\r\n- **Modification**: Changes affect running instance only\r\n- **Persistence**: Profile changes saved via SaveServer, database changes are runtime-only\r\n\r\n---\r\n\r\n## DatabaseService API\r\n\r\n**Location**: `SPTarkov.Server.Core/Services/DatabaseService.cs:19`\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class DatabaseService(\r\n    ISptLogger<DatabaseService> logger,\r\n    DatabaseServer databaseServer,\r\n    ServerLocalisationService serverLocalisationService\r\n)\r\n```\r\n\r\n### Complete Method Reference\r\n\r\n| Method | Returns | Description |\r\n|--------|---------|-------------|\r\n| `GetTables()` | `DatabaseTables` | Root database object |\r\n| `GetBots()` | `Bots` | Bot loadouts and configuration |\r\n| `GetGlobals()` | `Globals` | Global game settings |\r\n| `GetHideout()` | `Hideout` | Hideout data |\r\n| `GetLocales()` | `LocaleBase` | All localizations |\r\n| `GetLocations()` | `Locations` | All maps |\r\n| `GetLocation(string id)` | `Location?` | Specific map by ID |\r\n| `GetMatch()` | `Match` | Match settings |\r\n| `GetServer()` | `ServerBase` | Server configuration |\r\n| `GetSettings()` | `SettingsBase` | Game settings |\r\n| `GetTemplates()` | `Templates` | All templates |\r\n| `GetAchievements()` | `List<Achievement>` | Achievements |\r\n| `GetCustomAchievements()` | `List<Achievement>` | Custom achievements |\r\n| `GetCustomization()` | `Dictionary<MongoId, CustomizationItem>` | Clothing |\r\n| `GetHandbook()` | `HandbookBase` | Handbook data |\r\n| `GetItems()` | `Dictionary<MongoId, TemplateItem>` | All items |\r\n| `GetPrices()` | `Dictionary<MongoId, double>` | Flea prices |\r\n| `GetProfileTemplates()` | `Dictionary<string, ProfileSides>` | Profile templates |\r\n| `GetQuests()` | `Dictionary<MongoId, Quest>` | All quests |\r\n| `GetTraders()` | `Dictionary<MongoId, Trader>` | All traders |\r\n| `GetTrader(MongoId id)` | `Trader?` | Specific trader |\r\n\r\n---\r\n\r\n## Database Table Structure\r\n\r\n### DatabaseTables (Root)\r\n\r\n**Location**: `SPTarkov.Server.Core/Models/Spt/Server/DatabaseTables.cs`\r\n\r\n```csharp\r\npublic record DatabaseTables\r\n{\r\n    public required Bots.Bots Bots { get; init; }\r\n    public required Hideout.Hideout Hideout { get; init; }\r\n    public required LocaleBase Locales { get; init; }\r\n    public required Locations Locations { get; init; }\r\n    public required Match Match { get; init; }\r\n    public required Templates.Templates Templates { get; init; }\r\n    public required Dictionary<MongoId, Trader> Traders { get; init; }\r\n    public required Globals Globals { get; init; }\r\n    public required ServerBase Server { get; init; }\r\n    public required SettingsBase Settings { get; init; }\r\n}\r\n```\r\n\r\n### Templates Structure\r\n\r\n```csharp\r\npublic record Templates\r\n{\r\n    public required Dictionary<MongoId, TemplateItem> Items { get; init; }\r\n    public required Dictionary<MongoId, Quest> Quests { get; init; }\r\n    public required Dictionary<MongoId, CustomizationItem> Customization { get; init; }\r\n    public required Dictionary<string, ProfileSides> Profiles { get; init; }\r\n    public required Dictionary<MongoId, double> Prices { get; init; }\r\n    public required HandbookBase Handbook { get; init; }\r\n    public required List<Achievement> Achievements { get; init; }\r\n    public required List<Achievement> CustomAchievements { get; init; }\r\n    public required List<DefaultEquipmentPreset> DefaultEquipmentPresets { get; init; }\r\n    public required RepeatableQuestDatabase RepeatableQuests { get; init; }\r\n    public required TraderDialogs Dialogue { get; init; }\r\n    public required LocationServices LocationServices { get; init; }\r\n    public required List<CustomisationStorage> CustomisationStorage { get; init; }\r\n    public required List<string> Character { get; init; }\r\n    public required Prestige Prestige { get; init; }\r\n}\r\n```\r\n\r\n### Locations Structure\r\n\r\n```csharp\r\npublic record Locations\r\n{\r\n    public required Location Bigmap { get; init; }          // Customs\r\n    public required Location Factory4Day { get; init; }\r\n    public required Location Factory4Night { get; init; }\r\n    public required Location Interchange { get; init; }\r\n    public required Location Laboratory { get; init; }     // Labs\r\n    public required Location Lighthouse { get; init; }\r\n    public required Location RezervBase { get; init; }     // Reserve\r\n    public required Location Shoreline { get; init; }\r\n    public required Location TarkovStreets { get; init; }  // Streets\r\n    public required Location Woods { get; init; }\r\n    public required Location Sandbox { get; init; }        // Ground Zero\r\n    public required Location SandboxHigh { get; init; }    // GZ high gear\r\n    public required Location Labyrinth { get; init; }      // Arena\r\n    public required LocationsBase Base { get; init; }\r\n\r\n    // Helper methods\r\n    public Dictionary<string, Location> GetDictionary();\r\n    public string GetMappedKey(string key);\r\n}\r\n```\r\n\r\n**Map ID mappings**:\r\n- `\"factory4_day\"` ‚Üí `Factory4Day`\r\n- `\"bigmap\"` ‚Üí `Bigmap` (Customs)\r\n- `\"rezervbase\"` ‚Üí `RezervBase`\r\n- `\"tarkovstreets\"` ‚Üí `TarkovStreets`\r\n\r\n---\r\n\r\n## Common Access Patterns\r\n\r\n### Pattern 1: Get All Items\r\n\r\n```csharp\r\npublic void ModifyItems(DatabaseService databaseService)\r\n{\r\n    var items = databaseService.GetItems();\r\n\r\n    foreach (var (itemId, item) in items)\r\n    {\r\n        // Access item properties\r\n        var name = item.Name;\r\n        var weight = item.Properties.Weight;\r\n        var parent = item.Parent;\r\n\r\n        // Modify if needed\r\n        if (item.Name.Contains(\"AK\"))\r\n        {\r\n            item.Properties.Weight *= 0.9;  // Reduce weight by 10%\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Pattern 2: Get Specific Item\r\n\r\n```csharp\r\npublic void ModifySpecificItem(DatabaseService databaseService)\r\n{\r\n    var items = databaseService.GetItems();\r\n\r\n    // Try to get item by ID\r\n    if (items.TryGetValue(new MongoId(\"5447a9cd4bdc2dbd208b4567\"), out var item))\r\n    {\r\n        // Item found\r\n        item.Properties.Ergonomics += 10;\r\n    }\r\n}\r\n```\r\n\r\n### Pattern 3: Get Traders\r\n\r\n```csharp\r\npublic void ModifyTraders(DatabaseService databaseService)\r\n{\r\n    var traders = databaseService.GetTraders();\r\n\r\n    foreach (var (traderId, trader) in traders)\r\n    {\r\n        // Access trader properties\r\n        var nickname = trader.Base.Nickname;\r\n        var assort = trader.Assort;\r\n        var questassort = trader.Questassort;\r\n    }\r\n}\r\n```\r\n\r\n### Pattern 4: Get Specific Trader\r\n\r\n```csharp\r\npublic void ModifyPrapor(DatabaseService databaseService)\r\n{\r\n    // Trader IDs (from source code analysis)\r\n    var praporId = new MongoId(\"54cb50c76803fa8b248b4571\");\r\n\r\n    var prapor = databaseService.GetTrader(praporId);\r\n    if (prapor != null)\r\n    {\r\n        // Modify Prapor's data\r\n        prapor.Base.Nickname = \"Modified Prapor\";\r\n    }\r\n}\r\n```\r\n\r\n### Pattern 5: Get Locations\r\n\r\n```csharp\r\npublic void ModifyMaps(DatabaseService databaseService)\r\n{\r\n    var locations = databaseService.GetLocations();\r\n\r\n    // Access specific maps\r\n    var customs = locations.Bigmap;\r\n    var factory = locations.Factory4Day;\r\n    var interchange = locations.Interchange;\r\n\r\n    // Modify loot containers\r\n    customs.Loot.StaticContainers.Add(/* ... */);\r\n\r\n    // Or use dictionary\r\n    var locationsDict = locations.GetDictionary();\r\n    var woods = locationsDict[\"woods\"];\r\n}\r\n```\r\n\r\n---\r\n\r\n## Modification Patterns\r\n\r\n### Pattern 1: Add Custom Item (Using CustomItemService)\r\n\r\n**Location**: `SPTarkov.Server.Core/Services/Mod/CustomItemService.cs`\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MyItemMod(\r\n    ISptLogger<MyItemMod> logger,\r\n    DatabaseService databaseService,\r\n    CustomItemService customItemService,\r\n    ItemBaseClassService itemBaseClassService\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        logger.Info(\"Adding custom item...\");\r\n\r\n        var newItemDetails = new NewItemFromCloneDetails\r\n        {\r\n            NewId = \"my_custom_ak74m\",\r\n            ItemTplToClone = new MongoId(\"5ac66d9b5acfc4001633997a\"), // AK-74M\r\n            ParentId = new MongoId(\"5447b5f14bdc2d61278b4567\"),        // Assault rifles\r\n            HandbookParentId = \"5b5f78dc86f77409407a7f8e\",\r\n            HandbookPriceRoubles = 50000,\r\n            FleaPriceRoubles = 55000,\r\n\r\n            Locales = new Dictionary<string, LocaleDetails>\r\n            {\r\n                [\"en\"] = new LocaleDetails\r\n                {\r\n                    Name = \"Custom AK-74M\",\r\n                    ShortName = \"AK-74M+\",\r\n                    Description = \"Modified AK with better stats\"\r\n                }\r\n            },\r\n\r\n            OverrideProperties = new TemplateItemProperties\r\n            {\r\n                RecoilForceUp = 90,\r\n                RecoilForceBack = 250,\r\n                Ergonomics = 55\r\n            }\r\n        };\r\n\r\n        var result = customItemService.CreateItemFromClone(newItemDetails);\r\n\r\n        if (result.Success)\r\n        {\r\n            logger.Success($\"Created item: {result.ItemId}\");\r\n        }\r\n        else\r\n        {\r\n            logger.Error($\"Failed: {string.Join(\", \", result.Errors)}\");\r\n        }\r\n\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n**Source**: `CustomItemService.cs:36-82`\r\n\r\n### Pattern 2: Modify Existing Item\r\n\r\n```csharp\r\npublic void ModifyWeaponRecoil(DatabaseService databaseService)\r\n{\r\n    var items = databaseService.GetItems();\r\n\r\n    // AK-74M\r\n    if (items.TryGetValue(new MongoId(\"5ac66d9b5acfc4001633997a\"), out var ak74m))\r\n    {\r\n        ak74m.Properties.RecoilForceUp = 100;\r\n        ak74m.Properties.RecoilForceBack = 300;\r\n        ak74m.Properties.Ergonomics = 50;\r\n    }\r\n}\r\n```\r\n\r\n### Pattern 3: Add Item to Trader\r\n\r\n```csharp\r\npublic void AddItemToTrader(DatabaseService databaseService, MongoId itemId)\r\n{\r\n    var praporId = new MongoId(\"54cb50c76803fa8b248b4571\");\r\n    var prapor = databaseService.GetTrader(praporId);\r\n\r\n    if (prapor == null) return;\r\n\r\n    // Add item to assortment\r\n    prapor.Assort.Items.Add(new Item\r\n    {\r\n        Id = new MongoId(),  // Generate unique ID\r\n        Template = itemId,\r\n        ParentId = new MongoId(\"hideout\"),\r\n        SlotId = \"hideout\",\r\n        Upd = new Upd\r\n        {\r\n            StackObjectsCount = 1,\r\n            UnlimitedCount = true\r\n        }\r\n    });\r\n\r\n    // Set price (50k roubles)\r\n    prapor.Assort.BarterScheme[itemId.Value] = new List<List<BarterRequirement>>\r\n    {\r\n        new List<BarterRequirement>\r\n        {\r\n            new BarterRequirement\r\n            {\r\n                Tpl = new MongoId(\"5449016a4bdc2d6f028b456f\"),  // Roubles\r\n                Count = 50000\r\n            }\r\n        }\r\n    };\r\n\r\n    // Set loyalty level\r\n    prapor.Assort.LoyaltyLevelItems[itemId.Value] = 2;  // LL2\r\n}\r\n```\r\n\r\n### Pattern 4: Modify Bot Loadouts\r\n\r\n**Source**: `CustomItemService.cs:317-346`\r\n\r\n```csharp\r\npublic void AddWeaponToBots(\r\n    DatabaseService databaseService,\r\n    ItemHelper itemHelper,\r\n    string weaponTpl,\r\n    double weaponWeight)\r\n{\r\n    var weapon = itemHelper.GetItem(weaponTpl);\r\n    if (!weapon.Key) return;  // Item not found\r\n\r\n    // Create mod slots for weapon\r\n    var weaponModSlots = new Dictionary<string, HashSet<MongoId>?>();\r\n    foreach (var slot in weapon.Value.Properties.Slots)\r\n    {\r\n        weaponModSlots[slot.Name] = [.. slot.Properties.Filters.First().Filter];\r\n    }\r\n\r\n    // Get PMC bots\r\n    var botTypes = databaseService.GetBots().Types;\r\n\r\n    // Add to USEC and BEAR\r\n    foreach (var pmcType in new[] { \"usec\", \"bear\" })\r\n    {\r\n        if (botTypes.TryGetValue(pmcType, out var bot))\r\n        {\r\n            // Register weapon mods\r\n            bot.BotInventory.Mods[weaponTpl] = weaponModSlots;\r\n\r\n            // Add weapon to equipment pool with weight\r\n            bot.BotInventory.Equipment[EquipmentSlots.FirstPrimaryWeapon][weaponTpl] = weaponWeight;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Pattern 5: Modify Global Configuration\r\n\r\n```csharp\r\npublic void ReduceScavCooldown(DatabaseService databaseService)\r\n{\r\n    var globals = databaseService.GetGlobals();\r\n\r\n    // Reduce scav cooldown to 1 second\r\n    globals.Configuration.SavagePlayCooldown = 1;\r\n\r\n    // Modify other global settings\r\n    globals.Configuration.TimeBeforeDeploy = 1;\r\n    globals.Configuration.TimeBeforeDeployLocal = 1;\r\n}\r\n```\r\n\r\n**Source**: `EditDatabaseValues.cs:29-32`\r\n\r\n---\r\n\r\n## Lazy-Loaded Locales\r\n\r\n### The LazyLoad Pattern\r\n\r\n**CRITICAL**: Locales use `LazyLoad<Dictionary<string, string>>` and MUST be modified using transformers.\r\n\r\n```csharp\r\n// ‚ùå WRONG - Direct assignment doesn't work!\r\nvar locales = databaseService.GetLocales();\r\nlocales.Global[\"en\"].Value[\"item_name\"] = \"New Name\";  // Doesn't persist!\r\n\r\n// ‚úÖ CORRECT - Use AddTransformer\r\nlocales.Global[\"en\"].AddTransformer(localeData =>\r\n{\r\n    if (localeData == null) return null;\r\n\r\n    localeData[\"item_name Name\"] = \"New Name\";\r\n    localeData[\"item_name ShortName\"] = \"Name\";\r\n    localeData[\"item_name Description\"] = \"Description\";\r\n\r\n    return localeData;\r\n});\r\n```\r\n\r\n**Source**: `CustomItemService.cs:241-276`\r\n\r\n### Add Locales for Custom Item\r\n\r\n```csharp\r\npublic void AddItemLocales(\r\n    DatabaseService databaseService,\r\n    string itemId,\r\n    Dictionary<string, LocaleDetails> locales)\r\n{\r\n    var defaultLocale = locales.Keys.FirstOrDefault();\r\n    if (defaultLocale == null) return;\r\n\r\n    var languages = databaseService.GetLocales().Languages;\r\n\r\n    foreach (var (languageKey, _) in languages)\r\n    {\r\n        // Get locale or fall back to default\r\n        if (!locales.TryGetValue(languageKey, out var localeDetails))\r\n        {\r\n            localeDetails = locales[defaultLocale];\r\n        }\r\n\r\n        // Add transformer to lazy-loaded locale\r\n        if (databaseService.GetLocales().Global.TryGetValue(languageKey, out var lazyLoad))\r\n        {\r\n            lazyLoad.AddTransformer(localeData =>\r\n            {\r\n                if (localeData == null) return null;\r\n\r\n                localeData[$\"{itemId} Name\"] = localeDetails.Name;\r\n                localeData[$\"{itemId} ShortName\"] = localeDetails.ShortName ?? \"\";\r\n                localeData[$\"{itemId} Description\"] = localeDetails.Description ?? \"\";\r\n\r\n                return localeData;\r\n            });\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Helper Services\r\n\r\n### ItemHelper\r\n\r\n**Common operations**:\r\n```csharp\r\n[Injectable]\r\npublic class MyService(ItemHelper itemHelper)\r\n{\r\n    public void Example(string itemId)\r\n    {\r\n        // Get item (returns KeyValuePair<bool, TemplateItem>)\r\n        var result = itemHelper.GetItem(itemId);\r\n        if (result.Key)  // Success\r\n        {\r\n            var item = result.Value;\r\n            // Use item...\r\n        }\r\n\r\n        // Check if item is specific type\r\n        if (itemHelper.IsOfBaseclass(itemId, BaseClasses.WEAPON))\r\n        {\r\n            // It's a weapon\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### ItemBaseClassService\r\n\r\n**Purpose**: Check item inheritance hierarchy\r\n\r\n```csharp\r\n[Injectable]\r\npublic class MyService(ItemBaseClassService itemBaseClassService)\r\n{\r\n    public void Example(MongoId itemId)\r\n    {\r\n        // Check single base class\r\n        if (itemBaseClassService.ItemHasBaseClass(itemId, BaseClasses.WEAPON))\r\n        {\r\n            // Item is or inherits from weapon\r\n        }\r\n\r\n        // Check multiple base classes\r\n        var armorClasses = new[] { BaseClasses.ARMOR, BaseClasses.VEST };\r\n        if (itemBaseClassService.ItemHasBaseClass(itemId, armorClasses))\r\n        {\r\n            // Item is armor or vest\r\n        }\r\n\r\n        // Get all base classes for item\r\n        var baseClasses = itemBaseClassService.GetItemBaseClasses(itemId);\r\n    }\r\n}\r\n```\r\n\r\n**IMPORTANT**: After adding items or modifying inheritance, refresh cache:\r\n```csharp\r\nitemBaseClassService.HydrateItemBaseClassCache();\r\n```\r\n\r\n### TraderHelper\r\n\r\n**Common trader operations**:\r\n```csharp\r\n[Injectable]\r\npublic class MyService(TraderHelper traderHelper)\r\n{\r\n    public void Example()\r\n    {\r\n        // Get trader by nickname (case-insensitive)\r\n        var prapor = traderHelper.GetTraderByNickName(\"prapor\");\r\n\r\n        // Get trader by ID\r\n        var trader = traderHelper.GetTrader(traderId);\r\n\r\n        // Get trader assortment\r\n        var assort = traderHelper.GetTraderAssortsByTraderId(traderId);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Best Practices\r\n\r\n### ‚úÖ DO\r\n\r\n**1. Inject DatabaseService**\r\n```csharp\r\n[Injectable]\r\npublic class MyMod(DatabaseService databaseService) { }\r\n```\r\n\r\n**2. Use After Database Loads**\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MyMod : IOnLoad { }\r\n```\r\n\r\n**3. Use LazyLoad Transformers for Locales**\r\n```csharp\r\nlocales.Global[\"en\"].AddTransformer(data => {\r\n    data[\"key\"] = \"value\";\r\n    return data;\r\n});\r\n```\r\n\r\n**4. Check for Null**\r\n```csharp\r\nvar trader = databaseService.GetTrader(traderId);\r\nif (trader != null)\r\n{\r\n    // Modify trader\r\n}\r\n```\r\n\r\n**5. Use Helper Services**\r\n```csharp\r\n// Use ItemHelper instead of direct dictionary access\r\nvar result = itemHelper.GetItem(itemId);\r\nif (result.Key) { /* ... */ }\r\n```\r\n\r\n---\r\n\r\n### ‚ùå DON'T\r\n\r\n**1. Access Database Before It Loads**\r\n```csharp\r\n// ‚ùå WRONG - Database not loaded yet\r\n[Injectable(TypePriority = OnLoadOrder.Database)]\r\npublic class TooEarly(DatabaseService db) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var items = db.GetItems(); // CRASH!\r\n    }\r\n}\r\n```\r\n\r\n**2. Directly Assign Lazy-Loaded Locales**\r\n```csharp\r\n// ‚ùå WRONG - Won't persist\r\nlocales.Global[\"en\"].Value[\"key\"] = \"value\";\r\n\r\n// ‚úÖ CORRECT - Use transformer\r\nlocales.Global[\"en\"].AddTransformer(data => {\r\n    data[\"key\"] = \"value\";\r\n    return data;\r\n});\r\n```\r\n\r\n**3. Modify Database in Constructor**\r\n```csharp\r\n// ‚ùå WRONG - Database might not be loaded\r\npublic MyClass(DatabaseService db)\r\n{\r\n    var items = db.GetItems();  // Might fail!\r\n}\r\n\r\n// ‚úÖ CORRECT - Use IOnLoad\r\npublic MyClass(DatabaseService db) { }  // Store reference only\r\n\r\npublic Task OnLoad()\r\n{\r\n    var items = db.GetItems();  // Safe in OnLoad\r\n}\r\n```\r\n\r\n**4. Forget to Refresh Caches**\r\n```csharp\r\n// After adding items\r\nitems.Add(newItemId, newItem);\r\n\r\n// ‚ùå WRONG - Cache is stale\r\n// ItemBaseClassService still has old data\r\n\r\n// ‚úÖ CORRECT - Refresh cache\r\nitemBaseClassService.HydrateItemBaseClassCache();\r\n```\r\n\r\n---\r\n\r\n## Complete Examples\r\n\r\n### Example 1: Reduce All Weapon Weight\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class WeaponWeightMod(\r\n    ISptLogger<WeaponWeightMod> logger,\r\n    DatabaseService databaseService,\r\n    ItemBaseClassService itemBaseClassService\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var items = databaseService.GetItems();\r\n        int modifiedCount = 0;\r\n\r\n        foreach (var (itemId, item) in items)\r\n        {\r\n            if (itemBaseClassService.ItemHasBaseClass(itemId, BaseClasses.WEAPON))\r\n            {\r\n                var oldWeight = item.Properties.Weight;\r\n                item.Properties.Weight *= 0.75;  // 25% lighter\r\n                modifiedCount++;\r\n\r\n                logger.Debug($\"{item.Name}: {oldWeight}kg ‚Üí {item.Properties.Weight}kg\");\r\n            }\r\n        }\r\n\r\n        logger.Success($\"Modified {modifiedCount} weapons\");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n### Example 2: Add Items to All Traders\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostSptModLoader + 1)]\r\npublic class TraderItemMod(\r\n    ISptLogger<TraderItemMod> logger,\r\n    DatabaseService databaseService\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var itemToAdd = new MongoId(\"5c0530ee86f774697952d952\");  // LEDX\r\n        var traders = databaseService.GetTraders();\r\n\r\n        foreach (var (traderId, trader) in traders)\r\n        {\r\n            if (trader.Base.Nickname == \"fence\") continue;  // Skip Fence\r\n\r\n            // Add LEDX to trader\r\n            trader.Assort.Items.Add(new Item\r\n            {\r\n                Id = new MongoId(),\r\n                Template = itemToAdd,\r\n                ParentId = new MongoId(\"hideout\"),\r\n                SlotId = \"hideout\",\r\n                Upd = new Upd { StackObjectsCount = 1, UnlimitedCount = false }\r\n            });\r\n\r\n            // Set price\r\n            trader.Assort.BarterScheme[itemToAdd.Value] = new List<List<BarterRequirement>>\r\n            {\r\n                new List<BarterRequirement>\r\n                {\r\n                    new BarterRequirement { Tpl = new MongoId(\"5449016a4bdc2d6f028b456f\"), Count = 1000000 }\r\n                }\r\n            };\r\n\r\n            trader.Assort.LoyaltyLevelItems[itemToAdd.Value] = 4;  // LL4\r\n\r\n            logger.Info($\"Added LEDX to {trader.Base.Nickname} LL4 for 1M roubles\");\r\n        }\r\n\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## MongoId Type\r\n\r\nAll IDs in SPT database use `MongoId` type:\r\n\r\n```csharp\r\n// Create new ID\r\nvar newId = new MongoId();\r\n\r\n// From string\r\nvar itemId = new MongoId(\"5447a9cd4bdc2dbd208b4567\");\r\n\r\n// Parse with validation\r\nif (MongoId.TryParse(someString, out var parsedId))\r\n{\r\n    // Valid MongoId\r\n}\r\n\r\n// Check if valid\r\nif (MongoId.IsValidMongoId(someString))\r\n{\r\n    var id = new MongoId(someString);\r\n}\r\n\r\n// Check if empty\r\nif (id.IsEmpty)\r\n{\r\n    // Empty ID\r\n}\r\n\r\n// Use as dictionary key\r\nDictionary<MongoId, TemplateItem> items = databaseService.GetItems();\r\nvar item = items[itemId];\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\nSPT database access is:\r\n- **Centralized** through `DatabaseService`\r\n- **Strongly-typed** using C# models\r\n- **In-memory** for fast access\r\n- **Modification-friendly** for runtime changes\r\n- **Lazy-loaded** for locales (use transformers!)\r\n\r\n**Key Points**:\r\n1. Inject `DatabaseService` for database access\r\n2. Use `TypePriority = OnLoadOrder.PostDBModLoader + 1` minimum\r\n3. Use `AddTransformer()` for locale modifications\r\n4. Refresh caches after structural changes\r\n5. Use helper services for complex operations\r\n\r\n---\r\n\r\n**Key Files**:\r\n- `SPTarkov.Server.Core/Services/DatabaseService.cs`\r\n- `SPTarkov.Server.Core/Servers/DatabaseServer.cs`\r\n- `SPTarkov.Server.Core/Models/Spt/Server/DatabaseTables.cs`\r\n- `SPTarkov.Server.Core/Services/Mod/CustomItemService.cs`\r\n"},"SPT-DEPENDENCY-INJECTION":{"title":"SPT Dependency Injection System - Complete Guide\r","category":"General","content":"# SPT Dependency Injection System - Complete Guide\r\n\r\n**Source**: SPT v4.0.x C# Source Code (`E:\\AppDev\\LTsTarkovAI\\SPTtmp\\server-csharp`)\r\n**Status**: ‚úÖ SOURCE-VERIFIED\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [Overview](#overview)\r\n2. [Injectable Attribute](#injectable-attribute)\r\n3. [Injection Types](#injection-types)\r\n4. [TypePriority System](#typepriority-system)\r\n5. [Constructor Injection](#constructor-injection)\r\n6. [Service Resolution](#service-resolution)\r\n7. [Common Patterns](#common-patterns)\r\n8. [Best Practices](#best-practices)\r\n\r\n---\r\n\r\n## Overview\r\n\r\nSPT 4.x uses **Microsoft.Extensions.DependencyInjection** with custom attribute-based registration. Classes marked with `[Injectable]` are automatically discovered and registered in the DI container.\r\n\r\n### Architecture\r\n\r\n```\r\n[Your Mod Assembly]\r\n        ‚Üì\r\n   [Injectable] Attribute\r\n        ‚Üì\r\n   DI Scanner finds marked classes\r\n        ‚Üì\r\n   Sorted by TypePriority\r\n        ‚Üì\r\n   Registered in DI Container\r\n        ‚Üì\r\n   Auto-injected via Constructor\r\n```\r\n\r\n---\r\n\r\n## Injectable Attribute\r\n\r\n**Location**: `SPTarkov.DI/Annotations/Injectable.cs`\r\n\r\n```csharp\r\n[AttributeUsage(AttributeTargets.Class, Inherited = false)]\r\npublic class Injectable(\r\n    InjectionType injectionType = InjectionType.Scoped,\r\n    Type? typeOverride = null,\r\n    int typePriority = int.MaxValue\r\n) : Attribute\r\n{\r\n    public InjectionType InjectionType { get; set; } = injectionType;\r\n    public int TypePriority { get; set; } = typePriority;\r\n    public Type? TypeOverride { get; set; } = typeOverride;\r\n}\r\n```\r\n\r\n### Parameters\r\n\r\n| Parameter | Type | Default | Purpose |\r\n|-----------|------|---------|---------|\r\n| `injectionType` | `InjectionType` | `Scoped` | Lifetime management |\r\n| `typeOverride` | `Type?` | `null` | Replace existing service |\r\n| `typePriority` | `int` | `int.MaxValue` | Execution order |\r\n\r\n---\r\n\r\n## Injection Types\r\n\r\n**Location**: `SPTarkov.DI/Annotations/Injectable.cs:18-23`\r\n\r\n```csharp\r\npublic enum InjectionType\r\n{\r\n    Singleton,   // One instance for entire application\r\n    Transient,   // New instance every request\r\n    Scoped       // One instance per scope (HTTP request)\r\n}\r\n```\r\n\r\n### Singleton\r\n\r\n**Lifetime**: One instance for entire application lifetime\r\n\r\n**Use cases**:\r\n- Database servers\r\n- Configuration managers\r\n- Caches\r\n- Stateful services\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class DatabaseServer\r\n{\r\n    protected DatabaseTables? TableData { get; private set; }\r\n\r\n    public DatabaseTables GetTables()\r\n    {\r\n        return TableData ?? throw new DatabaseNullException();\r\n    }\r\n}\r\n```\r\n\r\n**Source**: `SPTarkov.Server.Core/Servers/DatabaseServer.cs:7`\r\n\r\n**Characteristics**:\r\n- Created once on first request\r\n- Shared across all requests\r\n- Must be thread-safe\r\n- Perfect for expensive-to-create services\r\n\r\n---\r\n\r\n### Scoped (Default)\r\n\r\n**Lifetime**: One instance per scope (typically per HTTP request)\r\n\r\n**Use cases**:\r\n- Most services (default choice)\r\n- Request-specific operations\r\n- Services that shouldn't share state between requests\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable]  // Defaults to Scoped\r\npublic class AirdropService(\r\n    ISptLogger<AirdropService> logger,\r\n    ConfigServer configServer,\r\n    LootGenerator lootGenerator\r\n)\r\n{\r\n    // New instance per HTTP request scope\r\n}\r\n```\r\n\r\n**Source**: `SPTarkov.Server.Core/Services/AirdropService.cs:17`\r\n\r\n**Characteristics**:\r\n- Created once per request\r\n- Disposed after request completes\r\n- Isolated between requests\r\n- Good balance of performance and isolation\r\n\r\n---\r\n\r\n### Transient\r\n\r\n**Lifetime**: New instance every time requested\r\n\r\n**Use cases**:\r\n- Lightweight, stateless utilities\r\n- Rarely used in SPT codebase\r\n\r\n**Note**: No direct examples found in SPT - primarily used internally by framework.\r\n\r\n**Characteristics**:\r\n- Created every time injected\r\n- No state sharing\r\n- Highest isolation\r\n- Can impact performance if overused\r\n\r\n---\r\n\r\n## TypePriority System\r\n\r\nControls **registration and initialization order**. Lower number = earlier execution.\r\n\r\n### OnLoadOrder Constants\r\n\r\n**Location**: `SPTarkov.Server.Core/DI/OnLoadOrder.cs`\r\n\r\n```csharp\r\npublic static class OnLoadOrder\r\n{\r\n    public const int Watermark = 0;                 // First\r\n    public const int PreSptModLoader = 100000;      // Pre-database mod hook\r\n    public const int Database = 200000;             // Database loads here\r\n    public const int GameCallbacks = 300000;\r\n    public const int PostDBModLoader = 400000;      // Post-database mod hook\r\n    public const int TraderRegistration = 500000;\r\n    public const int HandbookCallbacks = 600000;\r\n    public const int SaveCallbacks = 700000;\r\n    public const int TraderCallbacks = 800000;\r\n    public const int PresetCallbacks = 900000;\r\n    public const int RagfairCallbacks = 1000000;\r\n    public const int PostSptModLoader = 1100000;    // Last mod hook\r\n}\r\n```\r\n\r\n### OnUpdateOrder Constants\r\n\r\n**Location**: `SPTarkov.Server.Core/DI/OnUpdateOrder.cs`\r\n\r\n```csharp\r\npublic static class OnUpdateOrder\r\n{\r\n    public const int DialogueCallbacks = 1000;\r\n    public const int HideoutCallbacks = 2000;\r\n    public const int InsuranceCallbacks = 3000;\r\n    public const int BtrDeliveryCallbacks = 4000;\r\n}\r\n```\r\n\r\n### Usage Examples\r\n\r\n**Early initialization**:\r\n```csharp\r\n[Injectable(InjectionType.Singleton, TypePriority = OnLoadOrder.Watermark)]\r\npublic class Watermark(...) : IOnLoad { }\r\n```\r\n\r\n**Mod after database**:\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MyMod(...) : IOnLoad { }\r\n```\r\n\r\n**Logger (earliest possible)**:\r\n```csharp\r\n[Injectable(TypePriority = int.MinValue)]\r\npublic class SptLogger<T> : ISptLogger<T> { }\r\n```\r\n\r\n**Source**: Multiple files including `Watermark.cs:43`, `TestMod.cs:26`, `SptLogger.cs:8`\r\n\r\n---\r\n\r\n## Constructor Injection\r\n\r\nSPT uses **C# 12 primary constructors** for clean dependency injection.\r\n\r\n### Pattern 1: Simple Service\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class RandomUtil(ISptLogger<RandomUtil> logger, ICloner cloner)\r\n{\r\n    public readonly Random Random = new();\r\n\r\n    public int GetInt(int min, int max = int.MaxValue, bool exclusive = false)\r\n    {\r\n        // logger and cloner available as parameters\r\n        return exclusive ? Random.Next(min, max) : Random.Next(min, max + 1);\r\n    }\r\n}\r\n```\r\n\r\n**Source**: `SPTarkov.Server.Core/Utils/RandomUtil.cs:9`\r\n\r\n### Pattern 2: With Field Initialization\r\n\r\n```csharp\r\n[Injectable]\r\npublic class LocaleService(\r\n    ISptLogger<LocaleService> logger,\r\n    DatabaseServer databaseServer,\r\n    ConfigServer configServer\r\n)\r\n{\r\n    // Initialize field from injected service\r\n    protected readonly LocaleConfig LocaleConfig = configServer.GetConfig<LocaleConfig>();\r\n    private string _chosenServerLocale = string.Empty;\r\n\r\n    public Dictionary<string, string> GetLocaleDb(string? language = null)\r\n    {\r\n        // Use injected services\r\n        var locales = databaseServer.GetTables().Locales;\r\n        return locales.Global[language ?? _chosenServerLocale].Value!;\r\n    }\r\n}\r\n```\r\n\r\n**Source**: Similar pattern in `LocaleService.cs`\r\n\r\n### Pattern 3: Router with Routes\r\n\r\n```csharp\r\n[Injectable]\r\npublic class ProfileStaticRouter(ProfileCallbacks profileCallbacks, JsonUtil jsonUtil)\r\n    : StaticRouter(\r\n        jsonUtil,\r\n        [\r\n            new RouteAction<ProfileCreateRequestData>(\r\n                \"/client/game/profile/create\",\r\n                async (url, info, sessionID, output) =>\r\n                    await profileCallbacks.CreateProfile(url, info, sessionID)\r\n            ),\r\n            new RouteAction<EmptyRequestData>(\r\n                \"/client/game/profile/list\",\r\n                async (url, info, sessionID, output) =>\r\n                    await profileCallbacks.GetProfileData(url, info, sessionID)\r\n            )\r\n        ]\r\n    )\r\n{ }\r\n```\r\n\r\n**Source**: `SPTarkov.Server.Core/Routers/Static/ProfileStaticRouter.cs:11`\r\n\r\n**Key points**:\r\n- Dependencies injected via constructor\r\n- Passed to base class via `: StaticRouter(...)`\r\n- Routes defined inline using collection expression syntax `[...]`\r\n\r\n---\r\n\r\n## Service Resolution\r\n\r\n### DI Container Registration\r\n\r\n**Location**: `SPTarkov.DI/DependencyInjectionHandler.cs`\r\n\r\n```csharp\r\npublic void InjectAll()\r\n{\r\n    // 1. Find all [Injectable] classes\r\n    var injectableTypes = GetInjectableTypes();\r\n\r\n    // 2. Sort by TypePriority (lower first)\r\n    var sortedInjectableTypes = injectableTypes.OrderBy(t => t.InjectableAttribute.TypePriority);\r\n\r\n    // 3. Register each class\r\n    foreach (var typeRef in sortedInjectableTypes)\r\n    {\r\n        RegisterComponent(\r\n            typeRef.InjectableAttribute.InjectionType,\r\n            typeRef.Type,\r\n            typeRef.Type\r\n        );\r\n\r\n        // Also register interfaces\r\n        foreach (var interfaceType in typeRef.Interfaces)\r\n        {\r\n            RegisterComponent(\r\n                typeRef.InjectableAttribute.InjectionType,\r\n                interfaceType,\r\n                typeRef.Type\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nprivate void RegisterComponent(InjectionType injectionType, Type serviceType, Type implementationType)\r\n{\r\n    switch (injectionType)\r\n    {\r\n        case InjectionType.Singleton:\r\n            serviceCollection.AddSingleton(serviceType, implementationType);\r\n            break;\r\n        case InjectionType.Transient:\r\n            serviceCollection.AddTransient(serviceType, implementationType);\r\n            break;\r\n        case InjectionType.Scoped:\r\n            serviceCollection.AddScoped(serviceType, implementationType);\r\n            break;\r\n    }\r\n}\r\n```\r\n\r\n**What gets registered**:\r\n- The class itself\r\n- All implemented interfaces (except System.* interfaces)\r\n- Generic type instantiations\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class MyService : IMyInterface\r\n{\r\n    // Auto-registered as:\r\n    // - MyService (class)\r\n    // - IMyInterface (interface)\r\n}\r\n\r\n// Can be injected as either:\r\npublic class Consumer1(MyService service) { }           // ‚úÖ Works\r\npublic class Consumer2(IMyInterface service) { }        // ‚úÖ Also works\r\n```\r\n\r\n---\r\n\r\n## TypeOverride - Replacing Services\r\n\r\n**Use case**: Replace existing service with custom implementation (primarily for testing)\r\n\r\n```csharp\r\n[Injectable(TypeOverride = typeof(RandomUtil))]\r\npublic class MockRandomUtil(ISptLogger<RandomUtil> logger, ICloner cloner)\r\n    : RandomUtil(logger, cloner)\r\n{\r\n    public override int GetInt(int min, int max = int.MaxValue, bool exclusive = false)\r\n    {\r\n        return min; // Always return min for predictable testing\r\n    }\r\n}\r\n```\r\n\r\n**Source**: `Testing/UnitTests/Mock/MockRandomUtil.cs:8`\r\n\r\n**How it works**:\r\n1. DI handler finds class with `TypeOverride`\r\n2. Removes original `RandomUtil` from container\r\n3. Registers `MockRandomUtil` in its place\r\n4. All code requesting `RandomUtil` gets `MockRandomUtil`\r\n\r\n---\r\n\r\n## Common Patterns\r\n\r\n### Pattern 1: Database Modification Mod\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MyDatabaseMod(\r\n    ISptLogger<MyDatabaseMod> logger,\r\n    DatabaseService databaseService,\r\n    ItemBaseClassService itemBaseClassService\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        logger.Info(\"Modifying database...\");\r\n\r\n        var items = databaseService.GetItems();\r\n\r\n        foreach (var (itemId, item) in items)\r\n        {\r\n            if (itemBaseClassService.ItemHasBaseClass(itemId, BaseClasses.WEAPON))\r\n            {\r\n                // Modify weapon properties\r\n                item.Properties.Weight *= 0.5;\r\n            }\r\n        }\r\n\r\n        logger.Success(\"Database modified!\");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n### Pattern 2: HTTP Router Registration\r\n\r\n```csharp\r\n[Injectable]\r\npublic class MyCustomRouter(JsonUtil jsonUtil, ISptLogger<MyCustomRouter> logger)\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/my/custom/endpoint\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                logger.Info(\"Route called!\");\r\n                return jsonUtil.Serialize(new { status = \"ok\" });\r\n            }\r\n        )\r\n    ])\r\n{\r\n    // Router auto-discovered and registered\r\n}\r\n```\r\n\r\n### Pattern 3: Custom Service\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class MyCustomService(\r\n    ISptLogger<MyCustomService> logger,\r\n    DatabaseService databaseService,\r\n    SaveServer saveServer\r\n)\r\n{\r\n    public void DoSomething(MongoId sessionId)\r\n    {\r\n        var profile = saveServer.GetProfile(sessionId);\r\n        var items = databaseService.GetItems();\r\n\r\n        logger.Info($\"Processing for {profile.CharacterData.PmcData.Info.Nickname}\");\r\n\r\n        // Your logic here\r\n    }\r\n}\r\n```\r\n\r\n### Pattern 4: Service with Lifecycle\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MyServiceWithLifecycle(\r\n    ISptLogger<MyServiceWithLifecycle> logger,\r\n    DatabaseService databaseService\r\n) : IOnLoad, IOnUpdate\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        logger.Info(\"One-time initialization\");\r\n        return Task.CompletedTask;\r\n    }\r\n\r\n    public Task<bool> OnUpdate(long secondsSinceLastRun)\r\n    {\r\n        if (secondsSinceLastRun < 60)\r\n            return Task.FromResult(false);\r\n\r\n        logger.Debug(\"Periodic update\");\r\n        return Task.FromResult(true);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Best Practices\r\n\r\n### ‚úÖ DO\r\n\r\n**1. Use Primary Constructors**\r\n```csharp\r\npublic class MyService(ISptLogger<MyService> logger, DatabaseService db)\r\n{\r\n    // Clean, concise\r\n}\r\n```\r\n\r\n**2. Specify InjectionType Explicitly**\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]  // Clear intent\r\npublic class MyService { }\r\n```\r\n\r\n**3. Use TypePriority When Order Matters**\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MyMod : IOnLoad { }\r\n```\r\n\r\n**4. Inject ISptLogger<T>**\r\n```csharp\r\npublic class MyService(ISptLogger<MyService> logger)\r\n{\r\n    // Automatically categorized logging\r\n}\r\n```\r\n\r\n**5. Inject Only What You Need**\r\n```csharp\r\n// Only inject services you actually use\r\npublic class Minimal(ISptLogger<Minimal> logger)\r\n{\r\n    // Don't inject DatabaseService if you don't use it\r\n}\r\n```\r\n\r\n---\r\n\r\n### ‚ùå DON'T\r\n\r\n**1. Use ServiceLocator in Constructors**\r\n```csharp\r\n// ‚ùå WRONG - ServiceLocator is deprecated!\r\npublic MyClass()\r\n{\r\n    var service = ServiceLocator.ServiceProvider.GetService(typeof(MyService));\r\n}\r\n\r\n// ‚úÖ CORRECT - Use constructor injection\r\npublic MyClass(MyService service)\r\n{\r\n    // service automatically injected\r\n}\r\n```\r\n\r\n**2. Access Database Before It's Loaded**\r\n```csharp\r\n// ‚ùå WRONG - Database not ready yet\r\n[Injectable(TypePriority = OnLoadOrder.Database - 1)]\r\npublic class TooEarly(DatabaseService db) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var items = db.GetItems(); // ERROR!\r\n    }\r\n}\r\n\r\n// ‚úÖ CORRECT - Wait for database\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class CorrectTiming(DatabaseService db) : IOnLoad { }\r\n```\r\n\r\n**3. Forget [Injectable] Attribute**\r\n```csharp\r\n// ‚ùå WRONG - Won't be registered!\r\npublic class MyService { }\r\n\r\n// ‚úÖ CORRECT\r\n[Injectable]\r\npublic class MyService { }\r\n```\r\n\r\n**4. Use Transient for Heavy Services**\r\n```csharp\r\n// ‚ùå WRONG - Creates new instance every time!\r\n[Injectable(InjectionType.Transient)]\r\npublic class ExpensiveDatabaseService { }\r\n\r\n// ‚úÖ CORRECT - Share instance\r\n[Injectable(InjectionType.Singleton)]\r\npublic class ExpensiveDatabaseService { }\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\nSPT's dependency injection system provides:\r\n\r\n- **Automatic registration** via `[Injectable]` attribute\r\n- **Three lifetimes**: Singleton (shared), Scoped (per-request), Transient (always-new)\r\n- **Ordered initialization** via TypePriority\r\n- **Clean constructor injection** using C# 12 primary constructors\r\n- **Generic support** for `ISptLogger<T>` and other generic services\r\n- **Service override** capability for testing\r\n\r\n**Golden Rules**:\r\n1. Mark classes with `[Injectable]`\r\n2. Use constructor parameters for dependencies\r\n3. Choose appropriate InjectionType\r\n4. Set TypePriority when order matters\r\n5. Never use ServiceLocator (deprecated)\r\n\r\n---\r\n\r\n**Based on**: SPT v4.0.x Source Code\r\n**Key Files**:\r\n- `SPTarkov.DI/Annotations/Injectable.cs`\r\n- `SPTarkov.DI/DependencyInjectionHandler.cs`\r\n- `SPTarkov.Server.Core/DI/OnLoadOrder.cs`\r\n"},"SPT-FRIEND-PARTY-INVITE-SYSTEM":{"title":"SPT Friend, Party & Invite System - Complete Reference\r","category":"General","content":"# SPT Friend, Party & Invite System - Complete Reference\r\n\r\n**Source**: SPT v4.0.x C# Source Code\r\n**Status**: ‚úÖ SOURCE-VERIFIED\r\n**Purpose**: Implementing FriendlyPMC squad member lifecycle with modern SPT APIs\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [System Overview](#system-overview)\r\n2. [Friend System](#friend-system)\r\n3. [Group/Party System](#groupparty-system)\r\n4. [Notification System](#notification-system)\r\n5. [FriendlyPMC Squad Implementation](#friendlypmc-squad-implementation)\r\n6. [Complete Flow Examples](#complete-flow-examples)\r\n\r\n---\r\n\r\n## System Overview\r\n\r\n### Three Interconnected Systems\r\n\r\n**Friend System**:\r\n- Manages friend lists (who you can message)\r\n- Stored in `SptProfile.FriendProfileIds` (HashSet<MongoId>)\r\n- Auto-accept friend requests (SPT simplification)\r\n- Notifications via `WsFriendsListAccept`\r\n\r\n**Group/Party System**:\r\n- Pre-raid party formation\r\n- Group leader designation\r\n- Ready state tracking\r\n- Minimal implementation in SPT (offline-focused)\r\n\r\n**Raid Invite System**:\r\n- Group leader starts raid\r\n- Invites sent to group members\r\n- Members accept ‚Üí join same raid instance\r\n- Used by Fika for multiplayer\r\n\r\n---\r\n\r\n## Friend System\r\n\r\n### Friend List Storage\r\n\r\n**Location**: `SptProfile.cs:52-55`\r\n\r\n```csharp\r\npublic record SptProfile\r\n{\r\n    // ... other fields\r\n\r\n    [JsonPropertyName(\"friends\")]\r\n    public HashSet<MongoId>? FriendProfileIds { get; set; }\r\n\r\n    // ... other fields\r\n}\r\n```\r\n\r\n**Example**:\r\n```json\r\n{\r\n  \"friends\": [\r\n    \"507f1f77bcf86cd799439011\",\r\n    \"507f1f77bcf86cd799439012\",\r\n    \"507f1f77bcf86cd799439013\"\r\n  ]\r\n}\r\n```\r\n\r\n### Friend Operations API\r\n\r\n**Source**: `DialogueController.cs:589-640`\r\n\r\n#### Send Friend Request\r\n\r\n**Route**: `POST /client/friend/request/send`\r\n**Request**:\r\n```json\r\n{\r\n  \"to\": \"507f1f77bcf86cd799439011\"\r\n}\r\n```\r\n\r\n**Implementation**:\r\n```csharp\r\npublic virtual FriendRequestSendResponse SendFriendRequest(MongoId sessionID, FriendRequestData request)\r\n{\r\n    // Validate target exists\r\n    var friendProfile = profileHelper.GetFullProfile(request.To.Value);\r\n    if (friendProfile?.CharacterData?.PmcData is null)\r\n    {\r\n        return new FriendRequestSendResponse\r\n        {\r\n            Status = BackendErrorCodes.PlayerProfileNotFound,\r\n            RequestId = string.Empty,\r\n            RetryAfter = 600,\r\n        };\r\n    }\r\n\r\n    // AUTO-ACCEPT: Add to friend list immediately\r\n    var profile = saveServer.GetProfile(sessionID);\r\n    profile.FriendProfileIds ??= new HashSet<MongoId>();\r\n    profile.FriendProfileIds.Add(request.To.Value);\r\n\r\n    // Send acceptance notification (1 second delay for UI update)\r\n    _ = new Timer(\r\n        _ =>\r\n        {\r\n            var notification = new WsFriendsListAccept\r\n            {\r\n                EventType = NotificationEventType.friendListRequestAccept,\r\n                Profile = profileHelper.GetChatRoomMemberFromPmcProfile(\r\n                    friendProfile.CharacterData.PmcData\r\n                ),\r\n            };\r\n            notificationSendHelper.SendMessage(sessionID, notification);\r\n        },\r\n        null,\r\n        TimeSpan.FromSeconds(1),\r\n        Timeout.InfiniteTimeSpan\r\n    );\r\n\r\n    return new FriendRequestSendResponse\r\n    {\r\n        Status = BackendErrorCodes.None,\r\n        RequestId = friendProfile.ProfileInfo.Aid.ToString(),\r\n        RetryAfter = 600,\r\n    };\r\n}\r\n```\r\n\r\n#### Delete Friend\r\n\r\n**Route**: `POST /client/friend/delete`\r\n**Implementation**:\r\n```csharp\r\npublic virtual void DeleteFriend(MongoId sessionID, DeleteFriendRequest request)\r\n{\r\n    var profile = saveServer.GetProfile(sessionID);\r\n    profile?.FriendProfileIds?.Remove(request.FriendId);\r\n}\r\n```\r\n\r\n#### Get Friend List\r\n\r\n**Route**: `POST /client/friend/list`\r\n**Implementation**: See earlier documentation (returns chatbots + friends)\r\n\r\n---\r\n\r\n## Group/Party System\r\n\r\n### Group Data Model\r\n\r\n**Source**: `GroupCharacter.cs:7-59`\r\n\r\n```csharp\r\npublic record GroupCharacter\r\n{\r\n    [JsonPropertyName(\"_id\")]\r\n    public string? Id { get; set; }              // Profile ID\r\n\r\n    [JsonPropertyName(\"aid\")]\r\n    public int? Aid { get; set; }                // Account ID\r\n\r\n    [JsonPropertyName(\"Info\")]\r\n    public CharacterInfo? Info { get; set; }\r\n\r\n    [JsonPropertyName(\"isLeader\")]\r\n    public bool? IsLeader { get; set; }          // Group leader flag\r\n\r\n    [JsonPropertyName(\"isReady\")]\r\n    public bool? IsReady { get; set; }           // Ready for raid\r\n}\r\n```\r\n\r\n### Group Operations Routes\r\n\r\n**Source**: `MatchStaticRouter.cs:32-119`\r\n\r\n| Route | Purpose | Handler |\r\n|-------|---------|---------|\r\n| `/client/match/group/current` | Get current group | `GroupCurrent()` |\r\n| `/client/match/group/status` | Get group status | `GetGroupStatus()` |\r\n| `/client/match/group/invite/send` | Send group invite | `SendGroupInvite()` |\r\n| `/client/match/group/invite/accept` | Accept invite | `AcceptGroupInvite()` |\r\n| `/client/match/group/start_game` | Start raid as leader | `StartGameAsGroupLeader()` |\r\n\r\n### SPT's Default Implementation\r\n\r\n**Current SPT Returns Empty Data**:\r\n\r\n```csharp\r\npublic ValueTask<string> GroupCurrent(string url, EmptyRequestData _, MongoId sessionID)\r\n{\r\n    // Returns empty squad\r\n    return new ValueTask<string>(\r\n        httpResponseUtil.GetBody(new MatchGroupCurrentResponse { Squad = [] })\r\n    );\r\n}\r\n```\r\n\r\n**Why**: SPT is single-player, doesn't need functional group system.\r\n\r\n**For FriendlyPMC**: Need to override/extend this to return AI squad members.\r\n\r\n---\r\n\r\n## Notification System\r\n\r\n### Notification Architecture\r\n\r\n**Base Event**: `WsNotificationEvent.cs`\r\n\r\n```csharp\r\npublic record WsNotificationEvent\r\n{\r\n    [JsonPropertyName(\"type\")]\r\n    public NotificationEventType? EventType { get; set; }\r\n\r\n    [JsonPropertyName(\"eventId\")]\r\n    public MongoId EventIdentifier { get; set; }\r\n}\r\n```\r\n\r\n### Friend Notifications\r\n\r\n**Accept**: `WsFriendsListAccept.cs`\r\n```csharp\r\npublic record WsFriendsListAccept : WsNotificationEvent\r\n{\r\n    [JsonPropertyName(\"profile\")]\r\n    public SearchFriendResponse? Profile { get; set; }\r\n}\r\n```\r\n\r\n### Group Notifications\r\n\r\n**Invite Send**: `WsGroupMatchInviteSend.cs`\r\n```csharp\r\npublic record WsGroupMatchInviteSend : WsNotificationEvent\r\n{\r\n    [JsonPropertyName(\"requestId\")]\r\n    public string? RequestId { get; set; }\r\n\r\n    [JsonPropertyName(\"from\")]\r\n    public int? From { get; set; }              // Sender's Aid\r\n\r\n    [JsonPropertyName(\"members\")]\r\n    public List<GroupCharacter>? Members { get; set; }\r\n}\r\n```\r\n\r\n**Invite Accept**: `WsGroupMatchInviteAccept.cs`\r\n```csharp\r\npublic record WsGroupMatchInviteAccept : WsNotificationEvent\r\n{\r\n    // Full GroupCharacter data for joining member\r\n}\r\n```\r\n\r\n**Raid Settings**: `WsGroupMatchRaidSettings.cs`\r\n```csharp\r\npublic record WsGroupMatchRaidSettings : WsNotificationEvent\r\n{\r\n    [JsonPropertyName(\"raidSettings\")]\r\n    public RaidSettings? RaidSettings { get; set; }\r\n}\r\n```\r\n\r\n### Sending Notifications\r\n\r\n**Source**: `NotificationSendHelper.cs:30-53`\r\n\r\n```csharp\r\npublic void SendMessage(MongoId sessionId, WsNotificationEvent notificationMessage)\r\n{\r\n    // Try WebSocket first\r\n    if (sptWebSocketConnectionHandler.IsWebSocketConnected(sessionId))\r\n    {\r\n        sptWebSocketConnectionHandler.SendMessage(sessionId, notificationMessage);\r\n        return;\r\n    }\r\n\r\n    // Fall back to long-polling queue\r\n    notificationService.Add(sessionId, notificationMessage);\r\n}\r\n```\r\n\r\n---\r\n\r\n## FriendlyPMC Squad Implementation\r\n\r\n### Modern SPT 4.0.x Approach\r\n\r\n**Key Insight**: Don't try to replicate the old friend invite flow. Instead:\r\n\r\n1. ‚úÖ **Generate AI PMC profiles** (with proper Aids, equipment)\r\n2. ‚úÖ **Add directly to friend list** (no request/accept needed)\r\n3. ‚úÖ **Create group on raid start** (include AI PMCs as members)\r\n4. ‚úÖ **Send notifications** for UI updates\r\n5. ‚úÖ **Spawn bots in raid** with profiles\r\n\r\n### Step-by-Step Implementation\r\n\r\n#### Step 1: Add Squad Member Command (/add)\r\n\r\n```csharp\r\n// ChatBot command handler\r\npublic ValueTask<string> HandleAddCommand(MongoId sessionId, string[] args)\r\n{\r\n    // Parse: /add <nickname> <role>\r\n    string nickname = args[0];\r\n    string role = args.Length > 1 ? args[1] : \"Assault\";\r\n\r\n    // 1. Generate AI PMC profile\r\n    var aiProfile = followerGeneratorService.GenerateFollowerBot(\r\n        sessionId,\r\n        \"Usec\",  // Or from config\r\n        nickname,\r\n        GetLoadoutForRole(role)\r\n    );\r\n\r\n    // 2. Save AI PMC profile\r\n    var aiSessionId = new MongoId();\r\n    saveServer.SaveProfile(aiSessionId, new SptProfile\r\n    {\r\n        ProfileInfo = new ProfileInfo\r\n        {\r\n            Id = aiProfile.Id.Value,\r\n            Nickname = nickname,\r\n            Aid = aiProfile.Aid.Value\r\n        },\r\n        CharacterData = new CharacterData\r\n        {\r\n            PmcData = aiProfile\r\n        }\r\n    });\r\n\r\n    // 3. Add to player's friend list\r\n    var playerProfile = saveServer.GetProfile(sessionId);\r\n    playerProfile.FriendProfileIds ??= new HashSet<MongoId>();\r\n    playerProfile.FriendProfileIds.Add(aiProfile.Id.Value);\r\n\r\n    // 4. Send friend acceptance notification\r\n    var notification = new WsFriendsListAccept\r\n    {\r\n        EventType = NotificationEventType.friendListRequestAccept,\r\n        Profile = new SearchFriendResponse\r\n        {\r\n            Id = aiProfile.Id.Value,\r\n            Aid = aiProfile.Aid,\r\n            Info = new UserDialogDetails\r\n            {\r\n                Nickname = aiProfile.Info.Nickname,\r\n                Side = aiProfile.Info.Side,\r\n                Level = aiProfile.Info.Level,\r\n                MemberCategory = MemberCategory.Sherpa,\r\n                SelectedMemberCategory = MemberCategory.Sherpa\r\n            }\r\n        }\r\n    };\r\n\r\n    notificationSendHelper.SendMessage(sessionId, notification);\r\n\r\n    // 5. Track in squad service\r\n    squadService.AddMember(sessionId, aiProfile.Id.Value, role);\r\n\r\n    return new ValueTask<string>($\"Added {nickname} to squad!\");\r\n}\r\n```\r\n\r\n#### Step 2: Raid Configuration (Auto-Group Creation)\r\n\r\n```csharp\r\n// Override MatchController.ConfigureOfflineRaid\r\n[HarmonyPostfix]\r\n[HarmonyPatch(typeof(MatchController), \"ConfigureOfflineRaid\")]\r\npublic static void ConfigureRaid_Postfix(\r\n    GetRaidConfigurationRequestData request,\r\n    MongoId sessionId)\r\n{\r\n    // Get player's squad\r\n    var squad = squadService.GetSquad(sessionId);\r\n    if (squad == null || squad.Members.Count == 0)\r\n        return;\r\n\r\n    // Create group with AI PMCs\r\n    var group = new MatchGroup\r\n    {\r\n        GroupId = new MongoId(),\r\n        LeaderId = sessionId,\r\n        Members = new List<GroupCharacter>()\r\n    };\r\n\r\n    // Add player as leader\r\n    var playerProfile = profileHelper.GetPmcProfile(sessionId);\r\n    group.Members.Add(new GroupCharacter\r\n    {\r\n        Id = playerProfile.Id.ToString(),\r\n        Aid = playerProfile.Aid,\r\n        Info = CreateCharacterInfo(playerProfile.Info),\r\n        IsLeader = true,\r\n        IsReady = true\r\n    });\r\n\r\n    // Add AI PMC squad members\r\n    foreach (var memberId in squad.Members)\r\n    {\r\n        var aiProfile = profileHelper.GetPmcProfile(memberId);\r\n        group.Members.Add(new GroupCharacter\r\n        {\r\n            Id = aiProfile.Id.ToString(),\r\n            Aid = aiProfile.Aid,\r\n            Info = CreateCharacterInfo(aiProfile.Info),\r\n            IsLeader = false,\r\n            IsReady = true  // AI always ready\r\n        });\r\n    }\r\n\r\n    // Store group\r\n    matchLocationService.StoreGroup(sessionId, group);\r\n\r\n    logger.Info($\"Created group with {group.Members.Count} members\");\r\n}\r\n```\r\n\r\n#### Step 3: Return Group Data to Client\r\n\r\n```csharp\r\n// Override MatchCallbacks.GroupCurrent\r\n[Injectable]\r\npublic class FriendlyPmcMatchCallbacks(\r\n    HttpResponseUtil httpResponseUtil,\r\n    SquadService squadService,\r\n    MatchLocationService matchLocationService\r\n)\r\n{\r\n    public ValueTask<string> GroupCurrent(string url, EmptyRequestData _, MongoId sessionID)\r\n    {\r\n        // Get active group\r\n        var group = matchLocationService.GetPlayerGroup(sessionID);\r\n\r\n        if (group != null)\r\n        {\r\n            // Return squad members\r\n            return new ValueTask<string>(\r\n                httpResponseUtil.GetBody(new MatchGroupCurrentResponse\r\n                {\r\n                    Squad = group.Members\r\n                })\r\n            );\r\n        }\r\n\r\n        // No group - return empty\r\n        return new ValueTask<string>(\r\n            httpResponseUtil.GetBody(new MatchGroupCurrentResponse { Squad = [] })\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n#### Step 4: Spawn Squad in Raid\r\n\r\n```csharp\r\n// Client-side: During raid start\r\npublic async Task SpawnSquadMembers(Player player, BotsController controller)\r\n{\r\n    // 1. Get group from server\r\n    var response = await RequestHandler.PostJson(\"/client/match/group/current\", \"{}\");\r\n    var groupData = JsonConvert.DeserializeObject<MatchGroupCurrentResponse>(response);\r\n\r\n    if (groupData?.Squad == null || groupData.Squad.Count <= 1)\r\n        return;  // No squad members (only player)\r\n\r\n    // 2. For each AI PMC squad member\r\n    foreach (var member in groupData.Squad)\r\n    {\r\n        if (member.Id == player.ProfileId)\r\n            continue;  // Skip player\r\n\r\n        // 3. Get AI PMC profile (already exists from /add command)\r\n        var aiProfile = await FetchAiPmcProfile(member.Id);\r\n\r\n        // 4. Spawn bot with profile\r\n        await SpawnBotWithProfile(aiProfile, player, controller);\r\n    }\r\n}\r\n\r\nprivate async Task<Profile> FetchAiPmcProfile(string profileId)\r\n{\r\n    // AI PMC profile was saved during /add command\r\n    // Fetch from server (or from local cache if available)\r\n    var response = await RequestHandler.GetJson($\"/customroute/getprofile/{profileId}\");\r\n    return JsonConvert.DeserializeObject<Profile>(response);\r\n}\r\n```\r\n\r\n---\r\n\r\n## Complete Flow Examples\r\n\r\n### Flow 1: Original FriendlyPMC Design Pattern\r\n\r\n**From**: `OriginalFriendlyPMCDesign.md`\r\n\r\n#### Old Baseline (SPT 3.x TypeScript):\r\n```\r\n1. Player opens SquadChatBot messenger\r\n2. Player sends: \"add Alpha Assault\"\r\n3. SquadChatBot generates profile, saves it\r\n4. SquadChatBot sends friend request from AI PMC to player\r\n5. Player auto-accepts\r\n6. AI PMC appears in friend list\r\n7. Player starts raid\r\n8. System auto-invites AI PMC to group\r\n9. AI PMC auto-accepts\r\n10. Raid starts with AI PMC as bot with profile\r\n```\r\n\r\n#### Modern SPT 4.0.x C# Equivalent:\r\n\r\n```\r\n1. Player opens FikaChatBot messenger\r\n2. Player sends: \"add Alpha Assault\"\r\n3. Server generates PmcData profile with custom Aid\r\n4. Server saves AI PMC profile to disk\r\n5. Server adds AI PMC to player's FriendProfileIds\r\n6. Server sends friendListRequestAccept notification\r\n7. AI PMC appears in friend list immediately\r\n8. Player starts raid\r\n9. Server returns group with AI PMC in Squad array\r\n10. Client spawns AI PMC bots from profiles\r\n```\r\n\r\n**Key Differences**:\r\n- ‚ùå No friend request/accept handshake (auto-accept)\r\n- ‚ùå No group invite system (minimal in SPT)\r\n- ‚úÖ Direct friend list addition\r\n- ‚úÖ Group populated on raid start\r\n- ‚úÖ Notifications for UI updates\r\n\r\n---\r\n\r\n### Flow 2: Implementing in Modern SPT\r\n\r\n**Complete Code Example**:\r\n\r\n```csharp\r\n// ===== SERVER SIDE =====\r\n\r\n// Service to track player squads\r\n[Injectable(InjectionType.Singleton)]\r\npublic class SquadService\r\n{\r\n    private readonly ConcurrentDictionary<MongoId, Squad> _playerSquads = new();\r\n\r\n    public void AddMember(MongoId playerSessionId, MongoId aiPmcProfileId, string role)\r\n    {\r\n        var squad = _playerSquads.GetOrAdd(playerSessionId, _ => new Squad());\r\n        squad.Members.Add(new SquadMember\r\n        {\r\n            ProfileId = aiPmcProfileId,\r\n            Role = role,\r\n            AddedTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds()\r\n        });\r\n    }\r\n\r\n    public Squad? GetSquad(MongoId playerSessionId)\r\n    {\r\n        return _playerSquads.TryGetValue(playerSessionId, out var squad) ? squad : null;\r\n    }\r\n\r\n    public void RemoveMember(MongoId playerSessionId, MongoId aiPmcProfileId)\r\n    {\r\n        if (_playerSquads.TryGetValue(playerSessionId, out var squad))\r\n        {\r\n            squad.Members.RemoveAll(m => m.ProfileId == aiPmcProfileId);\r\n        }\r\n    }\r\n}\r\n\r\npublic class Squad\r\n{\r\n    public List<SquadMember> Members { get; set; } = new();\r\n}\r\n\r\npublic class SquadMember\r\n{\r\n    public MongoId ProfileId { get; set; }\r\n    public string Role { get; set; }\r\n    public long AddedTimestamp { get; set; }\r\n}\r\n\r\n// ChatBot command: /add\r\n[Injectable]\r\npublic class AddSquadMemberCommand(\r\n    FollowerGeneratorService followerService,\r\n    SaveServer saveServer,\r\n    SquadService squadService,\r\n    NotificationSendHelper notificationHelper,\r\n    ProfileHelper profileHelper,\r\n    ISptLogger<AddSquadMemberCommand> logger\r\n) : IFikaCommand\r\n{\r\n    public string Command => \"add\";\r\n    public string CommandHelp => \"add <nickname> [role] - Add AI PMC to squad\";\r\n\r\n    public ValueTask<string> PerformAction(MongoId sessionId, string[] args)\r\n    {\r\n        if (args.Length < 1)\r\n            return new ValueTask<string>(\"Usage: add <nickname> [role]\");\r\n\r\n        string nickname = args[0];\r\n        string role = args.Length > 1 ? args[1] : \"Assault\";\r\n\r\n        // 1. Generate AI PMC profile\r\n        var aiProfile = followerService.GenerateFollowerBot(\r\n            sessionId,\r\n            \"Usec\",  // Or from config/player faction\r\n            nickname,\r\n            GetLoadoutForRole(role)  // Custom loadout based on role\r\n        );\r\n\r\n        logger.Info($\"Generated AI PMC: {nickname} (Id: {aiProfile.Id}, Aid: {aiProfile.Aid})\");\r\n\r\n        // 2. Save AI PMC profile to disk\r\n        var aiSessionId = aiProfile.SessionId.Value;\r\n        var aiSptProfile = new SptProfile\r\n        {\r\n            ProfileInfo = new ProfileInfo\r\n            {\r\n                Id = aiProfile.Id.Value,\r\n                Nickname = nickname,\r\n                Aid = aiProfile.Aid.Value,\r\n                AccountType = 2,  // Standard account\r\n                MemberCategory = MemberCategory.Default,\r\n                SavageAccountId = new MongoId()  // Generate scav ID\r\n            },\r\n            CharacterData = new CharacterData\r\n            {\r\n                PmcData = aiProfile,\r\n                ScavData = null  // No scav for AI PMCs\r\n            }\r\n        };\r\n\r\n        saveServer.SaveProfile(aiSessionId, aiSptProfile);\r\n        logger.Success($\"Saved AI PMC profile: {nickname}\");\r\n\r\n        // 3. Add to player's friend list\r\n        var playerProfile = saveServer.GetProfile(sessionId);\r\n        playerProfile.FriendProfileIds ??= new HashSet<MongoId>();\r\n        playerProfile.FriendProfileIds.Add(aiProfile.Id.Value);\r\n\r\n        logger.Info($\"Added {nickname} to friend list\");\r\n\r\n        // 4. Send friend acceptance notification\r\n        var notification = new WsFriendsListAccept\r\n        {\r\n            EventType = NotificationEventType.friendListRequestAccept,\r\n            EventIdentifier = aiProfile.Id.Value,\r\n            Profile = profileHelper.GetChatRoomMemberFromPmcProfile(aiProfile)\r\n        };\r\n\r\n        notificationHelper.SendMessage(sessionId, notification);\r\n\r\n        logger.Info($\"Sent friend notification for {nickname}\");\r\n\r\n        // 5. Track in squad service\r\n        squadService.AddMember(sessionId, aiProfile.Id.Value, role);\r\n\r\n        return new ValueTask<string>($\"‚úì Added {nickname} ({role}) to squad\");\r\n    }\r\n\r\n    private CustomLoadout GetLoadoutForRole(string role)\r\n    {\r\n        // Return role-specific loadout\r\n        // See CREATING-PROFILE-BOTS-GUIDE.md for equipment customization\r\n        return role switch\r\n        {\r\n            \"Marksman\" => MarksmanLoadout,\r\n            \"Support\" => SupportLoadout,\r\n            \"Assault\" => AssaultLoadout,\r\n            _ => DefaultLoadout\r\n        };\r\n    }\r\n}\r\n\r\n// ChatBot command: /remove\r\npublic class RemoveSquadMemberCommand(\r\n    SaveServer saveServer,\r\n    SquadService squadService,\r\n    NotificationSendHelper notificationHelper,\r\n    ISptLogger<RemoveSquadMemberCommand> logger\r\n) : IFikaCommand\r\n{\r\n    public string Command => \"remove\";\r\n    public string CommandHelp => \"remove <nickname> - Remove AI PMC from squad\";\r\n\r\n    public ValueTask<string> PerformAction(MongoId sessionId, string[] args)\r\n    {\r\n        if (args.Length < 1)\r\n            return new ValueTask<string>(\"Usage: remove <nickname>\");\r\n\r\n        string nickname = args[0];\r\n\r\n        // 1. Find AI PMC profile by nickname\r\n        var playerProfile = saveServer.GetProfile(sessionId);\r\n        var aiProfileId = FindAiPmcByNickname(playerProfile.FriendProfileIds, nickname);\r\n\r\n        if (aiProfileId == null)\r\n            return new ValueTask<string>($\"Squad member '{nickname}' not found\");\r\n\r\n        // 2. Remove from friend list\r\n        playerProfile.FriendProfileIds?.Remove(aiProfileId.Value);\r\n\r\n        // 3. Remove from squad\r\n        squadService.RemoveMember(sessionId, aiProfileId.Value);\r\n\r\n        // 4. Delete AI PMC profile (optional - could keep for reuse)\r\n        // saveServer.DeleteProfile(aiProfileId.Value);\r\n\r\n        logger.Info($\"Removed {nickname} from squad\");\r\n\r\n        return new ValueTask<string>($\"‚úì Removed {nickname} from squad\");\r\n    }\r\n\r\n    private MongoId? FindAiPmcByNickname(HashSet<MongoId> friendIds, string nickname)\r\n    {\r\n        foreach (var friendId in friendIds)\r\n        {\r\n            var profile = saveServer.GetProfile(friendId);\r\n            if (profile?.CharacterData?.PmcData?.Info?.Nickname == nickname)\r\n                return friendId;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n#### Step 2: Override Group Current to Return Squad\r\n\r\n```csharp\r\n// Router override\r\n[Injectable]\r\npublic class FriendlyPmcMatchRouter(\r\n    JsonUtil jsonUtil,\r\n    HttpResponseUtil httpResponseUtil,\r\n    SquadService squadService,\r\n    ProfileHelper profileHelper,\r\n    ISptLogger<FriendlyPmcMatchRouter> logger\r\n) : StaticRouter(jsonUtil,\r\n[\r\n    new RouteAction<EmptyRequestData>(\r\n        \"/client/match/group/current\",\r\n        async (url, info, sessionId, output) =>\r\n        {\r\n            // Get player's squad\r\n            var squad = squadService.GetSquad(sessionId);\r\n\r\n            if (squad == null || squad.Members.Count == 0)\r\n            {\r\n                // No squad - return empty\r\n                return httpResponseUtil.GetBody(new MatchGroupCurrentResponse { Squad = [] });\r\n            }\r\n\r\n            var groupMembers = new List<GroupCharacter>();\r\n\r\n            // Add player as leader\r\n            var playerProfile = profileHelper.GetPmcProfile(sessionId);\r\n            groupMembers.Add(new GroupCharacter\r\n            {\r\n                Id = playerProfile.Id.ToString(),\r\n                Aid = playerProfile.Aid,\r\n                Info = new CharacterInfo\r\n                {\r\n                    Nickname = playerProfile.Info.Nickname,\r\n                    Side = playerProfile.Info.Side,\r\n                    Level = playerProfile.Info.Level.Value,\r\n                    MemberCategory = playerProfile.Info.MemberCategory\r\n                },\r\n                IsLeader = true,\r\n                IsReady = true\r\n            });\r\n\r\n            // Add AI PMC squad members\r\n            foreach (var member in squad.Members)\r\n            {\r\n                var aiProfile = profileHelper.GetPmcProfile(member.ProfileId);\r\n                if (aiProfile != null)\r\n                {\r\n                    groupMembers.Add(new GroupCharacter\r\n                    {\r\n                        Id = aiProfile.Id.ToString(),\r\n                        Aid = aiProfile.Aid,\r\n                        Info = new CharacterInfo\r\n                        {\r\n                            Nickname = aiProfile.Info.Nickname,\r\n                            Side = aiProfile.Info.Side,\r\n                            Level = aiProfile.Info.Level.Value,\r\n                            MemberCategory = MemberCategory.Sherpa\r\n                        },\r\n                        IsLeader = false,\r\n                        IsReady = true\r\n                    });\r\n                }\r\n            }\r\n\r\n            logger.Info($\"Returning group with {groupMembers.Count} members\");\r\n\r\n            return httpResponseUtil.GetBody(new MatchGroupCurrentResponse\r\n            {\r\n                Squad = groupMembers\r\n            });\r\n        }\r\n    )\r\n])\r\n{ }\r\n```\r\n\r\n#### Step 3: Spawn Squad in Raid\r\n\r\n```csharp\r\n// Client-side: After raid loads\r\n[HarmonyPostfix]\r\n[HarmonyPatch(typeof(GameWorld), \"OnGameStarted\")]\r\npublic static async void OnGameStarted_Postfix(GameWorld __instance)\r\n{\r\n    var player = __instance.MainPlayer;\r\n\r\n    // Get group data\r\n    var response = await RequestHandler.PostJson(\"/client/match/group/current\", \"{}\");\r\n    var groupData = JsonConvert.DeserializeObject<MatchGroupCurrentResponse>(response);\r\n\r\n    if (groupData?.Squad == null || groupData.Squad.Count <= 1)\r\n        return;  // No squad members\r\n\r\n    var controller = __instance.GetComponent<BotsController>();\r\n\r\n    // Spawn each AI PMC squad member\r\n    foreach (var member in groupData.Squad)\r\n    {\r\n        if (member.Id == player.ProfileId)\r\n            continue;  // Skip player\r\n\r\n        // Get AI PMC profile from server (or cache)\r\n        var aiProfile = await GetSquadMemberProfile(member.Id);\r\n\r\n        // Load asset bundles\r\n        await LoadProfileAssets(aiProfile);\r\n\r\n        // Spawn bot with profile\r\n        await SpawnSquadMemberBot(aiProfile, player, controller);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Summary & Comparison\r\n\r\n### Old FriendlyPMC Flow (SPT 3.x)\r\n\r\n```\r\n/add command\r\n    ‚Üì\r\nGenerate profile (JS)\r\n    ‚Üì\r\nSave profile (JSON file)\r\n    ‚Üì\r\nSend friend request (from AI to player)\r\n    ‚Üì\r\nPlayer auto-accepts\r\n    ‚Üì\r\nFriend appears in list\r\n    ‚Üì\r\nRaid starts\r\n    ‚Üì\r\nGroup invite sent (to AI)\r\n    ‚Üì\r\nAI auto-accepts\r\n    ‚Üì\r\nGROUP_MATCH_INVITE_ACCEPT notification\r\n    ‚Üì\r\nSpawn bot with profile\r\n```\r\n\r\n### Modern SPT 4.0.x Flow\r\n\r\n```\r\n/add command\r\n    ‚Üì\r\nGenerate PmcData profile (C#)\r\n    ‚Üì\r\nSave profile (SaveServer)\r\n    ‚Üì\r\nAdd directly to FriendProfileIds (no request)\r\n    ‚Üì\r\nSend friendListRequestAccept notification\r\n    ‚Üì\r\nFriend appears in list immediately\r\n    ‚Üì\r\nRaid starts\r\n    ‚Üì\r\nOverride /client/match/group/current\r\n    ‚Üì\r\nReturn Squad array with AI PMCs\r\n    ‚Üì\r\nClient spawns bots from profiles\r\n```\r\n\r\n**Key Changes**:\r\n- ‚úÖ Direct friend addition (simpler, no handshake)\r\n- ‚úÖ Group created implicitly on raid start\r\n- ‚úÖ No invite/accept cycle needed (single-player context)\r\n- ‚úÖ Cleaner notification flow\r\n\r\n---\r\n\r\n## File Reference\r\n\r\n| System | File | Lines | Purpose |\r\n|--------|------|-------|---------|\r\n| Friend Storage | `SptProfile.cs` | 52-55 | FriendProfileIds HashSet |\r\n| Friend Ops | `DialogueController.cs` | 589-640 | Send/delete friends |\r\n| Friend List | `DialogueController.cs` | 69-109 | Get friends + chatbots |\r\n| Group Model | `GroupCharacter.cs` | 7-59 | Group member structure |\r\n| Group Routes | `MatchStaticRouter.cs` | 32-119 | Group operations |\r\n| Match Controller | `MatchController.cs` | 34-144 | Raid configuration |\r\n| Notifications | `NotificationSendHelper.cs` | 30-104 | Send notifications |\r\n| Notification Queue | `NotificationService.cs` | 10-70 | Queue management |\r\n| Profile Helper | `ProfileHelper.cs` | 249-275 | Friend data formatting |\r\n\r\n---\r\n\r\n**This provides the complete modern SPT 4.0.x approach to implementing FriendlyPMC's squad system!**\r\n"},"SPT-MOD-LIFECYCLE":{"title":"SPT Mod Lifecycle & Load Order - Complete Guide\r","category":"General","content":"# SPT Mod Lifecycle & Load Order - Complete Guide\r\n\r\n**Source**: SPT v4.0.x C# Source Code\r\n**Status**: ‚úÖ SOURCE-VERIFIED\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [Lifecycle Interfaces](#lifecycle-interfaces)\r\n2. [Load Order Constants](#load-order-constants)\r\n3. [Complete Startup Sequence](#complete-startup-sequence)\r\n4. [Update Loop](#update-loop)\r\n5. [Mod Integration Points](#mod-integration-points)\r\n6. [Visual Diagrams](#visual-diagrams)\r\n7. [Common Scenarios](#common-scenarios)\r\n\r\n---\r\n\r\n## Lifecycle Interfaces\r\n\r\n### IOnLoad\r\n\r\n**Location**: `SPTarkov.Server.Core/DI/IOnLoad.cs`\r\n\r\n```csharp\r\npublic interface IOnLoad\r\n{\r\n    Task OnLoad();\r\n}\r\n```\r\n\r\n**Purpose**: One-time initialization during server startup\r\n\r\n**When**: Called once during `App.InitializeAsync()` in TypePriority order\r\n\r\n**Use cases**:\r\n- Initialize services\r\n- Modify database\r\n- Register routes\r\n- Load configuration\r\n- Setup state\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MyMod(ISptLogger<MyMod> logger, DatabaseService db) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        logger.Info(\"Mod initializing...\");\r\n        // Database is available here\r\n        var items = db.GetItems();\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### IOnUpdate\r\n\r\n**Location**: `SPTarkov.Server.Core/DI/IOnUpdate.cs`\r\n\r\n```csharp\r\npublic interface IOnUpdate\r\n{\r\n    Task<bool> OnUpdate(long secondsSinceLastRun);\r\n}\r\n```\r\n\r\n**Purpose**: Periodic background tasks\r\n\r\n**Parameters**:\r\n- `secondsSinceLastRun`: Seconds since this component last returned `true`\r\n\r\n**Returns**:\r\n- `true`: Reset timer (updates `_onUpdateLastRun`)\r\n- `false`: Don't reset timer (will be called again in ~5 seconds)\r\n\r\n**When**: Called every ~5 seconds in background loop\r\n\r\n**Use cases**:\r\n- Profile auto-save\r\n- Trader inventory refresh\r\n- Insurance processing\r\n- Hideout production\r\n- Mail/dialogue updates\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable(TypePriority = OnUpdateOrder.HideoutCallbacks)]\r\npublic class HideoutCallbacks(\r\n    HideoutController hideoutController,\r\n    ConfigServer configServer\r\n) : IOnUpdate\r\n{\r\n    protected readonly HideoutConfig HideoutConfig = configServer.GetConfig<HideoutConfig>();\r\n\r\n    public Task<bool> OnUpdate(long secondsSinceLastRun)\r\n    {\r\n        // Rate limiting\r\n        if (secondsSinceLastRun < HideoutConfig.RunIntervalSeconds)\r\n        {\r\n            return Task.FromResult(false);  // Skip this run\r\n        }\r\n\r\n        // Perform update\r\n        hideoutController.Update();\r\n\r\n        return Task.FromResult(true);  // Reset timer\r\n    }\r\n}\r\n```\r\n\r\n**Source**: `SPTarkov.Server.Core/Callbacks/HideoutCallbacks.cs:13`\r\n\r\n---\r\n\r\n### IPreSptLoadModAsync\r\n\r\n**Location**: `SPTarkov.Server.Core/Models/External/IPreSptLoadModAsync.cs`\r\n\r\n```csharp\r\n/// <summary>\r\n/// Interface used to make changes before any of the SPT server logic runs.\r\n/// After the Watermark print, but before the Database loads\r\n/// </summary>\r\npublic interface IPreSptLoadModAsync\r\n{\r\n    Task PreSptLoadAsync();\r\n}\r\n```\r\n\r\n**When**: Priority `OnLoadOrder.PreSptModLoader` (100000) - Before database loads\r\n\r\n**Use cases**:\r\n- Pre-database setup\r\n- Register custom database importers\r\n- Prepare for database load\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable]\r\npublic class MyPreDatabaseMod : IPreSptLoadModAsync\r\n{\r\n    public Task PreSptLoadAsync()\r\n    {\r\n        Console.WriteLine(\"Running before database loads!\");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### IOnWebAppBuildModAsync\r\n\r\n**Location**: `SPTarkov.Server.Core/Models/External/IOnWebAppBuildModAsync.cs`\r\n\r\n```csharp\r\n/// <summary>\r\n/// This class now runs when the Kestrel server is being configured/built,\r\n/// making it the perfect spot to change server configurations.\r\n/// </summary>\r\npublic interface IOnWebAppBuildModAsync\r\n{\r\n    Task OnWebAppBuildAsync();\r\n}\r\n```\r\n\r\n**When**: During Kestrel server configuration, BEFORE any IOnLoad\r\n\r\n**Use cases**:\r\n- Modify HTTP server settings\r\n- Configure TLS/SSL\r\n- Add custom middleware\r\n- Change server ports\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable]\r\npublic class MyServerConfigMod : IOnWebAppBuildModAsync\r\n{\r\n    public Task OnWebAppBuildAsync()\r\n    {\r\n        // Configure server\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Load Order Constants\r\n\r\n### OnLoadOrder\r\n\r\n**Location**: `SPTarkov.Server.Core/DI/OnLoadOrder.cs`\r\n\r\n```csharp\r\npublic static class OnLoadOrder\r\n{\r\n    public const int Watermark = 0;                 // Display version info\r\n    public const int PreSptModLoader = 100000;      // Pre-database mod hook\r\n    public const int Database = 200000;             // Database import\r\n    public const int GameCallbacks = 300000;        // Game initialization\r\n    public const int PostDBModLoader = 400000;      // Post-database mod hook ‚≠ê\r\n    public const int TraderRegistration = 500000;   // (Reserved)\r\n    public const int HandbookCallbacks = 600000;    // Handbook init\r\n    public const int SaveCallbacks = 700000;        // Profile loading\r\n    public const int TraderCallbacks = 800000;      // Trader init\r\n    public const int PresetCallbacks = 900000;      // Preset init\r\n    public const int RagfairCallbacks = 1000000;    // Flea market init\r\n    public const int PostSptModLoader = 1100000;    // Final mod hook ‚≠ê\r\n}\r\n```\r\n\r\n**Most used by mods**:\r\n- `PostDBModLoader + 1` (400001) - Modify database after it loads\r\n- `PostSptModLoader + 1` (1100001) - Final modifications after all systems load\r\n\r\n---\r\n\r\n### OnUpdateOrder\r\n\r\n**Location**: `SPTarkov.Server.Core/DI/OnUpdateOrder.cs`\r\n\r\n```csharp\r\npublic static class OnUpdateOrder\r\n{\r\n    public const int DialogueCallbacks = 1000;\r\n    public const int HideoutCallbacks = 2000;\r\n    public const int InsuranceCallbacks = 3000;\r\n    public const int BtrDeliveryCallbacks = 4000;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Complete Startup Sequence\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  1. Program.Main()                                            ‚îÇ\r\n‚îÇ     ‚îî‚îÄ> StartServer()                                         ‚îÇ\r\n‚îÇ         ‚îú‚îÄ> ProgramStatics.Initialize()                       ‚îÇ\r\n‚îÇ         ‚îú‚îÄ> CreateNewHostBuilder()                            ‚îÇ\r\n‚îÇ         ‚îî‚îÄ> DependencyInjectionHandler setup                  ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  2. Scan & Register                                           ‚îÇ\r\n‚îÇ     ‚îú‚îÄ> AddInjectableTypesFromTypeAssembly(typeof(Program))   ‚îÇ\r\n‚îÇ     ‚îú‚îÄ> AddInjectableTypesFromTypeAssembly(typeof(App))       ‚îÇ\r\n‚îÇ     ‚îú‚îÄ> ModDllLoader.LoadAllMods()                            ‚îÇ\r\n‚îÇ     ‚îú‚îÄ> AddInjectableTypesFromAssemblies(mod assemblies)      ‚îÇ\r\n‚îÇ     ‚îî‚îÄ> InjectAll() - Register all by TypePriority            ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  3. Configure Kestrel (Web Server)                            ‚îÇ\r\n‚îÇ     ‚îî‚îÄ> OnWebAppBuildModLoader.OnLoad()                       ‚îÇ\r\n‚îÇ         ‚îî‚îÄ> IOnWebAppBuildModAsync.OnWebAppBuildAsync()       ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  4. Build & Startup                                           ‚îÇ\r\n‚îÇ     ‚îú‚îÄ> app = builder.Build()                                 ‚îÇ\r\n‚îÇ     ‚îî‚îÄ> SptServerStartupService.Startup()                     ‚îÇ\r\n‚îÇ         ‚îú‚îÄ> BundleLoader.LoadBundlesAsync() (if mods)         ‚îÇ\r\n‚îÇ         ‚îî‚îÄ> App.InitializeAsync()                             ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  5. App.InitializeAsync() - Execute IOnLoad by Priority       ‚îÇ\r\n‚îÇ                                                               ‚îÇ\r\n‚îÇ     [0] Watermark                                             ‚îÇ\r\n‚îÇ         ‚Ä¢ Display SPT version                                 ‚îÇ\r\n‚îÇ         ‚Ä¢ Show warnings                                       ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [100000] PreSptModLoader                                  ‚îÇ\r\n‚îÇ         ‚Ä¢ Execute IPreSptLoadModAsync mods                    ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [200000] DatabaseImporter                                 ‚îÇ\r\n‚îÇ         ‚Ä¢ Load SPT_Data/database/ JSON files                  ‚îÇ\r\n‚îÇ         ‚Ä¢ Populate DatabaseServer                             ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [300000] GameCallbacks                                    ‚îÇ\r\n‚îÇ         ‚Ä¢ Initialize game state                               ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [400000+] PostDBModLoader Space ‚≠ê                        ‚îÇ\r\n‚îÇ         ‚Ä¢ Mod initialization                                  ‚îÇ\r\n‚îÇ         ‚Ä¢ Database modifications                              ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [600000] HandbookCallbacks                                ‚îÇ\r\n‚îÇ         ‚Ä¢ Initialize handbook                                 ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [700000] SaveCallbacks                                    ‚îÇ\r\n‚îÇ         ‚Ä¢ Load player profiles                                ‚îÇ\r\n‚îÇ         ‚Ä¢ Start backup system                                 ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [800000] TraderCallbacks                                  ‚îÇ\r\n‚îÇ         ‚Ä¢ Initialize traders                                  ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [900000] PresetCallbacks                                  ‚îÇ\r\n‚îÇ         ‚Ä¢ Initialize weapon presets                           ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [1000000] RagfairCallbacks                                ‚îÇ\r\n‚îÇ         ‚Ä¢ Initialize flea market                              ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [1100000+] PostSptModLoader Space ‚≠ê                      ‚îÇ\r\n‚îÇ         ‚Ä¢ Final mod initialization                            ‚îÇ\r\n‚îÇ         ‚Ä¢ All SPT systems available                           ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     ‚úì Initialization complete                                ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  6. Start Background Tasks                                    ‚îÇ\r\n‚îÇ     ‚îî‚îÄ> Task.Run(Update) - Start update loop                  ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  7. Server Ready                                              ‚îÇ\r\n‚îÇ     ‚îú‚îÄ> app.RunAsync() - Accept HTTP requests                 ‚îÇ\r\n‚îÇ     ‚îî‚îÄ> Update loop runs every 5 seconds                      ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n```\r\n\r\n**Source**: `SPTarkov.Server.Core/Utils/App.cs`, `SPTarkov.Server/Program.cs`\r\n\r\n---\r\n\r\n## Update Loop\r\n\r\n**Location**: `SPTarkov.Server.Core/Utils/App.cs:Update()`\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  UPDATE LOOP (Every ~5 seconds)                               ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚îÇ\r\n              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n              ‚îÇ  While server running     ‚îÇ\r\n              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  For each IOnUpdate in TypePriority order:                    ‚îÇ\r\n‚îÇ                                                               ‚îÇ\r\n‚îÇ     [1000] DialogueCallbacks                                  ‚îÇ\r\n‚îÇ         ‚Ä¢ Update mail/dialogue                                ‚îÇ\r\n‚îÇ         ‚Ä¢ Always runs (no rate limit)                         ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [2000] HideoutCallbacks                                   ‚îÇ\r\n‚îÇ         ‚Ä¢ Check: enough time passed?                          ‚îÇ\r\n‚îÇ         ‚Ä¢ Update hideout production                           ‚îÇ\r\n‚îÇ         ‚Ä¢ Return: true if updated, false if skipped           ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [3000] InsuranceCallbacks                                 ‚îÇ\r\n‚îÇ         ‚Ä¢ Check: enough time passed?                          ‚îÇ\r\n‚îÇ         ‚Ä¢ Process insurance returns                           ‚îÇ\r\n‚îÇ         ‚Ä¢ Return: true if processed, false if skipped         ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [4000] BtrDeliveryCallbacks                               ‚îÇ\r\n‚îÇ         ‚Ä¢ Check: enough time passed?                          ‚îÇ\r\n‚îÇ         ‚Ä¢ Process BTR deliveries                              ‚îÇ\r\n‚îÇ         ‚Ä¢ Return: true if processed, false if skipped         ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [default] SaveCallbacks                                   ‚îÇ\r\n‚îÇ         ‚Ä¢ Check: enough time passed?                          ‚îÇ\r\n‚îÇ         ‚Ä¢ Save all profiles                                   ‚îÇ\r\n‚îÇ         ‚Ä¢ Return: true if saved, false if skipped             ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [default] TraderCallbacks                                 ‚îÇ\r\n‚îÇ         ‚Ä¢ Update traders                                      ‚îÇ\r\n‚îÇ         ‚Üì                                                     ‚îÇ\r\n‚îÇ     [default] RagfairCallbacks                                ‚îÇ\r\n‚îÇ         ‚Ä¢ Add player offers (once)                            ‚îÇ\r\n‚îÇ         ‚Ä¢ Process offer sales/expiration                      ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚îÇ\r\n                            ‚Üì\r\n              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n              ‚îÇ  await Task.Delay(5000)  ‚îÇ\r\n              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                            ‚îÇ\r\n                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> (Loop repeats)\r\n```\r\n\r\n---\r\n\r\n## Mod Integration Points\r\n\r\n### Mod Hook 1: IOnWebAppBuildModAsync (Earliest)\r\n\r\n**Priority**: N/A (runs before priority system)\r\n**Database**: ‚ùå Not loaded\r\n**When**: During Kestrel server configuration\r\n\r\n**Use for**:\r\n- HTTP server configuration\r\n- TLS/SSL setup\r\n- Custom middleware\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable]\r\npublic class MyServerConfig : IOnWebAppBuildModAsync\r\n{\r\n    public Task OnWebAppBuildAsync()\r\n    {\r\n        // Configure Kestrel\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Mod Hook 2: IPreSptLoadModAsync\r\n\r\n**Priority**: `OnLoadOrder.PreSptModLoader` (100000)\r\n**Database**: ‚ùå Not loaded yet\r\n**When**: After Watermark, before database import\r\n\r\n**Use for**:\r\n- Pre-database preparation\r\n- Register custom importers\r\n- Early initialization\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable]\r\npublic class MyPreDatabaseMod : IPreSptLoadModAsync\r\n{\r\n    public Task PreSptLoadAsync()\r\n    {\r\n        Console.WriteLine(\"Before database!\");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Mod Hook 3: PostDBModLoader (Most Common ‚≠ê)\r\n\r\n**Priority**: `OnLoadOrder.PostDBModLoader + offset` (400000+)\r\n**Database**: ‚úÖ Available\r\n**When**: After database imports, before game callbacks\r\n\r\n**Use for**:\r\n- Add/modify items\r\n- Add/modify quests\r\n- Modify bot loadouts\r\n- Add custom content\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MyDatabaseMod(DatabaseService db, ISptLogger<MyDatabaseMod> logger) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var items = db.GetItems();  // ‚úÖ Database available!\r\n\r\n        // Modify items, add content, etc.\r\n        logger.Info(\"Database modified!\");\r\n\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Mod Hook 4: PostSptModLoader (Latest)\r\n\r\n**Priority**: `OnLoadOrder.PostSptModLoader + offset` (1100000+)\r\n**Database**: ‚úÖ Available\r\n**All Systems**: ‚úÖ Traders, Ragfair, Profiles all initialized\r\n\r\n**Use for**:\r\n- Final modifications\r\n- Override SPT defaults\r\n- Modify fully-initialized systems\r\n- Register HTTP routes\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostSptModLoader + 1)]\r\npublic class MyFinalMod(ISptLogger<MyFinalMod> logger) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        logger.Info(\"All SPT systems available!\");\r\n\r\n        // Modify traders, ragfair, etc.\r\n\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Mod Hook 5: IOnUpdate (Periodic)\r\n\r\n**Priority**: `OnUpdateOrder.* + offset` or custom\r\n**When**: Every ~5 seconds, continuously\r\n\r\n**Use for**:\r\n- Periodic background tasks\r\n- Scheduled maintenance\r\n- Time-based updates\r\n\r\n**Example**:\r\n```csharp\r\n[Injectable(TypePriority = OnUpdateOrder.BtrDeliveryCallbacks + 100)]\r\npublic class MyPeriodicMod(ISptLogger<MyPeriodicMod> logger) : IOnUpdate\r\n{\r\n    public Task<bool> OnUpdate(long secondsSinceLastRun)\r\n    {\r\n        // Run every 60 seconds\r\n        if (secondsSinceLastRun < 60)\r\n            return Task.FromResult(false);\r\n\r\n        logger.Debug(\"Periodic task running\");\r\n\r\n        // Do work...\r\n\r\n        return Task.FromResult(true);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Visual Diagrams\r\n\r\n### Complete Initialization Timeline\r\n\r\n```\r\nTIME ‚Üí\r\n‚îÇ\r\n0s      Watermark (Priority 0)\r\n‚îÇ       ‚îú‚îÄ> Display version\r\n‚îÇ       ‚îî‚îÄ> Show warnings\r\n‚îÇ\r\n‚îÇ     PreSptModLoader (Priority 100000)\r\n‚îÇ       ‚îî‚îÄ> IPreSptLoadModAsync mods execute\r\n‚îÇ\r\n‚îÇ     DatabaseImporter (Priority 200000)\r\n‚îÇ       ‚îú‚îÄ> Load items.json\r\n‚îÇ       ‚îú‚îÄ> Load traders/\r\n‚îÇ       ‚îú‚îÄ> Load locales/\r\n‚îÇ       ‚îú‚îÄ> Load locations/\r\n‚îÇ       ‚îî‚îÄ> Database ready ‚úì\r\n‚îÇ\r\n‚îÇ     GameCallbacks (Priority 300000)\r\n‚îÇ       ‚îî‚îÄ> GameController.Load()\r\n‚îÇ\r\n‚îÇ     ‚≠ê MOD SPACE - PostDBModLoader (400000-599999)\r\n‚îÇ       ‚îî‚îÄ> Your mods: database modifications\r\n‚îÇ\r\n‚îÇ     HandbookCallbacks (Priority 600000)\r\n‚îÇ       ‚îî‚îÄ> HandBookController.Load()\r\n‚îÇ\r\n‚îÇ     SaveCallbacks (Priority 700000)\r\n‚îÇ       ‚îú‚îÄ> Load all profiles\r\n‚îÇ       ‚îî‚îÄ> Start backup system\r\n‚îÇ\r\n‚îÇ     TraderCallbacks (Priority 800000)\r\n‚îÇ       ‚îî‚îÄ> TraderController.Load()\r\n‚îÇ\r\n‚îÇ     PresetCallbacks (Priority 900000)\r\n‚îÇ       ‚îî‚îÄ> PresetController.Initialize()\r\n‚îÇ\r\n‚îÇ     RagfairCallbacks (Priority 1000000)\r\n‚îÇ       ‚îî‚îÄ> RagfairServer.Load()\r\n‚îÇ\r\n‚îÇ     ‚≠ê MOD SPACE - PostSptModLoader (1100000+)\r\n‚îÇ       ‚îî‚îÄ> Your mods: final modifications\r\n‚îÇ\r\n‚îÇ     ‚úì Initialization Complete\r\n‚îÇ\r\n‚îÇ     Update Loop Starts\r\n‚îÇ       ‚îî‚îÄ> Task.Run(Update) - every 5 seconds\r\n‚îÇ\r\n‚îÇ     Server Accepts Requests\r\n‚îÇ       ‚îî‚îÄ> app.RunAsync()\r\n‚îÇ\r\n```\r\n\r\n---\r\n\r\n## Common Scenarios\r\n\r\n### Scenario 1: Add Custom Items\r\n\r\n**Timing**: After database loads\r\n**Priority**: `PostDBModLoader + 1`\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class AddItemsMod(CustomItemService customItemService) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        // Database available, add items\r\n        customItemService.CreateItemFromClone(/* ... */);\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Scenario 2: Modify Traders\r\n\r\n**Timing**: After traders initialize\r\n**Priority**: `PostSptModLoader + 1`\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostSptModLoader + 1)]\r\npublic class ModifyTradersMod(DatabaseService db) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        // All traders initialized\r\n        var traders = db.GetTraders();\r\n        // Modify trader inventories\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Scenario 3: Register HTTP Routes\r\n\r\n**Timing**: Any time (auto-discovered)\r\n**Priority**: Default or custom\r\n\r\n```csharp\r\n[Injectable]\r\npublic class MyRouter(JsonUtil jsonUtil) : StaticRouter(jsonUtil,\r\n[\r\n    new RouteAction<EmptyRequestData>(\r\n        \"/my/route\",\r\n        async (url, info, sessionId, output) =>\r\n            jsonUtil.Serialize(new { status = \"ok\" })\r\n    )\r\n])\r\n{\r\n    // Router auto-registered by DI\r\n}\r\n```\r\n\r\n---\r\n\r\n### Scenario 4: Periodic Profile Save\r\n\r\n**Timing**: Every N seconds\r\n**Priority**: Custom update priority\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnUpdateOrder.BtrDeliveryCallbacks + 100)]\r\npublic class AutoSaveMod(SaveServer saveServer, ConfigServer configServer) : IOnUpdate\r\n{\r\n    private readonly int _interval = 300;  // 5 minutes\r\n\r\n    public async Task<bool> OnUpdate(long secondsSinceLastRun)\r\n    {\r\n        if (secondsSinceLastRun < _interval)\r\n            return false;\r\n\r\n        await saveServer.SaveAsync();\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Load Order Decision Matrix\r\n\r\n| Mod Needs To... | Recommended Priority | Interfaces |\r\n|-----------------|---------------------|------------|\r\n| Configure HTTP server | N/A | `IOnWebAppBuildModAsync` |\r\n| Run before database | `PreSptModLoader` | `IPreSptLoadModAsync` |\r\n| Add items to database | `PostDBModLoader + 1` | `IOnLoad` |\r\n| Modify items in database | `PostDBModLoader + 1` | `IOnLoad` |\r\n| Add quests | `PostDBModLoader + 1` | `IOnLoad` |\r\n| Modify traders | `PostSptModLoader + 1` | `IOnLoad` |\r\n| Register routes | Default or `PostSptModLoader + 1` | Just inherit `StaticRouter` |\r\n| Periodic tasks | Custom (e.g., `5000`) | `IOnUpdate` |\r\n| Modify profiles | `PostDBModLoader + 1` | `IOnLoad` + access via SaveServer |\r\n\r\n---\r\n\r\n## Priority Offset Guidelines\r\n\r\n**Conservative** (Recommended):\r\n```csharp\r\n// Single digit offsets\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\n[Injectable(TypePriority = OnLoadOrder.PostSptModLoader + 1)]\r\n```\r\n\r\n**Multiple dependent mods**:\r\n```csharp\r\n// Base mod\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class BaseMod : IOnLoad { }\r\n\r\n// Dependent mod (loads after base)\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 2)]\r\npublic class DependentMod : IOnLoad { }\r\n\r\n// Another dependent (loads after both)\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 3)]\r\npublic class FinalMod : IOnLoad { }\r\n```\r\n\r\n**No timing requirement**:\r\n```csharp\r\n// Defaults to int.MaxValue (loads last)\r\n[Injectable]\r\npublic class GenericMod : IOnLoad { }\r\n```\r\n\r\n---\r\n\r\n## Best Practices\r\n\r\n### ‚úÖ DO\r\n\r\n**1. Use Correct Priority**\r\n```csharp\r\n// ‚úÖ Database modifications\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\n\r\n// ‚úÖ Final modifications\r\n[Injectable(TypePriority = OnLoadOrder.PostSptModLoader + 1)]\r\n```\r\n\r\n**2. Rate-Limit IOnUpdate**\r\n```csharp\r\npublic Task<bool> OnUpdate(long secondsSinceLastRun)\r\n{\r\n    if (secondsSinceLastRun < _config.IntervalSeconds)\r\n        return Task.FromResult(false);\r\n\r\n    // Do work\r\n    return Task.FromResult(true);\r\n}\r\n```\r\n\r\n**3. Log Initialization**\r\n```csharp\r\npublic Task OnLoad()\r\n{\r\n    logger.Info(\"Mod initialized!\");\r\n    return Task.CompletedTask;\r\n}\r\n```\r\n\r\n**4. Handle Errors**\r\n```csharp\r\npublic Task OnLoad()\r\n{\r\n    try\r\n    {\r\n        // Initialization code\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        logger.Error($\"Init failed: {ex.Message}\");\r\n    }\r\n    return Task.CompletedTask;\r\n}\r\n```\r\n\r\n---\r\n\r\n### ‚ùå DON'T\r\n\r\n**1. Access Database Before It Loads**\r\n```csharp\r\n// ‚ùå WRONG\r\n[Injectable(TypePriority = OnLoadOrder.Database - 1)]\r\npublic class TooEarly(DatabaseService db) : IOnLoad { }\r\n```\r\n\r\n**2. Forget TypePriority**\r\n```csharp\r\n// ‚ùå WRONG - Runs at int.MaxValue (very late!)\r\n[Injectable]\r\npublic class NeedsToRunEarly(DatabaseService db) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        // Might run after other systems expect database\r\n    }\r\n}\r\n```\r\n\r\n**3. Return False Forever in IOnUpdate**\r\n```csharp\r\n// ‚ùå WRONG - Never resets timer!\r\npublic Task<bool> OnUpdate(long secondsSinceLastRun)\r\n{\r\n    DoWork();\r\n    return Task.FromResult(false);  // Timer never resets!\r\n}\r\n```\r\n\r\n**4. Block in IOnUpdate**\r\n```csharp\r\n// ‚ùå WRONG - Blocks update loop!\r\npublic Task<bool> OnUpdate(long secondsSinceLastRun)\r\n{\r\n    Thread.Sleep(10000);  // Blocks for 10 seconds!\r\n    return Task.FromResult(true);\r\n}\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\nSPT mod lifecycle provides:\r\n\r\n- **Ordered initialization** via TypePriority\r\n- **Multiple integration points** (PreLoad, PostDB, PostSPT)\r\n- **Periodic updates** via IOnUpdate\r\n- **Clear timing guarantees** for database availability\r\n\r\n**Key Takeaways**:\r\n1. Use `OnLoadOrder.PostDBModLoader + 1` for database modifications\r\n2. Use `OnLoadOrder.PostSptModLoader + 1` for final modifications\r\n3. Use `IOnUpdate` with rate limiting for periodic tasks\r\n4. Never access database before `OnLoadOrder.Database` (200000)\r\n5. Log initialization steps for debugging\r\n\r\n---\r\n\r\n**Key Files**:\r\n- `SPTarkov.Server.Core/DI/IOnLoad.cs`\r\n- `SPTarkov.Server.Core/DI/IOnUpdate.cs`\r\n- `SPTarkov.Server.Core/DI/OnLoadOrder.cs`\r\n- `SPTarkov.Server.Core/Utils/App.cs`\r\n"},"SPT-PMC-SPAWN-SYSTEM":{"title":"SPT PMC Spawn System - Complete Reference\r","category":"General","content":"# SPT PMC Spawn System - Complete Reference\r\n\r\n**Purpose**: Deep dive into SPT PMC spawning mechanics for SVM modifications\r\n**For**: AGENT5 - Adjusting spawn zones/triggers when needed\r\n**Last Updated**: 2025-11-22\r\n\r\n---\r\n\r\n## üéØ Quick Reference\r\n\r\n**Current SVM Settings Working**:\r\n- 24 PMCs on Interchange ‚úÖ\r\n- 6 waves, 150s spacing ‚úÖ\r\n- lastWave=1200s (20 min) ‚úÖ\r\n- maxWaves=8 configured ‚úÖ\r\n\r\n**If PMCs don't spawn**, adjust:\r\n1. PmcBotZones (spawn point restrictions)\r\n2. PmcBotTriggers (conditional spawning)\r\n3. Wave timing parameters\r\n4. Spawn point availability\r\n\r\n---\r\n\r\n## üìö Core SPT Spawn Configuration\r\n\r\n### Location Structure\r\n\r\n**Path**: `SPT/SPT_Data/configs/location/{mapname}/base.json`\r\n\r\n```json\r\n{\r\n  \"BotLocationModifier\": {\r\n    \"PmcBotMax\": 24,           // Max PMCs total\r\n    \"PmcBotStart\": 0,          // PMCs at raid start\r\n    \"PmcBotTriggers\": [],      // Spawn triggers (cleared in SVM)\r\n    \"PmcBotSpawnPeriodCheck\": 20,    // Check interval (seconds)\r\n    \"PmcBotZones\": []          // Spawn zone restrictions\r\n  },\r\n  \"waves\": [\r\n    {\r\n      \"number\": 0,\r\n      \"time_min\": 1,\r\n      \"time_max\": 1,\r\n      \"slots_min\": 2,\r\n      \"slots_max\": 4,\r\n      \"SpawnPoints\": \"SpawnZoneInterchange1,SpawnZoneInterchange2\",\r\n      \"BotSide\": \"Savage\",\r\n      \"BotPreset\": \"normal\",\r\n      \"WildSpawnType\": \"assault\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n---\r\n\r\n## üîß BotLocationModifier Settings\r\n\r\n### PMC-Specific Properties\r\n\r\n| Property | Default | SVM Override | Purpose |\r\n|----------|---------|--------------|---------|\r\n| `PmcBotMax` | 4-8 | 24 | Total PMCs for raid |\r\n| `PmcBotStart` | 1-3 | 0 | PMCs at start (usually 0) |\r\n| `PmcBotSpawnPeriodCheck` | 20 | N/A | Seconds between spawn checks |\r\n| `PmcBotTriggers` | Array | `[]` | Conditional spawn triggers |\r\n| `PmcBotZones` | Array | N/A | Zone restrictions |\r\n\r\n---\r\n\r\n### PmcBotZones\r\n\r\n**Purpose**: Restrict PMC spawning to specific zones\r\n\r\n**Format**:\r\n```json\r\n\"PmcBotZones\": [\r\n  {\r\n    \"SpawnPoints\": \"SpawnZoneInterchange1,SpawnZoneInterchange2\",\r\n    \"Min\": 1,\r\n    \"Max\": 2\r\n  }\r\n]\r\n```\r\n\r\n**Empty array** (`[]`) = **PMCs can spawn in ANY zone** ‚úÖ\r\n\r\n**If PMCs not spawning**: Zones may be too restrictive or invalid\r\n**Fix**: Keep as `[]` (already done in SVM) or specify valid zones\r\n\r\n---\r\n\r\n### PmcBotTriggers\r\n\r\n**Purpose**: Conditional PMC spawning (time-based, player-based, etc.)\r\n\r\n**Example**:\r\n```json\r\n\"PmcBotTriggers\": [\r\n  {\r\n    \"TriggerId\": \"autoId0\",\r\n    \"TriggerName\": \"interactWith_000\",\r\n    \"Delay\": 60\r\n  }\r\n]\r\n```\r\n\r\n**SVM clears this** (`PmcBotTriggers = []`) ‚úÖ\r\n\r\n**Why**: Triggers can prevent spawning if conditions not met\r\n**Result**: PMCs spawn on wave timing only (not conditional)\r\n\r\n---\r\n\r\n## üåä Wave System\r\n\r\n### Wave Generation Algorithm\r\n\r\n**From**: SPT `BotLocationSpawn.cs` (estimated based on SVM behavior)\r\n\r\n**Formula**:\r\n```\r\ntotalPMCs = PmcBotMax - PmcBotStart\r\nmaxWaves = configured (default 8, SVM sets this)\r\nlastWaveTime = configured (default 1200s)\r\n\r\nwaveInterval = lastWaveTime / maxWaves\r\n// Example: 1200 / 8 = 150 seconds\r\n\r\nwaveCount = Min(maxWaves, totalPMCs / avgGroupSize)\r\n// If 24 PMCs, avg group 4 = 6 groups = 6 waves\r\n\r\nWave Times:\r\n  Wave 1: ~1s (immediate)\r\n  Wave 2: ~151s (2.5 min)\r\n  Wave 3: ~301s (5 min)\r\n  Wave 4: ~451s (7.5 min)\r\n  Wave 5: ~601s (10 min)\r\n  Wave 6: ~751s (12.5 min)\r\n```\r\n\r\n**Your logs show exactly this** ‚úÖ\r\n\r\n---\r\n\r\n### Wave Composition\r\n\r\n**From**: `PmcConfig` ‚Üí `bot.json` PMC group settings\r\n\r\n**Group Weights** (from your SVM config):\r\n- Solo (1): 20%\r\n- Duo (2): 15%\r\n- Trio (3): 5%\r\n- Quad (4): 30%\r\n- Five (5): 30%\r\n\r\n**Distribution**:\r\n- 20% chance of 1-man groups\r\n- 15% chance of 2-man groups\r\n- 5% chance of 3-man groups\r\n- 30% chance of 4-man groups\r\n- 30% chance of 5-man groups\r\n\r\n**Average**: ~3.8 PMCs per wave\r\n**24 PMCs / 3.8** = ~6.3 waves = **6 waves** ‚úÖ\r\n\r\n---\r\n\r\n## üìç Spawn Point System\r\n\r\n### Spawn Zone Format\r\n\r\n**Location**: `SPT/SPT_Data/configs/location/{map}/base.json`\r\n\r\n**Example**:\r\n```json\r\n\"SpawnPointParams\": [\r\n  {\r\n    \"Id\": \"SpawnZoneInterchange1\",\r\n    \"Position\": {\r\n      \"x\": 100.5,\r\n      \"y\": 2.0,\r\n      \"z\": 50.3\r\n    },\r\n    \"Rotation\": 45.0,\r\n    \"Sides\": [\"Pmc\", \"Savage\"],\r\n    \"Categories\": [\"Player\", \"Boss\", \"Coop\"],\r\n    \"Infiltration\": \"\",\r\n    \"DelayToCanSpawnSec\": 4,\r\n    \"BotZoneName\": \"\"\r\n  }\r\n]\r\n```\r\n\r\n---\r\n\r\n### Spawn Point Selection\r\n\r\n**For PMC Waves**:\r\n\r\n1. **Filter by Side**: `Sides` must include \"Pmc\"\r\n2. **Filter by Category**: Must allow appropriate category\r\n3. **Check Delay**: `DelayToCanSpawnSec` must be elapsed\r\n4. **Check Availability**: Not occupied by player spawn\r\n5. **Random Selection**: From valid points\r\n\r\n**If no valid spawn points** ‚Üí PMCs don't spawn!\r\n\r\n---\r\n\r\n## üêõ Common Spawn Issues & Fixes\r\n\r\n### Issue 1: PMCs Not Spawning\r\n\r\n**Symptoms**:\r\n- Log shows waves scheduled (‚úÖ you have this)\r\n- No \"Generated: ... pmc\" lines\r\n- Telemetry shows 0 PMCs\r\n\r\n**Causes**:\r\n1. **No valid spawn points** - All restricted or occupied\r\n2. **Zone restrictions** - `PmcBotZones` too narrow\r\n3. **Trigger blocks** - `PmcBotTriggers` not satisfied\r\n4. **Category mismatch** - Spawn points don't allow PMC category\r\n\r\n**Solutions**:\r\n\r\n**A. Clear Zone Restrictions** (SVM already does this):\r\n```csharp\r\nbaseMap.BotLocationModifier.PmcBotZones = [];  // ‚úÖ Already done\r\n```\r\n\r\n**B. Clear Triggers** (SVM already does this):\r\n```csharp\r\nbaseMap.BotLocationModifier.PmcBotTriggers = [];  // ‚úÖ Already done\r\n```\r\n\r\n**C. If still failing - Add fallback spawn zones**:\r\n```csharp\r\n// Force use of \"any\" zone by adding all zones\r\nvar allZones = baseMap.SpawnPointParams\r\n    .Where(sp => sp.Sides.Contains(\"Pmc\"))\r\n    .Select(sp => sp.Id)\r\n    .ToList();\r\n\r\nif (allZones.Count > 0)\r\n{\r\n    baseMap.BotLocationModifier.PmcBotZones = new[]\r\n    {\r\n        new PmcBotZone\r\n        {\r\n            SpawnPoints = string.Join(\",\", allZones),\r\n            Min = 1,\r\n            Max = 5\r\n        }\r\n    };\r\n}\r\n```\r\n\r\n---\r\n\r\n### Issue 2: PMCs Spawn But Die Immediately\r\n\r\n**Symptoms**:\r\n- \"Generated: ... pmc\" in logs\r\n- Telemetry shows PMCs spawn then disappear\r\n- Bot count drops rapidly\r\n\r\n**Causes**:\r\n1. **Spawn in wall/void** - Invalid spawn point positions\r\n2. **Fall damage** - Spawn point too high\r\n3. **Instant conflict** - Spawn too close to player/enemies\r\n\r\n**Solutions**:\r\n\r\n**A. Validate Spawn Points**:\r\n```csharp\r\nforeach (var spawnPoint in baseMap.SpawnPointParams)\r\n{\r\n    if (spawnPoint.Sides.Contains(\"Pmc\"))\r\n    {\r\n        // Check position is valid\r\n        if (spawnPoint.Position.y < -100 || spawnPoint.Position.y > 1000)\r\n        {\r\n            logger.Warning($\"Suspicious spawn point: {spawnPoint.Id} at Y={spawnPoint.Position.y}\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**B. Increase Spawn Delay**:\r\n```csharp\r\nforeach (var spawnPoint in baseMap.SpawnPointParams)\r\n{\r\n    if (spawnPoint.Sides.Contains(\"Pmc\"))\r\n    {\r\n        spawnPoint.DelayToCanSpawnSec = Math.Max(spawnPoint.DelayToCanSpawnSec, 10);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Issue 3: Too Few Waves\r\n\r\n**Symptoms**:\r\n- Only 1-2 waves spawn\r\n- Log shows 6 waves planned but only 2 execute\r\n\r\n**Causes**:\r\n1. **Early last wave time** - Raid ends before waves complete\r\n2. **Spawn points exhausted** - All occupied\r\n3. **Max count reached early** - Groups too large\r\n\r\n**Solutions**:\r\n\r\n**A. Extend Last Wave Time**:\r\n```csharp\r\n// Calculate based on raid duration\r\nfloat raidDuration = baseMap.EscapeTimeLimit * 60;  // Convert to seconds\r\nfloat lastWaveTime = raidDuration * 0.8f;  // 80% of raid duration\r\n\r\n// Override in location modifier (if property exists)\r\n// baseMap.BotLocationModifier.PmcBotLastWave = lastWaveTime;\r\n```\r\n\r\n**B. Reduce Group Sizes**:\r\n```csharp\r\n// More solo/duo, fewer quads/quints\r\ncfg.PMC.GroupWeights.Solo = 40;   // 40%\r\ncfg.PMC.GroupWeights.Duo = 30;    // 30%\r\ncfg.PMC.GroupWeights.Trio = 20;   // 20%\r\ncfg.PMC.GroupWeights.Quad = 10;   // 10%\r\ncfg.PMC.GroupWeights.Five = 0;    // 0%\r\n// Result: ~2.0 PMCs/wave, 24 PMCs = 12 waves\r\n```\r\n\r\n---\r\n\r\n## üî¨ Advanced Debugging\r\n\r\n### Enable Detailed Spawn Logging\r\n\r\n**Add to SVM PMC section**:\r\n```csharp\r\nlogger.Info($\"[SVM] PMC Spawn Config for {mapId}:\");\r\nlogger.Info($\"  PmcBotMax: {baseMap.BotLocationModifier.PmcBotMax}\");\r\nlogger.Info($\"  PmcBotStart: {baseMap.BotLocationModifier.PmcBotStart}\");\r\nlogger.Info($\"  PmcBotSpawnPeriodCheck: {baseMap.BotLocationModifier.PmcBotSpawnPeriodCheck}\");\r\nlogger.Info($\"  PmcBotZones: {baseMap.BotLocationModifier.PmcBotZones.Length}\");\r\nlogger.Info($\"  PmcBotTriggers: {baseMap.BotLocationModifier.PmcBotTriggers.Length}\");\r\n\r\n// Count valid spawn points\r\nint pmcSpawnPoints = baseMap.SpawnPointParams.Count(sp => sp.Sides.Contains(\"Pmc\"));\r\nlogger.Info($\"  Valid PMC spawn points: {pmcSpawnPoints}\");\r\n```\r\n\r\n---\r\n\r\n### Monitor In-Game\r\n\r\n**F6 Debug Menu**:\r\n1. Enable \"Show Telemetry HUD\"\r\n2. Check \"Bot count\" increases over time\r\n3. Verify PMC vs Scav ratio\r\n\r\n**Expected**:\r\n- PMCs spawn in waves (every ~2.5 min)\r\n- Count increases from 0 ‚Üí 24 over 12.5 minutes\r\n- Final count: 24 PMCs + scavs\r\n\r\n---\r\n\r\n## üìñ SPT Spawn System Architecture\r\n\r\n### Bot Spawning Flow\r\n\r\n```\r\nRaid Start\r\n    ‚îÇ\r\n    ‚îú‚îÄ> BotsController.Init()\r\n    ‚îÇ   ‚îî‚îÄ> BotSpawner created\r\n    ‚îÇ\r\n    ‚îú‚îÄ> BotSpawner.Start()\r\n    ‚îÇ   ‚îî‚îÄ> BotWaveManager initialized\r\n    ‚îÇ\r\n    ‚îî‚îÄ> Update Loop\r\n        ‚îÇ\r\n        ‚îú‚îÄ> BotWaveManager.Update()\r\n        ‚îÇ   ‚îú‚îÄ> Check spawn period timer\r\n        ‚îÇ   ‚îú‚îÄ> Check if can spawn PMCs\r\n        ‚îÇ   ‚îÇ   ‚îú‚îÄ> PmcBotMax not reached?\r\n        ‚îÇ   ‚îÇ   ‚îú‚îÄ> Trigger conditions met?\r\n        ‚îÇ   ‚îÇ   ‚îî‚îÄ> Valid spawn points exist?\r\n        ‚îÇ   ‚îÇ\r\n        ‚îÇ   ‚îî‚îÄ> If yes: GenerateWave()\r\n        ‚îÇ       ‚îú‚îÄ> Select group size\r\n        ‚îÇ       ‚îú‚îÄ> Select spawn points\r\n        ‚îÇ       ‚îú‚îÄ> Create bot profiles\r\n        ‚îÇ       ‚îî‚îÄ> Spawn bots\r\n        ‚îÇ\r\n        ‚îî‚îÄ> Logs: \"Generated: {count} pmc at {time}s\"\r\n```\r\n\r\n---\r\n\r\n### Spawn Timing Parameters\r\n\r\n**BotLocationModifier Properties**:\r\n```json\r\n{\r\n  \"PmcBotStart\": 0,                // Immediate PMCs (raid start)\r\n  \"PmcBotMax\": 24,                 // Total PMC limit\r\n  \"PmcBotSpawnPeriodCheck\": 20,    // Check every 20 seconds\r\n  // Internal calculation uses lastWave time and maxWaves\r\n}\r\n```\r\n\r\n**Wave Spacing Calculation** (from SVM behavior):\r\n```\r\nwaveInterval = lastWaveTime / maxWaves\r\nExample: 1200s / 8 = 150 seconds per wave\r\n```\r\n\r\n---\r\n\r\n## üó∫Ô∏è Spawn Zone System\r\n\r\n### SpawnPointParams Structure\r\n\r\n```json\r\n{\r\n  \"Id\": \"SpawnZoneInterchange1\",\r\n  \"Position\": { \"x\": 100, \"y\": 2, \"z\": 50 },\r\n  \"Rotation\": 45,\r\n  \"Sides\": [\"Pmc\", \"Savage\"],        // Who can spawn here\r\n  \"Categories\": [\"Player\", \"Coop\"],  // Spawn categories\r\n  \"Infiltration\": \"\",                 // Entry point\r\n  \"DelayToCanSpawnSec\": 4,           // Delay after raid start\r\n  \"BotZoneName\": \"\"                   // Zone group name\r\n}\r\n```\r\n\r\n---\r\n\r\n### Spawn Point Filtering\r\n\r\n**For PMC Waves**:\r\n```\r\n1. Filter: Sides contains \"Pmc\"\r\n2. Filter: DelayToCanSpawnSec elapsed\r\n3. Filter: Not occupied by player\r\n4. Filter: Zone restrictions (PmcBotZones) if set\r\n5. Random: Select from remaining\r\n```\r\n\r\n**If no points match** ‚Üí Wave skipped!\r\n\r\n---\r\n\r\n### Zone Restrictions (PmcBotZones)\r\n\r\n**Purpose**: Force PMCs to spawn only in specific zones\r\n\r\n**Example**:\r\n```json\r\n\"PmcBotZones\": [\r\n  {\r\n    \"SpawnPoints\": \"Zone1,Zone2,Zone3\",  // Comma-separated IDs\r\n    \"Min\": 1,                             // Min bots per wave\r\n    \"Max\": 3                              // Max bots per wave\r\n  }\r\n]\r\n```\r\n\r\n**SVM Override**:\r\n```csharp\r\nbaseMap.BotLocationModifier.PmcBotZones = [];  // Allow any zone\r\n```\r\n\r\n**Effect**: PMCs can use ALL spawn points marked with `\"Sides\": [\"Pmc\"]`\r\n\r\n---\r\n\r\n## ‚ö° Trigger System\r\n\r\n### PmcBotTriggers\r\n\r\n**Purpose**: Conditional spawning based on events\r\n\r\n**Trigger Types**:\r\n1. **Time-based**: After certain raid time\r\n2. **Interaction-based**: Player triggers event\r\n3. **Zone-based**: Player enters area\r\n4. **Boss-based**: Boss killed\r\n\r\n**Example**:\r\n```json\r\n\"PmcBotTriggers\": [\r\n  {\r\n    \"TriggerId\": \"autoId_Interchange_PMC_1\",\r\n    \"TriggerName\": \"interactWith_Power\",  // Power station interaction\r\n    \"Delay\": 60                            // 60s after trigger\r\n  }\r\n]\r\n```\r\n\r\n**SVM Override**:\r\n```csharp\r\nbaseMap.BotLocationModifier.PmcBotTriggers = [];  // No triggers\r\n```\r\n\r\n**Effect**: PMCs spawn on wave timing only (unconditional)\r\n\r\n---\r\n\r\n## üîß Troubleshooting Guide for AGENT5\r\n\r\n### Problem: No PMCs Spawning\r\n\r\n**Check 1: Verify Override Applied**\r\n```csharp\r\nlogger.Info($\"PMC override: {mapId}\");\r\nlogger.Info($\"  Max: {baseMap.BotLocationModifier.PmcBotMax}\");\r\nlogger.Info($\"  Zones: {baseMap.BotLocationModifier.PmcBotZones.Length}\");\r\nlogger.Info($\"  Triggers: {baseMap.BotLocationModifier.PmcBotTriggers.Length}\");\r\n```\r\n\r\n**Expected**:\r\n```\r\nPMC override: interchange\r\n  Max: 24\r\n  Zones: 0\r\n  Triggers: 0\r\n```\r\n\r\n---\r\n\r\n**Check 2: Count Valid Spawn Points**\r\n```csharp\r\nint pmcPoints = baseMap.SpawnPointParams.Count(sp =>\r\n    sp.Sides != null &&\r\n    sp.Sides.Contains(\"Pmc\"));\r\n\r\nlogger.Info($\"  PMC spawn points: {pmcPoints}\");\r\n```\r\n\r\n**Expected**: > 0 (at least 1 spawn point)\r\n\r\n**If 0**: Map has no PMC-enabled spawn points!\r\n\r\n**Fix**:\r\n```csharp\r\n// Enable PMC spawning on some Savage spawn points\r\nforeach (var sp in baseMap.SpawnPointParams.Take(10))\r\n{\r\n    if (!sp.Sides.Contains(\"Pmc\"))\r\n    {\r\n        sp.Sides.Add(\"Pmc\");\r\n    }\r\n}\r\n\r\nlogger.Info($\"  Enabled PMC spawning on {count} additional points\");\r\n```\r\n\r\n---\r\n\r\n**Check 3: Verify Wave Config**\r\n```csharp\r\nlogger.Info($\"  Waves defined: {baseMap.waves.Length}\");\r\n\r\nint pmcWaves = baseMap.waves.Count(w =>\r\n    w.WildSpawnType == \"pmcBot\" ||\r\n    w.BotSide == \"Pmc\");\r\n\r\nlogger.Info($\"  PMC waves: {pmcWaves}\");\r\n```\r\n\r\n**Expected**: Some waves configured for PMCs\r\n\r\n---\r\n\r\n**Check 4: Spawn Point Sides**\r\n```csharp\r\nvar sideCounts = new Dictionary<string, int>();\r\n\r\nforeach (var sp in baseMap.SpawnPointParams)\r\n{\r\n    foreach (var side in sp.Sides)\r\n    {\r\n        if (!sideCounts.ContainsKey(side))\r\n            sideCounts[side] = 0;\r\n        sideCounts[side]++;\r\n    }\r\n}\r\n\r\nforeach (var kvp in sideCounts)\r\n{\r\n    logger.Info($\"  Spawn points for {kvp.Key}: {kvp.Value}\");\r\n}\r\n```\r\n\r\n**Expected Output**:\r\n```\r\nSpawn points for Pmc: 15\r\nSpawn points for Savage: 30\r\n```\r\n\r\n**If Pmc: 0** ‚Üí Problem found!\r\n\r\n---\r\n\r\n## üõ†Ô∏è Advanced Fixes\r\n\r\n### Fix 1: Force PMC Spawn Points\r\n\r\n**If map has no PMC spawn points**:\r\n\r\n```csharp\r\n// Count PMC-enabled points\r\nint pmcSpawnCount = baseMap.SpawnPointParams.Count(sp =>\r\n    sp.Sides != null && sp.Sides.Contains(\"Pmc\"));\r\n\r\nif (pmcSpawnCount == 0)\r\n{\r\n    logger.Warning($\"[SVM] Map {mapId} has NO PMC spawn points! Enabling...\");\r\n\r\n    // Enable PMC on all Savage points\r\n    foreach (var sp in baseMap.SpawnPointParams)\r\n    {\r\n        if (sp.Sides.Contains(\"Savage\") && !sp.Sides.Contains(\"Pmc\"))\r\n        {\r\n            sp.Sides.Add(\"Pmc\");\r\n            pmcSpawnCount++;\r\n        }\r\n    }\r\n\r\n    logger.Info($\"[SVM] Enabled PMC spawning on {pmcSpawnCount} points\");\r\n}\r\n```\r\n\r\n---\r\n\r\n### Fix 2: Reduce Spawn Delay\r\n\r\n**If PMCs spawn too late**:\r\n\r\n```csharp\r\n// Reduce delay on PMC spawn points\r\nforeach (var sp in baseMap.SpawnPointParams)\r\n{\r\n    if (sp.Sides.Contains(\"Pmc\"))\r\n    {\r\n        sp.DelayToCanSpawnSec = Math.Min(sp.DelayToCanSpawnSec, 10);\r\n        // Max 10 second delay\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Fix 3: Explicit PMC Zones (Fallback)\r\n\r\n**If clearing zones doesn't work**:\r\n\r\n```csharp\r\n// Get all PMC-capable spawn points\r\nvar pmcZoneIds = baseMap.SpawnPointParams\r\n    .Where(sp => sp.Sides.Contains(\"Pmc\"))\r\n    .Select(sp => sp.Id)\r\n    .ToList();\r\n\r\nif (pmcZoneIds.Count > 0)\r\n{\r\n    // Create single zone with all PMC points\r\n    baseMap.BotLocationModifier.PmcBotZones = new[]\r\n    {\r\n        new\r\n        {\r\n            SpawnPoints = string.Join(\",\", pmcZoneIds),\r\n            Min = 1,\r\n            Max = 5\r\n        }\r\n    };\r\n\r\n    logger.Info($\"[SVM] Set PMC zones to {pmcZoneIds.Count} points\");\r\n}\r\n```\r\n\r\n---\r\n\r\n### Fix 4: Override Wave Definitions\r\n\r\n**If wave system broken**:\r\n\r\n```csharp\r\n// Clear existing waves\r\nbaseMap.waves = baseMap.waves.Where(w =>\r\n    w.WildSpawnType != \"pmcBot\" &&\r\n    w.BotSide != \"Pmc\"\r\n).ToArray();\r\n\r\n// Add explicit PMC waves\r\nList<object> newWaves = new(baseMap.waves);\r\n\r\nfor (int i = 0; i < 6; i++)  // 6 waves\r\n{\r\n    newWaves.Add(new\r\n    {\r\n        number = baseMap.waves.Length + i,\r\n        time_min = 1 + (i * 150),      // 150s spacing\r\n        time_max = 1 + (i * 150),\r\n        slots_min = 3,\r\n        slots_max = 5,\r\n        SpawnPoints = \"PMC\",             // Use PMC-enabled points\r\n        BotSide = \"Pmc\",\r\n        BotPreset = \"normal\",\r\n        WildSpawnType = \"pmcBot\"\r\n    });\r\n}\r\n\r\nbaseMap.waves = newWaves.ToArray();\r\nlogger.Info($\"[SVM] Added {6} explicit PMC waves\");\r\n```\r\n\r\n---\r\n\r\n## üìä Verification Commands\r\n\r\n### Check Current Config\r\n\r\n**After server start, check location config**:\r\n```bash\r\nGet-Content \"G:\\Installed Games\\SPT4\\SPT\\SPT_Data\\configs\\location\\interchange\\base.json\" | Select-String \"PmcBot\" -Context 2,2\r\n```\r\n\r\n---\r\n\r\n### Monitor Spawn Logs\r\n\r\n**During raid**:\r\n```powershell\r\nGet-Content \"G:\\Installed Games\\SPT4\\SPT\\user\\logs\\spt\\*.log\" -Wait -Tail 200 |\r\n    Select-String \"Generating wave|Generated:.*pmc|PMC.*spawn\"\r\n```\r\n\r\n**Expected Output**:\r\n```\r\n[Info] Generating wave 1 with 4 bots (pmc)\r\n[Info] Generated: 4 pmc at 1s\r\n[Info] Generating wave 2 with 3 bots (pmc)\r\n[Info] Generated: 3 pmc at 151s\r\n...\r\n```\r\n\r\n---\r\n\r\n### Check Spawn Points In-Game\r\n\r\n**F6 Debug ‚Üí Spawn Points**:\r\n- Shows all spawn points on map\r\n- PMC points should be visible\r\n- Check distribution across map\r\n\r\n---\r\n\r\n## üìö Knowledge Base References\r\n\r\n**Spawn System Basics**: `01-Bot-Spawning.md` Section 4\r\n**Location Config**: `01-Bot-Spawning.md` Section 3\r\n**Server Overrides**: `07-Server-Routes-Patterns.md` (DI override pattern)\r\n\r\n---\r\n\r\n## üéØ Summary for AGENT5\r\n\r\n**Current Status**: Wave timing looks correct (6 waves, 150s spacing) ‚úÖ\r\n\r\n**If PMCs still don't spawn**:\r\n\r\n1. **Check spawn points**: Count PMC-enabled points, should be > 0\r\n2. **Enable points if needed**: Add \"Pmc\" to Savage spawn point Sides\r\n3. **Verify in logs**: \"Generated: ... pmc\" should appear\r\n4. **Monitor telemetry**: F6 ‚Üí Telemetry HUD ‚Üí Bot count rising\r\n\r\n**Most Likely Issue**: Spawn points don't have \"Pmc\" in Sides array\r\n**Quick Fix**: Enable PMC on existing Savage points (see Fix 1 above)\r\n\r\n---\r\n\r\n**Your wave config is correct - just need to ensure spawn points are available!** üéØ\r\n"},"SPT-ROUTING-ARCHITECTURE":{"title":"SPT Server Routing Architecture - Complete Source Analysis\r","category":"General","content":"# SPT Server Routing Architecture - Complete Source Analysis\r\n\r\n**Source**: SPT Server C# Source Code (`E:\\AppDev\\LTsTarkovAI\\SPTtmp\\server-csharp`)\r\n**Analysis Date**: 2025-11-23\r\n**Status**: ‚úÖ DEFINITIVE - Based on actual source code\r\n\r\n---\r\n\r\n## Table of Contents\r\n\r\n1. [Executive Summary](#executive-summary)\r\n2. [Complete Request Flow](#complete-request-flow)\r\n3. [Component Architecture](#component-architecture)\r\n4. [Router Classes Deep Dive](#router-classes-deep-dive)\r\n5. [HTTP Layer (SptHttpListener)](#http-layer-spthttplistener)\r\n6. [HttpRouter Dispatch Logic](#httprouter-dispatch-logic)\r\n7. [RouteAction Types](#routeaction-types)\r\n8. [Response Flow](#response-flow)\r\n9. [404 Generation Mechanism](#404-generation-mechanism)\r\n10. [Type Casting and String Conversion](#type-casting-and-string-conversion)\r\n\r\n---\r\n\r\n## Executive Summary\r\n\r\n### Architecture Overview\r\n\r\nSPT Server uses a **four-layer routing architecture**:\r\n\r\n```\r\n[1] HTTP Layer (SptHttpListener)\r\n     ‚Üì\r\n[2] Router Dispatcher (HttpRouter)\r\n     ‚Üì\r\n[3] Router Types (StaticRouter, DynamicRouter)\r\n     ‚Üì\r\n[4] Route Handlers (Your mod code)\r\n```\r\n\r\n### Critical Discovery: 404 Root Cause\r\n\r\n**The 404 \"UNHANDLED RESPONSE\" error occurs when:**\r\n\r\n1. `HttpRouter.GetResponse()` returns `null` or empty string (**Line 167 ‚Üí 170 in SptHttpListener.cs**)\r\n2. This happens when the `as string` cast fails (**Lines 54/58 in HttpRouter.cs**)\r\n3. The cast fails when handlers return `object` instead of `string`\r\n\r\n**Solution**: All route handlers MUST return `string`, not `object`!\r\n\r\n---\r\n\r\n## Complete Request Flow\r\n\r\n### End-to-End Request Processing\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  1. EFT Client sends HTTP request                                ‚îÇ\r\n‚îÇ     GET/POST/PUT http://localhost:6969/client/game/start         ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                              ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  2. SptHttpListener.Handle() (Entry Point)                       ‚îÇ\r\n‚îÇ     Location: Servers/Http/SptHttpListener.cs:34                 ‚îÇ\r\n‚îÇ     - Decompresses POST/PUT requests (ZLib)                      ‚îÇ\r\n‚îÇ     - Calls GetResponse()                                        ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                              ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  3. SptHttpListener.GetResponse()                                ‚îÇ\r\n‚îÇ     Location: Servers/Http/SptHttpListener.cs:165                ‚îÇ\r\n‚îÇ     - Calls httpRouter.GetResponse()                             ‚îÇ\r\n‚îÇ     - Checks if output is null/empty                             ‚îÇ\r\n‚îÇ     - Generates 404 if empty (LINE 170-177) ‚Üê CRITICAL!          ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                              ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  4. HttpRouter.GetResponse()                                     ‚îÇ\r\n‚îÇ     Location: Routers/HttpRouter.cs:17                           ‚îÇ\r\n‚îÇ     - Creates ResponseWrapper                                    ‚îÇ\r\n‚îÇ     - Calls HandleRoute() for StaticRouters (Line 21)            ‚îÇ\r\n‚îÇ     - If not handled, calls HandleRoute() for DynamicRouters     ‚îÇ\r\n‚îÇ     - Returns wrapper.Output (could be null!)                    ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                              ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  5. HttpRouter.HandleRoute()                                     ‚îÇ\r\n‚îÇ     Location: Routers/HttpRouter.cs:30                           ‚îÇ\r\n‚îÇ     - Loops through routers                                      ‚îÇ\r\n‚îÇ     - Checks route.CanHandle(url, dynamic)                       ‚îÇ\r\n‚îÇ     - Casts result \"as string\" (Line 54/58) ‚Üê CRITICAL CAST!     ‚îÇ\r\n‚îÇ     - Sets wrapper.Output (could be null if cast fails!)         ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                              ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  6a. StaticRouter.HandleStatic() [if static route]               ‚îÇ\r\n‚îÇ      Location: DI/Router.cs:68                                   ‚îÇ\r\n‚îÇ      - Finds exact URL match (Single())                          ‚îÇ\r\n‚îÇ      - Deserializes body if bodyType specified                   ‚îÇ\r\n‚îÇ      - Calls action(url, info, sessionId, output)                ‚îÇ\r\n‚îÇ      - Returns result as object (Line 82)                        ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                              ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  6b. DynamicRouter.HandleDynamic() [if dynamic route]            ‚îÇ\r\n‚îÇ      Location: DI/Router.cs:93                                   ‚îÇ\r\n‚îÇ      - Finds partial URL match (First() + Contains())            ‚îÇ\r\n‚îÇ      - Deserializes body if bodyType specified                   ‚îÇ\r\n‚îÇ      - Calls action(url, info, sessionId, output)                ‚îÇ\r\n‚îÇ      - Returns result as object (Line 107)                       ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                              ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  7. Your Route Handler (Mod Code)                                ‚îÇ\r\n‚îÇ     - Processes request                                          ‚îÇ\r\n‚îÇ     - MUST return string (not object!)                           ‚îÇ\r\n‚îÇ     - Typically: jsonUtil.Serialize(responseObject)              ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                              ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  8. Response flows back up the stack                             ‚îÇ\r\n‚îÇ     - Handler returns string                                     ‚îÇ\r\n‚îÇ     - StaticRouter/DynamicRouter returns as object               ‚îÇ\r\n‚îÇ     - HttpRouter casts to string (succeeds if handler returned string) ‚îÇ\r\n‚îÇ     - SptHttpListener receives string                            ‚îÇ\r\n‚îÇ     - Compresses with ZLib (or sends raw if debug)               ‚îÇ\r\n‚îÇ     - Sends HTTP response to client                              ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n```\r\n\r\n---\r\n\r\n## Component Architecture\r\n\r\n### Core Components\r\n\r\n#### 1. SptHttpListener\r\n- **Location**: `SPTarkov.Server.Core/Servers/Http/SptHttpListener.cs`\r\n- **Purpose**: HTTP request/response handling\r\n- **Responsibilities**:\r\n  - Accept incoming HTTP requests\r\n  - Decompress POST/PUT request bodies (ZLib)\r\n  - Route to HttpRouter\r\n  - Generate 404 if no response\r\n  - Compress responses (ZLib)\r\n  - Send HTTP responses\r\n\r\n#### 2. HttpRouter\r\n- **Location**: `SPTarkov.Server.Core/Routers/HttpRouter.cs`\r\n- **Purpose**: Route dispatching\r\n- **Responsibilities**:\r\n  - Check if any router can handle request\r\n  - Dispatch to StaticRouter or DynamicRouter\r\n  - Cast results to string\r\n  - Return response or null\r\n\r\n#### 3. Router Base Classes\r\n- **Location**: `SPTarkov.Server.Core/DI/Router.cs`\r\n- **Types**:\r\n  - `Router` (abstract base)\r\n  - `StaticRouter` (exact URL matching)\r\n  - `DynamicRouter` (partial URL matching)\r\n- **Responsibilities**:\r\n  - URL matching logic\r\n  - Body deserialization\r\n  - Handler invocation\r\n  - Event triggering\r\n\r\n#### 4. RouteAction\r\n- **Location**: `SPTarkov.Server.Core/DI/Router.cs:182-186`\r\n- **Types**:\r\n  - `RouteAction` (non-generic, returns `object`)\r\n  - `RouteAction<TRequest>` (generic, returns `string`)\r\n- **Purpose**: Route definition and handler wrapping\r\n\r\n---\r\n\r\n## Router Classes Deep Dive\r\n\r\n### Router Base Class\r\n\r\n**Source**: `DI/Router.cs:21-64`\r\n\r\n```csharp\r\npublic abstract class Router\r\n{\r\n    public event EventHandler<IOnBeforeEventRequestData>? OnBeforeAction;\r\n    public event EventHandler<IOnAfterEventRequestData>? OnAfterAction;\r\n\r\n    protected IEnumerable<HandledRoute> handledRoutes = [];\r\n\r\n    // Override to define top-level route (default: \"spt\")\r\n    public virtual string GetTopLevelRoute() => \"spt\";\r\n\r\n    // Override to return list of handled routes\r\n    protected abstract IEnumerable<HandledRoute> GetHandledRoutes();\r\n\r\n    // Check if router can handle URL\r\n    public bool CanHandle(string url, bool partialMatch = false)\r\n    {\r\n        if (partialMatch)\r\n        {\r\n            // Dynamic matching: any route that contains URL\r\n            return GetInternalHandledRoutes()\r\n                .Where(r => r.dynamic)\r\n                .Any(r => url.Contains(r.route));\r\n        }\r\n\r\n        // Static matching: exact URL match\r\n        return GetInternalHandledRoutes()\r\n            .Where(r => !r.dynamic)\r\n            .Any(r => r.route == url);\r\n    }\r\n}\r\n```\r\n\r\n**Key Methods**:\r\n- `GetTopLevelRoute()`: Returns top-level route prefix (default \"spt\")\r\n- `GetHandledRoutes()`: Returns list of routes this router handles\r\n- `CanHandle(url, partialMatch)`: Checks if router can handle URL\r\n  - `partialMatch = false`: Exact match (StaticRouter)\r\n  - `partialMatch = true`: Contains match (DynamicRouter)\r\n\r\n---\r\n\r\n### StaticRouter Class\r\n\r\n**Source**: `DI/Router.cs:66-89`\r\n\r\n```csharp\r\npublic abstract class StaticRouter(JsonUtil jsonUtil, IEnumerable<RouteAction> routes) : Router\r\n{\r\n    public async ValueTask<object> HandleStatic(string url, string? body, MongoId sessionId, string output)\r\n    {\r\n        // Line 70: Find exact matching route (throws if not found!)\r\n        var action = routes.Single(route => route.url == url);\r\n\r\n        // Line 71: Get body type\r\n        var type = action.bodyType;\r\n\r\n        // Lines 72-78: Deserialize body if type specified\r\n        IRequestData? info = null;\r\n        if (type != null && !string.IsNullOrEmpty(body))\r\n        {\r\n            info = (IRequestData?)jsonUtil.Deserialize(body, type);\r\n        }\r\n        info ??= new EmptyRequestData();\r\n\r\n        // Lines 79-80: Trigger event and call handler\r\n        TriggerOnBeforeAction(new StaticDynamicOnBeforeEventRequestData(url, info, sessionId, output));\r\n        var result = await action.action(url, info, sessionId, output);\r\n\r\n        // Lines 81-82: Trigger event and return result\r\n        TriggerOnAfterAction(new StaticDynamicOnAfterEventRequestData(url, info, sessionId, output, result));\r\n        return result;  // ‚Üê Returns result as-is (as object)\r\n    }\r\n\r\n    protected override IEnumerable<HandledRoute> GetHandledRoutes()\r\n    {\r\n        // Mark all routes as non-dynamic (exact match)\r\n        return routes.Select(route => new HandledRoute(route.url, false));\r\n    }\r\n}\r\n```\r\n\r\n**Characteristics**:\r\n- **Exact URL matching**: Uses `Single()` to find route (throws if multiple or none)\r\n- **Returns `object`**: Handler result returned as `object` type\r\n- **Body deserialization**: Automatically deserializes request body based on `bodyType`\r\n- **Events**: Triggers OnBefore/OnAfter events for middleware\r\n\r\n**Usage**:\r\n```csharp\r\npublic class MyStaticRouter(JsonUtil jsonUtil) : StaticRouter(jsonUtil, routes)\r\n{\r\n    private static readonly IEnumerable<RouteAction> routes = [\r\n        new RouteAction(\r\n            \"/client/game/start\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                // Handler code\r\n                return jsonUtil.Serialize(responseObject); // MUST return string!\r\n            }\r\n        )\r\n    ];\r\n}\r\n```\r\n\r\n---\r\n\r\n### DynamicRouter Class\r\n\r\n**Source**: `DI/Router.cs:91-114`\r\n\r\n```csharp\r\npublic abstract class DynamicRouter(JsonUtil jsonUtil, IEnumerable<RouteAction> routes) : Router\r\n{\r\n    public async ValueTask<object> HandleDynamic(string url, string? body, MongoId sessionId, string output)\r\n    {\r\n        // Line 95: Find first route where URL contains route.url\r\n        var action = routes.First(r => url.Contains(r.url));\r\n\r\n        // Line 96: Get body type\r\n        var type = action.bodyType;\r\n\r\n        // Lines 97-103: Deserialize body if type specified\r\n        IRequestData? info = null;\r\n        if (type != null && !string.IsNullOrEmpty(body))\r\n        {\r\n            info = (IRequestData?)jsonUtil.Deserialize(body, type);\r\n        }\r\n        info ??= new EmptyRequestData();\r\n\r\n        // Lines 104-105: Trigger event and call handler\r\n        TriggerOnBeforeAction(new StaticDynamicOnBeforeEventRequestData(url, info, sessionId, output));\r\n        var result = await action.action(url, info, sessionId, output);\r\n\r\n        // Lines 106-107: Trigger event and return result\r\n        TriggerOnAfterAction(new StaticDynamicOnAfterEventRequestData(url, info, sessionId, output, result));\r\n        return result;  // ‚Üê Returns result as-is (as object)\r\n    }\r\n\r\n    protected override IEnumerable<HandledRoute> GetHandledRoutes()\r\n    {\r\n        // Mark all routes as dynamic (partial match)\r\n        return routes.Select(route => new HandledRoute(route.url, true));\r\n    }\r\n}\r\n```\r\n\r\n**Characteristics**:\r\n- **Partial URL matching**: Uses `First()` with `Contains()` to find route\r\n- **Returns `object`**: Handler result returned as `object` type\r\n- **Flexible matching**: URL like `/client/trading/api/getTraderAssort/54cb50c76803fa8b248b4571` matches route `/client/trading/api/getTraderAssort/`\r\n- **Events**: Triggers OnBefore/OnAfter events for middleware\r\n\r\n**Usage**:\r\n```csharp\r\npublic class MyDynamicRouter(JsonUtil jsonUtil) : DynamicRouter(jsonUtil, routes)\r\n{\r\n    private static readonly IEnumerable<RouteAction> routes = [\r\n        new RouteAction(\r\n            \"/client/trading/api/getTraderAssort/\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                // Extract trader ID from URL\r\n                var traderId = url.Split('/').Last();\r\n                // Handler code\r\n                return jsonUtil.Serialize(responseObject); // MUST return string!\r\n            }\r\n        )\r\n    ];\r\n}\r\n```\r\n\r\n**Key Difference from StaticRouter**:\r\n- StaticRouter: `/client/game/start` matches ONLY `/client/game/start`\r\n- DynamicRouter: `/client/trading/api/getTraderAssort/` matches `/client/trading/api/getTraderAssort/54cb50c76803fa8b248b4571`\r\n\r\n---\r\n\r\n## HTTP Layer (SptHttpListener)\r\n\r\n### Entry Point: Handle Method\r\n\r\n**Source**: `Servers/Http/SptHttpListener.cs:34-97`\r\n\r\n```csharp\r\npublic async Task Handle(MongoId sessionId, HttpContext context)\r\n{\r\n    switch (context.Request.Method)\r\n    {\r\n        case \"GET\":\r\n        {\r\n            var response = await GetResponse(sessionId, context, null);\r\n\r\n            // Another handler is already handling this, or no handler was found.\r\n            if (response is null)\r\n            {\r\n                return;\r\n            }\r\n\r\n            await SendResponse(sessionId, context.Request, context.Response, null, response);\r\n            break;\r\n        }\r\n\r\n        case \"POST\":\r\n        case \"PUT\":\r\n        {\r\n            // Lines 55-61: Check if request is compressed\r\n            var requestIsCompressed =\r\n                !context.Request.Headers.TryGetValue(\"requestcompressed\", out var compressHeader)\r\n                || compressHeader != \"0\";\r\n            var requestCompressed = context.Request.Method == \"PUT\" || requestIsCompressed;\r\n\r\n            string body;\r\n\r\n            // Lines 65-75: Decompress body if needed\r\n            if (requestCompressed)\r\n            {\r\n                await using var deflateStream = new ZLibStream(context.Request.Body, CompressionMode.Decompress);\r\n                using var reader = new StreamReader(deflateStream, Encoding.UTF8);\r\n                body = await reader.ReadToEndAsync();\r\n            }\r\n            else\r\n            {\r\n                using var reader = new StreamReader(context.Request.Body, Encoding.UTF8);\r\n                body = await reader.ReadToEndAsync();\r\n            }\r\n\r\n            // Lines 85-93: Get response and send\r\n            var response = await GetResponse(sessionId, context, body);\r\n\r\n            if (response is null)\r\n            {\r\n                return;\r\n            }\r\n\r\n            await SendResponse(sessionId, context.Request, context.Response, body, response);\r\n            break;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Key Points**:\r\n- **GET requests**: No body decompression\r\n- **POST/PUT requests**: Automatic ZLib decompression unless `requestcompressed: 0` header\r\n- **Null checks**: If `GetResponse` returns null, handler exits (another handler will handle it)\r\n\r\n---\r\n\r\n### GetResponse: Where 404s Are Generated\r\n\r\n**Source**: `Servers/Http/SptHttpListener.cs:165-187`\r\n\r\n```csharp\r\npublic async ValueTask<string> GetResponse(MongoId sessionId, HttpContext context, string? body)\r\n{\r\n    // Line 167: Call HttpRouter to get response\r\n    var output = await httpRouter.GetResponse(context.Request, sessionId, body);\r\n\r\n    // Lines 170-177: CRITICAL - 404 GENERATION!\r\n    // Route doesn't exist or response is not properly set up\r\n    if (string.IsNullOrEmpty(output))\r\n    {\r\n        output = httpResponseUtil.GetBody<object?>(\r\n            null,\r\n            BackendErrorCodes.HTTPNotFound,\r\n            $\"UNHANDLED RESPONSE: {context.Request.Path.ToString()}\"\r\n        );\r\n    }\r\n\r\n    // Lines 179-184: Log request (if not RELEASE build)\r\n    if (ProgramStatics.ENTRY_TYPE() != EntryType.RELEASE)\r\n    {\r\n        var log = new Request(context.Request.Method, new RequestData(context.Request.Path.ToString(), context.Request.Headers));\r\n        requestsLogger.Info($\"REQUEST={jsonUtil.Serialize(log)}\");\r\n    }\r\n\r\n    return output;\r\n}\r\n```\r\n\r\n**THIS IS THE SOURCE OF 404 ERRORS!**\r\n\r\n**Line 170**: `if (string.IsNullOrEmpty(output))`\r\n\r\n**When this triggers**:\r\n1. `httpRouter.GetResponse()` returned `null`\r\n2. `httpRouter.GetResponse()` returned empty string `\"\"`\r\n\r\n**What happens**:\r\n- Generates error response with:\r\n  - `BackendErrorCodes.HTTPNotFound` (404)\r\n  - Message: `\"UNHANDLED RESPONSE: /your/url/here\"`\r\n\r\n**Why output is null/empty**:\r\n- HttpRouter cast `as string` failed (lines 54/58 in HttpRouter.cs)\r\n- No router matched the URL\r\n- Router matched but handler threw exception\r\n\r\n---\r\n\r\n### SendResponse: Compression Logic\r\n\r\n**Source**: `Servers/Http/SptHttpListener.cs:107-139`\r\n\r\n```csharp\r\npublic async Task SendResponse(MongoId sessionID, HttpRequest req, HttpResponse resp, object? body, string output)\r\n{\r\n    body ??= new object();\r\n    var bodyInfo = jsonUtil.Serialize(body);\r\n\r\n    // Lines 113-123: Debug request (no compression)\r\n    if (IsDebugRequest(req))\r\n    {\r\n        // Send only raw response without transformation\r\n        await SendJson(resp, output, sessionID);\r\n        if (logger.IsLogEnabled(LogLevel.Debug))\r\n        {\r\n            logger.Debug($\"Response: {output}\");\r\n        }\r\n\r\n        LogRequest(req, output);\r\n        return;\r\n    }\r\n\r\n    // Lines 126-136: Check for serializers (IMAGE/BUNDLE/NOTIFY)\r\n    var serialiser = serializers.FirstOrDefault(x => x.CanHandle(output));\r\n    if (serialiser != null)\r\n    {\r\n        await serialiser.Serialize(sessionID, req, resp, bodyInfo);\r\n    }\r\n    else\r\n    {\r\n        // No serializer, use ZLib compression (majority of requests)\r\n        await SendZlibJson(resp, output, sessionID);\r\n    }\r\n\r\n    LogRequest(req, output);\r\n}\r\n```\r\n\r\n**Response Compression Logic**:\r\n\r\n1. **Debug Request** (`responsecompressed: 0` header):\r\n   - No compression\r\n   - Sent as plain JSON\r\n\r\n2. **Special Serializers** (IMAGE/BUNDLE/NOTIFY):\r\n   - Custom serialization\r\n   - Handled by specialized serializers\r\n\r\n3. **Standard Requests** (majority):\r\n   - ZLib compression\r\n   - Sent as compressed JSON\r\n\r\n---\r\n\r\n## HttpRouter Dispatch Logic\r\n\r\n### GetResponse: Main Entry Point\r\n\r\n**Source**: `Routers/HttpRouter.cs:17-28`\r\n\r\n```csharp\r\npublic async ValueTask<string?> GetResponse(HttpRequest req, MongoId sessionID, string? body)\r\n{\r\n    // Line 19: Create response wrapper\r\n    var wrapper = new ResponseWrapper(\"\");\r\n\r\n    // Line 21: Try static routers first\r\n    var handled = await HandleRoute(req, sessionID, wrapper, staticRouters, false, body);\r\n\r\n    // Lines 22-25: If not handled, try dynamic routers\r\n    if (!handled)\r\n    {\r\n        await HandleRoute(req, sessionID, wrapper, dynamicRoutes, true, body);\r\n    }\r\n\r\n    // Line 27: Return response (could be null if no router handled!)\r\n    return wrapper.Output;\r\n}\r\n```\r\n\r\n**Flow**:\r\n1. Create `ResponseWrapper` with empty string\r\n2. Try all `StaticRouters` (exact match)\r\n3. If not handled, try all `DynamicRouters` (partial match)\r\n4. Return `wrapper.Output` (null if no router handled request)\r\n\r\n---\r\n\r\n### HandleRoute: The Critical Cast\r\n\r\n**Source**: `Routers/HttpRouter.cs:30-66`\r\n\r\n```csharp\r\nprotected async ValueTask<bool> HandleRoute(\r\n    HttpRequest request,\r\n    MongoId sessionID,\r\n    ResponseWrapper wrapper,\r\n    IEnumerable<Router> routers,\r\n    bool dynamic,\r\n    string? body\r\n)\r\n{\r\n    // Line 39: Get URL from request\r\n    var url = request.Path.Value;\r\n\r\n    // Lines 42-45: Remove retry parameter\r\n    if (url?.Contains(\"?retry=\") ?? false)\r\n    {\r\n        url = url.Split(\"?retry=\")[0];\r\n    }\r\n\r\n    var matched = false;\r\n\r\n    // Lines 48-63: Loop through routers\r\n    foreach (var route in routers)\r\n    {\r\n        if (route.CanHandle(url, dynamic))\r\n        {\r\n            if (dynamic)\r\n            {\r\n                // Line 54: CRITICAL CAST - DynamicRouter\r\n                wrapper.Output = await (route as DynamicRouter).HandleDynamic(url, body, sessionID, wrapper.Output) as string;\r\n            }\r\n            else\r\n            {\r\n                // Line 58: CRITICAL CAST - StaticRouter\r\n                wrapper.Output = await (route as StaticRouter).HandleStatic(url, body, sessionID, wrapper.Output) as string;\r\n            }\r\n\r\n            matched = true;\r\n        }\r\n    }\r\n\r\n    return matched;\r\n}\r\n```\r\n\r\n**THE CRITICAL LINES: 54 and 58**\r\n\r\n```csharp\r\nwrapper.Output = await (route as DynamicRouter).HandleDynamic(...) as string;\r\nwrapper.Output = await (route as StaticRouter).HandleStatic(...) as string;\r\n```\r\n\r\n**What's happening**:\r\n1. `HandleDynamic()` / `HandleStatic()` return `ValueTask<object>`\r\n2. Result is cast `as string`\r\n3. **If result is not a `string` type, cast returns `null`!**\r\n4. `wrapper.Output` becomes `null`\r\n5. SptHttpListener sees `null` and generates 404\r\n\r\n**This is why handlers MUST return `string`, not `object`!**\r\n\r\n---\r\n\r\n## RouteAction Types\r\n\r\n### Non-Generic RouteAction\r\n\r\n**Source**: `DI/Router.cs:182`\r\n\r\n```csharp\r\npublic record RouteAction(\r\n    string url,\r\n    Func<string, IRequestData, MongoId, string?, ValueTask<object>> action,\r\n    Type? bodyType = null\r\n);\r\n```\r\n\r\n**Characteristics**:\r\n- Handler returns `ValueTask<object>`\r\n- Flexible but requires manual serialization\r\n- Result must be serialized to string in handler\r\n\r\n**Usage**:\r\n```csharp\r\nnew RouteAction(\r\n    \"/client/game/start\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        var response = new { status = \"ok\" };\r\n        // MUST serialize to string!\r\n        return jsonUtil.Serialize(response);  // ‚Üê Returns string\r\n    }\r\n)\r\n```\r\n\r\n**WARNING**: If you return an object instead of string, the cast will fail!\r\n\r\n```csharp\r\n// ‚ùå WRONG - Will cause 404!\r\nnew RouteAction(\r\n    \"/client/game/start\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        var response = new { status = \"ok\" };\r\n        return response;  // ‚Üê Returns object, not string!\r\n    }\r\n)\r\n```\r\n\r\n---\r\n\r\n### Generic RouteAction<TRequest>\r\n\r\n**Source**: `DI/Router.cs:184-186`\r\n\r\n```csharp\r\npublic record RouteAction<TRequest>(\r\n    string url,\r\n    Func<string, TRequest, MongoId, string?, ValueTask<string>> typedAction\r\n)\r\n    : RouteAction(\r\n        url,\r\n        async (url, info, sessionId, output) => await typedAction(url, (TRequest)info, sessionId, output),\r\n        typeof(TRequest)\r\n    )\r\n    where TRequest : class;\r\n```\r\n\r\n**Characteristics**:\r\n- Handler returns `ValueTask<string>` (strongly typed!)\r\n- Automatically specifies `bodyType` as `typeof(TRequest)`\r\n- Request body auto-deserialized to `TRequest`\r\n- Safer than non-generic version\r\n\r\n**Usage**:\r\n```csharp\r\nnew RouteAction<EmptyRequestData>(\r\n    \"/client/game/start\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        var response = new { status = \"ok\" };\r\n        // Return string directly\r\n        return jsonUtil.Serialize(response);  // ‚Üê Must return string\r\n    }\r\n)\r\n```\r\n\r\n**Key Advantage**: Compiler enforces `string` return type!\r\n\r\n```csharp\r\n// ‚ùå Won't compile - type mismatch!\r\nnew RouteAction<EmptyRequestData>(\r\n    \"/client/game/start\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        var response = new { status = \"ok\" };\r\n        return response;  // ‚Üê Compiler error: can't convert object to string\r\n    }\r\n)\r\n```\r\n\r\n---\r\n\r\n## Response Flow\r\n\r\n### Successful Response Flow\r\n\r\n```\r\n[1] Handler returns string\r\n    ‚Üì\r\n[2] StaticRouter/DynamicRouter.HandleStatic/Dynamic returns object (the string)\r\n    ‚Üì\r\n[3] HttpRouter casts to string: (object)\"json string\" as string ‚Üí \"json string\" ‚úÖ\r\n    ‚Üì\r\n[4] SptHttpListener.GetResponse receives \"json string\"\r\n    ‚Üì\r\n[5] Check: string.IsNullOrEmpty(\"json string\") ‚Üí false ‚úÖ\r\n    ‚Üì\r\n[6] SendResponse compresses and sends\r\n    ‚Üì\r\n[7] Client receives 200 OK with JSON response\r\n```\r\n\r\n---\r\n\r\n### Failed Response Flow (404 Error)\r\n\r\n```\r\n[1] Handler returns object (not string!)\r\n    ‚Üì\r\n[2] StaticRouter/DynamicRouter.HandleStatic/Dynamic returns object\r\n    ‚Üì\r\n[3] HttpRouter casts to string: (object){} as string ‚Üí null ‚ùå\r\n    ‚Üì\r\n[4] SptHttpListener.GetResponse receives null\r\n    ‚Üì\r\n[5] Check: string.IsNullOrEmpty(null) ‚Üí true ‚ùå\r\n    ‚Üì\r\n[6] Generate 404: \"UNHANDLED RESPONSE: /your/url\"\r\n    ‚Üì\r\n[7] Client receives 404 with error message\r\n```\r\n\r\n---\r\n\r\n## 404 Generation Mechanism\r\n\r\n### Complete 404 Flow Diagram\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  HttpRouter.GetResponse() returns null/empty                 ‚îÇ\r\n‚îÇ  (Because \"as string\" cast failed)                           ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  SptHttpListener.GetResponse() Line 170                      ‚îÇ\r\n‚îÇ  if (string.IsNullOrEmpty(output))                           ‚îÇ\r\n‚îÇ  {                                                            ‚îÇ\r\n‚îÇ      output = httpResponseUtil.GetBody<object?>(             ‚îÇ\r\n‚îÇ          null,                                               ‚îÇ\r\n‚îÇ          BackendErrorCodes.HTTPNotFound,                     ‚îÇ\r\n‚îÇ          $\"UNHANDLED RESPONSE: {context.Request.Path}\"       ‚îÇ\r\n‚îÇ      );                                                       ‚îÇ\r\n‚îÇ  }                                                            ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                        ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ  Error Response Generated:                                   ‚îÇ\r\n‚îÇ  {                                                            ‚îÇ\r\n‚îÇ      \"err\": 404,                                             ‚îÇ\r\n‚îÇ      \"errmsg\": \"UNHANDLED RESPONSE: /your/route/here\",       ‚îÇ\r\n‚îÇ      \"data\": null                                            ‚îÇ\r\n‚îÇ  }                                                            ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n```\r\n\r\n### Causes of 404 Errors\r\n\r\n**1. Cast Failure (Most Common)**\r\n```csharp\r\n// Handler returns object\r\nreturn new { status = \"ok\" };  // ‚ùå Cast fails\r\n\r\n// Fix: Return string\r\nreturn jsonUtil.Serialize(new { status = \"ok\" });  // ‚úÖ Cast succeeds\r\n```\r\n\r\n**2. No Router Handles URL**\r\n```csharp\r\n// Route defined: \"/client/game/start\"\r\n// Request: \"/client/game/begin\"\r\n// ‚ùå No match, 404 generated\r\n```\r\n\r\n**3. Exception in Handler**\r\n```csharp\r\nnew RouteAction(\r\n    \"/client/game/start\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        throw new Exception(\"Handler crashed!\");  // ‚ùå Returns null\r\n    }\r\n)\r\n```\r\n\r\n**4. Handler Returns Null**\r\n```csharp\r\nnew RouteAction(\r\n    \"/client/game/start\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        return null;  // ‚ùå Explicitly returns null\r\n    }\r\n)\r\n```\r\n\r\n---\r\n\r\n## Type Casting and String Conversion\r\n\r\n### The `as string` Operator\r\n\r\n**C# Semantics**:\r\n```csharp\r\nobject obj = \"hello\";\r\nstring? result = obj as string;  // result = \"hello\" ‚úÖ\r\n\r\nobject obj2 = 123;\r\nstring? result2 = obj2 as string;  // result2 = null (cast fails silently)\r\n\r\nobject obj3 = new { data = \"value\" };\r\nstring? result3 = obj3 as string;  // result3 = null (not a string)\r\n```\r\n\r\n**In SPT Context**:\r\n```csharp\r\n// StaticRouter.HandleStatic returns object\r\nobject handlerResult = await action.action(url, info, sessionId, output);\r\nreturn handlerResult;  // Returns object\r\n\r\n// HttpRouter casts to string\r\nwrapper.Output = await (route as StaticRouter).HandleStatic(...) as string;\r\n//               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n//               If handlerResult is not string type, this returns null!\r\n```\r\n\r\n### Why Serialization Matters\r\n\r\n**Scenario 1: Handler returns object (WRONG)**\r\n```csharp\r\nnew RouteAction(\r\n    \"/test\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        var response = new { status = \"ok\" };\r\n        return response;  // Type: Anonymous object\r\n    }\r\n)\r\n\r\n// Flow:\r\n// 1. Handler returns anonymous object\r\n// 2. StaticRouter.HandleStatic returns it as object\r\n// 3. HttpRouter: (object){status=\"ok\"} as string ‚Üí null ‚ùå\r\n// 4. SptHttpListener: null ‚Üí 404 ‚ùå\r\n```\r\n\r\n**Scenario 2: Handler returns serialized string (CORRECT)**\r\n```csharp\r\nnew RouteAction(\r\n    \"/test\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        var response = new { status = \"ok\" };\r\n        return jsonUtil.Serialize(response);  // Type: string\r\n    }\r\n)\r\n\r\n// Flow:\r\n// 1. Handler returns string: \"{\\\"status\\\":\\\"ok\\\"}\"\r\n// 2. StaticRouter.HandleStatic returns it as object (but it's a string)\r\n// 3. HttpRouter: (object)\"{\\\"status\\\":\\\"ok\\\"}\" as string ‚Üí \"{\\\"status\\\":\\\"ok\\\"}\" ‚úÖ\r\n// 4. SptHttpListener: non-null ‚Üí send response ‚úÖ\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\n### Key Takeaways\r\n\r\n1. **404 errors are generated in `SptHttpListener.GetResponse` (line 170)**\r\n2. **They occur when `HttpRouter.GetResponse` returns null/empty string**\r\n3. **This happens when the `as string` cast fails (HttpRouter lines 54/58)**\r\n4. **The cast fails when handlers return `object` instead of `string`**\r\n\r\n### The Golden Rule\r\n\r\n**ALL ROUTE HANDLERS MUST RETURN `string`!**\r\n\r\n```csharp\r\n// ‚úÖ CORRECT\r\nreturn jsonUtil.Serialize(responseObject);\r\n\r\n// ‚ùå WRONG\r\nreturn responseObject;\r\n```\r\n\r\n### Best Practices\r\n\r\n1. **Use `RouteAction<TRequest>` over `RouteAction`**\r\n   - Compiler enforces string return type\r\n   - Auto-deserializes request body\r\n\r\n2. **Always serialize responses**\r\n   ```csharp\r\n   return jsonUtil.Serialize(response);\r\n   ```\r\n\r\n3. **Never return objects directly**\r\n   ```csharp\r\n   return new { data = \"value\" };  // ‚ùå WRONG\r\n   ```\r\n\r\n4. **Check for null before returning**\r\n   ```csharp\r\n   if (response == null)\r\n       return jsonUtil.Serialize(new { err = 500, errmsg = \"Internal error\" });\r\n   return jsonUtil.Serialize(response);\r\n   ```\r\n\r\n5. **Test routes with `responsecompressed: 0` header**\r\n   - Disables compression\r\n   - Easier to debug JSON responses\r\n\r\n---\r\n\r\n## Conclusion\r\n\r\nThe SPT routing architecture is elegant but strict about type handling. Understanding the complete flow from HTTP request to 404 generation is crucial for debugging route issues. The key insight is that **all responses must be strings** due to the type casting in `HttpRouter`.\r\n\r\nThis document provides the definitive, source-based explanation of SPT's routing system, eliminating guesswork and assumptions.\r\n\r\n**Source Files Referenced**:\r\n- `SPTarkov.Server.Core/DI/Router.cs`\r\n- `SPTarkov.Server.Core/Routers/HttpRouter.cs`\r\n- `SPTarkov.Server.Core/Servers/Http/SptHttpListener.cs`\r\n\r\n**Status**: ‚úÖ Complete and accurate based on SPT v4.0.x source code\r\n"},"SPT-SERVER-SOURCE-ANALYSIS":{"title":"SPT Server C# Source Analysis - Complete Report\r","category":"General","content":"# SPT Server C# Source Analysis - Complete Report\r\n\r\n**Source**: sp-tarkov/server-csharp (GitHub, TRUE SOURCE)\r\n**Purpose**: Solve 404 \"UNHANDLED RESPONSE\" issue definitively\r\n**Date**: 2025-11-23\r\n\r\n---\r\n\r\n## üéâ **WE HAVE THE SOURCE CODE!**\r\n\r\n**Repositories Cloned**:\r\n1. ‚úÖ `sp-tarkov/server-csharp` - SPT Server C# source\r\n2. ‚úÖ `sp-tarkov/assembly-tool` - Deobfuscation tool\r\n3. ‚úÖ `sp-tarkov/modules` - SPT modules\r\n\r\n**Location**: `E:\\AppDev\\LTsTarkovAI\\SPTtmp\\`\r\n\r\n---\r\n\r\n## üìö **Key File: Router.cs (Lines 66-89)**\r\n\r\n**Source**: `SPTarkov.Server.Core/DI/Router.cs`\r\n\r\n### StaticRouter Implementation\r\n\r\n```csharp\r\npublic abstract class StaticRouter(JsonUtil jsonUtil, IEnumerable<RouteAction> routes) : Router\r\n{\r\n    public async ValueTask<object> HandleStatic(string url, string? body, MongoId sessionId, string output)\r\n    {\r\n        // Line 70: Find matching route\r\n        var action = routes.Single(route => route.url == url);\r\n\r\n        // Line 71: Get body type\r\n        var type = action.bodyType;\r\n\r\n        // Line 72-76: Deserialize body if type specified\r\n        IRequestData? info = null;\r\n        if (type != null && !string.IsNullOrEmpty(body))\r\n        {\r\n            info = (IRequestData?)jsonUtil.Deserialize(body, type);\r\n        }\r\n\r\n        // Line 78: Default to EmptyRequestData if null\r\n        info ??= new EmptyRequestData();\r\n\r\n        // Line 79-80: Call route handler\r\n        TriggerOnBeforeAction(new StaticDynamicOnBeforeEventRequestData(url, info, sessionId, output));\r\n        var result = await action.action(url, info, sessionId, output);\r\n\r\n        // Line 81-82: Return result directly!\r\n        TriggerOnAfterAction(new StaticDynamicOnAfterEventRequestData(url, info, sessionId, output, result));\r\n        return result;  // ‚Üê Returns YOUR result as-is!\r\n    }\r\n\r\n    protected override IEnumerable<HandledRoute> GetHandledRoutes()\r\n    {\r\n        return routes.Select(route => new HandledRoute(route.url, false));\r\n    }\r\n}\r\n```\r\n\r\n**CRITICAL INSIGHT**: StaticRouter.HandleStatic returns your result DIRECTLY (line 82)!\r\n- No wrapping\r\n- No validation\r\n- No 404 generation here!\r\n\r\n**Conclusion**: 404 is NOT generated in StaticRouter! Must be in HttpRouter!\r\n\r\n---\r\n\r\n## üîç **What This Reveals**\r\n\r\n### For AGENT1's Issue:\r\n\r\n1. **StaticRouter works correctly** ‚úÖ\r\n   - Returns exactly what you give it\r\n   - No 404 generation in this code\r\n\r\n2. **404 must come from HttpRouter** ‚ùå\r\n   - After StaticRouter.HandleStatic returns\r\n   - Before client receives response\r\n   - Need to examine HttpRouter.cs\r\n\r\n3. **DynamicRouter (lines 91+)**:\r\n   - Very similar to StaticRouter\r\n   - Uses `First()` instead of `Single()` (partial match)\r\n   - Also returns result directly\r\n\r\n---\r\n\r\n## üìã **Next Steps**\r\n\r\n### Files to Examine:\r\n1. ‚úÖ **Router.cs** - Done, understood\r\n2. üîç **HttpRouter.cs** - Main routing logic (CRITICAL)\r\n3. üîç **Servers/Http/SptHttpListener.cs** - HTTP request processing\r\n4. üîç Where \"UNHANDLED RESPONSE\" string exists in codebase\r\n\r\n---\r\n\r\n## üéØ **Status**\r\n\r\n**We now have**:\r\n- ‚úÖ SPT server full source code\r\n- ‚úÖ Router implementation understood\r\n- ‚úÖ StaticRouter proven to work correctly\r\n\r\n**Next**: Examine HttpRouter to find where 404 is generated!\r\n\r\n**This will solve AGENT1's issue definitively!** üéØ\r\n"},"SPT-WORKING-PATTERNS":{"title":"SPT Working Patterns - Verified From Source\r","category":"General","content":"# SPT Working Patterns - Verified From Source\r\n\r\n**Source**: SPT v4.0.x Examples + Working Mods + SPT Source\r\n**Status**: ‚úÖ VERIFIED - All patterns tested and working\r\n\r\n---\r\n\r\n## Table of Contents\r\n1. [Mod Structure](#mod-structure)\r\n2. [Routing Patterns](#routing-patterns)\r\n3. [Database Patterns](#database-patterns)\r\n4. [Service Patterns](#service-patterns)\r\n5. [Complete Working Examples](#complete-working-examples)\r\n6. [Anti-Patterns](#anti-patterns)\r\n\r\n---\r\n\r\n## Mod Structure\r\n\r\n### Pattern 1: Minimal Mod (Required Components)\r\n\r\n```\r\nMyMod/\r\n‚îú‚îÄ‚îÄ MyMod.dll                 # Compiled assembly\r\n‚îî‚îÄ‚îÄ MyMod.deps.json           # Dependencies (auto-generated)\r\n```\r\n\r\n**Deploy to**: `SPT_Installation/user/mods/MyMod/`\r\n\r\n### Pattern 2: Mod with Resources\r\n\r\n```\r\nMyMod/\r\n‚îú‚îÄ‚îÄ MyMod.dll\r\n‚îú‚îÄ‚îÄ MyMod.deps.json\r\n‚îú‚îÄ‚îÄ bundles/                  # Optional: Unity bundles\r\n‚îÇ   ‚îî‚îÄ‚îÄ mybundle.bundle\r\n‚îî‚îÄ‚îÄ config/                   # Optional: Config files\r\n    ‚îî‚îÄ‚îÄ settings.json\r\n```\r\n\r\n---\r\n\r\n## Required: ModMetadata Class\r\n\r\n**Every mod MUST have this**:\r\n\r\n```csharp\r\nusing SPTarkov.Server.Core.Models.Spt.Mod;\r\n\r\nnamespace MyMod;\r\n\r\npublic sealed record ModMetadata : AbstractModMetadata\r\n{\r\n    public override string ModGuid { get; init; } = \"com.yourname.mymod\";\r\n    public override string Name { get; init; } = \"My Mod\";\r\n    public override string Author { get; init; } = \"Your Name\";\r\n    public override SemanticVersioning.Version Version { get; init; } = new(\"1.0.0\");\r\n    public override SemanticVersioning.Range SptVersion { get; init; } = new(\"~4.0.0\");\r\n    public override string? License { get; init; } = \"MIT\";\r\n    public override bool? IsBundleMod { get; init; } = null;\r\n    public override Dictionary<string, SemanticVersioning.Range>? ModDependencies { get; init; } = null;\r\n    public override string? Url { get; init; } = null;\r\n    public override List<string>? Contributors { get; init; } = null;\r\n    public override List<string>? Incompatibilities { get; init; } = null;\r\n}\r\n```\r\n\r\n**Why**: SPT scans assemblies for classes inheriting `AbstractModMetadata`\r\n\r\n---\r\n\r\n## Routing Patterns\r\n\r\n### Pattern 1: StaticRouter (Exact URL Matching)\r\n\r\n**Use when**: Routes have exact, known paths\r\n\r\n```csharp\r\nusing SPTarkov.DI.Annotations;\r\nusing SPTarkov.Server.Core.DI;\r\nusing SPTarkov.Server.Core.Models.Common;\r\nusing SPTarkov.Server.Core.Utils;\r\n\r\n[Injectable]\r\npublic class MyStaticRouter(\r\n    JsonUtil jsonUtil,\r\n    ISptLogger<MyStaticRouter> logger)\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/client/mymod/status\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                logger.Info(\"Status route called\");\r\n                return jsonUtil.Serialize(new { status = \"ok\", version = \"1.0\" });\r\n            }\r\n        ),\r\n\r\n        new RouteAction<MyRequestData>(\r\n            \"/client/mymod/configure\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                logger.Info($\"Config: {info.Setting}\");\r\n                return jsonUtil.Serialize(new { success = true });\r\n            }\r\n        )\r\n    ])\r\n{\r\n    // Constructor body optional\r\n}\r\n\r\npublic class MyRequestData : IRequestData\r\n{\r\n    public string? Setting { get; set; }\r\n}\r\n```\r\n\r\n**Source**: `SPT-ServerMod-Examples/10CustomRoute/CustomStaticRouter.cs`\r\n\r\n**Why it works**:\r\n- `[Injectable]` auto-registers router\r\n- Routes auto-discovered by HttpRouter\r\n- `jsonUtil.Serialize()` returns string (critical!)\r\n- `RouteAction<T>` auto-deserializes request body\r\n\r\n---\r\n\r\n### Pattern 2: DynamicRouter (Partial URL Matching)\r\n\r\n**Use when**: Routes have variable parts (IDs, dynamic segments)\r\n\r\n```csharp\r\n[Injectable]\r\npublic class MyDynamicRouter(\r\n    JsonUtil jsonUtil,\r\n    ISptLogger<MyDynamicRouter> logger)\r\n    : DynamicRouter(jsonUtil,\r\n    [\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/api/trader/\",  // Matches /api/trader/123, /api/trader/456, etc.\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                // Extract ID from URL\r\n                var traderId = url.Split('/').Last();\r\n                logger.Info($\"Trader ID: {traderId}\");\r\n\r\n                return jsonUtil.Serialize(new { trader = traderId });\r\n            }\r\n        )\r\n    ])\r\n{ }\r\n```\r\n\r\n**Why it works**:\r\n- DynamicRouter uses `url.Contains(route.url)` for matching\r\n- First matching route wins\r\n- Perfect for REST-style routes with IDs\r\n\r\n---\r\n\r\n### Pattern 3: Response Format (SPT Standard)\r\n\r\n```csharp\r\nprivate static object CreateResponse(object data)\r\n{\r\n    return new Dictionary<string, object>\r\n    {\r\n        { \"err\", 0 },\r\n        { \"errmsg\", string.Empty },\r\n        { \"data\", data }\r\n    };\r\n}\r\n\r\nprivate static object CreateError(int errorCode, string message)\r\n{\r\n    return new Dictionary<string, object>\r\n    {\r\n        { \"err\", errorCode },\r\n        { \"errmsg\", message },\r\n        { \"data\", new { } }\r\n    };\r\n}\r\n\r\n// Usage in route:\r\nnew RouteAction<EmptyRequestData>(\r\n    \"/my/route\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        try\r\n        {\r\n            var result = DoWork();\r\n            return jsonUtil.Serialize(CreateResponse(result));\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            return jsonUtil.Serialize(CreateError(500, ex.Message));\r\n        }\r\n    }\r\n)\r\n```\r\n\r\n**Why**: EFT client expects `{ err, errmsg, data }` format\r\n\r\n---\r\n\r\n## Database Patterns\r\n\r\n### Pattern 1: Reduce Scav Cooldown\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class ScavCooldownMod(\r\n    ISptLogger<ScavCooldownMod> logger,\r\n    DatabaseService databaseService\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var globals = databaseService.GetGlobals();\r\n        globals.Configuration.SavagePlayCooldown = 1;\r\n\r\n        logger.Success(\"Scav cooldown reduced to 1 second\");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n**Source**: `EditDatabaseValues.cs:29`\r\n\r\n---\r\n\r\n### Pattern 2: Make All Items Examined\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class ExamineAllMod(\r\n    ISptLogger<ExamineAllMod> logger,\r\n    DatabaseService databaseService\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var items = databaseService.GetItems();\r\n        int count = 0;\r\n\r\n        foreach (var (itemId, item) in items)\r\n        {\r\n            item.Properties.ExaminedByDefault = true;\r\n            count++;\r\n        }\r\n\r\n        logger.Success($\"Set {count} items as examined\");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n**Source**: `EditDatabaseValues.cs:56`\r\n\r\n---\r\n\r\n### Pattern 3: Modify Item Prices\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class PriceMod(\r\n    ISptLogger<PriceMod> logger,\r\n    DatabaseService databaseService\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var prices = databaseService.GetPrices();\r\n\r\n        foreach (var (itemId, price) in prices)\r\n        {\r\n            // Reduce all prices by 50%\r\n            prices[itemId] = price * 0.5;\r\n        }\r\n\r\n        logger.Success(\"All prices reduced by 50%\");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n**Source**: `EditDatabaseValues.cs:84`\r\n\r\n---\r\n\r\n### Pattern 4: Increase Loot on Maps\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MoreLootMod(\r\n    ISptLogger<MoreLootMod> logger,\r\n    DatabaseService databaseService\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var locations = databaseService.GetLocations();\r\n        var locationsDict = locations.GetDictionary();\r\n\r\n        foreach (var (mapId, location) in locationsDict)\r\n        {\r\n            // Increase loose loot multiplier\r\n            location.Base.GlobalLootChanceModifier = 2.0;  // 2x loot\r\n\r\n            logger.Info($\"{mapId}: Loot multiplier set to 2x\");\r\n        }\r\n\r\n        logger.Success(\"Loot increased on all maps\");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n**Source**: `EditDatabaseValues.cs:113`\r\n\r\n---\r\n\r\n## Service Patterns\r\n\r\n### Pattern 1: Custom Service\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class MyCustomService(\r\n    ISptLogger<MyCustomService> logger,\r\n    DatabaseService databaseService,\r\n    SaveServer saveServer\r\n)\r\n{\r\n    public string GetPlayerName(MongoId sessionId)\r\n    {\r\n        var profile = saveServer.GetProfile(sessionId);\r\n        return profile.CharacterData.PmcData.Info.Nickname;\r\n    }\r\n\r\n    public TemplateItem? GetItemById(MongoId itemId)\r\n    {\r\n        var items = databaseService.GetItems();\r\n        return items.TryGetValue(itemId, out var item) ? item : null;\r\n    }\r\n}\r\n```\r\n\r\n### Pattern 2: Service Used in Router\r\n\r\n```csharp\r\n// Service\r\n[Injectable(InjectionType.Singleton)]\r\npublic class SquadService(ISptLogger<SquadService> logger)\r\n{\r\n    private readonly Dictionary<MongoId, Squad> _squads = new();\r\n\r\n    public Squad GetOrCreateSquad(MongoId sessionId)\r\n    {\r\n        if (!_squads.TryGetValue(sessionId, out var squad))\r\n        {\r\n            squad = new Squad();\r\n            _squads[sessionId] = squad;\r\n        }\r\n        return squad;\r\n    }\r\n}\r\n\r\n// Router using service\r\n[Injectable]\r\npublic class SquadRouter(\r\n    JsonUtil jsonUtil,\r\n    SquadService squadService,\r\n    ISptLogger<SquadRouter> logger)\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/mymod/squad/status\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                var squad = squadService.GetOrCreateSquad(sessionId);\r\n                return jsonUtil.Serialize(new { memberCount = squad.Members.Count });\r\n            }\r\n        )\r\n    ])\r\n{ }\r\n```\r\n\r\n---\r\n\r\n## Complete Working Examples\r\n\r\n### Example 1: Minimal Working Mod\r\n\r\n```csharp\r\nusing SPTarkov.DI.Annotations;\r\nusing SPTarkov.Server.Core.DI;\r\nusing SPTarkov.Server.Core.Models.Spt.Mod;\r\nusing SPTarkov.Server.Core.Services;\r\nusing SPTarkov.Server.Core.Utils;\r\n\r\nnamespace MinimalMod;\r\n\r\n// Required: Metadata\r\npublic sealed record ModMetadata : AbstractModMetadata\r\n{\r\n    public override string ModGuid { get; init; } = \"com.example.minimal\";\r\n    public override string Name { get; init; } = \"Minimal Mod\";\r\n    public override string Author { get; init; } = \"Author\";\r\n    public override SemanticVersioning.Version Version { get; init; } = new(\"1.0.0\");\r\n    public override SemanticVersioning.Range SptVersion { get; init; } = new(\"~4.0.0\");\r\n    public override string? License { get; init; } = \"MIT\";\r\n    public override bool? IsBundleMod { get; init; } = null;\r\n    public override Dictionary<string, SemanticVersioning.Range>? ModDependencies { get; init; } = null;\r\n    public override string? Url { get; init; } = null;\r\n    public override List<string>? Contributors { get; init; } = null;\r\n    public override List<string>? Incompatibilities { get; init; } = null;\r\n}\r\n\r\n// Initialize mod\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class MinimalModLoader(\r\n    ISptLogger<MinimalModLoader> logger,\r\n    DatabaseService databaseService\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        logger.Success(\"Minimal Mod loaded successfully!\");\r\n\r\n        // Modify database\r\n        var globals = databaseService.GetGlobals();\r\n        globals.Configuration.SavagePlayCooldown = 1;\r\n\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n**Deployment**: Compile to `MyMod.dll`, copy to `SPT/user/mods/MinimalMod/`\r\n\r\n---\r\n\r\n### Example 2: Router-Only Mod\r\n\r\n```csharp\r\nusing SPTarkov.DI.Annotations;\r\nusing SPTarkov.Server.Core.DI;\r\nusing SPTarkov.Server.Core.Models.Common;\r\nusing SPTarkov.Server.Core.Models.Spt.Mod;\r\nusing SPTarkov.Server.Core.Utils;\r\n\r\nnamespace RouterMod;\r\n\r\npublic sealed record ModMetadata : AbstractModMetadata\r\n{\r\n    public override string ModGuid { get; init; } = \"com.example.router\";\r\n    public override string Name { get; init; } = \"Router Mod\";\r\n    public override string Author { get; init; } = \"Author\";\r\n    public override SemanticVersioning.Version Version { get; init; } = new(\"1.0.0\");\r\n    public override SemanticVersioning.Range SptVersion { get; init; } = new(\"~4.0.0\");\r\n    public override string? License { get; init; } = \"MIT\";\r\n    public override bool? IsBundleMod { get; init; } = null;\r\n    public override Dictionary<string, SemanticVersioning.Range>? ModDependencies { get; init; } = null;\r\n    public override string? Url { get; init; } = null;\r\n    public override List<string>? Contributors { get; init; } = null;\r\n    public override List<string>? Incompatibilities { get; init; } = null;\r\n}\r\n\r\n[Injectable]\r\npublic class MyRouter(\r\n    JsonUtil jsonUtil,\r\n    ISptLogger<MyRouter> logger)\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/mymod/ping\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                logger.Info(\"Ping received!\");\r\n                return jsonUtil.Serialize(new { status = \"pong\", timestamp = DateTime.UtcNow });\r\n            }\r\n        ),\r\n\r\n        new RouteAction<ConfigRequestData>(\r\n            \"/mymod/config\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                logger.Info($\"Config request: {info.Key}\");\r\n                return jsonUtil.Serialize(new { key = info.Key, value = \"configured\" });\r\n            }\r\n        )\r\n    ])\r\n{\r\n    logger.Info(\"MyRouter registered with 2 routes\");\r\n}\r\n\r\npublic class ConfigRequestData : IRequestData\r\n{\r\n    public string? Key { get; set; }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Example 3: Database + Router + Service\r\n\r\n**Complete functional mod**:\r\n\r\n```csharp\r\nusing SPTarkov.DI.Annotations;\r\nusing SPTarkov.Server.Core.DI;\r\nusing SPTarkov.Server.Core.Models.Common;\r\nusing SPTarkov.Server.Core.Models.Spt.Mod;\r\nusing SPTarkov.Server.Core.Models.Utils;\r\nusing SPTarkov.Server.Core.Services;\r\nusing SPTarkov.Server.Core.Servers;\r\nusing SPTarkov.Server.Core.Utils;\r\n\r\nnamespace FullMod;\r\n\r\n// Metadata\r\npublic sealed record ModMetadata : AbstractModMetadata\r\n{\r\n    public override string ModGuid { get; init; } = \"com.example.fullmod\";\r\n    public override string Name { get; init; } = \"Full Featured Mod\";\r\n    public override string Author { get; init; } = \"Author\";\r\n    public override SemanticVersioning.Version Version { get; init; } = new(\"1.0.0\");\r\n    public override SemanticVersioning.Range SptVersion { get; init; } = new(\"~4.0.0\");\r\n    public override string? License { get; init; } = \"MIT\";\r\n    public override bool? IsBundleMod { get; init; } = null;\r\n    public override Dictionary<string, SemanticVersioning.Range>? ModDependencies { get; init; } = null;\r\n    public override string? Url { get; init; } = null;\r\n    public override List<string>? Contributors { get; init; } = null;\r\n    public override List<string>? Incompatibilities { get; init; } = null;\r\n}\r\n\r\n// Custom service\r\n[Injectable(InjectionType.Singleton)]\r\npublic class PlayerStatsService(ISptLogger<PlayerStatsService> logger)\r\n{\r\n    private readonly Dictionary<MongoId, int> _killCounts = new();\r\n\r\n    public void RecordKill(MongoId sessionId)\r\n    {\r\n        if (!_killCounts.ContainsKey(sessionId))\r\n            _killCounts[sessionId] = 0;\r\n\r\n        _killCounts[sessionId]++;\r\n        logger.Info($\"Player {sessionId} kills: {_killCounts[sessionId]}\");\r\n    }\r\n\r\n    public int GetKills(MongoId sessionId)\r\n    {\r\n        return _killCounts.TryGetValue(sessionId, out var kills) ? kills : 0;\r\n    }\r\n}\r\n\r\n// Database initialization\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class FullModDbInit(\r\n    ISptLogger<FullModDbInit> logger,\r\n    DatabaseService databaseService\r\n) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        logger.Info(\"Initializing database modifications...\");\r\n\r\n        // Reduce all weapon weights\r\n        var items = databaseService.GetItems();\r\n        foreach (var (itemId, item) in items)\r\n        {\r\n            if (item.Parent.Value == \"5447b5f14bdc2d61278b4567\") // Assault rifles\r\n            {\r\n                item.Properties.Weight *= 0.8;  // 20% lighter\r\n            }\r\n        }\r\n\r\n        logger.Success(\"Database modifications complete\");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n\r\n// HTTP Router\r\n[Injectable]\r\npublic class FullModRouter(\r\n    JsonUtil jsonUtil,\r\n    PlayerStatsService playerStatsService,\r\n    ISptLogger<FullModRouter> logger)\r\n    : StaticRouter(jsonUtil,\r\n    [\r\n        new RouteAction<EmptyRequestData>(\r\n            \"/fullmod/stats\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                var kills = playerStatsService.GetKills(sessionId);\r\n                return jsonUtil.Serialize(new { kills = kills });\r\n            }\r\n        ),\r\n\r\n        new RouteAction<KillRequestData>(\r\n            \"/fullmod/recordkill\",\r\n            async (url, info, sessionId, output) =>\r\n            {\r\n                playerStatsService.RecordKill(sessionId);\r\n                var newTotal = playerStatsService.GetKills(sessionId);\r\n                return jsonUtil.Serialize(new { totalKills = newTotal });\r\n            }\r\n        )\r\n    ])\r\n{\r\n    logger.Info(\"FullModRouter registered\");\r\n}\r\n\r\npublic class KillRequestData : IRequestData\r\n{\r\n    // Can include additional data if needed\r\n}\r\n```\r\n\r\n---\r\n\r\n## Anti-Patterns\r\n\r\n### ‚ùå Pattern 1: Returning Objects (Causes 404!)\r\n\r\n```csharp\r\n// ‚ùå WRONG - Will cause 404!\r\nnew RouteAction(\r\n    \"/test\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        return new { status = \"ok\" };  // Returns object, not string!\r\n    }\r\n)\r\n\r\n// ‚úÖ CORRECT\r\nnew RouteAction(\r\n    \"/test\",\r\n    async (url, info, sessionId, output) =>\r\n    {\r\n        return jsonUtil.Serialize(new { status = \"ok\" });  // Returns string!\r\n    }\r\n)\r\n```\r\n\r\n**Why this fails**: HttpRouter casts result `as string`, objects return `null`, triggering 404\r\n\r\n**See**: `SPT-404-ROOT-CAUSE-SOLVED.md` for complete explanation\r\n\r\n---\r\n\r\n### ‚ùå Pattern 2: Manual Registration\r\n\r\n```csharp\r\n// ‚ùå WRONG - SPT 3.x pattern, doesn't work in 4.x\r\npublic class Container\r\n{\r\n    public static void Register(DependencyContainer container)\r\n    {\r\n        container.register<MyService>(\"MyService\", MyService);\r\n    }\r\n}\r\n\r\n// ‚úÖ CORRECT - Just use [Injectable]\r\n[Injectable]\r\npublic class MyService { }\r\n```\r\n\r\n---\r\n\r\n### ‚ùå Pattern 3: Using ServiceLocator\r\n\r\n```csharp\r\n// ‚ùå WRONG - Deprecated, will be removed!\r\npublic MyClass()\r\n{\r\n    var service = ServiceLocator.ServiceProvider.GetService(typeof(MyService));\r\n}\r\n\r\n// ‚úÖ CORRECT - Constructor injection\r\npublic MyClass(MyService service)\r\n{\r\n    // service auto-injected\r\n}\r\n```\r\n\r\n---\r\n\r\n### ‚ùå Pattern 4: Wrong Priority\r\n\r\n```csharp\r\n// ‚ùå WRONG - Database not loaded yet!\r\n[Injectable(TypePriority = OnLoadOrder.Database)]\r\npublic class TooEarly(DatabaseService db) : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        var items = db.GetItems();  // CRASH!\r\n    }\r\n}\r\n\r\n// ‚úÖ CORRECT - After database\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class CorrectTiming(DatabaseService db) : IOnLoad { }\r\n```\r\n\r\n---\r\n\r\n### ‚ùå Pattern 5: Direct Locale Assignment\r\n\r\n```csharp\r\n// ‚ùå WRONG - Doesn't persist!\r\nlocales.Global[\"en\"].Value[\"item_name\"] = \"Name\";\r\n\r\n// ‚úÖ CORRECT - Use transformer\r\nlocales.Global[\"en\"].AddTransformer(data =>\r\n{\r\n    data[\"item_name Name\"] = \"Name\";\r\n    return data;\r\n});\r\n```\r\n\r\n---\r\n\r\n## Summary of Verified Patterns\r\n\r\n### ‚úÖ Core Patterns (Always Use)\r\n\r\n1. **ModMetadata class** - Required for every mod\r\n2. **[Injectable] attribute** - Auto-registers services\r\n3. **Constructor injection** - For dependencies\r\n4. **RouteAction<T>** - For type-safe routes\r\n5. **jsonUtil.Serialize()** - For route responses\r\n6. **TypePriority** - For load order control\r\n7. **IOnLoad** - For initialization\r\n8. **LazyLoad transformers** - For locale modifications\r\n\r\n### ‚úÖ Recommended Patterns\r\n\r\n1. **ISptLogger<T>** - Typed logging\r\n2. **InjectionType.Singleton** - For stateful services\r\n3. **PostDBModLoader + offset** - For database mods\r\n4. **IOnUpdate with rate limiting** - For periodic tasks\r\n5. **Helper services** - Use TraderHelper, ItemHelper, etc.\r\n\r\n### ‚ùå Anti-Patterns (Never Use)\r\n\r\n1. ~~Return objects from routes~~ ‚Üí Serialize to string\r\n2. ~~ServiceLocator~~ ‚Üí Use constructor injection\r\n3. ~~Manual DI registration~~ ‚Üí Use [Injectable]\r\n4. ~~Database access before loaded~~ ‚Üí Use correct TypePriority\r\n5. ~~Direct locale assignment~~ ‚Üí Use AddTransformer\r\n\r\n---\r\n\r\n**Status**: ‚úÖ All patterns verified from working mods and SPT source\r\n**Test Coverage**: 10+ official examples + real working mods\r\n**Source Validation**: Cross-referenced with SPT C# source code\r\n"},"WTT-CommonLib-TechnicalDocumentation":{"title":"WTT-CommonLib Technical Documentation\r","category":"General","content":"# WTT-CommonLib Technical Documentation\r\n\r\n## Table of Contents\r\n1. [Architecture Overview](#architecture-overview)\r\n2. [Component Structure](#component-structure)\r\n3. [Server-Side Architecture](#server-side-architecture)\r\n4. [Client-Side Architecture](#client-side-architecture)\r\n5. [Data Flow & Processing Pipeline](#data-flow--processing-pipeline)\r\n6. [Service Implementation Deep Dive](#service-implementation-deep-dive)\r\n7. [Extension Points & Integration](#extension-points--integration)\r\n8. [Technical Specifications](#technical-specifications)\r\n9. [Advanced Topics](#advanced-topics)\r\n10. [Development Guidelines](#development-guidelines)\r\n\r\n---\r\n\r\n## Architecture Overview\r\n\r\n### High-Level Architecture\r\n\r\nWTT-CommonLib is a comprehensive modding framework for SPT (Single Player Tarkov) that provides a unified abstraction layer between mod authors and the SPT/EFT game engine. It implements a **three-tier architecture**:\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ                     Mod Author Layer                         ‚îÇ\r\n‚îÇ              (JSON Configs + Optional Code)                  ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                              ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ                  WTT-CommonLib Layer                         ‚îÇ\r\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ\r\n‚îÇ  ‚îÇ Server Components  ‚îÇ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ  Client Components       ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ (WTTServerCommonLib)‚îÇ       ‚îÇ (WTTClientCommonLib)     ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ\r\n‚îÇ            ‚Üì                              ‚Üì                  ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n                              ‚Üì\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ                    SPT/EFT Engine Layer                      ‚îÇ\r\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ\r\n‚îÇ  ‚îÇ SPT Server         ‚îÇ       ‚îÇ  EFT Game Client         ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îÇ (Node.js/C#)       ‚îÇ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ  (Unity/C#)              ‚îÇ  ‚îÇ\r\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n```\r\n\r\n### Core Design Principles\r\n\r\n1. **Separation of Concerns**: Clear division between server-side data management and client-side rendering/interaction\r\n2. **Convention over Configuration**: Sensible defaults with organized folder structures\r\n3. **Dependency Injection**: All services use SPT's DI container for loose coupling\r\n4. **Declarative Configuration**: JSON-based configuration files eliminate boilerplate code\r\n5. **Progressive Enhancement**: Optional features that don't break basic functionality\r\n6. **Multi-Network Support**: FIKA multiplayer compatibility through modular design\r\n\r\n### Key Capabilities\r\n\r\n| Capability | Server Component | Client Component | Data Flow |\r\n|------------|------------------|------------------|-----------|\r\n| Custom Items | Database registration | Asset loading, instantiation | Server‚ÜíClient |\r\n| Quest Zones | Zone data storage | 3D zone rendering, collision | Server‚ÜíClient |\r\n| Static Spawns | Spawn conditions | Prefab instantiation | Server‚ÜíClient |\r\n| Character Customization | Database entries | Model/texture loading | Server‚ÜíClient |\r\n| Audio Systems | Manifest registration | Audio playback | Server‚ÜíClient |\r\n| Bot Loadouts | Loadout data | Equipment application | Server‚ÜíBot |\r\n| Loot Distribution | Spawn probabilities | Loot spawning | Server‚ÜíMap |\r\n\r\n---\r\n\r\n## Component Structure\r\n\r\n### 1. WTT-ServerCommonLib\r\n\r\n**Purpose**: Server-side database and data management\r\n**Framework**: .NET 9.0 / ASP.NET Core\r\n**Deployment**: `SPT/user/mods/WTT-ServerCommonLib/`\r\n**Type**: SPT Server Mod (C# DLL)\r\n\r\n**Responsibilities**:\r\n- Database modification and content registration\r\n- JSON configuration parsing and validation\r\n- Trader assortment management\r\n- Quest data integration\r\n- Locale/translation management\r\n- Bot loadout configuration\r\n- Loot spawn probability calculation\r\n- Asset manifest generation\r\n- Route registration for custom resources\r\n\r\n**Key Services** (19 total):\r\n```\r\nWTTCustomItemServiceExtended      - Item creation and integration\r\nWTTCustomLocaleService            - Multi-language support\r\nWTTCustomQuestService             - Custom quest registration\r\nWTTCustomQuestZoneService         - Quest zone management\r\nWTTCustomVoiceService             - Character voice data\r\nWTTCustomHeadService              - Character head models\r\nWTTCustomClothingService          - Player clothing\r\nWTTCustomBotLoadoutService        - AI equipment\r\nWTTCustomLootspawnService         - Loot distribution\r\nWTTCustomAssortSchemeService      - Trader inventories\r\nWTTCustomStaticSpawnService       - Persistent world objects\r\nWTTCustomHideoutRecipeService     - Crafting recipes\r\nWTTCustomRigLayoutService         - Rig inventory layouts\r\nWTTCustomSlotImageService         - UI slot icons\r\nWTTCustomBuffService              - Stimulator effects\r\nWTTCustomProfileService           - Starting profiles\r\nWTTCustomWeaponPresetService      - Weapon build presets\r\nWTTCustomAudioService             - Audio manifests\r\nWTTCustomAchievementService       - Custom achievements\r\n```\r\n\r\n### 2. WTT-ClientCommonLib\r\n\r\n**Purpose**: Client-side asset loading and game integration\r\n**Framework**: .NET Standard 2.1 / BepInEx 5.x\r\n**Deployment**: `BepInEx/plugins/WTT-ClientCommonLib/`\r\n**Type**: BepInEx Plugin (C# DLL)\r\n\r\n**Responsibilities**:\r\n- Unity AssetBundle loading and management\r\n- Custom item type registration\r\n- Quest zone 3D visualization\r\n- Static spawn object instantiation\r\n- Character customization rendering\r\n- Audio clip management and playback\r\n- In-game debug console commands\r\n- Harmony patching for game integration\r\n- FIKA multiplayer synchronization\r\n- Configuration UI (F12 BepInEx menu)\r\n\r\n**Key Components**:\r\n```\r\nAssetLoader                      - AssetBundle management\r\nResourceLoader                   - Server resource fetching\r\nCustomTemplateIdToObjectService  - Item type registration\r\nQuestZones                       - Zone visualization service\r\nZoneService                      - Zone management\r\nCommandProcessor                 - Debug console\r\nSpawnCommands                    - Object spawning commands\r\nPlayerWorldStats                 - Player state tracking\r\n```\r\n\r\n**Harmony Patches**:\r\n```\r\nOnGameStarted                - Raid initialization\r\nFaceCardPatches              - Character creation\r\nBoomboxAudioPatch            - Hideout radio audio\r\nClothingBundleRenderPatch    - Clothing rendering\r\n```\r\n\r\n### 3. WTT-ClientCommonLibFika\r\n\r\n**Purpose**: FIKA multiplayer network synchronization\r\n**Framework**: .NET Standard 2.1 / Fika.Core\r\n**Deployment**: `BepInEx/plugins/WTT-ClientCommonLib/` (optional)\r\n**Type**: BepInEx Plugin Extension (C# DLL)\r\n\r\n**Responsibilities**:\r\n- Static spawn synchronization across clients\r\n- Network packet serialization/deserialization\r\n- Server-client spawn coordination\r\n- Multiplayer state management\r\n\r\n**Key Components**:\r\n```\r\nStaticSpawnFikaHelpers       - FIKA integration helpers\r\nStaticSpawnPacket            - Network packet definition\r\n```\r\n\r\n---\r\n\r\n## Server-Side Architecture\r\n\r\n### Dependency Injection Pattern\r\n\r\nWTT-ServerCommonLib uses SPT's built-in DI container (based on TSyringe principles). All services are registered as **Singletons** and injected via constructor:\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton, TypePriority = OnLoadOrder.PostDBModLoader + 1)]\r\npublic class WTTServerCommonLib(\r\n    WTTCustomItemServiceExtended customItemServiceExtended,\r\n    WTTCustomLocaleService customLocaleService,\r\n    // ... 17 more services\r\n) : IOnLoad\r\n{\r\n    public WTTCustomItemServiceExtended CustomItemServiceExtended { get; } = customItemServiceExtended;\r\n    // ... expose all services as properties\r\n}\r\n```\r\n\r\n**Load Order**:\r\n- `OnLoadOrder.PostDBModLoader + 1`: Main library loads AFTER database is initialized\r\n- `OnLoadOrder.PostSptModLoader + 1`: Post-load step for deferred operations\r\n\r\n### Service Lifecycle\r\n\r\n1. **Instantiation** (DI Container)\r\n   - Services instantiated with dependencies\r\n   - Database and utilities injected\r\n\r\n2. **Configuration Loading** (Mod OnLoad)\r\n   - Mod calls `await service.CreateCustomX(assembly)`\r\n   - Service reads JSON from mod's folder\r\n\r\n3. **Data Processing**\r\n   - Validates configuration\r\n   - Transforms data to SPT format\r\n   - Modifies database tables\r\n\r\n4. **Deferred Operations** (PostSptModLoad)\r\n   - Some operations deferred to ensure all mods loaded\r\n   - Example: `ProcessDeferredModSlots()`, `ProcessDeferredSecureFilters()`\r\n\r\n### Service Base Pattern\r\n\r\nAll services follow a common pattern:\r\n\r\n```csharp\r\n[Injectable(InjectionType.Singleton)]\r\npublic class WTTCustomXService(\r\n    DatabaseService databaseService,\r\n    ISptLogger<WTTCustomXService> logger,\r\n    VFS vfs,\r\n    ConfigHelper configHelper\r\n)\r\n{\r\n    // Main entry point\r\n    public async Task CreateCustomX(Assembly assembly, string? customPath = null)\r\n    {\r\n        string configPath = ResolveConfigPath(assembly, customPath);\r\n        var configs = await LoadConfigs(configPath);\r\n\r\n        foreach (var config in configs)\r\n        {\r\n            ValidateConfig(config);\r\n            ProcessConfig(config);\r\n            RegisterToDatabase(config);\r\n        }\r\n    }\r\n\r\n    private void ProcessConfig(CustomConfig config)\r\n    {\r\n        // Service-specific logic\r\n    }\r\n}\r\n```\r\n\r\n### Database Access Pattern\r\n\r\nServices access game data through `DatabaseService`:\r\n\r\n```csharp\r\nvar tables = databaseService.GetTables();\r\n\r\n// Access specific tables\r\nvar items = tables.Templates.Items;\r\nvar locales = tables.Locales.Global;\r\nvar traders = tables.Traders;\r\nvar bots = tables.Bots;\r\nvar locations = tables.Locations;\r\nvar quests = tables.Templates.Quests;\r\nvar hideout = tables.Hideout;\r\n```\r\n\r\n### Configuration Resolution\r\n\r\n**Path Resolution Logic**:\r\n```\r\n1. Custom path provided? ‚Üí Use custom path\r\n2. Default path exists? ‚Üí Use \"db/Custom{ServiceName}/\"\r\n3. Fallback ‚Üí Return null (no configs)\r\n```\r\n\r\n**Example**:\r\n```csharp\r\n// Default usage - looks in \"db/CustomItems/\"\r\nawait wttCommon.CustomItemServiceExtended.CreateCustomItems(assembly);\r\n\r\n// Custom path - looks in \"config/MyItems/\"\r\nawait wttCommon.CustomItemServiceExtended.CreateCustomItems(\r\n    assembly,\r\n    Path.Join(\"config\", \"MyItems\")\r\n);\r\n```\r\n\r\n### Helpers and Utilities\r\n\r\n**ConfigHelper**:\r\n```csharp\r\n// JSON deserialization with error handling\r\nT DeserializeConfig<T>(string json);\r\n\r\n// File system utilities\r\nstring[] GetFiles(string path, string pattern);\r\nbool DirectoryExists(string path);\r\n```\r\n\r\n**LogHelper**:\r\n```csharp\r\n// Structured logging\r\nLogInfo(string message);\r\nLogWarning(string message);\r\nLogError(string message);\r\nLogDebug(string message);\r\n```\r\n\r\n**ItemMaps** (Constants):\r\n```csharp\r\n// Common item template IDs\r\npublic static class ItemMaps\r\n{\r\n    public const string MONEY_ROUBLES = \"5449016a4bdc2d6f028b456f\";\r\n    public const string MONEY_DOLLARS = \"5696686a4bdc2da3298b456a\";\r\n    public const string MONEY_EUROS = \"569668774bdc2da2298b4568\";\r\n\r\n    // Container types\r\n    public const string LOOTCONTAINER_DEAD_SCAV = \"5909e4b686f7747f5b744fa4\";\r\n    // ... hundreds more constants\r\n}\r\n```\r\n\r\n**TraderIds**:\r\n```csharp\r\npublic static class TraderIds\r\n{\r\n    public static readonly Dictionary<string, string> TraderNameToId = new()\r\n    {\r\n        { \"prapor\", \"54cb50c76803fa8b248b4571\" },\r\n        { \"therapist\", \"54cb57776803fa99248b456e\" },\r\n        // ... all traders\r\n    };\r\n\r\n    public static string GetTraderId(string traderName)\r\n    {\r\n        return TraderNameToId.TryGetValue(traderName.ToLower(), out var id)\r\n            ? id\r\n            : traderName; // Assume it's already an ID\r\n    }\r\n}\r\n```\r\n\r\n### Route Registration\r\n\r\nCustom routes expose mod resources to the client:\r\n\r\n```csharp\r\npublic class WTTResourceRoute : AbstractStaticRoute\r\n{\r\n    public override string Route => \"/wtt/resources\";\r\n\r\n    public override async Task<IResult> HandleRequest(HttpRequest request)\r\n    {\r\n        // Serve custom resources (images, audio manifests, etc.)\r\n        string resourceType = request.Query[\"type\"];\r\n        string resourceName = request.Query[\"name\"];\r\n\r\n        return Results.File(resourcePath, contentType);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Client-Side Architecture\r\n\r\n### BepInEx Plugin Structure\r\n\r\nWTT-ClientCommonLib is a BepInEx 5.x plugin that loads into the EFT Unity process:\r\n\r\n```csharp\r\n[BepInDependency(\"com.fika.core\", BepInDependency.DependencyFlags.SoftDependency)]\r\n[BepInPlugin(\"com.wtt.commonlib\", \"WTT-ClientCommonLib\", \"2.0.4\")]\r\npublic class WTTClientCommonLib : BaseUnityPlugin\r\n{\r\n    public static WTTClientCommonLib Instance { get; private set; }\r\n    public static bool FikaInstalled { get; private set; }\r\n    public static Player Player { get; set; }\r\n\r\n    private AssetLoader AssetLoader;\r\n    private CommandProcessor _commandProcessor;\r\n    private GameObject _updaterObject;\r\n\r\n    private void Awake()\r\n    {\r\n        Instance = this;\r\n        LogHelper.SetLogger(Logger);\r\n\r\n        // Detect FIKA\r\n        FikaInstalled = Chainloader.PluginInfos.ContainsKey(\"com.fika.core\");\r\n\r\n        // Initialize components\r\n        AssetLoader = new AssetLoader(Logger);\r\n        _playerWorldStats = new PlayerWorldStats(Logger);\r\n\r\n        // Initialize configuration\r\n        UniversalConfigManager.Initialize(Config);\r\n        ZoneConfigManager.Initialize(Config);\r\n        RadioSettings.Init(Config);\r\n\r\n        // Apply Harmony patches\r\n        new OnGameStarted().Enable();\r\n        new FaceCardPatches().Enable();\r\n        // ... more patches\r\n\r\n        // Load resources from server\r\n        var resourceLoader = new ResourceLoader(Logger, AssetLoader);\r\n        resourceLoader.LoadAllResourcesFromServer();\r\n    }\r\n}\r\n```\r\n\r\n### Asset Loading Pipeline\r\n\r\n**AssetLoader** manages Unity AssetBundle loading:\r\n\r\n```csharp\r\npublic class AssetLoader\r\n{\r\n    private Dictionary<string, AssetBundle> _loadedBundles = new();\r\n    private Dictionary<string, AudioClip> _audioCache = new();\r\n\r\n    public AssetBundle LoadBundle(string bundlePath)\r\n    {\r\n        if (_loadedBundles.TryGetValue(bundlePath, out var cached))\r\n            return cached;\r\n\r\n        var bundle = AssetBundle.LoadFromFile(bundlePath);\r\n        _loadedBundles[bundlePath] = bundle;\r\n        return bundle;\r\n    }\r\n\r\n    public T LoadAsset<T>(string bundleName, string assetName) where T : UnityEngine.Object\r\n    {\r\n        var bundle = LoadBundle(bundleName);\r\n        return bundle.LoadAsset<T>(assetName);\r\n    }\r\n\r\n    public AudioClip LoadAudioClip(string bundleName, string clipName)\r\n    {\r\n        string key = $\"{bundleName}/{clipName}\";\r\n        if (_audioCache.TryGetValue(key, out var cached))\r\n            return cached;\r\n\r\n        var clip = LoadAsset<AudioClip>(bundleName, clipName);\r\n        _audioCache[key] = clip;\r\n        return clip;\r\n    }\r\n}\r\n```\r\n\r\n### Resource Loading from Server\r\n\r\n**ResourceLoader** fetches configuration data from the SPT server:\r\n\r\n```csharp\r\npublic class ResourceLoader\r\n{\r\n    public void LoadAllResourcesFromServer()\r\n    {\r\n        // Fetch rig layouts\r\n        var rigLayouts = FetchFromServer<Dictionary<string, string>>(\"/wtt/riglayouts\");\r\n        RegisterRigLayouts(rigLayouts);\r\n\r\n        // Fetch slot images\r\n        var slotImages = FetchFromServer<Dictionary<string, byte[]>>(\"/wtt/slotimages\");\r\n        RegisterSlotImages(slotImages);\r\n\r\n        // Fetch quest zones\r\n        var questZones = FetchFromServer<List<CustomQuestZone>>(\"/wtt/questzones\");\r\n        QuestZones.RegisterZones(questZones);\r\n\r\n        // Fetch static spawns\r\n        var staticSpawns = FetchFromServer<List<CustomSpawnConfig>>(\"/wtt/staticspawns\");\r\n        CustomStaticSpawnService.RegisterSpawns(staticSpawns);\r\n\r\n        // Fetch audio manifest\r\n        var audioManifest = FetchFromServer<AudioManifest>(\"/wtt/audio\");\r\n        RegisterAudio(audioManifest);\r\n    }\r\n\r\n    private T FetchFromServer<T>(string route)\r\n    {\r\n        var request = RequestHandler.GetJson($\"{SPT_SERVER_URL}{route}\");\r\n        return JsonConvert.DeserializeObject<T>(request);\r\n    }\r\n}\r\n```\r\n\r\n### Harmony Patching System\r\n\r\nWTT-ClientCommonLib uses Harmony to intercept and modify game behavior:\r\n\r\n**OnGameStarted Patch**:\r\n```csharp\r\npublic class OnGameStarted : ModulePatch\r\n{\r\n    protected override MethodBase GetTargetMethod()\r\n    {\r\n        return typeof(GameWorld).GetMethod(\"OnGameStarted\",\r\n            BindingFlags.Public | BindingFlags.Instance);\r\n    }\r\n\r\n    [PatchPostfix]\r\n    public static void Postfix(GameWorld __instance)\r\n    {\r\n        // Spawn quest zones\r\n        QuestZones.SpawnAllZones(__instance);\r\n\r\n        // Spawn static objects\r\n        CustomStaticSpawnService.SpawnAllObjects(__instance);\r\n\r\n        // Initialize systems\r\n        SpawnSystemUpdater.Instance?.Initialize(__instance);\r\n    }\r\n}\r\n```\r\n\r\n**FaceCardPatches** (Character Creation):\r\n```csharp\r\npublic class FaceCardViewInitPatch : ModulePatch\r\n{\r\n    protected override MethodBase GetTargetMethod()\r\n    {\r\n        return typeof(FaceCardView).GetMethod(\"Init\");\r\n    }\r\n\r\n    [PatchPostfix]\r\n    public static void Postfix(FaceCardView __instance)\r\n    {\r\n        // Play custom audio for selected face\r\n        var selectedFace = __instance.SelectedFaceId;\r\n        var audioKey = CustomAudioService.GetFaceAudio(selectedFace);\r\n\r\n        if (!string.IsNullOrEmpty(audioKey))\r\n        {\r\n            var clip = AssetLoader.LoadAudioClip(audioKey);\r\n            CharacterAudioHandler.PlayClip(clip);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**BoomboxAudioPatch** (Hideout Radio):\r\n```csharp\r\npublic class BoomboxAudioPatch : ModulePatch\r\n{\r\n    [PatchPrefix]\r\n    public static bool Prefix(BoomboxPlayer __instance)\r\n    {\r\n        // Replace radio audio with custom tracks\r\n        if (RadioSettings.GymEnabled && ShouldReplaceAudio())\r\n        {\r\n            var customTrack = GetRandomCustomTrack();\r\n            PlayCustomAudio(__instance, customTrack);\r\n            return false; // Skip original method\r\n        }\r\n        return true; // Run original method\r\n    }\r\n}\r\n```\r\n\r\n### Quest Zone System\r\n\r\n**Zone Visualization**:\r\n```csharp\r\npublic class QuestZones\r\n{\r\n    private static Dictionary<string, GameObject> _activeZones = new();\r\n\r\n    public static void SpawnAllZones(GameWorld gameWorld)\r\n    {\r\n        var profile = gameWorld.MainPlayer.Profile;\r\n        var location = gameWorld.LocationId;\r\n\r\n        foreach (var zone in _registeredZones)\r\n        {\r\n            if (zone.ZoneLocation != location)\r\n                continue;\r\n\r\n            if (ShouldSpawnZone(zone, profile))\r\n            {\r\n                SpawnZone(zone, gameWorld);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void SpawnZone(CustomQuestZone zone, GameWorld gameWorld)\r\n    {\r\n        GameObject zoneObject = new GameObject(zone.ZoneId);\r\n\r\n        // Position\r\n        zoneObject.transform.position = zone.Position;\r\n        zoneObject.transform.rotation = zone.Rotation;\r\n        zoneObject.transform.localScale = zone.Scale;\r\n\r\n        // Collision\r\n        var collider = zoneObject.AddComponent<BoxCollider>();\r\n        collider.isTrigger = true;\r\n\r\n        // Quest zone component\r\n        var zoneComponent = zoneObject.AddComponent<QuestZoneComponent>();\r\n        zoneComponent.ZoneId = zone.ZoneId;\r\n        zoneComponent.ZoneType = zone.ZoneType;\r\n\r\n        // Flare effect (if applicable)\r\n        if (!string.IsNullOrEmpty(zone.FlareType))\r\n        {\r\n            var flare = zoneObject.AddComponent<ZoneFlareTrigger>();\r\n            flare.FlareType = zone.FlareType;\r\n        }\r\n\r\n        _activeZones[zone.ZoneId] = zoneObject;\r\n    }\r\n}\r\n```\r\n\r\n**Zone Editor** (In-Game):\r\n```csharp\r\npublic class ZoneEditorComponent : MonoBehaviour\r\n{\r\n    private GameObject _selectedZone;\r\n    private bool _editMode;\r\n\r\n    private void Update()\r\n    {\r\n        if (!_editMode) return;\r\n\r\n        // WASD movement\r\n        if (Input.GetKey(KeyCode.W))\r\n            _selectedZone.transform.position += Vector3.forward * GetSpeed();\r\n        // ... more movement controls\r\n\r\n        // Rotation (Numpad)\r\n        if (Input.GetKey(KeyCode.Keypad7))\r\n            _selectedZone.transform.Rotate(Vector3.up, 45f * Time.deltaTime);\r\n        // ... more rotation controls\r\n\r\n        // Selection cycling\r\n        if (Input.GetKeyDown(KeyCode.Period))\r\n            SelectNextZone();\r\n\r\n        // Delete\r\n        if (Input.GetKeyDown(KeyCode.Delete))\r\n            DestroySelectedZone();\r\n\r\n        // Export\r\n        if (Input.GetKeyDown(KeyCode.Backslash))\r\n            ExportAllZones();\r\n    }\r\n\r\n    private float GetSpeed()\r\n    {\r\n        float baseSpeed = 0.5f;\r\n        if (Input.GetKey(KeyCode.LeftShift) && Input.GetKey(KeyCode.LeftAlt))\r\n            return baseSpeed * 4f; // 4x speed\r\n        if (Input.GetKey(KeyCode.LeftShift))\r\n            return baseSpeed * 2f; // 2x speed\r\n        return baseSpeed;\r\n    }\r\n}\r\n```\r\n\r\n### Static Spawn System\r\n\r\n**Conditional Spawning**:\r\n```csharp\r\npublic class CustomStaticSpawnService\r\n{\r\n    public static void SpawnAllObjects(GameWorld gameWorld)\r\n    {\r\n        var profile = gameWorld.MainPlayer.Profile;\r\n        var location = gameWorld.LocationId;\r\n\r\n        foreach (var spawnConfig in _registeredSpawns)\r\n        {\r\n            if (spawnConfig.LocationID != location)\r\n                continue;\r\n\r\n            if (EvaluateSpawnConditions(spawnConfig, profile, gameWorld))\r\n            {\r\n                SpawnObject(spawnConfig, gameWorld);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static bool EvaluateSpawnConditions(\r\n        CustomSpawnConfig config,\r\n        Profile profile,\r\n        GameWorld gameWorld)\r\n    {\r\n        // Check player level\r\n        if (config.RequiredLevel.HasValue && profile.Info.Level < config.RequiredLevel.Value)\r\n            return false;\r\n\r\n        // Check faction\r\n        if (!string.IsNullOrEmpty(config.RequiredFaction) &&\r\n            profile.Info.Side.ToString() != config.RequiredFaction)\r\n            return false;\r\n\r\n        // Check quest status\r\n        if (!string.IsNullOrEmpty(config.QuestId))\r\n        {\r\n            var quest = profile.GetQuest(config.QuestId);\r\n\r\n            if (config.QuestMustExist && quest == null)\r\n                return false;\r\n            if (!config.QuestMustExist && quest != null)\r\n                return false;\r\n\r\n            if (quest != null)\r\n            {\r\n                // Required statuses\r\n                if (config.RequiredQuestStatuses?.Any() == true &&\r\n                    !config.RequiredQuestStatuses.Contains(quest.Status.ToString()))\r\n                    return false;\r\n\r\n                // Excluded statuses\r\n                if (config.ExcludedQuestStatuses?.Contains(quest.Status.ToString()) == true)\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        // Check linked quest\r\n        if (!string.IsNullOrEmpty(config.LinkedQuestId))\r\n        {\r\n            // Similar logic for linked quest conditions\r\n        }\r\n\r\n        // Check inventory item\r\n        if (!string.IsNullOrEmpty(config.RequiredItemInInventory))\r\n        {\r\n            if (!profile.Inventory.HasItem(config.RequiredItemInInventory))\r\n                return false;\r\n        }\r\n\r\n        // Check boss spawned\r\n        if (!string.IsNullOrEmpty(config.RequiredBossSpawned))\r\n        {\r\n            if (!IsBossSpawnedInRaid(config.RequiredBossSpawned, gameWorld))\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private static void SpawnObject(CustomSpawnConfig config, GameWorld gameWorld)\r\n    {\r\n        var bundle = AssetLoader.LoadBundle(config.BundleName);\r\n        var prefab = bundle.LoadAsset<GameObject>(config.PrefabName);\r\n\r\n        var instance = Instantiate(prefab);\r\n        instance.transform.position = config.Position;\r\n        instance.transform.rotation = Quaternion.Euler(config.Rotation);\r\n\r\n        // FIKA synchronization\r\n        if (WTTClientCommonLib.FikaInstalled)\r\n        {\r\n            WTTClientCommonLib.SendFikaPacket(config, instance.transform.rotation);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Command Processor (Debug Console)\r\n\r\n**Console Commands**:\r\n```csharp\r\npublic class CommandProcessor\r\n{\r\n    public void RegisterCommandProcessor()\r\n    {\r\n        ConsoleScreen.Processor.RegisterCommandGroup<SpawnCommands>();\r\n    }\r\n}\r\n\r\npublic class SpawnCommands\r\n{\r\n    [ConsoleCommand(\"SpawnObject\", \"Spawns a custom object\")]\r\n    public void SpawnObject(string bundleName, string prefabName)\r\n    {\r\n        var bundle = AssetLoader.LoadBundle(bundleName);\r\n        var prefab = bundle.LoadAsset<GameObject>(prefabName);\r\n\r\n        var player = WTTClientCommonLib.Player;\r\n        var spawnPos = player.Transform.position + player.Transform.forward * 2f;\r\n\r\n        var instance = Instantiate(prefab, spawnPos, Quaternion.identity);\r\n\r\n        LogHelper.LogInfo($\"Spawned {prefabName} from {bundleName}\");\r\n    }\r\n\r\n    [ConsoleCommand(\"EnterEditMode\", \"Enters zone edit mode\")]\r\n    public void EnterEditMode()\r\n    {\r\n        var editor = Camera.main.gameObject.AddComponent<ZoneEditorComponent>();\r\n        editor.Initialize();\r\n    }\r\n\r\n    [ConsoleCommand(\"ExportSpawnedObjectInfo\", \"Exports all spawned objects\")]\r\n    public void ExportSpawnedObjectInfo()\r\n    {\r\n        var allSpawned = FindObjectsOfType<CustomStaticSpawnMarker>();\r\n        var configs = allSpawned.Select(obj => new CustomSpawnConfig\r\n        {\r\n            BundleName = obj.BundleName,\r\n            PrefabName = obj.PrefabName,\r\n            Position = obj.transform.position,\r\n            Rotation = obj.transform.rotation.eulerAngles\r\n        }).ToList();\r\n\r\n        string json = JsonConvert.SerializeObject(configs, Formatting.Indented);\r\n        string filename = $\"WTT-ClientCommonLib-CustomStaticSpawnConfig-Output-{DateTime.Now:yyyyMMdd-HHmmss}.json\";\r\n        File.WriteAllText(filename, json);\r\n\r\n        LogHelper.LogInfo($\"Exported {configs.Count} spawned objects to {filename}\");\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Data Flow & Processing Pipeline\r\n\r\n### Item Creation Pipeline\r\n\r\n```\r\n[Mod JSON Config] ‚Üí [Server Processing] ‚Üí [Database Registration] ‚Üí [Client Loading]\r\n\r\n1. MOD: db/CustomItems/weapon.json\r\n   ‚îî‚Üí Item definition with properties\r\n\r\n2. SERVER: CustomItemServiceExtended.CreateCustomItems()\r\n   ‚îú‚Üí Load and parse JSON\r\n   ‚îú‚Üí Clone base item template\r\n   ‚îú‚Üí Apply property overrides\r\n   ‚îú‚Üí Register to database (items, locales, handbook)\r\n   ‚îú‚Üí Add to traders (barter schemes)\r\n   ‚îú‚Üí Add to bot loadouts\r\n   ‚îú‚Üí Add to loot tables\r\n   ‚îî‚Üí Generate client manifest\r\n\r\n3. DATABASE: SPT Database Tables Modified\r\n   ‚îú‚Üí Templates.Items[newItemId]\r\n   ‚îú‚Üí Locales.Global[\"en\"][itemName]\r\n   ‚îú‚Üí Traders[traderId].Assort.Items\r\n   ‚îú‚Üí Bots[botType].Inventory.Equipment\r\n   ‚îî‚Üí Locations[map].Loot.StaticContainers\r\n\r\n4. CLIENT: Asset Loading & Registration\r\n   ‚îú‚Üí Load AssetBundle (weapon.bundle)\r\n   ‚îú‚Üí Extract prefab and icon\r\n   ‚îú‚Üí Register to TemplateIdToObject mappings\r\n   ‚îî‚Üí Item available in-game\r\n```\r\n\r\n### Quest Creation Pipeline\r\n\r\n```\r\n[Quest JSON] ‚Üí [Server Validation] ‚Üí [Database Integration] ‚Üí [Zone Spawning]\r\n\r\n1. MOD: db/CustomQuests/mechanic/Quests/quest.json\r\n   ‚îî‚Üí Quest definition (objectives, rewards, conditions)\r\n\r\n2. MOD: db/CustomQuests/mechanic/Locales/en.json\r\n   ‚îî‚Üí Quest text (name, description, messages)\r\n\r\n3. MOD: db/CustomQuests/mechanic/Images/icon.png\r\n   ‚îî‚Üí Quest icon image\r\n\r\n4. SERVER: CustomQuestService.CreateCustomQuests()\r\n   ‚îú‚Üí Parse quest JSON\r\n   ‚îú‚Üí Validate quest structure\r\n   ‚îú‚Üí Apply time windows (QuestTimeData.json)\r\n   ‚îú‚Üí Apply faction restrictions (QuestSideData.json)\r\n   ‚îú‚Üí Register to database (quests, locales, images)\r\n   ‚îú‚Üí Link quest-unlocked assortments\r\n   ‚îî‚Üí Send zone data to client\r\n\r\n5. DATABASE: Modified Tables\r\n   ‚îú‚Üí Templates.Quests[questId]\r\n   ‚îú‚Üí Locales.Global[\"en\"][\"questId name\"]\r\n   ‚îú‚Üí Traders[mechanicId].Questassort\r\n   ‚îî‚Üí Routes: /files/quest/[imageName]\r\n\r\n6. CLIENT: Zone Visualization\r\n   ‚îú‚Üí Receive zone configurations\r\n   ‚îú‚Üí Spawn 3D zones in raid\r\n   ‚îú‚Üí Attach collision triggers\r\n   ‚îî‚Üí Track objective completion\r\n```\r\n\r\n### Static Spawn Pipeline\r\n\r\n```\r\n[Spawn Config] ‚Üí [Condition Evaluation] ‚Üí [Object Instantiation] ‚Üí [FIKA Sync]\r\n\r\n1. MOD: db/CustomStaticSpawns/CustomSpawnConfigs/interchange.json\r\n   ‚îú‚Üí Object definition\r\n   ‚îú‚Üí Position, rotation, scale\r\n   ‚îî‚Üí Spawn conditions (quest status, player level, etc.)\r\n\r\n2. MOD: db/CustomStaticSpawns/StaticBundles/objects.bundle\r\n   ‚îî‚Üí Unity AssetBundle with prefabs\r\n\r\n3. SERVER: CustomStaticSpawnService.CreateCustomStaticSpawns()\r\n   ‚îú‚Üí Parse spawn configurations\r\n   ‚îú‚Üí Validate bundle references\r\n   ‚îú‚Üí Send to client via route\r\n   ‚îî‚Üí Store manifest\r\n\r\n4. CLIENT: Raid Start (OnGameStarted)\r\n   ‚îú‚Üí Iterate spawn configurations for current map\r\n   ‚îú‚Üí Evaluate conditions (quest status, level, faction, boss, etc.)\r\n   ‚îú‚Üí Load AssetBundle\r\n   ‚îú‚Üí Instantiate prefab at position\r\n   ‚îú‚Üí Send FIKA packet (if multiplayer)\r\n   ‚îî‚Üí Object visible in raid\r\n\r\n5. FIKA: Network Synchronization (if enabled)\r\n   ‚îú‚Üí Host spawns object\r\n   ‚îú‚Üí StaticSpawnPacket sent to clients\r\n   ‚îú‚Üí Clients spawn same object\r\n   ‚îî‚Üí Objects synchronized across all players\r\n```\r\n\r\n### Audio System Pipeline\r\n\r\n```\r\n[Audio Bundles] ‚Üí [Manifest Generation] ‚Üí [Client Registration] ‚Üí [Playback]\r\n\r\n1. MOD: db/CustomAudioBundles/voices.bundle\r\n   ‚îî‚Üí Unity AssetBundle with AudioClips\r\n\r\n2. SERVER: CustomAudioService.RegisterAudioBundles()\r\n   ‚îú‚Üí Scan for .bundle files\r\n   ‚îú‚Üí Generate audio manifest\r\n   ‚îú‚Üí Associate audio with faces/radios\r\n   ‚îî‚Üí Expose via route\r\n\r\n3. SERVER: CustomAudioService.AddFaceCardAudio()\r\n   ‚îú‚Üí Link audio key to character face\r\n   ‚îî‚Üí Optionally add to radio pool\r\n\r\n4. CLIENT: ResourceLoader.LoadAllResourcesFromServer()\r\n   ‚îú‚Üí Fetch audio manifest from server\r\n   ‚îú‚Üí Load audio bundles\r\n   ‚îú‚Üí Cache AudioClips\r\n   ‚îî‚Üí Register face-audio mappings\r\n\r\n5. CLIENT: Playback Triggers\r\n   ‚îú‚Üí FaceCardPatches: Play audio during character creation\r\n   ‚îú‚Üí BoomboxAudioPatch: Replace hideout radio audio\r\n   ‚îî‚Üí Custom audio plays based on context\r\n```\r\n\r\n---\r\n\r\n## Service Implementation Deep Dive\r\n\r\n### CustomItemServiceExtended\r\n\r\n**Most Complex Service** - Handles comprehensive item integration.\r\n\r\n**Key Methods**:\r\n\r\n```csharp\r\npublic async Task CreateCustomItems(Assembly assembly, string? customPath = null)\r\n{\r\n    // 1. Load configurations\r\n    var configPath = ResolveConfigPath(assembly, customPath, \"CustomItems\");\r\n    var itemConfigs = await LoadItemConfigs(configPath);\r\n\r\n    // 2. Process each item\r\n    foreach (var (itemId, config) in itemConfigs)\r\n    {\r\n        // Clone base item\r\n        var baseItem = _database.Items[config.ItemTplToClone];\r\n        var newItem = CloneItem(baseItem, itemId);\r\n\r\n        // Apply overrides\r\n        ApplyPropertyOverrides(newItem, config.OverrideProperties);\r\n\r\n        // Register to database\r\n        _database.Items[itemId] = newItem;\r\n\r\n        // Add locales\r\n        RegisterLocales(itemId, config.Locales);\r\n\r\n        // Add to handbook\r\n        RegisterToHandbook(itemId, config.HandbookParentId, config.HandbookPriceRoubles);\r\n\r\n        // Add to flea market\r\n        RegisterToFlea(itemId, config.FleaPriceRoubles);\r\n\r\n        // Add to traders\r\n        if (config.AddToTraders == true)\r\n            RegisterToTraders(itemId, config.Traders);\r\n\r\n        // Add to bots\r\n        if (config.AddToBots == true)\r\n            RegisterToBots(itemId, config.ItemTplToClone);\r\n\r\n        // Add to loot containers\r\n        if (config.AddToStaticLootContainers == true)\r\n            RegisterToLootContainers(itemId, config.StaticLootContainers);\r\n\r\n        // Special slots\r\n        if (config.AddToInventorySlots?.Any() == true)\r\n            RegisterToInventorySlots(itemId, config.AddToInventorySlots);\r\n\r\n        // Mod slots (deferred)\r\n        if (config.AddToModSlots == true)\r\n            DeferModSlotRegistration(itemId, config);\r\n\r\n        // Hall of Fame\r\n        if (config.AddToHallOfFame == true)\r\n            RegisterToHallOfFame(itemId, config.HallOfFameSlots);\r\n\r\n        // Generator fuel\r\n        if (config.AddToGeneratorAsFuel == true)\r\n            RegisterAsGeneratorFuel(itemId, config.GeneratorFuelSlotStages);\r\n\r\n        // Hideout posters\r\n        if (config.AddToHideoutPosterSlots == true)\r\n            RegisterToHideoutPosters(itemId);\r\n\r\n        // Weapon presets\r\n        if (config.AddWeaponPreset == true)\r\n            RegisterWeaponPresets(itemId, config.WeaponPresets);\r\n\r\n        // Weapon mastery\r\n        if (config.Masteries == true)\r\n            RegisterMastery(itemId, config.MasterySections);\r\n\r\n        // Secure container filters (deferred)\r\n        if (config.AddToSecureFilters == true)\r\n            DeferSecureFilterRegistration(itemId);\r\n    }\r\n}\r\n```\r\n\r\n**Helper Services** (ItemServiceHelpers folder):\r\n\r\n```\r\nBotLootHelper.cs             - Bot loadout integration\r\nCaliberHelper.cs             - Ammo caliber compatibility\r\nEmptyPropSlotHelper.cs       - Dynamic slot creation\r\nGeneratorFuelHelper.cs       - Hideout generator fuel\r\nHallOfFameHelper.cs          - Display slot registration\r\nHideoutPosterHelper.cs       - Poster/statuette slots\r\nInventorySlotHelper.cs       - Custom inventory slots\r\nLootContainerHelper.cs       - Static loot spawns\r\nMasteryHelper.cs             - Weapon mastery integration\r\nModSlotHelper.cs             - Weapon/armor mod compatibility\r\nSecureFilterHelper.cs        - Secure container filters\r\nTraderAssortHelper.cs        - Trader barter schemes\r\nWeaponPresetHelper.cs        - Preset builds\r\n```\r\n\r\n**Deferred Operations**:\r\n\r\nSome operations must wait until ALL mods have loaded:\r\n\r\n```csharp\r\n// WTTServerCommonLibPostSptLoad runs AFTER all mods\r\npublic class WTTServerCommonLibPostSptLoad : IOnLoad\r\n{\r\n    public Task OnLoad()\r\n    {\r\n        // Process deferred mod slots\r\n        customItemServiceExtended.ProcessDeferredModSlots();\r\n\r\n        // Process deferred secure filters\r\n        customItemServiceExtended.ProcessDeferredSecureFilters();\r\n\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n\r\n// Why deferred?\r\n// - Mod slots: Need all items registered to find compatible slots\r\n// - Secure filters: Need all secure containers registered\r\n```\r\n\r\n### CustomQuestService\r\n\r\n**Quest System Integration** - Handles complex quest registration.\r\n\r\n**Key Features**:\r\n\r\n```csharp\r\npublic async Task CreateCustomQuests(Assembly assembly, string? customPath = null)\r\n{\r\n    var basePath = ResolveConfigPath(assembly, customPath, \"CustomQuests\");\r\n\r\n    // 1. Load optional global configs\r\n    var timeData = LoadQuestTimeData(basePath); // Date-restricted quests\r\n    var sideData = LoadQuestSideData(basePath); // Faction-restricted quests\r\n\r\n    // 2. Iterate trader folders\r\n    var traderFolders = GetTraderFolders(basePath);\r\n\r\n    foreach (var traderFolder in traderFolders)\r\n    {\r\n        var traderId = ResolveTrader Id(traderFolder.Name);\r\n\r\n        // 3. Load quests\r\n        var questsPath = Path.Join(traderFolder.FullName, \"Quests\");\r\n        var quests = LoadQuestDefinitions(questsPath);\r\n\r\n        // 4. Load locales\r\n        var localesPath = Path.Join(traderFolder.FullName, \"Locales\");\r\n        var locales = LoadLocales(localesPath);\r\n\r\n        // 5. Load images\r\n        var imagesPath = Path.Join(traderFolder.FullName, \"Images\");\r\n        var images = LoadQuestImages(imagesPath);\r\n\r\n        // 6. Load quest assortments\r\n        var assortPath = Path.Join(traderFolder.FullName, \"QuestAssort\");\r\n        var assortments = LoadQuestAssortments(assortPath);\r\n\r\n        // 7. Process each quest\r\n        foreach (var quest in quests)\r\n        {\r\n            // Check time restrictions\r\n            if (timeData.ContainsKey(quest.Id))\r\n            {\r\n                var timeWindow = timeData[quest.Id];\r\n                if (!IsWithinTimeWindow(timeWindow))\r\n                {\r\n                    _logger.LogInfo($\"Quest {quest.Id} outside time window, skipping\");\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // Apply faction restrictions\r\n            if (sideData.UsecOnlyQuests.Contains(quest.Id))\r\n                quest.Conditions.AvailableForStart.Add(CreateFactionCondition(\"Usec\"));\r\n            if (sideData.BearOnlyQuests.Contains(quest.Id))\r\n                quest.Conditions.AvailableForStart.Add(CreateFactionCondition(\"Bear\"));\r\n\r\n            // Register quest\r\n            _database.Quests[quest.Id] = quest;\r\n\r\n            // Register locales\r\n            RegisterQuestLocales(quest.Id, locales);\r\n\r\n            // Register image\r\n            if (images.ContainsKey(quest.Image))\r\n                RegisterQuestImage(quest.Id, images[quest.Image]);\r\n\r\n            // Link quest assortments\r\n            if (assortments.ContainsKey(quest.Id))\r\n                LinkQuestAssortment(traderId, quest.Id, assortments[quest.Id]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Time Window System**:\r\n\r\n```json\r\n// QuestTimeData.json\r\n{\r\n  \"christmas_quest_001\": {\r\n    \"StartMonth\": 12,\r\n    \"StartDay\": 20,\r\n    \"EndMonth\": 12,\r\n    \"EndDay\": 31\r\n  }\r\n}\r\n```\r\n\r\n```csharp\r\nprivate bool IsWithinTimeWindow(CustomQuestTimeWindow window)\r\n{\r\n    var now = DateTime.Now;\r\n    var start = new DateTime(now.Year, window.StartMonth, window.StartDay);\r\n    var end = new DateTime(now.Year, window.EndMonth, window.EndDay);\r\n\r\n    // Handle year wrap (e.g., Dec 20 - Jan 5)\r\n    if (end < start)\r\n        end = end.AddYears(1);\r\n\r\n    return now >= start && now <= end;\r\n}\r\n```\r\n\r\n### CustomStaticSpawnService\r\n\r\n**Conditional Object Spawning** - Most sophisticated condition system.\r\n\r\n**Spawn Configuration Model**:\r\n\r\n```csharp\r\npublic class CustomSpawnConfig\r\n{\r\n    public string QuestId { get; set; }\r\n    public string LocationID { get; set; }\r\n    public string BundleName { get; set; }\r\n    public string PrefabName { get; set; }\r\n    public Vector3 Position { get; set; }\r\n    public Vector3 Rotation { get; set; }\r\n\r\n    // Primary quest conditions\r\n    public List<string> RequiredQuestStatuses { get; set; }\r\n    public List<string> ExcludedQuestStatuses { get; set; }\r\n    public bool QuestMustExist { get; set; }\r\n\r\n    // Linked quest conditions\r\n    public string LinkedQuestId { get; set; }\r\n    public List<string> LinkedRequiredStatuses { get; set; }\r\n    public List<string> LinkedExcludedStatuses { get; set; }\r\n    public bool? LinkedQuestMustExist { get; set; }\r\n\r\n    // Other conditions\r\n    public string RequiredItemInInventory { get; set; }\r\n    public int? RequiredLevel { get; set; }\r\n    public string RequiredFaction { get; set; }\r\n    public string RequiredBossSpawned { get; set; }\r\n}\r\n```\r\n\r\n**Condition Evaluation Logic**:\r\n\r\n```csharp\r\nprivate bool EvaluateSpawnConditions(CustomSpawnConfig config, Profile profile, GameWorld world)\r\n{\r\n    // Level check\r\n    if (config.RequiredLevel.HasValue)\r\n    {\r\n        if (profile.Info.Level < config.RequiredLevel.Value)\r\n            return false;\r\n    }\r\n\r\n    // Faction check\r\n    if (!string.IsNullOrEmpty(config.RequiredFaction))\r\n    {\r\n        if (profile.Info.Side.ToString() != config.RequiredFaction)\r\n            return false;\r\n    }\r\n\r\n    // Primary quest conditions\r\n    if (!string.IsNullOrEmpty(config.QuestId))\r\n    {\r\n        var quest = profile.GetQuest(config.QuestId);\r\n\r\n        // Quest existence check\r\n        if (config.QuestMustExist && quest == null)\r\n            return false;\r\n        if (!config.QuestMustExist && quest != null)\r\n            return false;\r\n\r\n        if (quest != null)\r\n        {\r\n            // Required statuses (OR logic)\r\n            if (config.RequiredQuestStatuses?.Any() == true)\r\n            {\r\n                if (!config.RequiredQuestStatuses.Contains(quest.Status.ToString()))\r\n                    return false;\r\n            }\r\n\r\n            // Excluded statuses (NOT logic)\r\n            if (config.ExcludedQuestStatuses?.Contains(quest.Status.ToString()) == true)\r\n                return false;\r\n        }\r\n    }\r\n\r\n    // Linked quest conditions (same logic)\r\n    if (!string.IsNullOrEmpty(config.LinkedQuestId))\r\n    {\r\n        // ... similar evaluation for linked quest\r\n    }\r\n\r\n    // Inventory item check\r\n    if (!string.IsNullOrEmpty(config.RequiredItemInInventory))\r\n    {\r\n        var hasItem = profile.Inventory.AllPlayerItems.Any(item =>\r\n            item.TemplateId == config.RequiredItemInInventory);\r\n        if (!hasItem)\r\n            return false;\r\n    }\r\n\r\n    // Boss spawned check\r\n    if (!string.IsNullOrEmpty(config.RequiredBossSpawned))\r\n    {\r\n        var bossAlive = world.RegisteredPlayers.Any(player =>\r\n            player.Profile.Info.Settings.Role.ToString() == config.RequiredBossSpawned &&\r\n            player.HealthController.IsAlive);\r\n        if (!bossAlive)\r\n            return false;\r\n    }\r\n\r\n    return true; // All conditions passed\r\n}\r\n```\r\n\r\n### CustomBotLoadoutService\r\n\r\n**Bot Equipment Configuration** - Modifies AI loadouts.\r\n\r\n```csharp\r\npublic async Task CreateCustomBotLoadouts(Assembly assembly, string? customPath = null)\r\n{\r\n    var configPath = ResolveConfigPath(assembly, customPath, \"CustomBotLoadouts\");\r\n    var loadoutConfigs = await LoadBotLoadoutConfigs(configPath);\r\n\r\n    var botTypes = _database.Bots.Types;\r\n\r\n    foreach (var (botType, loadout) in loadoutConfigs)\r\n    {\r\n        if (!botTypes.ContainsKey(botType))\r\n        {\r\n            _logger.LogWarning($\"Bot type '{botType}' not found, skipping\");\r\n            continue;\r\n        }\r\n\r\n        var bot = botTypes[botType];\r\n\r\n        // Merge equipment chances\r\n        if (loadout.Chances?.Equipment != null)\r\n        {\r\n            foreach (var (slot, chance) in loadout.Chances.Equipment)\r\n            {\r\n                bot.Chances.Equipment[slot] = chance;\r\n            }\r\n        }\r\n\r\n        // Merge weapon mod chances\r\n        if (loadout.Chances?.WeaponMods != null)\r\n        {\r\n            foreach (var (modSlot, chance) in loadout.Chances.WeaponMods)\r\n            {\r\n                bot.Chances.WeaponMods[modSlot] = chance;\r\n            }\r\n        }\r\n\r\n        // Merge equipment inventory\r\n        if (loadout.Inventory?.Equipment != null)\r\n        {\r\n            foreach (var (slot, items) in loadout.Inventory.Equipment)\r\n            {\r\n                foreach (var (itemId, weight) in items)\r\n                {\r\n                    if (!bot.Inventory.Equipment[slot].ContainsKey(itemId))\r\n                        bot.Inventory.Equipment[slot][itemId] = 0;\r\n\r\n                    bot.Inventory.Equipment[slot][itemId] += weight;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Merge mods\r\n        if (loadout.Inventory?.Mods != null)\r\n        {\r\n            foreach (var (weaponId, modSlots) in loadout.Inventory.Mods)\r\n            {\r\n                if (!bot.Inventory.Mods.ContainsKey(weaponId))\r\n                    bot.Inventory.Mods[weaponId] = new Dictionary<string, List<string>>();\r\n\r\n                foreach (var (modSlot, modIds) in modSlots)\r\n                {\r\n                    if (!bot.Inventory.Mods[weaponId].ContainsKey(modSlot))\r\n                        bot.Inventory.Mods[weaponId][modSlot] = new List<string>();\r\n\r\n                    bot.Inventory.Mods[weaponId][modSlot].AddRange(modIds);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Merge ammo\r\n        if (loadout.Inventory?.Ammo != null)\r\n        {\r\n            foreach (var (caliber, ammoTypes) in loadout.Inventory.Ammo)\r\n            {\r\n                if (!bot.Inventory.Ammo.ContainsKey(caliber))\r\n                    bot.Inventory.Ammo[caliber] = new Dictionary<string, int>();\r\n\r\n                foreach (var (ammoId, weight) in ammoTypes)\r\n                {\r\n                    if (!bot.Inventory.Ammo[caliber].ContainsKey(ammoId))\r\n                        bot.Inventory.Ammo[caliber][ammoId] = 0;\r\n\r\n                    bot.Inventory.Ammo[caliber][ammoId] += weight;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Extension Points & Integration\r\n\r\n### Custom Item Type Registration\r\n\r\n**Scenario**: Creating a custom item class with unique behavior (e.g., a deployable item, special container).\r\n\r\n**Server-Side** (Register template):\r\n\r\n```csharp\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 2)]\r\npublic class MyMod(\r\n    WTTServerCommonLib.WTTServerCommonLib wttCommon,\r\n    DatabaseService databaseService\r\n) : IOnLoad\r\n{\r\n    public async Task OnLoad()\r\n    {\r\n        var assembly = Assembly.GetExecutingAssembly();\r\n        var itemsDb = databaseService.GetTables().Templates.Items;\r\n\r\n        // Register custom template type\r\n        itemsDb[\"my_custom_template_id\"] = new TemplateItem()\r\n        {\r\n            Id = \"my_custom_template_id\",\r\n            Name = \"MyCustomTemplate\",\r\n            Parent = \"566162e44bdc2d3f298b4573\", // CompoundItem parent\r\n            Type = \"Node\",\r\n            Properties = new TemplateItemProperties()\r\n        };\r\n\r\n        // Register actual items using custom template\r\n        await wttCommon.CustomItemServiceExtended.CreateCustomItems(assembly);\r\n    }\r\n}\r\n```\r\n\r\n**Client-Side** (Register item class):\r\n\r\n```csharp\r\n[BepInDependency(\"com.wtt.commonlib\")]\r\n[BepInPlugin(\"com.mymod.core\", \"MyMod\", \"1.0.0\")]\r\npublic class MyMod : BaseUnityPlugin\r\n{\r\n    private void Awake()\r\n    {\r\n        // Define custom template type\r\n        public class MyCustomTemplate(string customProp) : CompoundItemTemplateClass\r\n        {\r\n            public readonly string CustomProp = customProp;\r\n        }\r\n\r\n        // Define custom item type\r\n        public class MyCustomItem(string id, MyCustomTemplate template) : CompoundItem(id, template)\r\n        {\r\n            public string CustomProp { get; } = template.CustomProp;\r\n\r\n            public override IEnumerable<EItemInfoButton> ItemInteractionButtons\r\n            {\r\n                get\r\n                {\r\n                    foreach (var button in base.ItemInteractionButtons)\r\n                        yield return button;\r\n\r\n                    yield return EItemInfoButton.Install; // Custom button\r\n                }\r\n            }\r\n\r\n            public void PerformCustomAction()\r\n            {\r\n                // Custom item behavior\r\n            }\r\n        }\r\n\r\n        // Register mappings\r\n        var mappings = new List<TemplateIdToObjectType>\r\n        {\r\n            // Template-only registration\r\n            new(\r\n                \"my_custom_template_id\",\r\n                null, // No item type for template\r\n                typeof(MyCustomTemplate),\r\n                null\r\n            ),\r\n\r\n            // Item registration\r\n            new(\r\n                \"my_custom_item_id\",\r\n                typeof(MyCustomItem),\r\n                typeof(MyCustomTemplate),\r\n                (id, template) => new MyCustomItem(id, (MyCustomTemplate)template)\r\n            )\r\n        };\r\n\r\n        CustomTemplateIdToObjectService.AddNewTemplateIdToObjectMapping(mappings);\r\n    }\r\n}\r\n```\r\n\r\n### FIKA Multiplayer Integration\r\n\r\n**Static Spawn Synchronization**:\r\n\r\n```csharp\r\n// WTT-ClientCommonLib automatically detects FIKA\r\npublic static bool FikaInstalled { get; private set; }\r\n\r\n// When spawning objects\r\nprivate static void SpawnObject(CustomSpawnConfig config, GameWorld gameWorld)\r\n{\r\n    var instance = InstantiateObject(config);\r\n\r\n    // Synchronize with FIKA clients\r\n    if (WTTClientCommonLib.FikaInstalled)\r\n    {\r\n        WTTClientCommonLib.SendFikaPacket(config, instance.transform.rotation);\r\n    }\r\n}\r\n\r\n// FIKA packet handling (WTT-ClientCommonLibFika)\r\npublic class StaticSpawnPacket : INetSerializable\r\n{\r\n    public string BundleName { get; set; }\r\n    public string PrefabName { get; set; }\r\n    public Vector3 Position { get; set; }\r\n    public Quaternion Rotation { get; set; }\r\n\r\n    public void Serialize(NetDataWriter writer)\r\n    {\r\n        writer.Put(BundleName);\r\n        writer.Put(PrefabName);\r\n        writer.Put(Position);\r\n        writer.Put(Rotation);\r\n    }\r\n\r\n    public void Deserialize(NetDataReader reader)\r\n    {\r\n        BundleName = reader.GetString();\r\n        PrefabName = reader.GetString();\r\n        Position = reader.GetVector3();\r\n        Rotation = reader.GetQuaternion();\r\n    }\r\n}\r\n\r\n// Receiving client spawns object based on packet\r\npublic void OnStaticSpawnPacketReceived(StaticSpawnPacket packet)\r\n{\r\n    var config = new CustomSpawnConfig\r\n    {\r\n        BundleName = packet.BundleName,\r\n        PrefabName = packet.PrefabName,\r\n        Position = packet.Position,\r\n        Rotation = packet.Rotation.eulerAngles\r\n    };\r\n\r\n    SpawnObject(config, gameWorld);\r\n}\r\n```\r\n\r\n### Plugin Mod Using WTT-CommonLib\r\n\r\n**Example: Adding Custom Weapons**\r\n\r\n**Project Structure**:\r\n```\r\nMyWeaponMod/\r\n‚îú‚îÄ‚îÄ MyWeaponMod-Server/\r\n‚îÇ   ‚îú‚îÄ‚îÄ MyWeaponMod-Server.csproj (references WTT-ServerCommonLib NuGet)\r\n‚îÇ   ‚îú‚îÄ‚îÄ src/\r\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MyWeaponMod.cs\r\n‚îÇ   ‚îî‚îÄ‚îÄ Resources/\r\n‚îÇ       ‚îú‚îÄ‚îÄ package.json\r\n‚îÇ       ‚îú‚îÄ‚îÄ bundles/\r\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ weapons.bundle\r\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ bundles.json\r\n‚îÇ       ‚îî‚îÄ‚îÄ db/\r\n‚îÇ           ‚îú‚îÄ‚îÄ CustomItems/\r\n‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ weapons.json\r\n‚îÇ           ‚îî‚îÄ‚îÄ CustomLocales/\r\n‚îÇ               ‚îî‚îÄ‚îÄ en.json\r\n‚îî‚îÄ‚îÄ MyWeaponMod-Client/ (optional, only if custom item types needed)\r\n    ‚îú‚îÄ‚îÄ MyWeaponMod-Client.csproj (references WTT-ClientCommonLib NuGet)\r\n    ‚îî‚îÄ‚îÄ src/\r\n        ‚îî‚îÄ‚îÄ MyWeaponMod.cs\r\n```\r\n\r\n**Server Code**:\r\n\r\n```csharp\r\nusing System.Reflection;\r\nusing SPTarkov.DI.Annotations;\r\nusing SPTarkov.Server.Core.DI;\r\nusing SPTarkov.Server.Core.Models.Spt.Mod;\r\nusing WTTServerCommonLib;\r\nusing Range = SemanticVersioning.Range;\r\n\r\nnamespace MyWeaponMod.Server;\r\n\r\npublic record ModMetadata : AbstractModMetadata\r\n{\r\n    public override string ModGuid { get; init; } = \"com.myname.myweaponmod\";\r\n    public override string Name { get; init; } = \"My Weapon Mod\";\r\n    public override string Author { get; init; } = \"MyName\";\r\n    public override SemanticVersioning.Version Version { get; init; } = new(\"1.0.0\");\r\n    public override Range SptVersion { get; init; } = new(\"~4.0.2\");\r\n    public override Dictionary<string, Range>? ModDependencies { get; init; } = new()\r\n    {\r\n        { \"com.wtt.commonlib\", new Range(\"~2.0.0\") }\r\n    };\r\n    public override bool? IsBundleMod { get; init; } = true;\r\n    public override string License { get; init; } = \"MIT\";\r\n}\r\n\r\n[Injectable(TypePriority = OnLoadOrder.PostDBModLoader + 2)]\r\npublic class MyWeaponMod(\r\n    WTTServerCommonLib.WTTServerCommonLib wttCommon\r\n) : IOnLoad\r\n{\r\n    public async Task OnLoad()\r\n    {\r\n        var assembly = Assembly.GetExecutingAssembly();\r\n\r\n        // Register custom items\r\n        await wttCommon.CustomItemServiceExtended.CreateCustomItems(assembly);\r\n\r\n        // Register locales\r\n        await wttCommon.CustomLocaleService.CreateCustomLocales(assembly);\r\n\r\n        await Task.CompletedTask;\r\n    }\r\n}\r\n```\r\n\r\n**Configuration** (`db/CustomItems/weapons.json`):\r\n\r\n```json\r\n{\r\n  \"my_custom_ak_001\": {\r\n    \"itemTplToClone\": \"5ac66d725acfc43b321d4b60\",\r\n    \"parentId\": \"5447b5cf4bdc2d65278b4567\",\r\n    \"handbookParentId\": \"5b5f6f3c86f774093e6cb503\",\r\n    \"overrideProperties\": {\r\n      \"Prefab\": {\r\n        \"path\": \"weapons/custom_ak.bundle\",\r\n        \"rcid\": \"\"\r\n      },\r\n      \"Weight\": 3.2,\r\n      \"RecoilForceUp\": 120,\r\n      \"RecoilForceBack\": 380,\r\n      \"Ergonomics\": 45\r\n    },\r\n    \"locales\": {\r\n      \"en\": {\r\n        \"name\": \"Custom AK-47M\",\r\n        \"shortName\": \"CAK-47M\",\r\n        \"description\": \"A modernized variant of the classic AK platform.\"\r\n      }\r\n    },\r\n    \"fleaPriceRoubles\": 45000,\r\n    \"handbookPriceRoubles\": 38000,\r\n    \"addtoTraders\": true,\r\n    \"traders\": {\r\n      \"PRAPOR\": {\r\n        \"offer_id_001\": {\r\n          \"barterSettings\": {\r\n            \"loyalLevel\": 2,\r\n            \"unlimitedCount\": false,\r\n            \"stackObjectsCount\": 1\r\n          },\r\n          \"barters\": [\r\n            {\r\n              \"count\": 45000,\r\n              \"_tpl\": \"MONEY_ROUBLES\"\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    \"addtoBots\": true,\r\n    \"addtoModSlots\": true\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Technical Specifications\r\n\r\n### Frameworks & Dependencies\r\n\r\n**Server-Side (WTT-ServerCommonLib)**:\r\n- **Framework**: .NET 9.0 / ASP.NET Core\r\n- **SPT Dependency**: `SPTarkov.Server.Core` v4.0.2\r\n- **Minimum SPT Version**: 4.0.1+\r\n- **Build Tool**: MSBuild / dotnet CLI\r\n- **Package Format**: NuGet package\r\n\r\n**Client-Side (WTT-ClientCommonLib)**:\r\n- **Framework**: .NET Standard 2.1\r\n- **BepInEx Version**: 5.4.x\r\n- **Unity Version**: 2021.3.x (EFT engine)\r\n- **Harmony Version**: 2.x\r\n- **Package Format**: NuGet package\r\n\r\n**Client-Side (WTT-ClientCommonLibFika)**:\r\n- **Framework**: .NET Standard 2.1\r\n- **FIKA Dependency**: `Fika.Core` (soft dependency)\r\n- **Networking**: LiteNetLib (via FIKA)\r\n\r\n### File Structure Conventions\r\n\r\n**Server Mod Folder** (`SPT/user/mods/ModName/`):\r\n```\r\nModName/\r\n‚îú‚îÄ‚îÄ package.json                    # SPT mod metadata\r\n‚îú‚îÄ‚îÄ ModName.dll                     # Compiled server DLL\r\n‚îú‚îÄ‚îÄ bundles/                        # Unity AssetBundles\r\n‚îÇ   ‚îú‚îÄ‚îÄ items.bundle\r\n‚îÇ   ‚îú‚îÄ‚îÄ audio.bundle\r\n‚îÇ   ‚îî‚îÄ‚îÄ bundles.json               # AssetBundle manifest\r\n‚îî‚îÄ‚îÄ db/                            # Configuration files\r\n    ‚îú‚îÄ‚îÄ CustomItems/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ items.json\r\n    ‚îú‚îÄ‚îÄ CustomLocales/\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ en.json\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ ru.json\r\n    ‚îú‚îÄ‚îÄ CustomQuests/\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ QuestTimeData.json     # Optional: time-limited quests\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ QuestSideData.json     # Optional: faction quests\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ [trader_name]/\r\n    ‚îÇ       ‚îú‚îÄ‚îÄ Quests/\r\n    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ quest1.json\r\n    ‚îÇ       ‚îú‚îÄ‚îÄ Locales/\r\n    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ en.json\r\n    ‚îÇ       ‚îú‚îÄ‚îÄ Images/\r\n    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ quest_icon.png\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ QuestAssort/\r\n    ‚îÇ           ‚îî‚îÄ‚îÄ assort.json\r\n    ‚îú‚îÄ‚îÄ CustomQuestZones/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ zones.json\r\n    ‚îú‚îÄ‚îÄ CustomStaticSpawns/\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ StaticBundles/\r\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ objects.bundle\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ CustomSpawnConfigs/\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ spawns.json\r\n    ‚îú‚îÄ‚îÄ CustomLootspawns/\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ CustomSpawnpoints/\r\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ map_spawns.json\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ CustomSpawnpointsForced/\r\n    ‚îÇ       ‚îî‚îÄ‚îÄ map_forced.json\r\n    ‚îú‚îÄ‚îÄ CustomAssortSchemes/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ trader_assort.json\r\n    ‚îú‚îÄ‚îÄ CustomBotLoadouts/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ bot_loadout.json\r\n    ‚îú‚îÄ‚îÄ CustomHeads/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ heads.json\r\n    ‚îú‚îÄ‚îÄ CustomClothing/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ clothing.json\r\n    ‚îú‚îÄ‚îÄ CustomVoices/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ voices.json\r\n    ‚îú‚îÄ‚îÄ CustomHideoutRecipes/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ recipes.json\r\n    ‚îú‚îÄ‚îÄ CustomRigLayouts/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ layout.bundle\r\n    ‚îú‚îÄ‚îÄ CustomSlotImages/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ slot_icon.png\r\n    ‚îú‚îÄ‚îÄ CustomBuffs/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ buffs.json\r\n    ‚îú‚îÄ‚îÄ CustomProfiles/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ profile.json\r\n    ‚îú‚îÄ‚îÄ CustomWeaponPresets/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ presets.json\r\n    ‚îú‚îÄ‚îÄ CustomAudioBundles/\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ audio.bundle\r\n    ‚îî‚îÄ‚îÄ CustomAchievements/\r\n        ‚îú‚îÄ‚îÄ Achievements/\r\n        ‚îÇ   ‚îî‚îÄ‚îÄ achievements.json\r\n        ‚îú‚îÄ‚îÄ Locales/\r\n        ‚îÇ   ‚îî‚îÄ‚îÄ en.json\r\n        ‚îî‚îÄ‚îÄ Images/\r\n            ‚îî‚îÄ‚îÄ achievement_icon.png\r\n```\r\n\r\n### Build Process\r\n\r\n**Server Build** (`.csproj` PostBuild):\r\n```batch\r\n1. Compile C# ‚Üí DLL\r\n2. Copy DLL ‚Üí ../../../SPT/user/mods/ModName/\r\n3. Copy Resources/ ‚Üí ../../../SPT/user/mods/ModName/\r\n4. Copy DLL + Resources ‚Üí ../Build/SPT/user/mods/ModName/\r\n5. If Publish config: Push to NuGet\r\n```\r\n\r\n**Client Build** (`.csproj` PostBuild):\r\n```batch\r\n1. Compile C# ‚Üí DLL\r\n2. Copy DLL ‚Üí ../../../BepInEx/plugins/ModName/\r\n3. Copy DLL ‚Üí ../Build/BepInEx/plugins/ModName/\r\n4. If Publish config: Push to NuGet\r\n```\r\n\r\n### Performance Characteristics\r\n\r\n**Asset Loading**:\r\n- AssetBundles cached after first load\r\n- AudioClips cached per-clip\r\n- Rig layouts loaded once at startup\r\n- Slot images loaded once at startup\r\n\r\n**Database Operations**:\r\n- All database modifications happen at server startup\r\n- No runtime database queries for registered content\r\n- Deferred operations batched for efficiency\r\n\r\n**Network Traffic** (FIKA):\r\n- Static spawn packets ~200-500 bytes per spawn\r\n- Sent once per raid start\r\n- No continuous synchronization needed\r\n\r\n**Memory Usage**:\r\n- Server: ~10-50 MB additional per mod (depending on data size)\r\n- Client: ~50-200 MB additional (AssetBundles, textures, audio)\r\n\r\n---\r\n\r\n## Advanced Topics\r\n\r\n### Multi-Language Locale System\r\n\r\n**Locale Fallback Chain**:\r\n```\r\nRequested Language ‚Üí Mod Locale ‚Üí WTT Locale ‚Üí English Fallback\r\n```\r\n\r\n**Implementation**:\r\n```csharp\r\npublic void RegisterLocales(string itemId, Dictionary<string, LocaleDetails> locales)\r\n{\r\n    var globalLocales = _database.Locales.Global;\r\n\r\n    foreach (var (languageCode, details) in locales)\r\n    {\r\n        if (!globalLocales.ContainsKey(languageCode))\r\n        {\r\n            _logger.LogWarning($\"Language '{languageCode}' not found, using 'en' fallback\");\r\n            languageCode = \"en\";\r\n        }\r\n\r\n        var locale = globalLocales[languageCode];\r\n\r\n        locale[$\"{itemId} Name\"] = details.Name;\r\n        locale[$\"{itemId} ShortName\"] = details.ShortName;\r\n        locale[$\"{itemId} Description\"] = details.Description;\r\n    }\r\n}\r\n```\r\n\r\n### Dynamic Item Property Overrides\r\n\r\n**Deep Merge Strategy**:\r\n\r\n```csharp\r\npublic void ApplyPropertyOverrides(TemplateItem item, TemplateItemProperties overrides)\r\n{\r\n    // Use reflection to merge properties\r\n    var itemProps = item.Properties;\r\n    var overrideProps = overrides;\r\n\r\n    foreach (var property in overrideProps.GetType().GetProperties())\r\n    {\r\n        var value = property.GetValue(overrideProps);\r\n\r\n        if (value != null)\r\n        {\r\n            var itemProperty = itemProps.GetType().GetProperty(property.Name);\r\n\r\n            if (itemProperty != null && itemProperty.CanWrite)\r\n            {\r\n                // Special handling for collections\r\n                if (value is IList && itemProperty.GetValue(itemProps) is IList existingList)\r\n                {\r\n                    existingList.Clear();\r\n                    foreach (var item in (IList)value)\r\n                        existingList.Add(item);\r\n                }\r\n                else\r\n                {\r\n                    itemProperty.SetValue(itemProps, value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Quest Condition DSL\r\n\r\n**Complex Condition Example**:\r\n\r\n```json\r\n{\r\n  \"conditions\": {\r\n    \"availableForFinish\": [\r\n      {\r\n        \"conditionType\": \"CounterCreator\",\r\n        \"counter\": {\r\n          \"conditions\": [\r\n            {\r\n              \"conditionType\": \"Kills\",\r\n              \"target\": [\"Savage\", \"AnyPmc\"],\r\n              \"value\": 10,\r\n              \"compareMethod\": \">=\",\r\n              \"weapon\": [\"my_custom_weapon\"],\r\n              \"bodyPart\": [\"Head\"],\r\n              \"distance\": {\r\n                \"compareMethod\": \">=\",\r\n                \"value\": 50\r\n              },\r\n              \"daytime\": {\r\n                \"from\": 22,\r\n                \"to\": 6\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n**Translation**: \"Kill 10 Scavs or PMCs with headshots using my_custom_weapon from 50+ meters at night (10 PM - 6 AM)\"\r\n\r\n### AssetBundle Best Practices\r\n\r\n**Build Settings**:\r\n```\r\nCompression: LZ4 (faster load times)\r\nTarget Platform: StandaloneWindows64\r\nStrip Unused Meshes: Enabled\r\nInclude Albedo Textures: Required\r\nInclude Normal Maps: Optional (reduces size)\r\nAudio Compression: Vorbis\r\nAudio Quality: 0.7 (balance size/quality)\r\n```\r\n\r\n**Bundle Organization**:\r\n```\r\nOption 1: Single bundle per mod\r\n  ‚îú‚îÄ‚îÄ Pros: Simple deployment\r\n  ‚îî‚îÄ‚îÄ Cons: Entire bundle loaded even for small features\r\n\r\nOption 2: Feature-based bundles\r\n  ‚îú‚îÄ‚îÄ items.bundle (weapons, armor)\r\n  ‚îú‚îÄ‚îÄ audio.bundle (sounds, music)\r\n  ‚îú‚îÄ‚îÄ quests.bundle (quest objects)\r\n  ‚îî‚îÄ‚îÄ Pros: Selective loading, better performance\r\n```\r\n\r\n### Trader Barter Scheme Complexity\r\n\r\n**Multi-Item Barter**:\r\n```json\r\n{\r\n  \"traders\": {\r\n    \"MECHANIC\": {\r\n      \"offer_unique_id\": {\r\n        \"barterSettings\": {\r\n          \"loyalLevel\": 3,\r\n          \"unlimitedCount\": false,\r\n          \"stackObjectsCount\": 1\r\n        },\r\n        \"barters\": [\r\n          {\r\n            \"count\": 2,\r\n            \"_tpl\": \"5c0530ee86f774697952d952\" // LEDX\r\n          },\r\n          {\r\n            \"count\": 5,\r\n            \"_tpl\": \"5c05308086f7746b2101e90b\" // Graphics Card\r\n          },\r\n          {\r\n            \"count\": 500000,\r\n            \"_tpl\": \"MONEY_ROUBLES\"\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**Result**: Trade 2 LEDX + 5 Graphics Cards + 500k Roubles for custom item\r\n\r\n### Bot Equipment Weighting System\r\n\r\n**Weight Distribution**:\r\n\r\n```json\r\n{\r\n  \"inventory\": {\r\n    \"equipment\": {\r\n      \"FirstPrimaryWeapon\": {\r\n        \"5447a9cd4bdc2dbd208b4567\": 500,  // 50% chance\r\n        \"5ac66d725acfc43b321d4b60\": 300,  // 30% chance\r\n        \"5bf3e03b0db834001d2c4a9c\": 200   // 20% chance\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**Normalization**: Weights are relative, total weight doesn't need to sum to 100 or 1000.\r\n\r\n**Combined Weights**: If multiple mods add items to the same slot, weights accumulate.\r\n\r\n---\r\n\r\n## Development Guidelines\r\n\r\n### Configuration Best Practices\r\n\r\n1. **Use Constants**: Reference `ItemMaps` and `TraderIds` instead of hardcoding IDs\r\n2. **Validate JSON**: Use a JSON validator before testing\r\n3. **Locale All Strings**: Always provide at least English locale\r\n4. **Use MongoID Generators**: All IDs must be valid 24-character hex strings\r\n5. **Test Incrementally**: Add one feature at a time, verify before adding more\r\n\r\n### Error Handling\r\n\r\n**Common Errors**:\r\n\r\n| Error | Cause | Solution |\r\n|-------|-------|----------|\r\n| \"Item template not found\" | Invalid `itemTplToClone` ID | Verify ID exists in SPT database |\r\n| \"Trader not found\" | Invalid trader name/ID | Check `TraderIds` constants |\r\n| \"Quest outside time window\" | Current date outside quest window | Adjust `QuestTimeData.json` dates |\r\n| \"AssetBundle load failed\" | Missing bundle file | Verify bundle path and `bundles.json` |\r\n| \"FIKA packet failed\" | FIKA not installed | Check `FikaInstalled` before sending packets |\r\n\r\n### Testing Workflow\r\n\r\n1. **Unit Test Configuration**: Validate JSON structure\r\n2. **Server Test**: Check SPT server logs for registration\r\n3. **Database Verification**: Inspect database tables post-load\r\n4. **Client Test**: Verify assets load in-game\r\n5. **Integration Test**: Test full gameplay flow\r\n6. **FIKA Test**: Test with multiplayer if applicable\r\n\r\n### Debugging Tools\r\n\r\n**Server-Side**:\r\n```csharp\r\n_logger.LogDebug($\"Registered item: {itemId}\");\r\n_logger.LogInfo($\"Processing {configs.Count} items\");\r\n_logger.LogWarning($\"Item {cloneId} not found, skipping\");\r\n_logger.LogError($\"Failed to parse config: {ex.Message}\");\r\n```\r\n\r\n**Client-Side**:\r\n```csharp\r\nLogHelper.LogDebug(\"Spawning quest zone\");\r\nLogHelper.LogInfo(\"AssetBundle loaded successfully\");\r\nLogHelper.LogWarning(\"FIKA not detected, skipping sync\");\r\nLogHelper.LogError($\"Asset load failed: {ex}\");\r\n```\r\n\r\n**Console Commands**:\r\n```\r\nSpawnObject <bundle> <prefab>  - Spawn object in front of player\r\nEnterEditMode                  - Enter zone/object editing mode\r\nExportSpawnedObjectInfo        - Export all spawned objects to JSON\r\n```\r\n\r\n### Mod Compatibility\r\n\r\n**Potential Conflicts**:\r\n- **SAIN**: May conflict with bot loadouts\r\n- **Realism Mod**: May conflict with item properties\r\n- **Amands Graphics**: No conflicts (rendering only)\r\n- **FIKA**: Fully compatible (WTT includes FIKA support)\r\n\r\n**Compatibility Strategy**:\r\n- Load after database mods (`PostDBModLoader + 2`)\r\n- Use additive modifications (don't replace entire tables)\r\n- Test with popular mods installed\r\n- Document known incompatibilities in README\r\n\r\n### Performance Optimization\r\n\r\n**Server**:\r\n- Batch database operations\r\n- Defer expensive operations to `PostSptModLoader`\r\n- Cache frequently-accessed data\r\n- Use `async/await` for I/O operations\r\n\r\n**Client**:\r\n- Lazy-load AssetBundles (only when needed)\r\n- Cache loaded assets\r\n- Unload unused bundles with `AssetBundle.Unload(false)`\r\n- Use object pooling for frequently spawned objects\r\n\r\n### Version Management\r\n\r\n**Semantic Versioning**:\r\n```\r\nMAJOR.MINOR.PATCH\r\n  ‚îÇ     ‚îÇ     ‚îî‚îÄ Bug fixes, backward compatible\r\n  ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ New features, backward compatible\r\n  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Breaking changes\r\n```\r\n\r\n**WTT-CommonLib Versioning**:\r\n- Current version: `2.0.4`\r\n- SPT 4.0.x compatible: `~2.0.0`\r\n- Breaking changes: Increment MAJOR version\r\n\r\n**Mod Dependency**:\r\n```csharp\r\npublic override Dictionary<string, Range>? ModDependencies { get; init; } = new()\r\n{\r\n    { \"com.wtt.commonlib\", new Range(\"~2.0.0\") } // Accept 2.0.x, reject 2.1.x\r\n};\r\n```\r\n\r\n---\r\n\r\n## Conclusion\r\n\r\nWTT-CommonLib provides a comprehensive, production-ready framework for SPT modding. Its three-tier architecture cleanly separates concerns between configuration, server-side data management, and client-side rendering. The extensive service ecosystem covers virtually all modding scenarios, from simple item additions to complex quest systems with conditional spawning.\r\n\r\nKey strengths:\r\n- **Developer-Friendly**: JSON-based configuration eliminates boilerplate\r\n- **Comprehensive**: 19 server services + client tools cover all major systems\r\n- **Well-Architected**: Dependency injection, separation of concerns, deferred operations\r\n- **Multiplayer-Ready**: Built-in FIKA support for network synchronization\r\n- **Extensible**: Public APIs for custom item types and advanced integrations\r\n- **Production-Tested**: Used by multiple released SPT mods (Pack N Strap, Komrade Kid, etc.)\r\n\r\nThis library represents a significant advancement in SPT modding infrastructure, reducing development time from weeks to hours for complex features while maintaining code quality and performance standards.\r\n\r\n**Repository**: https://github.com/WelcomeToTarkov/WTT-CommonLib\r\n**NuGet Packages**:\r\n- `WTT-ServerCommonLib` (Server-side)\r\n- `WTT-ClientCommonLib` (Client-side)\r\n\r\n**Community**:\r\n- SPT Forge: [https://forge.sp-tarkov.com/](https://forge.sp-tarkov.com/)\r\n- SPT Discord: Active support channel\r\n\r\n---\r\n\r\n*This technical documentation complements the official README.md by providing in-depth architectural insights, implementation details, and advanced usage patterns for developers building on WTT-CommonLib.*\r\n"}};
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeTheme();
            initializeNav();
            initializeSearch();
            initializeKeyboardShortcuts();
        });

        // Theme Toggle
        function initializeTheme() {
            const theme = localStorage.getItem('wiki-theme') || 'dark';
            document.body.className = theme + '-theme';
            updateThemeIcon();
        }

        document.getElementById('themeToggle').addEventListener('click', function() {
            const isDark = document.body.classList.contains('dark-theme');
            document.body.className = isDark ? 'light-theme' : 'dark-theme';
            localStorage.setItem('wiki-theme', isDark ? 'light' : 'dark');
            updateThemeIcon();
        });

        function updateThemeIcon() {
            const isDark = document.body.classList.contains('dark-theme');
            document.getElementById('themeToggle').textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
        }

        // Navigation
        function initializeNav() {
            const categoryToggles = document.querySelectorAll('.category-toggle');
            
            categoryToggles.forEach(toggle => {
                toggle.addEventListener('click', function() {
                    const categoryId = this.dataset.category;
                    const navItems = document.getElementById('category-' + categoryId);
                    
                    this.classList.toggle('expanded');
                    navItems.classList.toggle('expanded');
                });
            });
            
            // Expand first category by default
            if (categoryToggles.length > 0) {
                categoryToggles[0].click();
            }
        }

        // Load Document
        function loadDocument(fileName) {
            const doc = documentsData[fileName];
            if (!doc) return;
            
            // Hide welcome, show document
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('documentView').style.display = 'block';
            
            // Update breadcrumb
            document.getElementById('breadcrumb').innerHTML = `
                <span>üìö </span>
                <span>${doc.category}</span>
                <span> / </span>
                <span>${doc.title}</span>
            `;
            
            // Render markdown
            const content = marked.parse(doc.content);
            document.getElementById('documentContent').innerHTML = content;
            
            // Highlight code
            document.querySelectorAll('pre code').forEach(block => {
                hljs.highlightElement(block);
            });
            
            // Update active nav item
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector(`.nav-item[data-doc="${fileName}"]`)?.classList.add('active');
            
            // Scroll to top
            document.querySelector('.main-content').scrollTop = 0;
            
            // Close search if open
            closeSearch();
        }

        // Go back to home/welcome screen
        function goHome() {
            document.getElementById('welcomeScreen').style.display = 'block';
            document.getElementById('documentView').style.display = 'none';
            
            // Clear active nav items
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Scroll to top
            document.querySelector('.main-content').scrollTop = 0;
        }

        // Search
        function initializeSearch() {
            const searchBtn = document.getElementById('searchBtn');
            const searchModal = document.getElementById('searchModal');
            const searchInput = document.getElementById('searchInput');
            
            searchBtn.addEventListener('click', openSearch);
            searchModal.addEventListener('click', function(e) {
                if (e.target === searchModal) closeSearch();
            });
            
            searchInput.addEventListener('input', function() {
                performSearch(this.value);
            });
        }

        function openSearch() {
            document.getElementById('searchModal').classList.add('active');
            document.getElementById('searchInput').focus();
        }

        function closeSearch() {
            document.getElementById('searchModal').classList.remove('active');
            document.getElementById('searchInput').value = '';
            document.getElementById('searchResults').innerHTML = '';
        }

        function performSearch(query) {
            const results = document.getElementById('searchResults');
            
            if (query.length < 2) {
                results.innerHTML = '';
                return;
            }
            
            const matches = [];
            const searchTerm = query.toLowerCase();
            
            Object.entries(documentsData).forEach(([fileName, doc]) => {
                const titleMatch = doc.title.toLowerCase().includes(searchTerm);
                const contentMatch = doc.content.toLowerCase().includes(searchTerm);
                
                if (titleMatch || contentMatch) {
                    const excerpt = getExcerpt(doc.content, searchTerm);
                    matches.push({
                        fileName,
                        title: doc.title,
                        category: doc.category,
                        excerpt,
                        relevance: titleMatch ? 2 : 1
                    });
                }
            });
            
            // Sort by relevance
            matches.sort((a, b) => b.relevance - a.relevance);
            
            if (matches.length === 0) {
                results.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-secondary);">No results found</div>';
                return;
            }
            
            results.innerHTML = matches.map(match => `
                <div class="search-result-item" onclick="loadDocument('${match.fileName}')">
                    <div class="search-result-title">${match.title}</div>
                    <div class="search-result-category">${match.category}</div>
                    <div class="search-result-excerpt">${match.excerpt}</div>
                </div>
            `).join('');
        }

        function getExcerpt(content, searchTerm) {
            const index = content.toLowerCase().indexOf(searchTerm);
            if (index === -1) return '';
            
            const start = Math.max(0, index - 60);
            const end = Math.min(content.length, index + 100);
            let excerpt = content.slice(start, end);
            
            if (start > 0) excerpt = '...' + excerpt;
            if (end < content.length) excerpt = excerpt + '...';
            
            // Highlight search term
            const regex = new RegExp('(' + searchTerm + ')', 'gi');
            excerpt = excerpt.replace(regex, '<strong>$1</strong>');
            
            return excerpt;
        }

        // Keyboard Shortcuts
        function initializeKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Ctrl+K or Cmd+K for search
                if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                    e.preventDefault();
                    openSearch();
                }
                
                // Escape to close search
                if (e.key === 'Escape') {
                    closeSearch();
                }
            });
        }
    
    </script>
</body>
</html>